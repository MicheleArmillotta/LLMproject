[
  {
    "function_name": "dlm_user_purge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "6287-6303",
    "snippet": "int dlm_user_purge(struct dlm_ls *ls, struct dlm_user_proc *proc,\n\t\t   int nodeid, int pid)\n{\n\tint error = 0;\n\n\tif (nodeid && (nodeid != dlm_our_nodeid())) {\n\t\terror = send_purge(ls, nodeid, pid);\n\t} else {\n\t\tdlm_lock_recovery(ls);\n\t\tif (pid == current->pid)\n\t\t\tpurge_proc_locks(ls, proc);\n\t\telse\n\t\t\tdo_purge(ls, nodeid, pid);\n\t\tdlm_unlock_recovery(ls);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_unlock_recovery",
          "args": [
            "ls"
          ],
          "line": 6300
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "210-213",
          "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_purge",
          "args": [
            "ls",
            "nodeid",
            "pid"
          ],
          "line": 6299
        },
        "resolved": true,
        "details": {
          "function_name": "do_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6256-6269",
          "snippet": "static void do_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (pid && lkb->lkb_ownpid != pid)\n\t\t\tcontinue;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (pid && lkb->lkb_ownpid != pid)\n\t\t\tcontinue;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "purge_proc_locks",
          "args": [
            "ls",
            "proc"
          ],
          "line": 6297
        },
        "resolved": true,
        "details": {
          "function_name": "purge_proc_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6214-6252",
          "snippet": "static void purge_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\twhile (1) {\n\t\tlkb = NULL;\n\t\tspin_lock(&proc->locks_spin);\n\t\tif (!list_empty(&proc->locks)) {\n\t\t\tlkb = list_entry(proc->locks.next, struct dlm_lkb,\n\t\t\t\t\t lkb_ownqueue);\n\t\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\t}\n\t\tspin_unlock(&proc->locks_spin);\n\n\t\tif (!lkb)\n\t\t\tbreak;\n\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tdlm_put_lkb(lkb); /* ref from proc->locks list */\n\t}\n\n\tspin_lock(&proc->locks_spin);\n\tlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tdlm_put_lkb(lkb);\n\t}\n\tspin_unlock(&proc->locks_spin);\n\n\tspin_lock(&proc->asts_spin);\n\tlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\n\t\tmemset(&lkb->lkb_callbacks, 0,\n\t\t       sizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tspin_unlock(&proc->asts_spin);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void purge_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\twhile (1) {\n\t\tlkb = NULL;\n\t\tspin_lock(&proc->locks_spin);\n\t\tif (!list_empty(&proc->locks)) {\n\t\t\tlkb = list_entry(proc->locks.next, struct dlm_lkb,\n\t\t\t\t\t lkb_ownqueue);\n\t\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\t}\n\t\tspin_unlock(&proc->locks_spin);\n\n\t\tif (!lkb)\n\t\t\tbreak;\n\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tdlm_put_lkb(lkb); /* ref from proc->locks list */\n\t}\n\n\tspin_lock(&proc->locks_spin);\n\tlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tdlm_put_lkb(lkb);\n\t}\n\tspin_unlock(&proc->locks_spin);\n\n\tspin_lock(&proc->asts_spin);\n\tlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\n\t\tmemset(&lkb->lkb_callbacks, 0,\n\t\t       sizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tspin_unlock(&proc->asts_spin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_recovery",
          "args": [
            "ls"
          ],
          "line": 6295
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_recovery_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "215-218",
          "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_purge",
          "args": [
            "ls",
            "nodeid",
            "pid"
          ],
          "line": 6293
        },
        "resolved": true,
        "details": {
          "function_name": "send_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6271-6285",
          "snippet": "static int send_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint error;\n\n\terror = _create_message(ls, sizeof(struct dlm_message), nodeid,\n\t\t\t\tDLM_MSG_PURGE, &ms, &mh);\n\tif (error)\n\t\treturn error;\n\tms->m_nodeid = nodeid;\n\tms->m_pid = pid;\n\n\treturn send_message(mh, ms);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\n\nstatic int send_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint error;\n\n\terror = _create_message(ls, sizeof(struct dlm_message), nodeid,\n\t\t\t\tDLM_MSG_PURGE, &ms, &mh);\n\tif (error)\n\t\treturn error;\n\tms->m_nodeid = nodeid;\n\tms->m_pid = pid;\n\n\treturn send_message(mh, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 6292
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\n\nint dlm_user_purge(struct dlm_ls *ls, struct dlm_user_proc *proc,\n\t\t   int nodeid, int pid)\n{\n\tint error = 0;\n\n\tif (nodeid && (nodeid != dlm_our_nodeid())) {\n\t\terror = send_purge(ls, nodeid, pid);\n\t} else {\n\t\tdlm_lock_recovery(ls);\n\t\tif (pid == current->pid)\n\t\t\tpurge_proc_locks(ls, proc);\n\t\telse\n\t\t\tdo_purge(ls, nodeid, pid);\n\t\tdlm_unlock_recovery(ls);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "send_purge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "6271-6285",
    "snippet": "static int send_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint error;\n\n\terror = _create_message(ls, sizeof(struct dlm_message), nodeid,\n\t\t\t\tDLM_MSG_PURGE, &ms, &mh);\n\tif (error)\n\t\treturn error;\n\tms->m_nodeid = nodeid;\n\tms->m_pid = pid;\n\n\treturn send_message(mh, ms);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_message",
          "args": [
            "mh",
            "ms"
          ],
          "line": 6284
        },
        "resolved": true,
        "details": {
          "function_name": "send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3590-3595",
          "snippet": "static int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_create_message",
          "args": [
            "ls",
            "sizeof(struct dlm_message)",
            "nodeid",
            "DLM_MSG_PURGE",
            "&ms",
            "&mh"
          ],
          "line": 6277
        },
        "resolved": true,
        "details": {
          "function_name": "_create_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3526-3558",
          "snippet": "static int _create_message(struct dlm_ls *ls, int mb_len,\n\t\t\t   int to_nodeid, int mstype,\n\t\t\t   struct dlm_message **ms_ret,\n\t\t\t   struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\n\t/* get_buffer gives us a message handle (mh) that we need to\n\t   pass into lowcomms_commit and a message buffer (mb) that we\n\t   write our data into */\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\n\tmemset(mb, 0, mb_len);\n\n\tms = (struct dlm_message *) mb;\n\n\tms->m_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tms->m_header.h_lockspace = ls->ls_global_id;\n\tms->m_header.h_nodeid = dlm_our_nodeid();\n\tms->m_header.h_length = mb_len;\n\tms->m_header.h_cmd = DLM_MSG;\n\n\tms->m_type = mstype;\n\n\t*mh_ret = mh;\n\t*ms_ret = ms;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int _create_message(struct dlm_ls *ls, int mb_len,\n\t\t\t   int to_nodeid, int mstype,\n\t\t\t   struct dlm_message **ms_ret,\n\t\t\t   struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\n\t/* get_buffer gives us a message handle (mh) that we need to\n\t   pass into lowcomms_commit and a message buffer (mb) that we\n\t   write our data into */\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\n\tmemset(mb, 0, mb_len);\n\n\tms = (struct dlm_message *) mb;\n\n\tms->m_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tms->m_header.h_lockspace = ls->ls_global_id;\n\tms->m_header.h_nodeid = dlm_our_nodeid();\n\tms->m_header.h_length = mb_len;\n\tms->m_header.h_cmd = DLM_MSG;\n\n\tms->m_type = mstype;\n\n\t*mh_ret = mh;\n\t*ms_ret = ms;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\n\nstatic int send_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint error;\n\n\terror = _create_message(ls, sizeof(struct dlm_message), nodeid,\n\t\t\t\tDLM_MSG_PURGE, &ms, &mh);\n\tif (error)\n\t\treturn error;\n\tms->m_nodeid = nodeid;\n\tms->m_pid = pid;\n\n\treturn send_message(mh, ms);\n}"
  },
  {
    "function_name": "do_purge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "6256-6269",
    "snippet": "static void do_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (pid && lkb->lkb_ownpid != pid)\n\t\t\tcontinue;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_orphans_mutex"
          ],
          "line": 6268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 6266
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_ownqueue"
          ],
          "line": 6265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_proc_lock",
          "args": [
            "ls",
            "lkb"
          ],
          "line": 6264
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_proc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6122-6134",
          "snippet": "static int unlock_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\tset_unlock_args(DLM_LKF_FORCEUNLOCK | DLM_LKF_IVVALBLK,\n\t\t\tlkb->lkb_ua, &args);\n\n\terror = unlock_lock(ls, lkb, &args);\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int unlock_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\tset_unlock_args(DLM_LKF_FORCEUNLOCK | DLM_LKF_IVVALBLK,\n\t\t\tlkb->lkb_ua, &args);\n\n\terror = unlock_lock(ls, lkb, &args);\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "safe",
            "&ls->ls_orphans",
            "lkb_ownqueue"
          ],
          "line": 6261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_orphans_mutex"
          ],
          "line": 6260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (pid && lkb->lkb_ownpid != pid)\n\t\t\tcontinue;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n}"
  },
  {
    "function_name": "purge_proc_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "6214-6252",
    "snippet": "static void purge_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\twhile (1) {\n\t\tlkb = NULL;\n\t\tspin_lock(&proc->locks_spin);\n\t\tif (!list_empty(&proc->locks)) {\n\t\t\tlkb = list_entry(proc->locks.next, struct dlm_lkb,\n\t\t\t\t\t lkb_ownqueue);\n\t\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\t}\n\t\tspin_unlock(&proc->locks_spin);\n\n\t\tif (!lkb)\n\t\t\tbreak;\n\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tdlm_put_lkb(lkb); /* ref from proc->locks list */\n\t}\n\n\tspin_lock(&proc->locks_spin);\n\tlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tdlm_put_lkb(lkb);\n\t}\n\tspin_unlock(&proc->locks_spin);\n\n\tspin_lock(&proc->asts_spin);\n\tlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\n\t\tmemset(&lkb->lkb_callbacks, 0,\n\t\t       sizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tspin_unlock(&proc->asts_spin);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&proc->asts_spin"
          ],
          "line": 6251
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 6249
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_cb_list"
          ],
          "line": 6248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lkb->lkb_callbacks",
            "0",
            "sizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE"
          ],
          "line": 6246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "safe",
            "&proc->asts",
            "lkb_cb_list"
          ],
          "line": 6245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&proc->asts_spin"
          ],
          "line": 6244
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_ownqueue"
          ],
          "line": 6238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "safe",
            "&proc->unlocking",
            "lkb_ownqueue"
          ],
          "line": 6237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_proc_lock",
          "args": [
            "ls",
            "lkb"
          ],
          "line": 6232
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_proc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6122-6134",
          "snippet": "static int unlock_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\tset_unlock_args(DLM_LKF_FORCEUNLOCK | DLM_LKF_IVVALBLK,\n\t\t\tlkb->lkb_ua, &args);\n\n\terror = unlock_lock(ls, lkb, &args);\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int unlock_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\tset_unlock_args(DLM_LKF_FORCEUNLOCK | DLM_LKF_IVVALBLK,\n\t\t\tlkb->lkb_ua, &args);\n\n\terror = unlock_lock(ls, lkb, &args);\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_ownqueue"
          ],
          "line": 6224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "proc->locks.next",
            "structdlm_lkb",
            "lkb_ownqueue"
          ],
          "line": 6222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&proc->locks"
          ],
          "line": 6221
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void purge_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\twhile (1) {\n\t\tlkb = NULL;\n\t\tspin_lock(&proc->locks_spin);\n\t\tif (!list_empty(&proc->locks)) {\n\t\t\tlkb = list_entry(proc->locks.next, struct dlm_lkb,\n\t\t\t\t\t lkb_ownqueue);\n\t\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\t}\n\t\tspin_unlock(&proc->locks_spin);\n\n\t\tif (!lkb)\n\t\t\tbreak;\n\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tdlm_put_lkb(lkb); /* ref from proc->locks list */\n\t}\n\n\tspin_lock(&proc->locks_spin);\n\tlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tdlm_put_lkb(lkb);\n\t}\n\tspin_unlock(&proc->locks_spin);\n\n\tspin_lock(&proc->asts_spin);\n\tlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\n\t\tmemset(&lkb->lkb_callbacks, 0,\n\t\t       sizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tspin_unlock(&proc->asts_spin);\n}"
  },
  {
    "function_name": "dlm_clear_proc_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "6171-6212",
    "snippet": "void dlm_clear_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tdlm_lock_recovery(ls);\n\n\twhile (1) {\n\t\tlkb = del_proc_lock(ls, proc);\n\t\tif (!lkb)\n\t\t\tbreak;\n\t\tdel_timeout(lkb);\n\t\tif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\n\t\t\torphan_proc_lock(ls, lkb);\n\t\telse\n\t\t\tunlock_proc_lock(ls, lkb);\n\n\t\t/* this removes the reference for the proc->locks list\n\t\t   added by dlm_user_request, it may result in the lkb\n\t\t   being freed */\n\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\n\t/* in-progress unlocks */\n\tlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\n\t\tmemset(&lkb->lkb_callbacks, 0,\n\t\t       sizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n\tdlm_unlock_recovery(ls);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_unlock_recovery",
          "args": [
            "ls"
          ],
          "line": 6211
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "210-213",
          "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_clear_proc_locks"
          ],
          "line": 6210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 6207
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_cb_list"
          ],
          "line": 6206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lkb->lkb_callbacks",
            "0",
            "sizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE"
          ],
          "line": 6204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "safe",
            "&proc->asts",
            "lkb_cb_list"
          ],
          "line": 6203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_ownqueue"
          ],
          "line": 6198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "safe",
            "&proc->unlocking",
            "lkb_ownqueue"
          ],
          "line": 6197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_clear_proc_locks"
          ],
          "line": 6194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_proc_lock",
          "args": [
            "ls",
            "lkb"
          ],
          "line": 6185
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_proc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6122-6134",
          "snippet": "static int unlock_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\tset_unlock_args(DLM_LKF_FORCEUNLOCK | DLM_LKF_IVVALBLK,\n\t\t\tlkb->lkb_ua, &args);\n\n\terror = unlock_lock(ls, lkb, &args);\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int unlock_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\tset_unlock_args(DLM_LKF_FORCEUNLOCK | DLM_LKF_IVVALBLK,\n\t\t\tlkb->lkb_ua, &args);\n\n\terror = unlock_lock(ls, lkb, &args);\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphan_proc_lock",
          "args": [
            "ls",
            "lkb"
          ],
          "line": 6183
        },
        "resolved": true,
        "details": {
          "function_name": "orphan_proc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6099-6115",
          "snippet": "static int orphan_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\thold_lkb(lkb); /* reference for the ls_orphans list */\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ls->ls_orphans);\n\tmutex_unlock(&ls->ls_orphans_mutex);\n\n\tset_unlock_args(0, lkb->lkb_ua, &args);\n\n\terror = cancel_lock(ls, lkb, &args);\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int orphan_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\thold_lkb(lkb); /* reference for the ls_orphans list */\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ls->ls_orphans);\n\tmutex_unlock(&ls->ls_orphans_mutex);\n\n\tset_unlock_args(0, lkb->lkb_ua, &args);\n\n\terror = cancel_lock(ls, lkb, &args);\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timeout",
          "args": [
            "lkb"
          ],
          "line": 6181
        },
        "resolved": true,
        "details": {
          "function_name": "del_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1839-1849",
          "snippet": "static void del_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tif (!list_empty(&lkb->lkb_time_list)) {\n\t\tlist_del_init(&lkb->lkb_time_list);\n\t\tunhold_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tif (!list_empty(&lkb->lkb_time_list)) {\n\t\tlist_del_init(&lkb->lkb_time_list);\n\t\tunhold_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_proc_lock",
          "args": [
            "ls",
            "proc"
          ],
          "line": 6178
        },
        "resolved": true,
        "details": {
          "function_name": "del_proc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6140-6159",
          "snippet": "static struct dlm_lkb *del_proc_lock(struct dlm_ls *ls,\n\t\t\t\t     struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb = NULL;\n\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\tif (list_empty(&proc->locks))\n\t\tgoto out;\n\n\tlkb = list_entry(proc->locks.next, struct dlm_lkb, lkb_ownqueue);\n\tlist_del_init(&lkb->lkb_ownqueue);\n\n\tif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\n\t\tlkb->lkb_flags |= DLM_IFL_ORPHAN;\n\telse\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n out:\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n\treturn lkb;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic struct dlm_lkb *del_proc_lock(struct dlm_ls *ls,\n\t\t\t\t     struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb = NULL;\n\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\tif (list_empty(&proc->locks))\n\t\tgoto out;\n\n\tlkb = list_entry(proc->locks.next, struct dlm_lkb, lkb_ownqueue);\n\tlist_del_init(&lkb->lkb_ownqueue);\n\n\tif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\n\t\tlkb->lkb_flags |= DLM_IFL_ORPHAN;\n\telse\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n out:\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n\treturn lkb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_recovery",
          "args": [
            "ls"
          ],
          "line": 6175
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_recovery_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "215-218",
          "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_clear_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tdlm_lock_recovery(ls);\n\n\twhile (1) {\n\t\tlkb = del_proc_lock(ls, proc);\n\t\tif (!lkb)\n\t\t\tbreak;\n\t\tdel_timeout(lkb);\n\t\tif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\n\t\t\torphan_proc_lock(ls, lkb);\n\t\telse\n\t\t\tunlock_proc_lock(ls, lkb);\n\n\t\t/* this removes the reference for the proc->locks list\n\t\t   added by dlm_user_request, it may result in the lkb\n\t\t   being freed */\n\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\n\t/* in-progress unlocks */\n\tlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\n\t\tmemset(&lkb->lkb_callbacks, 0,\n\t\t       sizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n\tdlm_unlock_recovery(ls);\n}"
  },
  {
    "function_name": "del_proc_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "6140-6159",
    "snippet": "static struct dlm_lkb *del_proc_lock(struct dlm_ls *ls,\n\t\t\t\t     struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb = NULL;\n\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\tif (list_empty(&proc->locks))\n\t\tgoto out;\n\n\tlkb = list_entry(proc->locks.next, struct dlm_lkb, lkb_ownqueue);\n\tlist_del_init(&lkb->lkb_ownqueue);\n\n\tif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\n\t\tlkb->lkb_flags |= DLM_IFL_ORPHAN;\n\telse\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n out:\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n\treturn lkb;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_clear_proc_locks"
          ],
          "line": 6157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_ownqueue"
          ],
          "line": 6150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "proc->locks.next",
            "structdlm_lkb",
            "lkb_ownqueue"
          ],
          "line": 6149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&proc->locks"
          ],
          "line": 6146
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_clear_proc_locks"
          ],
          "line": 6145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic struct dlm_lkb *del_proc_lock(struct dlm_ls *ls,\n\t\t\t\t     struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb = NULL;\n\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\tif (list_empty(&proc->locks))\n\t\tgoto out;\n\n\tlkb = list_entry(proc->locks.next, struct dlm_lkb, lkb_ownqueue);\n\tlist_del_init(&lkb->lkb_ownqueue);\n\n\tif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\n\t\tlkb->lkb_flags |= DLM_IFL_ORPHAN;\n\telse\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n out:\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n\treturn lkb;\n}"
  },
  {
    "function_name": "unlock_proc_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "6122-6134",
    "snippet": "static int unlock_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\tset_unlock_args(DLM_LKF_FORCEUNLOCK | DLM_LKF_IVVALBLK,\n\t\t\tlkb->lkb_ua, &args);\n\n\terror = unlock_lock(ls, lkb, &args);\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_lock",
          "args": [
            "ls",
            "lkb",
            "&args"
          ],
          "line": 6130
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3361-3381",
          "snippet": "static int unlock_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _unlock_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int unlock_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _unlock_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_unlock_args",
          "args": [
            "DLM_LKF_FORCEUNLOCK | DLM_LKF_IVVALBLK",
            "lkb->lkb_ua",
            "&args"
          ],
          "line": 6127
        },
        "resolved": true,
        "details": {
          "function_name": "set_unlock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2871-2883",
          "snippet": "static int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int unlock_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\tset_unlock_args(DLM_LKF_FORCEUNLOCK | DLM_LKF_IVVALBLK,\n\t\t\tlkb->lkb_ua, &args);\n\n\terror = unlock_lock(ls, lkb, &args);\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\treturn error;\n}"
  },
  {
    "function_name": "orphan_proc_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "6099-6115",
    "snippet": "static int orphan_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\thold_lkb(lkb); /* reference for the ls_orphans list */\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ls->ls_orphans);\n\tmutex_unlock(&ls->ls_orphans_mutex);\n\n\tset_unlock_args(0, lkb->lkb_ua, &args);\n\n\terror = cancel_lock(ls, lkb, &args);\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancel_lock",
          "args": [
            "ls",
            "lkb",
            "&args"
          ],
          "line": 6111
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3383-3403",
          "snippet": "static int cancel_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _cancel_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int cancel_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _cancel_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_unlock_args",
          "args": [
            "0",
            "lkb->lkb_ua",
            "&args"
          ],
          "line": 6109
        },
        "resolved": true,
        "details": {
          "function_name": "set_unlock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2871-2883",
          "snippet": "static int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_orphans_mutex"
          ],
          "line": 6107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lkb->lkb_ownqueue",
            "&ls->ls_orphans"
          ],
          "line": 6106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_orphans_mutex"
          ],
          "line": 6105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hold_lkb",
          "args": [
            "lkb"
          ],
          "line": 6104
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int orphan_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\thold_lkb(lkb); /* reference for the ls_orphans list */\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ls->ls_orphans);\n\tmutex_unlock(&ls->ls_orphans_mutex);\n\n\tset_unlock_args(0, lkb->lkb_ua, &args);\n\n\terror = cancel_lock(ls, lkb, &args);\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_user_deadlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "6048-6094",
    "snippet": "int dlm_user_deadlock(struct dlm_ls *ls, uint32_t flags, uint32_t lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\t/* same as cancel_lock(), but set DEADLOCK_CANCEL after lock_rsb */\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, &args);\n\tif (error)\n\t\tgoto out_r;\n\tlkb->lkb_flags |= DLM_IFL_DEADLOCK_CANCEL;\n\n\terror = _cancel_lock(r, lkb);\n out_r:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_unlock_recovery",
          "args": [
            "ls"
          ],
          "line": 6092
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "210-213",
          "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 6090
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 6082
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 6081
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_cancel_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 6079
        },
        "resolved": true,
        "details": {
          "function_name": "_cancel_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3291-3306",
          "snippet": "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_cancel() calls do_cancel() on remote node */\n\t\terror = send_cancel(r, lkb);\n\t} else {\n\t\terror = do_cancel(r, lkb);\n\t\t/* for remote locks the cancel_reply is sent\n\t\t   between do_cancel and do_cancel_effects */\n\t\tdo_cancel_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_cancel() calls do_cancel() on remote node */\n\t\terror = send_cancel(r, lkb);\n\t} else {\n\t\terror = do_cancel(r, lkb);\n\t\t/* for remote locks the cancel_reply is sent\n\t\t   between do_cancel and do_cancel_effects */\n\t\tdo_cancel_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_unlock_args",
          "args": [
            "lkb",
            "&args"
          ],
          "line": 6074
        },
        "resolved": true,
        "details": {
          "function_name": "validate_unlock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2936-3064",
          "snippet": "static int validate_unlock_args(struct dlm_lkb *lkb, struct dlm_args *args)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv = -EINVAL;\n\n\tif (lkb->lkb_flags & DLM_IFL_MSTCPY) {\n\t\tlog_error(ls, \"unlock on MSTCPY %x\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tgoto out;\n\t}\n\n\t/* an lkb may still exist even though the lock is EOL'ed due to a\n\t   cancel, unlock or failed noqueue request; an app can't use these\n\t   locks; return same error as if the lkid had not been found at all */\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\tlog_debug(ls, \"unlock on ENDOFLIFE %x\", lkb->lkb_id);\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* an lkb may be waiting for an rsb lookup to complete where the\n\t   lookup was initiated by another lock */\n\n\tif (!list_empty(&lkb->lkb_rsb_lookup)) {\n\t\tif (args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) {\n\t\t\tlog_debug(ls, \"unlock on rsb_lookup %x\", lkb->lkb_id);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tqueue_cast(lkb->lkb_resource, lkb,\n\t\t\t\t   args->flags & DLM_LKF_CANCEL ?\n\t\t\t\t   -DLM_ECANCEL : -DLM_EUNLOCK);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t}\n\t\t/* caller changes -EBUSY to 0 for CANCEL and FORCEUNLOCK */\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* cancel not allowed with another cancel/unlock in progress */\n\n\tif (args->flags & DLM_LKF_CANCEL) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CANCEL)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* there's nothing to cancel */\n\t\tif (lkb->lkb_status == DLM_LKSTS_GRANTED &&\n\t\t    !lkb->lkb_wait_type) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_CANCEL */\n\t\tgoto out_ok;\n\t}\n\n\t/* do we need to allow a force-unlock if there's a normal unlock\n\t   already in progress?  in what conditions could the normal unlock\n\t   fail such that we'd want to send a force-unlock to be sure? */\n\n\tif (args->flags & DLM_LKF_FORCEUNLOCK) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK)\n\t\t\tgoto out;\n\n\t\tif (is_overlap_unlock(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_UNLOCK */\n\t\tgoto out_ok;\n\t}\n\n\t/* normal unlock not allowed if there's any op in progress */\n\trv = -EBUSY;\n\tif (lkb->lkb_wait_type || lkb->lkb_wait_count)\n\t\tgoto out;\n\n out_ok:\n\t/* an overlapping op shouldn't blow away exflags from other op */\n\tlkb->lkb_exflags |= args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astparam = args->astparam;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_unlock_args %d %x %x %x %x %d %s\", rv,\n\t\t\t  lkb->lkb_id, lkb->lkb_flags, lkb->lkb_exflags,\n\t\t\t  args->flags, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_unlock_args(struct dlm_lkb *lkb, struct dlm_args *args)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv = -EINVAL;\n\n\tif (lkb->lkb_flags & DLM_IFL_MSTCPY) {\n\t\tlog_error(ls, \"unlock on MSTCPY %x\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tgoto out;\n\t}\n\n\t/* an lkb may still exist even though the lock is EOL'ed due to a\n\t   cancel, unlock or failed noqueue request; an app can't use these\n\t   locks; return same error as if the lkid had not been found at all */\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\tlog_debug(ls, \"unlock on ENDOFLIFE %x\", lkb->lkb_id);\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* an lkb may be waiting for an rsb lookup to complete where the\n\t   lookup was initiated by another lock */\n\n\tif (!list_empty(&lkb->lkb_rsb_lookup)) {\n\t\tif (args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) {\n\t\t\tlog_debug(ls, \"unlock on rsb_lookup %x\", lkb->lkb_id);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tqueue_cast(lkb->lkb_resource, lkb,\n\t\t\t\t   args->flags & DLM_LKF_CANCEL ?\n\t\t\t\t   -DLM_ECANCEL : -DLM_EUNLOCK);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t}\n\t\t/* caller changes -EBUSY to 0 for CANCEL and FORCEUNLOCK */\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* cancel not allowed with another cancel/unlock in progress */\n\n\tif (args->flags & DLM_LKF_CANCEL) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CANCEL)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* there's nothing to cancel */\n\t\tif (lkb->lkb_status == DLM_LKSTS_GRANTED &&\n\t\t    !lkb->lkb_wait_type) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_CANCEL */\n\t\tgoto out_ok;\n\t}\n\n\t/* do we need to allow a force-unlock if there's a normal unlock\n\t   already in progress?  in what conditions could the normal unlock\n\t   fail such that we'd want to send a force-unlock to be sure? */\n\n\tif (args->flags & DLM_LKF_FORCEUNLOCK) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK)\n\t\t\tgoto out;\n\n\t\tif (is_overlap_unlock(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_UNLOCK */\n\t\tgoto out_ok;\n\t}\n\n\t/* normal unlock not allowed if there's any op in progress */\n\trv = -EBUSY;\n\tif (lkb->lkb_wait_type || lkb->lkb_wait_count)\n\t\tgoto out;\n\n out_ok:\n\t/* an overlapping op shouldn't blow away exflags from other op */\n\tlkb->lkb_exflags |= args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astparam = args->astparam;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_unlock_args %d %x %x %x %x %d %s\", rv,\n\t\t\t  lkb->lkb_id, lkb->lkb_flags, lkb->lkb_exflags,\n\t\t\t  args->flags, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 6071
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_unlock_args",
          "args": [
            "flags",
            "ua",
            "&args"
          ],
          "line": 6064
        },
        "resolved": true,
        "details": {
          "function_name": "set_unlock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2871-2883",
          "snippet": "static int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "lkid",
            "&lkb"
          ],
          "line": 6058
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_recovery",
          "args": [
            "ls"
          ],
          "line": 6056
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_recovery_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "215-218",
          "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_deadlock(struct dlm_ls *ls, uint32_t flags, uint32_t lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\t/* same as cancel_lock(), but set DEADLOCK_CANCEL after lock_rsb */\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, &args);\n\tif (error)\n\t\tgoto out_r;\n\tlkb->lkb_flags |= DLM_IFL_DEADLOCK_CANCEL;\n\n\terror = _cancel_lock(r, lkb);\n out_r:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_user_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "6010-6046",
    "snippet": "int dlm_user_cancel(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t    uint32_t flags, uint32_t lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\tif (ua_tmp->castparam)\n\t\tua->castparam = ua_tmp->castparam;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = cancel_lock(ls, lkb, &args);\n\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ua_tmp"
          ],
          "line": 6044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_unlock_recovery",
          "args": [
            "ls"
          ],
          "line": 6043
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "210-213",
          "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 6041
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_lock",
          "args": [
            "ls",
            "lkb",
            "&args"
          ],
          "line": 6033
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3383-3403",
          "snippet": "static int cancel_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _cancel_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int cancel_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _cancel_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_unlock_args",
          "args": [
            "flags",
            "ua",
            "&args"
          ],
          "line": 6029
        },
        "resolved": true,
        "details": {
          "function_name": "set_unlock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2871-2883",
          "snippet": "static int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "lkid",
            "&lkb"
          ],
          "line": 6020
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_recovery",
          "args": [
            "ls"
          ],
          "line": 6018
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_recovery_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "215-218",
          "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_cancel(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t    uint32_t flags, uint32_t lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\tif (ua_tmp->castparam)\n\t\tua->castparam = ua_tmp->castparam;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = cancel_lock(ls, lkb, &args);\n\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_user_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5961-6008",
    "snippet": "int dlm_user_unlock(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t    uint32_t flags, uint32_t lkid, char *lvb_in)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\n\tif (lvb_in && ua->lksb.sb_lvbptr)\n\t\tmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\n\tif (ua_tmp->castparam)\n\t\tua->castparam = ua_tmp->castparam;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY && (flags & DLM_LKF_FORCEUNLOCK))\n\t\terror = 0;\n\tif (error)\n\t\tgoto out_put;\n\n\tspin_lock(&ua->proc->locks_spin);\n\t/* dlm_user_add_cb() may have already taken lkb off the proc list */\n\tif (!list_empty(&lkb->lkb_ownqueue))\n\t\tlist_move(&lkb->lkb_ownqueue, &ua->proc->unlocking);\n\tspin_unlock(&ua->proc->locks_spin);\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ua_tmp"
          ],
          "line": 6006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_unlock_recovery",
          "args": [
            "ls"
          ],
          "line": 6005
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "210-213",
          "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 6003
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ua->proc->locks_spin"
          ],
          "line": 6001
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&lkb->lkb_ownqueue",
            "&ua->proc->unlocking"
          ],
          "line": 6000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lkb->lkb_ownqueue"
          ],
          "line": 5999
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ua->proc->locks_spin"
          ],
          "line": 5997
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_lock",
          "args": [
            "ls",
            "lkb",
            "&args"
          ],
          "line": 5987
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3361-3381",
          "snippet": "static int unlock_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _unlock_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int unlock_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _unlock_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_unlock_args",
          "args": [
            "flags",
            "ua",
            "&args"
          ],
          "line": 5983
        },
        "resolved": true,
        "details": {
          "function_name": "set_unlock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2871-2883",
          "snippet": "static int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ua->lksb.sb_lvbptr",
            "lvb_in",
            "DLM_USER_LVB_LEN"
          ],
          "line": 5978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "lkid",
            "&lkb"
          ],
          "line": 5971
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_recovery",
          "args": [
            "ls"
          ],
          "line": 5969
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_recovery_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "215-218",
          "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_unlock(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t    uint32_t flags, uint32_t lkid, char *lvb_in)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\n\tif (lvb_in && ua->lksb.sb_lvbptr)\n\t\tmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\n\tif (ua_tmp->castparam)\n\t\tua->castparam = ua_tmp->castparam;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY && (flags & DLM_LKF_FORCEUNLOCK))\n\t\terror = 0;\n\tif (error)\n\t\tgoto out_put;\n\n\tspin_lock(&ua->proc->locks_spin);\n\t/* dlm_user_add_cb() may have already taken lkb off the proc list */\n\tif (!list_empty(&lkb->lkb_ownqueue))\n\t\tlist_move(&lkb->lkb_ownqueue, &ua->proc->unlocking);\n\tspin_unlock(&ua->proc->locks_spin);\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_user_adopt_orphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5895-5959",
    "snippet": "int dlm_user_adopt_orphan(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t     int mode, uint32_t flags, void *name, unsigned int namelen,\n\t\t     unsigned long timeout_cs, uint32_t *lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_user_args *ua;\n\tint found_other_mode = 0;\n\tint found = 0;\n\tint rv = 0;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (lkb->lkb_resource->res_length != namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(lkb->lkb_resource->res_name, name, namelen))\n\t\t\tcontinue;\n\t\tif (lkb->lkb_grmode != mode) {\n\t\t\tfound_other_mode = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = 1;\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags &= ~DLM_IFL_ORPHAN;\n\t\t*lkid = lkb->lkb_id;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n\n\tif (!found && found_other_mode) {\n\t\trv = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (!found) {\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = flags;\n\tlkb->lkb_ownpid = (int) current->pid;\n\n\tua = lkb->lkb_ua;\n\n\tua->proc = ua_tmp->proc;\n\tua->xid = ua_tmp->xid;\n\tua->castparam = ua_tmp->castparam;\n\tua->castaddr = ua_tmp->castaddr;\n\tua->bastparam = ua_tmp->bastparam;\n\tua->bastaddr = ua_tmp->bastaddr;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\t/*\n\t * The lkb reference from the ls_orphans list was not\n\t * removed above, and is now considered the reference\n\t * for the proc locks list.\n\t */\n\n\tspin_lock(&ua->proc->locks_spin);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\n\tspin_unlock(&ua->proc->locks_spin);\n out:\n\tkfree(ua_tmp);\n\treturn rv;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ua_tmp"
          ],
          "line": 5957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ua->proc->locks_spin"
          ],
          "line": 5955
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lkb->lkb_ownqueue",
            "&ua->proc->locks"
          ],
          "line": 5954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ua->proc->locks_spin"
          ],
          "line": 5953
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_orphans_mutex"
          ],
          "line": 5922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_ownqueue"
          ],
          "line": 5917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "lkb->lkb_resource->res_name",
            "name",
            "namelen"
          ],
          "line": 5909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&ls->ls_orphans",
            "lkb_ownqueue"
          ],
          "line": 5906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_orphans_mutex"
          ],
          "line": 5905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_adopt_orphan(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t     int mode, uint32_t flags, void *name, unsigned int namelen,\n\t\t     unsigned long timeout_cs, uint32_t *lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_user_args *ua;\n\tint found_other_mode = 0;\n\tint found = 0;\n\tint rv = 0;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (lkb->lkb_resource->res_length != namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(lkb->lkb_resource->res_name, name, namelen))\n\t\t\tcontinue;\n\t\tif (lkb->lkb_grmode != mode) {\n\t\t\tfound_other_mode = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = 1;\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags &= ~DLM_IFL_ORPHAN;\n\t\t*lkid = lkb->lkb_id;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n\n\tif (!found && found_other_mode) {\n\t\trv = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (!found) {\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = flags;\n\tlkb->lkb_ownpid = (int) current->pid;\n\n\tua = lkb->lkb_ua;\n\n\tua->proc = ua_tmp->proc;\n\tua->xid = ua_tmp->xid;\n\tua->castparam = ua_tmp->castparam;\n\tua->castaddr = ua_tmp->castaddr;\n\tua->bastparam = ua_tmp->bastparam;\n\tua->bastaddr = ua_tmp->bastaddr;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\t/*\n\t * The lkb reference from the ls_orphans list was not\n\t * removed above, and is now considered the reference\n\t * for the proc locks list.\n\t */\n\n\tspin_lock(&ua->proc->locks_spin);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\n\tspin_unlock(&ua->proc->locks_spin);\n out:\n\tkfree(ua_tmp);\n\treturn rv;\n}"
  },
  {
    "function_name": "dlm_user_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5835-5887",
    "snippet": "int dlm_user_convert(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t     int mode, uint32_t flags, uint32_t lkid, char *lvb_in,\n\t\t     unsigned long timeout_cs)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\t/* user can change the params on its lock when it converts it, or\n\t   add an lvb that didn't exist before */\n\n\tua = lkb->lkb_ua;\n\n\tif (flags & DLM_LKF_VALBLK && !ua->lksb.sb_lvbptr) {\n\t\tua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\n\t\tif (!ua->lksb.sb_lvbptr) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\tif (lvb_in && ua->lksb.sb_lvbptr)\n\t\tmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\n\n\tua->xid = ua_tmp->xid;\n\tua->castparam = ua_tmp->castparam;\n\tua->castaddr = ua_tmp->castaddr;\n\tua->bastparam = ua_tmp->bastparam;\n\tua->bastaddr = ua_tmp->bastaddr;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_lock_args(mode, &ua->lksb, flags, 0, timeout_cs,\n\t\t\t      fake_astfn, ua, fake_bastfn, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = convert_lock(ls, lkb, &args);\n\n\tif (error == -EINPROGRESS || error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ua_tmp"
          ],
          "line": 5885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_unlock_recovery",
          "args": [
            "ls"
          ],
          "line": 5884
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "210-213",
          "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 5882
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_lock",
          "args": [
            "ls",
            "lkb",
            "&args"
          ],
          "line": 5877
        },
        "resolved": true,
        "details": {
          "function_name": "convert_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3339-3359",
          "snippet": "static int convert_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\tstruct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _convert_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int convert_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\tstruct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _convert_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_lock_args",
          "args": [
            "mode",
            "&ua->lksb",
            "flags",
            "0",
            "timeout_cs",
            "fake_astfn",
            "ua",
            "fake_bastfn",
            "&args"
          ],
          "line": 5872
        },
        "resolved": true,
        "details": {
          "function_name": "set_lock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2805-2869",
          "snippet": "static int set_lock_args(int mode, struct dlm_lksb *lksb, uint32_t flags,\n\t\t\t int namelen, unsigned long timeout_cs,\n\t\t\t void (*ast) (void *astparam),\n\t\t\t void *astparam,\n\t\t\t void (*bast) (void *astparam, int mode),\n\t\t\t struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\t/* check for invalid arg usage */\n\n\tif (mode < 0 || mode > DLM_LOCK_EX)\n\t\tgoto out;\n\n\tif (!(flags & DLM_LKF_CONVERT) && (namelen > DLM_RESNAME_MAXLEN))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_QUECVT && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_CONVERT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_QUECVT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && mode != DLM_LOCK_NL)\n\t\tgoto out;\n\n\tif (!ast || !lksb)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_VALBLK && !lksb->sb_lvbptr)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVERT && !lksb->sb_lkid)\n\t\tgoto out;\n\n\t/* these args will be copied to the lkb in validate_lock_args,\n\t   it cannot be done now because when converting locks, fields in\n\t   an active lkb cannot be modified before locking the rsb */\n\n\targs->flags = flags;\n\targs->astfn = ast;\n\targs->astparam = astparam;\n\targs->bastfn = bast;\n\targs->timeout = timeout_cs;\n\targs->mode = mode;\n\targs->lksb = lksb;\n\trv = 0;\n out:\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int set_lock_args(int mode, struct dlm_lksb *lksb, uint32_t flags,\n\t\t\t int namelen, unsigned long timeout_cs,\n\t\t\t void (*ast) (void *astparam),\n\t\t\t void *astparam,\n\t\t\t void (*bast) (void *astparam, int mode),\n\t\t\t struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\t/* check for invalid arg usage */\n\n\tif (mode < 0 || mode > DLM_LOCK_EX)\n\t\tgoto out;\n\n\tif (!(flags & DLM_LKF_CONVERT) && (namelen > DLM_RESNAME_MAXLEN))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_QUECVT && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_CONVERT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_QUECVT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && mode != DLM_LOCK_NL)\n\t\tgoto out;\n\n\tif (!ast || !lksb)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_VALBLK && !lksb->sb_lvbptr)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVERT && !lksb->sb_lkid)\n\t\tgoto out;\n\n\t/* these args will be copied to the lkb in validate_lock_args,\n\t   it cannot be done now because when converting locks, fields in\n\t   an active lkb cannot be modified before locking the rsb */\n\n\targs->flags = flags;\n\targs->astfn = ast;\n\targs->astparam = astparam;\n\targs->bastfn = bast;\n\targs->timeout = timeout_cs;\n\targs->mode = mode;\n\targs->lksb = lksb;\n\trv = 0;\n out:\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ua->lksb.sb_lvbptr",
            "lvb_in",
            "DLM_USER_LVB_LEN"
          ],
          "line": 5863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "DLM_USER_LVB_LEN",
            "GFP_NOFS"
          ],
          "line": 5856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "lkid",
            "&lkb"
          ],
          "line": 5846
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_recovery",
          "args": [
            "ls"
          ],
          "line": 5844
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_recovery_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "215-218",
          "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_convert(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t     int mode, uint32_t flags, uint32_t lkid, char *lvb_in,\n\t\t     unsigned long timeout_cs)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\t/* user can change the params on its lock when it converts it, or\n\t   add an lvb that didn't exist before */\n\n\tua = lkb->lkb_ua;\n\n\tif (flags & DLM_LKF_VALBLK && !ua->lksb.sb_lvbptr) {\n\t\tua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\n\t\tif (!ua->lksb.sb_lvbptr) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\tif (lvb_in && ua->lksb.sb_lvbptr)\n\t\tmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\n\n\tua->xid = ua_tmp->xid;\n\tua->castparam = ua_tmp->castparam;\n\tua->castaddr = ua_tmp->castaddr;\n\tua->bastparam = ua_tmp->bastparam;\n\tua->bastaddr = ua_tmp->bastaddr;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_lock_args(mode, &ua->lksb, flags, 0, timeout_cs,\n\t\t\t      fake_astfn, ua, fake_bastfn, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = convert_lock(ls, lkb, &args);\n\n\tif (error == -EINPROGRESS || error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_user_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5770-5833",
    "snippet": "int dlm_user_request(struct dlm_ls *ls, struct dlm_user_args *ua,\n\t\t     int mode, uint32_t flags, void *name, unsigned int namelen,\n\t\t     unsigned long timeout_cs)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = create_lkb(ls, &lkb);\n\tif (error) {\n\t\tkfree(ua);\n\t\tgoto out;\n\t}\n\n\tif (flags & DLM_LKF_VALBLK) {\n\t\tua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\n\t\tif (!ua->lksb.sb_lvbptr) {\n\t\t\tkfree(ua);\n\t\t\t__put_lkb(ls, lkb);\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* After ua is attached to lkb it will be freed by dlm_free_lkb().\n\t   When DLM_IFL_USER is set, the dlm knows that this is a userspace\n\t   lock and that lkb_astparam is the dlm_user_args structure. */\n\n\terror = set_lock_args(mode, &ua->lksb, flags, namelen, timeout_cs,\n\t\t\t      fake_astfn, ua, fake_bastfn, &args);\n\tlkb->lkb_flags |= DLM_IFL_USER;\n\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out;\n\t}\n\n\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\terror = 0;\n\t\tbreak;\n\tcase -EAGAIN:\n\t\terror = 0;\n\t\t/* fall through */\n\tdefault:\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out;\n\t}\n\n\t/* add this new lkb to the per-process list of locks */\n\tspin_lock(&ua->proc->locks_spin);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\n\tspin_unlock(&ua->proc->locks_spin);\n out:\n\tdlm_unlock_recovery(ls);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_unlock_recovery",
          "args": [
            "ls"
          ],
          "line": 5831
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "210-213",
          "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ua->proc->locks_spin"
          ],
          "line": 5829
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lkb->lkb_ownqueue",
            "&ua->proc->locks"
          ],
          "line": 5828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hold_lkb",
          "args": [
            "lkb"
          ],
          "line": 5827
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ua->proc->locks_spin"
          ],
          "line": 5826
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_lkb",
          "args": [
            "ls",
            "lkb"
          ],
          "line": 5821
        },
        "resolved": true,
        "details": {
          "function_name": "__put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1247-1267",
          "snippet": "static int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_lock",
          "args": [
            "ls",
            "lkb",
            "name",
            "namelen",
            "&args"
          ],
          "line": 5809
        },
        "resolved": true,
        "details": {
          "function_name": "request_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3313-3337",
          "snippet": "static int request_lock(struct dlm_ls *ls, struct dlm_lkb *lkb, char *name,\n\t\t\tint len, struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\treturn error;\n\n\terror = find_rsb(ls, name, len, 0, R_REQUEST, &r);\n\tif (error)\n\t\treturn error;\n\n\tlock_rsb(r);\n\n\tattach_lkb(r, lkb);\n\tlkb->lkb_lksb->sb_lkid = lkb->lkb_id;\n\n\terror = _request_lock(r, lkb);\n\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int request_lock(struct dlm_ls *ls, struct dlm_lkb *lkb, char *name,\n\t\t\tint len, struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\treturn error;\n\n\terror = find_rsb(ls, name, len, 0, R_REQUEST, &r);\n\tif (error)\n\t\treturn error;\n\n\tlock_rsb(r);\n\n\tattach_lkb(r, lkb);\n\tlkb->lkb_lksb->sb_lkid = lkb->lkb_id;\n\n\terror = _request_lock(r, lkb);\n\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_lock_args",
          "args": [
            "mode",
            "&ua->lksb",
            "flags",
            "namelen",
            "timeout_cs",
            "fake_astfn",
            "ua",
            "fake_bastfn",
            "&args"
          ],
          "line": 5800
        },
        "resolved": true,
        "details": {
          "function_name": "set_lock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2805-2869",
          "snippet": "static int set_lock_args(int mode, struct dlm_lksb *lksb, uint32_t flags,\n\t\t\t int namelen, unsigned long timeout_cs,\n\t\t\t void (*ast) (void *astparam),\n\t\t\t void *astparam,\n\t\t\t void (*bast) (void *astparam, int mode),\n\t\t\t struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\t/* check for invalid arg usage */\n\n\tif (mode < 0 || mode > DLM_LOCK_EX)\n\t\tgoto out;\n\n\tif (!(flags & DLM_LKF_CONVERT) && (namelen > DLM_RESNAME_MAXLEN))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_QUECVT && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_CONVERT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_QUECVT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && mode != DLM_LOCK_NL)\n\t\tgoto out;\n\n\tif (!ast || !lksb)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_VALBLK && !lksb->sb_lvbptr)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVERT && !lksb->sb_lkid)\n\t\tgoto out;\n\n\t/* these args will be copied to the lkb in validate_lock_args,\n\t   it cannot be done now because when converting locks, fields in\n\t   an active lkb cannot be modified before locking the rsb */\n\n\targs->flags = flags;\n\targs->astfn = ast;\n\targs->astparam = astparam;\n\targs->bastfn = bast;\n\targs->timeout = timeout_cs;\n\targs->mode = mode;\n\targs->lksb = lksb;\n\trv = 0;\n out:\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int set_lock_args(int mode, struct dlm_lksb *lksb, uint32_t flags,\n\t\t\t int namelen, unsigned long timeout_cs,\n\t\t\t void (*ast) (void *astparam),\n\t\t\t void *astparam,\n\t\t\t void (*bast) (void *astparam, int mode),\n\t\t\t struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\t/* check for invalid arg usage */\n\n\tif (mode < 0 || mode > DLM_LOCK_EX)\n\t\tgoto out;\n\n\tif (!(flags & DLM_LKF_CONVERT) && (namelen > DLM_RESNAME_MAXLEN))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_QUECVT && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_CONVERT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_QUECVT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && mode != DLM_LOCK_NL)\n\t\tgoto out;\n\n\tif (!ast || !lksb)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_VALBLK && !lksb->sb_lvbptr)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVERT && !lksb->sb_lkid)\n\t\tgoto out;\n\n\t/* these args will be copied to the lkb in validate_lock_args,\n\t   it cannot be done now because when converting locks, fields in\n\t   an active lkb cannot be modified before locking the rsb */\n\n\targs->flags = flags;\n\targs->astfn = ast;\n\targs->astparam = astparam;\n\targs->bastfn = bast;\n\targs->timeout = timeout_cs;\n\targs->mode = mode;\n\targs->lksb = lksb;\n\trv = 0;\n out:\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ua"
          ],
          "line": 5789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "DLM_USER_LVB_LEN",
            "GFP_NOFS"
          ],
          "line": 5787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ua"
          ],
          "line": 5782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_lkb",
          "args": [
            "ls",
            "&lkb"
          ],
          "line": 5780
        },
        "resolved": true,
        "details": {
          "function_name": "create_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1184-1218",
          "snippet": "static int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_time_list);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tmutex_init(&lkb->lkb_cb_mutex);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, 1, 0, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_time_list);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tmutex_init(&lkb->lkb_cb_mutex);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, 1, 0, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_recovery",
          "args": [
            "ls"
          ],
          "line": 5778
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_recovery_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "215-218",
          "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_request(struct dlm_ls *ls, struct dlm_user_args *ua,\n\t\t     int mode, uint32_t flags, void *name, unsigned int namelen,\n\t\t     unsigned long timeout_cs)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = create_lkb(ls, &lkb);\n\tif (error) {\n\t\tkfree(ua);\n\t\tgoto out;\n\t}\n\n\tif (flags & DLM_LKF_VALBLK) {\n\t\tua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\n\t\tif (!ua->lksb.sb_lvbptr) {\n\t\t\tkfree(ua);\n\t\t\t__put_lkb(ls, lkb);\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* After ua is attached to lkb it will be freed by dlm_free_lkb().\n\t   When DLM_IFL_USER is set, the dlm knows that this is a userspace\n\t   lock and that lkb_astparam is the dlm_user_args structure. */\n\n\terror = set_lock_args(mode, &ua->lksb, flags, namelen, timeout_cs,\n\t\t\t      fake_astfn, ua, fake_bastfn, &args);\n\tlkb->lkb_flags |= DLM_IFL_USER;\n\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out;\n\t}\n\n\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\terror = 0;\n\t\tbreak;\n\tcase -EAGAIN:\n\t\terror = 0;\n\t\t/* fall through */\n\tdefault:\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out;\n\t}\n\n\t/* add this new lkb to the per-process list of locks */\n\tspin_lock(&ua->proc->locks_spin);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\n\tspin_unlock(&ua->proc->locks_spin);\n out:\n\tdlm_unlock_recovery(ls);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_recover_process_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5706-5768",
    "snippet": "int dlm_recover_process_copy(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tuint32_t lkid, remid;\n\tint error, result;\n\n\tlkid = le32_to_cpu(rl->rl_lkid);\n\tremid = le32_to_cpu(rl->rl_remid);\n\tresult = le32_to_cpu(rl->rl_result);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error) {\n\t\tlog_error(ls, \"dlm_recover_process_copy no %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\treturn error;\n\t}\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\tif (!is_process_copy(lkb)) {\n\t\tlog_error(ls, \"dlm_recover_process_copy bad %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\tdlm_dump_rsb(r);\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (result) {\n\tcase -EBADR:\n\t\t/* There's a chance the new master received our lock before\n\t\t   dlm_recover_master_reply(), this wouldn't happen if we did\n\t\t   a barrier between recover_masters and recover_locks. */\n\n\t\tlog_debug(ls, \"dlm_recover_process_copy %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\n\t\tdlm_send_rcom_lock(r, lkb);\n\t\tgoto out;\n\tcase -EEXIST:\n\tcase 0:\n\t\tlkb->lkb_remid = remid;\n\t\tbreak;\n\tdefault:\n\t\tlog_error(ls, \"dlm_recover_process_copy %x remote %d %x %d unk\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t}\n\n\t/* an ack for dlm_recover_locks() which waits for replies from\n\t   all the locks it sends to new masters */\n\tdlm_recovered_lock(r);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 5765
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 5764
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 5763
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recovered_lock",
          "args": [
            "r"
          ],
          "line": 5761
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recovered_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "697-709",
          "snippet": "void dlm_recovered_lock(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(rsb_flag(r, RSB_NEW_MASTER), dlm_dump_rsb(r););\n\n\tr->res_recover_locks_count--;\n\tif (!r->res_recover_locks_count) {\n\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\trecover_list_del(r);\n\t}\n\n\tif (recover_list_empty(r->res_ls))\n\t\twake_up(&r->res_ls->ls_wait_general);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recovered_lock(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(rsb_flag(r, RSB_NEW_MASTER), dlm_dump_rsb(r););\n\n\tr->res_recover_locks_count--;\n\tif (!r->res_recover_locks_count) {\n\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\trecover_list_del(r);\n\t}\n\n\tif (recover_list_empty(r->res_ls))\n\t\twake_up(&r->res_ls->ls_wait_general);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_recover_process_copy %x remote %d %x %d unk\"",
            "lkid",
            "rc->rc_header.h_nodeid",
            "remid",
            "result"
          ],
          "line": 5755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_send_rcom_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 5748
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_rcom_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "417-439",
          "snippet": "int dlm_send_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_lock *rl;\n\tint error, len = sizeof(struct rcom_lock);\n\n\tif (lkb->lkb_lvbptr)\n\t\tlen += ls->ls_lvblen;\n\n\terror = create_rcom(ls, r->res_nodeid, DLM_RCOM_LOCK, len, &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\trl = (struct rcom_lock *) rc->rc_buf;\n\tpack_rcom_lock(r, lkb, rl);\n\trc->rc_id = (unsigned long) r;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_send_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_lock *rl;\n\tint error, len = sizeof(struct rcom_lock);\n\n\tif (lkb->lkb_lvbptr)\n\t\tlen += ls->ls_lvblen;\n\n\terror = create_rcom(ls, r->res_nodeid, DLM_RCOM_LOCK, len, &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\trl = (struct rcom_lock *) rc->rc_buf;\n\tpack_rcom_lock(r, lkb, rl);\n\trc->rc_id = (unsigned long) r;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"dlm_recover_process_copy %x remote %d %x %d\"",
            "lkid",
            "rc->rc_header.h_nodeid",
            "remid",
            "result"
          ],
          "line": 5745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 5732
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_recover_process_copy bad %x remote %d %x %d\"",
            "lkid",
            "rc->rc_header.h_nodeid",
            "remid",
            "result"
          ],
          "line": 5730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_process_copy",
          "args": [
            "lkb"
          ],
          "line": 5729
        },
        "resolved": true,
        "details": {
          "function_name": "is_process_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "251-254",
          "snippet": "static inline int is_process_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_nodeid && !(lkb->lkb_flags & DLM_IFL_MSTCPY));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_process_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_nodeid && !(lkb->lkb_flags & DLM_IFL_MSTCPY));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 5726
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_recover_process_copy no %x remote %d %x %d\"",
            "lkid",
            "rc->rc_header.h_nodeid",
            "remid",
            "result"
          ],
          "line": 5720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "lkid",
            "&lkb"
          ],
          "line": 5718
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rl->rl_result"
          ],
          "line": 5716
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_recover_process_copy(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tuint32_t lkid, remid;\n\tint error, result;\n\n\tlkid = le32_to_cpu(rl->rl_lkid);\n\tremid = le32_to_cpu(rl->rl_remid);\n\tresult = le32_to_cpu(rl->rl_result);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error) {\n\t\tlog_error(ls, \"dlm_recover_process_copy no %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\treturn error;\n\t}\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\tif (!is_process_copy(lkb)) {\n\t\tlog_error(ls, \"dlm_recover_process_copy bad %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\tdlm_dump_rsb(r);\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (result) {\n\tcase -EBADR:\n\t\t/* There's a chance the new master received our lock before\n\t\t   dlm_recover_master_reply(), this wouldn't happen if we did\n\t\t   a barrier between recover_masters and recover_locks. */\n\n\t\tlog_debug(ls, \"dlm_recover_process_copy %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\n\t\tdlm_send_rcom_lock(r, lkb);\n\t\tgoto out;\n\tcase -EEXIST:\n\tcase 0:\n\t\tlkb->lkb_remid = remid;\n\t\tbreak;\n\tdefault:\n\t\tlog_error(ls, \"dlm_recover_process_copy %x remote %d %x %d unk\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t}\n\n\t/* an ack for dlm_recover_locks() which waits for replies from\n\t   all the locks it sends to new masters */\n\tdlm_recovered_lock(r);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_recover_master_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5625-5703",
    "snippet": "int dlm_recover_master_copy(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tuint32_t remid = 0;\n\tint from_nodeid = rc->rc_header.h_nodeid;\n\tint error;\n\n\tif (rl->rl_parent_lkid) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tremid = le32_to_cpu(rl->rl_lkid);\n\n\t/* In general we expect the rsb returned to be R_MASTER, but we don't\n\t   have to require it.  Recovery of masters on one node can overlap\n\t   recovery of locks on another node, so one node can send us MSTCPY\n\t   locks before we've made ourselves master of this rsb.  We can still\n\t   add new MSTCPY locks that we receive here without any harm; when\n\t   we make ourselves master, dlm_recover_masters() won't touch the\n\t   MSTCPY locks we've received early. */\n\n\terror = find_rsb(ls, rl->rl_name, le16_to_cpu(rl->rl_namelen),\n\t\t\t from_nodeid, R_RECEIVE_RECOVER, &r);\n\tif (error)\n\t\tgoto out;\n\n\tlock_rsb(r);\n\n\tif (dlm_no_directory(ls) && (dlm_dir_nodeid(r) != dlm_our_nodeid())) {\n\t\tlog_error(ls, \"dlm_recover_master_copy remote %d %x not dir\",\n\t\t\t  from_nodeid, remid);\n\t\terror = -EBADR;\n\t\tgoto out_unlock;\n\t}\n\n\tlkb = search_remid(r, from_nodeid, remid);\n\tif (lkb) {\n\t\terror = -EEXIST;\n\t\tgoto out_remid;\n\t}\n\n\terror = create_lkb(ls, &lkb);\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = receive_rcom_lock_args(ls, lkb, r, rc);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out_unlock;\n\t}\n\n\tattach_lkb(r, lkb);\n\tadd_lkb(r, lkb, rl->rl_status);\n\terror = 0;\n\tls->ls_recover_locks_in++;\n\n\tif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\n\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n\n out_remid:\n\t/* this is the new value returned to the lock holder for\n\t   saving in its process-copy lkb */\n\trl->rl_remid = cpu_to_le32(lkb->lkb_id);\n\n\tlkb->lkb_recover_seq = ls->ls_recover_seq;\n\n out_unlock:\n\tunlock_rsb(r);\n\tput_rsb(r);\n out:\n\tif (error && error != -EEXIST)\n\t\tlog_rinfo(ls, \"dlm_recover_master_copy remote %d %x error %d\",\n\t\t\t  from_nodeid, remid, error);\n\trl->rl_result = cpu_to_le32(error);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "error"
          ],
          "line": 5701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_master_copy remote %d %x error %d\"",
            "from_nodeid",
            "remid",
            "error"
          ],
          "line": 5699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 5696
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 5695
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lkb->lkb_id"
          ],
          "line": 5690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "r",
            "RSB_RECOVER_GRANT"
          ],
          "line": 5685
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&r->res_convertqueue"
          ],
          "line": 5684
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_lkb",
          "args": [
            "r",
            "lkb",
            "rl->rl_status"
          ],
          "line": 5680
        },
        "resolved": true,
        "details": {
          "function_name": "add_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1314-1346",
          "snippet": "static void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_lkb",
          "args": [
            "r",
            "lkb"
          ],
          "line": 5679
        },
        "resolved": true,
        "details": {
          "function_name": "attach_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1170-1174",
          "snippet": "static void attach_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\thold_rsb(r);\n\tlkb->lkb_resource = r;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void attach_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\thold_rsb(r);\n\tlkb->lkb_resource = r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_lkb",
          "args": [
            "ls",
            "lkb"
          ],
          "line": 5675
        },
        "resolved": true,
        "details": {
          "function_name": "__put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1247-1267",
          "snippet": "static int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_rcom_lock_args",
          "args": [
            "ls",
            "lkb",
            "r",
            "rc"
          ],
          "line": 5673
        },
        "resolved": true,
        "details": {
          "function_name": "receive_rcom_lock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5574-5616",
          "snippet": "static int receive_rcom_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t  struct dlm_rsb *r, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\n\tlkb->lkb_nodeid = rc->rc_header.h_nodeid;\n\tlkb->lkb_ownpid = le32_to_cpu(rl->rl_ownpid);\n\tlkb->lkb_remid = le32_to_cpu(rl->rl_lkid);\n\tlkb->lkb_exflags = le32_to_cpu(rl->rl_exflags);\n\tlkb->lkb_flags = le32_to_cpu(rl->rl_flags) & 0x0000FFFF;\n\tlkb->lkb_flags |= DLM_IFL_MSTCPY;\n\tlkb->lkb_lvbseq = le32_to_cpu(rl->rl_lvbseq);\n\tlkb->lkb_rqmode = rl->rl_rqmode;\n\tlkb->lkb_grmode = rl->rl_grmode;\n\t/* don't set lkb_status because add_lkb wants to itself */\n\n\tlkb->lkb_bastfn = (rl->rl_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\n\tlkb->lkb_astfn = (rl->rl_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tint lvblen = rc->rc_header.h_length - sizeof(struct dlm_rcom) -\n\t\t\t sizeof(struct rcom_lock);\n\t\tif (lvblen > ls->ls_lvblen)\n\t\t\treturn -EINVAL;\n\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(lkb->lkb_lvbptr, rl->rl_lvb, lvblen);\n\t}\n\n\t/* Conversions between PR and CW (middle modes) need special handling.\n\t   The real granted mode of these converting locks cannot be determined\n\t   until all locks have been rebuilt on the rsb (recover_conversion) */\n\n\tif (rl->rl_wait_type == cpu_to_le16(DLM_MSG_CONVERT) &&\n\t    middle_conversion(lkb)) {\n\t\trl->rl_status = DLM_LKSTS_CONVERT;\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\trsb_set_flag(r, RSB_RECOVER_CONVERT);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_rcom_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t  struct dlm_rsb *r, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\n\tlkb->lkb_nodeid = rc->rc_header.h_nodeid;\n\tlkb->lkb_ownpid = le32_to_cpu(rl->rl_ownpid);\n\tlkb->lkb_remid = le32_to_cpu(rl->rl_lkid);\n\tlkb->lkb_exflags = le32_to_cpu(rl->rl_exflags);\n\tlkb->lkb_flags = le32_to_cpu(rl->rl_flags) & 0x0000FFFF;\n\tlkb->lkb_flags |= DLM_IFL_MSTCPY;\n\tlkb->lkb_lvbseq = le32_to_cpu(rl->rl_lvbseq);\n\tlkb->lkb_rqmode = rl->rl_rqmode;\n\tlkb->lkb_grmode = rl->rl_grmode;\n\t/* don't set lkb_status because add_lkb wants to itself */\n\n\tlkb->lkb_bastfn = (rl->rl_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\n\tlkb->lkb_astfn = (rl->rl_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tint lvblen = rc->rc_header.h_length - sizeof(struct dlm_rcom) -\n\t\t\t sizeof(struct rcom_lock);\n\t\tif (lvblen > ls->ls_lvblen)\n\t\t\treturn -EINVAL;\n\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(lkb->lkb_lvbptr, rl->rl_lvb, lvblen);\n\t}\n\n\t/* Conversions between PR and CW (middle modes) need special handling.\n\t   The real granted mode of these converting locks cannot be determined\n\t   until all locks have been rebuilt on the rsb (recover_conversion) */\n\n\tif (rl->rl_wait_type == cpu_to_le16(DLM_MSG_CONVERT) &&\n\t    middle_conversion(lkb)) {\n\t\trl->rl_status = DLM_LKSTS_CONVERT;\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\trsb_set_flag(r, RSB_RECOVER_CONVERT);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_lkb",
          "args": [
            "ls",
            "&lkb"
          ],
          "line": 5669
        },
        "resolved": true,
        "details": {
          "function_name": "create_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1184-1218",
          "snippet": "static int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_time_list);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tmutex_init(&lkb->lkb_cb_mutex);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, 1, 0, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_time_list);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tmutex_init(&lkb->lkb_cb_mutex);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, 1, 0, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_remid",
          "args": [
            "r",
            "from_nodeid",
            "remid"
          ],
          "line": 5663
        },
        "resolved": true,
        "details": {
          "function_name": "search_remid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5556-5571",
          "snippet": "static struct dlm_lkb *search_remid(struct dlm_rsb *r, int nodeid,\n\t\t\t\t    uint32_t remid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlkb = search_remid_list(&r->res_grantqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\tlkb = search_remid_list(&r->res_convertqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\tlkb = search_remid_list(&r->res_waitqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic struct dlm_lkb *search_remid(struct dlm_rsb *r, int nodeid,\n\t\t\t\t    uint32_t remid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlkb = search_remid_list(&r->res_grantqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\tlkb = search_remid_list(&r->res_convertqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\tlkb = search_remid_list(&r->res_waitqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_recover_master_copy remote %d %x not dir\"",
            "from_nodeid",
            "remid"
          ],
          "line": 5657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 5656
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dir_nodeid",
          "args": [
            "r"
          ],
          "line": 5656
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "47-50",
          "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_no_directory",
          "args": [
            "ls"
          ],
          "line": 5656
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "705-708",
          "snippet": "static inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_NODIR\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_NODIR\t\t10\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_rsb",
          "args": [
            "ls",
            "rl->rl_name",
            "le16_to_cpu(rl->rl_namelen)",
            "from_nodeid",
            "R_RECEIVE_RECOVER",
            "&r"
          ],
          "line": 5649
        },
        "resolved": true,
        "details": {
          "function_name": "find_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "818-838",
          "snippet": "static int find_rsb(struct dlm_ls *ls, char *name, int len, int from_nodeid,\n\t\t    unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tuint32_t hash, b;\n\tint dir_nodeid;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tif (dlm_no_directory(ls))\n\t\treturn find_rsb_nodir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n\telse\n\t\treturn find_rsb_dir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int find_rsb(struct dlm_ls *ls, char *name, int len, int from_nodeid,\n\t\t    unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tuint32_t hash, b;\n\tint dir_nodeid;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tif (dlm_no_directory(ls))\n\t\treturn find_rsb_nodir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n\telse\n\t\treturn find_rsb_dir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rl->rl_namelen"
          ],
          "line": 5649
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rl->rl_lkid"
          ],
          "line": 5639
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_recover_master_copy(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tuint32_t remid = 0;\n\tint from_nodeid = rc->rc_header.h_nodeid;\n\tint error;\n\n\tif (rl->rl_parent_lkid) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tremid = le32_to_cpu(rl->rl_lkid);\n\n\t/* In general we expect the rsb returned to be R_MASTER, but we don't\n\t   have to require it.  Recovery of masters on one node can overlap\n\t   recovery of locks on another node, so one node can send us MSTCPY\n\t   locks before we've made ourselves master of this rsb.  We can still\n\t   add new MSTCPY locks that we receive here without any harm; when\n\t   we make ourselves master, dlm_recover_masters() won't touch the\n\t   MSTCPY locks we've received early. */\n\n\terror = find_rsb(ls, rl->rl_name, le16_to_cpu(rl->rl_namelen),\n\t\t\t from_nodeid, R_RECEIVE_RECOVER, &r);\n\tif (error)\n\t\tgoto out;\n\n\tlock_rsb(r);\n\n\tif (dlm_no_directory(ls) && (dlm_dir_nodeid(r) != dlm_our_nodeid())) {\n\t\tlog_error(ls, \"dlm_recover_master_copy remote %d %x not dir\",\n\t\t\t  from_nodeid, remid);\n\t\terror = -EBADR;\n\t\tgoto out_unlock;\n\t}\n\n\tlkb = search_remid(r, from_nodeid, remid);\n\tif (lkb) {\n\t\terror = -EEXIST;\n\t\tgoto out_remid;\n\t}\n\n\terror = create_lkb(ls, &lkb);\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = receive_rcom_lock_args(ls, lkb, r, rc);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out_unlock;\n\t}\n\n\tattach_lkb(r, lkb);\n\tadd_lkb(r, lkb, rl->rl_status);\n\terror = 0;\n\tls->ls_recover_locks_in++;\n\n\tif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\n\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n\n out_remid:\n\t/* this is the new value returned to the lock holder for\n\t   saving in its process-copy lkb */\n\trl->rl_remid = cpu_to_le32(lkb->lkb_id);\n\n\tlkb->lkb_recover_seq = ls->ls_recover_seq;\n\n out_unlock:\n\tunlock_rsb(r);\n\tput_rsb(r);\n out:\n\tif (error && error != -EEXIST)\n\t\tlog_rinfo(ls, \"dlm_recover_master_copy remote %d %x error %d\",\n\t\t\t  from_nodeid, remid, error);\n\trl->rl_result = cpu_to_le32(error);\n\treturn error;\n}"
  },
  {
    "function_name": "receive_rcom_lock_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5574-5616",
    "snippet": "static int receive_rcom_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t  struct dlm_rsb *r, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\n\tlkb->lkb_nodeid = rc->rc_header.h_nodeid;\n\tlkb->lkb_ownpid = le32_to_cpu(rl->rl_ownpid);\n\tlkb->lkb_remid = le32_to_cpu(rl->rl_lkid);\n\tlkb->lkb_exflags = le32_to_cpu(rl->rl_exflags);\n\tlkb->lkb_flags = le32_to_cpu(rl->rl_flags) & 0x0000FFFF;\n\tlkb->lkb_flags |= DLM_IFL_MSTCPY;\n\tlkb->lkb_lvbseq = le32_to_cpu(rl->rl_lvbseq);\n\tlkb->lkb_rqmode = rl->rl_rqmode;\n\tlkb->lkb_grmode = rl->rl_grmode;\n\t/* don't set lkb_status because add_lkb wants to itself */\n\n\tlkb->lkb_bastfn = (rl->rl_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\n\tlkb->lkb_astfn = (rl->rl_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tint lvblen = rc->rc_header.h_length - sizeof(struct dlm_rcom) -\n\t\t\t sizeof(struct rcom_lock);\n\t\tif (lvblen > ls->ls_lvblen)\n\t\t\treturn -EINVAL;\n\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(lkb->lkb_lvbptr, rl->rl_lvb, lvblen);\n\t}\n\n\t/* Conversions between PR and CW (middle modes) need special handling.\n\t   The real granted mode of these converting locks cannot be determined\n\t   until all locks have been rebuilt on the rsb (recover_conversion) */\n\n\tif (rl->rl_wait_type == cpu_to_le16(DLM_MSG_CONVERT) &&\n\t    middle_conversion(lkb)) {\n\t\trl->rl_status = DLM_LKSTS_CONVERT;\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\trsb_set_flag(r, RSB_RECOVER_CONVERT);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "r",
            "RSB_RECOVER_CONVERT"
          ],
          "line": 5612
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "middle_conversion",
          "args": [
            "lkb"
          ],
          "line": 5609
        },
        "resolved": true,
        "details": {
          "function_name": "middle_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "261-267",
          "snippet": "static inline int middle_conversion(struct dlm_lkb *lkb)\n{\n\tif ((lkb->lkb_grmode==DLM_LOCK_PR && lkb->lkb_rqmode==DLM_LOCK_CW) ||\n\t    (lkb->lkb_rqmode==DLM_LOCK_PR && lkb->lkb_grmode==DLM_LOCK_CW))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int middle_conversion(struct dlm_lkb *lkb)\n{\n\tif ((lkb->lkb_grmode==DLM_LOCK_PR && lkb->lkb_rqmode==DLM_LOCK_CW) ||\n\t    (lkb->lkb_rqmode==DLM_LOCK_PR && lkb->lkb_grmode==DLM_LOCK_CW))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "DLM_MSG_CONVERT"
          ],
          "line": 5608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lkb->lkb_lvbptr",
            "rl->rl_lvb",
            "lvblen"
          ],
          "line": 5601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_allocate_lvb",
          "args": [
            "ls"
          ],
          "line": 5598
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_allocate_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "47-53",
          "snippet": "char *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nchar *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rl->rl_lvbseq"
          ],
          "line": 5585
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_rcom_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t  struct dlm_rsb *r, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\n\tlkb->lkb_nodeid = rc->rc_header.h_nodeid;\n\tlkb->lkb_ownpid = le32_to_cpu(rl->rl_ownpid);\n\tlkb->lkb_remid = le32_to_cpu(rl->rl_lkid);\n\tlkb->lkb_exflags = le32_to_cpu(rl->rl_exflags);\n\tlkb->lkb_flags = le32_to_cpu(rl->rl_flags) & 0x0000FFFF;\n\tlkb->lkb_flags |= DLM_IFL_MSTCPY;\n\tlkb->lkb_lvbseq = le32_to_cpu(rl->rl_lvbseq);\n\tlkb->lkb_rqmode = rl->rl_rqmode;\n\tlkb->lkb_grmode = rl->rl_grmode;\n\t/* don't set lkb_status because add_lkb wants to itself */\n\n\tlkb->lkb_bastfn = (rl->rl_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\n\tlkb->lkb_astfn = (rl->rl_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tint lvblen = rc->rc_header.h_length - sizeof(struct dlm_rcom) -\n\t\t\t sizeof(struct rcom_lock);\n\t\tif (lvblen > ls->ls_lvblen)\n\t\t\treturn -EINVAL;\n\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(lkb->lkb_lvbptr, rl->rl_lvb, lvblen);\n\t}\n\n\t/* Conversions between PR and CW (middle modes) need special handling.\n\t   The real granted mode of these converting locks cannot be determined\n\t   until all locks have been rebuilt on the rsb (recover_conversion) */\n\n\tif (rl->rl_wait_type == cpu_to_le16(DLM_MSG_CONVERT) &&\n\t    middle_conversion(lkb)) {\n\t\trl->rl_status = DLM_LKSTS_CONVERT;\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\trsb_set_flag(r, RSB_RECOVER_CONVERT);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "search_remid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5556-5571",
    "snippet": "static struct dlm_lkb *search_remid(struct dlm_rsb *r, int nodeid,\n\t\t\t\t    uint32_t remid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlkb = search_remid_list(&r->res_grantqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\tlkb = search_remid_list(&r->res_convertqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\tlkb = search_remid_list(&r->res_waitqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "search_remid_list",
          "args": [
            "&r->res_waitqueue",
            "nodeid",
            "remid"
          ],
          "line": 5567
        },
        "resolved": true,
        "details": {
          "function_name": "search_remid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5544-5554",
          "snippet": "static struct dlm_lkb *search_remid_list(struct list_head *head, int nodeid,\n\t\t\t\t\t uint32_t remid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue) {\n\t\tif (lkb->lkb_nodeid == nodeid && lkb->lkb_remid == remid)\n\t\t\treturn lkb;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic struct dlm_lkb *search_remid_list(struct list_head *head, int nodeid,\n\t\t\t\t\t uint32_t remid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue) {\n\t\tif (lkb->lkb_nodeid == nodeid && lkb->lkb_remid == remid)\n\t\t\treturn lkb;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic struct dlm_lkb *search_remid(struct dlm_rsb *r, int nodeid,\n\t\t\t\t    uint32_t remid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlkb = search_remid_list(&r->res_grantqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\tlkb = search_remid_list(&r->res_convertqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\tlkb = search_remid_list(&r->res_waitqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\treturn NULL;\n}"
  },
  {
    "function_name": "search_remid_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5544-5554",
    "snippet": "static struct dlm_lkb *search_remid_list(struct list_head *head, int nodeid,\n\t\t\t\t\t uint32_t remid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue) {\n\t\tif (lkb->lkb_nodeid == nodeid && lkb->lkb_remid == remid)\n\t\t\treturn lkb;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "head",
            "lkb_statequeue"
          ],
          "line": 5549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic struct dlm_lkb *search_remid_list(struct list_head *head, int nodeid,\n\t\t\t\t\t uint32_t remid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue) {\n\t\tif (lkb->lkb_nodeid == nodeid && lkb->lkb_remid == remid)\n\t\t\treturn lkb;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "dlm_recover_grant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5510-5542",
    "snippet": "void dlm_recover_grant(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint bucket = 0;\n\tunsigned int count = 0;\n\tunsigned int rsb_count = 0;\n\tunsigned int lkb_count = 0;\n\n\twhile (1) {\n\t\tr = find_grant_rsb(ls, bucket);\n\t\tif (!r) {\n\t\t\tif (bucket == ls->ls_rsbtbl_size - 1)\n\t\t\t\tbreak;\n\t\t\tbucket++;\n\t\t\tcontinue;\n\t\t}\n\t\trsb_count++;\n\t\tcount = 0;\n\t\tlock_rsb(r);\n\t\t/* the RECOVER_GRANT flag is checked in the grant path */\n\t\tgrant_pending_locks(r, &count);\n\t\trsb_clear_flag(r, RSB_RECOVER_GRANT);\n\t\tlkb_count += count;\n\t\tconfirm_master(r, 0);\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tcond_resched();\n\t}\n\n\tif (lkb_count)\n\t\tlog_rinfo(ls, \"dlm_recover_grant %u locks on %u resources\",\n\t\t\t  lkb_count, rsb_count);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_grant %u locks on %u resources\"",
            "lkb_count",
            "rsb_count"
          ],
          "line": 5540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 5536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 5535
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 5534
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "confirm_master",
          "args": [
            "r",
            "0"
          ],
          "line": 5533
        },
        "resolved": true,
        "details": {
          "function_name": "confirm_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2768-2803",
          "snippet": "static void confirm_master(struct dlm_rsb *r, int error)\n{\n\tstruct dlm_lkb *lkb;\n\n\tif (!r->res_first_lkid)\n\t\treturn;\n\n\tswitch (error) {\n\tcase 0:\n\tcase -EINPROGRESS:\n\t\tr->res_first_lkid = 0;\n\t\tprocess_lookup_list(r);\n\t\tbreak;\n\n\tcase -EAGAIN:\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* the remote request failed and won't be retried (it was\n\t\t   a NOQUEUE, or has been canceled/unlocked); make a waiting\n\t\t   lkb the first_lkid */\n\n\t\tr->res_first_lkid = 0;\n\n\t\tif (!list_empty(&r->res_lookup)) {\n\t\t\tlkb = list_entry(r->res_lookup.next, struct dlm_lkb,\n\t\t\t\t\t lkb_rsb_lookup);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tr->res_first_lkid = lkb->lkb_id;\n\t\t\t_request_lock(r, lkb);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"confirm_master unknown error %d\", error);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void confirm_master(struct dlm_rsb *r, int error)\n{\n\tstruct dlm_lkb *lkb;\n\n\tif (!r->res_first_lkid)\n\t\treturn;\n\n\tswitch (error) {\n\tcase 0:\n\tcase -EINPROGRESS:\n\t\tr->res_first_lkid = 0;\n\t\tprocess_lookup_list(r);\n\t\tbreak;\n\n\tcase -EAGAIN:\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* the remote request failed and won't be retried (it was\n\t\t   a NOQUEUE, or has been canceled/unlocked); make a waiting\n\t\t   lkb the first_lkid */\n\n\t\tr->res_first_lkid = 0;\n\n\t\tif (!list_empty(&r->res_lookup)) {\n\t\t\tlkb = list_entry(r->res_lookup.next, struct dlm_lkb,\n\t\t\t\t\t lkb_rsb_lookup);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tr->res_first_lkid = lkb->lkb_id;\n\t\t\t_request_lock(r, lkb);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"confirm_master unknown error %d\", error);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_clear_flag",
          "args": [
            "r",
            "RSB_RECOVER_GRANT"
          ],
          "line": 5531
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_clear_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "353-356",
          "snippet": "static inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_pending_locks",
          "args": [
            "r",
            "&count"
          ],
          "line": 5530
        },
        "resolved": true,
        "details": {
          "function_name": "grant_pending_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2610-2644",
          "snippet": "static void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t/*\n\t * If there are locks left on the wait/convert queue then send blocking\n\t * ASTs to granted locks based on the largest requested mode (high)\n\t * found above.\n\t */\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t/*\n\t * If there are locks left on the wait/convert queue then send blocking\n\t * ASTs to granted locks based on the largest requested mode (high)\n\t * found above.\n\t */\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_grant_rsb",
          "args": [
            "ls",
            "bucket"
          ],
          "line": 5519
        },
        "resolved": true,
        "details": {
          "function_name": "find_grant_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5470-5491",
          "snippet": "static struct dlm_rsb *find_grant_rsb(struct dlm_ls *ls, int bucket)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\tfor (n = rb_first(&ls->ls_rsbtbl[bucket].keep); n; n = rb_next(n)) {\n\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\n\t\tif (!rsb_flag(r, RSB_RECOVER_GRANT))\n\t\t\tcontinue;\n\t\tif (!is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_RECOVER_GRANT);\n\t\t\tcontinue;\n\t\t}\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\treturn r;\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic struct dlm_rsb *find_grant_rsb(struct dlm_ls *ls, int bucket)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\tfor (n = rb_first(&ls->ls_rsbtbl[bucket].keep); n; n = rb_next(n)) {\n\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\n\t\tif (!rsb_flag(r, RSB_RECOVER_GRANT))\n\t\t\tcontinue;\n\t\tif (!is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_RECOVER_GRANT);\n\t\t\tcontinue;\n\t\t}\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\treturn r;\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_recover_grant(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint bucket = 0;\n\tunsigned int count = 0;\n\tunsigned int rsb_count = 0;\n\tunsigned int lkb_count = 0;\n\n\twhile (1) {\n\t\tr = find_grant_rsb(ls, bucket);\n\t\tif (!r) {\n\t\t\tif (bucket == ls->ls_rsbtbl_size - 1)\n\t\t\t\tbreak;\n\t\t\tbucket++;\n\t\t\tcontinue;\n\t\t}\n\t\trsb_count++;\n\t\tcount = 0;\n\t\tlock_rsb(r);\n\t\t/* the RECOVER_GRANT flag is checked in the grant path */\n\t\tgrant_pending_locks(r, &count);\n\t\trsb_clear_flag(r, RSB_RECOVER_GRANT);\n\t\tlkb_count += count;\n\t\tconfirm_master(r, 0);\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tcond_resched();\n\t}\n\n\tif (lkb_count)\n\t\tlog_rinfo(ls, \"dlm_recover_grant %u locks on %u resources\",\n\t\t\t  lkb_count, rsb_count);\n}"
  },
  {
    "function_name": "find_grant_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5470-5491",
    "snippet": "static struct dlm_rsb *find_grant_rsb(struct dlm_ls *ls, int bucket)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\tfor (n = rb_first(&ls->ls_rsbtbl[bucket].keep); n; n = rb_next(n)) {\n\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\n\t\tif (!rsb_flag(r, RSB_RECOVER_GRANT))\n\t\t\tcontinue;\n\t\tif (!is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_RECOVER_GRANT);\n\t\t\tcontinue;\n\t\t}\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\treturn r;\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[bucket].lock"
          ],
          "line": 5489
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 5485
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_clear_flag",
          "args": [
            "r",
            "RSB_RECOVER_GRANT"
          ],
          "line": 5482
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_clear_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "353-356",
          "snippet": "static inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master",
          "args": [
            "r"
          ],
          "line": 5481
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_flag",
          "args": [
            "r",
            "RSB_RECOVER_GRANT"
          ],
          "line": 5479
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "358-361",
          "snippet": "static inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 5477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 5476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ls->ls_rsbtbl[bucket].keep"
          ],
          "line": 5476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[bucket].lock"
          ],
          "line": 5475
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic struct dlm_rsb *find_grant_rsb(struct dlm_ls *ls, int bucket)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\tfor (n = rb_first(&ls->ls_rsbtbl[bucket].keep); n; n = rb_next(n)) {\n\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\n\t\tif (!rsb_flag(r, RSB_RECOVER_GRANT))\n\t\t\tcontinue;\n\t\tif (!is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_RECOVER_GRANT);\n\t\t\tcontinue;\n\t\t}\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\treturn r;\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "dlm_recover_purge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5428-5468",
    "snippet": "void dlm_recover_purge(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tstruct dlm_member *memb;\n\tint nodes_count = 0;\n\tint nodeid_gone = 0;\n\tunsigned int lkb_count = 0;\n\n\t/* cache one removed nodeid to optimize the common\n\t   case of a single node removed */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\n\t\tnodes_count++;\n\t\tnodeid_gone = memb->nodeid;\n\t}\n\n\tif (!nodes_count)\n\t\treturn;\n\n\tdown_write(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\t\tif (is_master(r)) {\n\t\t\tpurge_dead_list(ls, r, &r->res_grantqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t\tpurge_dead_list(ls, r, &r->res_convertqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t\tpurge_dead_list(ls, r, &r->res_waitqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t}\n\t\tunlock_rsb(r);\n\t\tunhold_rsb(r);\n\t\tcond_resched();\n\t}\n\tup_write(&ls->ls_root_sem);\n\n\tif (lkb_count)\n\t\tlog_rinfo(ls, \"dlm_recover_purge %u locks for %u nodes\",\n\t\t\t  lkb_count, nodes_count);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_purge %u locks for %u nodes\"",
            "lkb_count",
            "nodes_count"
          ],
          "line": 5466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 5463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhold_rsb",
          "args": [
            "r"
          ],
          "line": 5460
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 5459
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "purge_dead_list",
          "args": [
            "ls",
            "r",
            "&r->res_waitqueue",
            "nodeid_gone",
            "&lkb_count"
          ],
          "line": 5456
        },
        "resolved": true,
        "details": {
          "function_name": "purge_dead_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5393-5424",
          "snippet": "static void purge_dead_list(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t    struct list_head *list,\n\t\t\t    int nodeid_gone, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\n\t\tif (!is_master_copy(lkb))\n\t\t\tcontinue;\n\n\t\tif ((lkb->lkb_nodeid == nodeid_gone) ||\n\t\t    dlm_is_removed(ls, lkb->lkb_nodeid)) {\n\n\t\t\t/* tell recover_lvb to invalidate the lvb\n\t\t\t   because a node holding EX/PW failed */\n\t\t\tif ((lkb->lkb_exflags & DLM_LKF_VALBLK) &&\n\t\t\t    (lkb->lkb_grmode >= DLM_LOCK_PW)) {\n\t\t\t\trsb_set_flag(r, RSB_RECOVER_LVB_INVAL);\n\t\t\t}\n\n\t\t\tdel_lkb(r, lkb);\n\n\t\t\t/* this put should free the lkb */\n\t\t\tif (!dlm_put_lkb(lkb))\n\t\t\t\tlog_error(ls, \"purged dead lkb not released\");\n\n\t\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n\n\t\t\t(*count)++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void purge_dead_list(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t    struct list_head *list,\n\t\t\t    int nodeid_gone, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\n\t\tif (!is_master_copy(lkb))\n\t\t\tcontinue;\n\n\t\tif ((lkb->lkb_nodeid == nodeid_gone) ||\n\t\t    dlm_is_removed(ls, lkb->lkb_nodeid)) {\n\n\t\t\t/* tell recover_lvb to invalidate the lvb\n\t\t\t   because a node holding EX/PW failed */\n\t\t\tif ((lkb->lkb_exflags & DLM_LKF_VALBLK) &&\n\t\t\t    (lkb->lkb_grmode >= DLM_LOCK_PW)) {\n\t\t\t\trsb_set_flag(r, RSB_RECOVER_LVB_INVAL);\n\t\t\t}\n\n\t\t\tdel_lkb(r, lkb);\n\n\t\t\t/* this put should free the lkb */\n\t\t\tif (!dlm_put_lkb(lkb))\n\t\t\t\tlog_error(ls, \"purged dead lkb not released\");\n\n\t\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n\n\t\t\t(*count)++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master",
          "args": [
            "r"
          ],
          "line": 5451
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "r",
            "&ls->ls_root_list",
            "res_root_list"
          ],
          "line": 5448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 5447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes_gone",
            "list"
          ],
          "line": 5439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_recover_purge(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tstruct dlm_member *memb;\n\tint nodes_count = 0;\n\tint nodeid_gone = 0;\n\tunsigned int lkb_count = 0;\n\n\t/* cache one removed nodeid to optimize the common\n\t   case of a single node removed */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\n\t\tnodes_count++;\n\t\tnodeid_gone = memb->nodeid;\n\t}\n\n\tif (!nodes_count)\n\t\treturn;\n\n\tdown_write(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\t\tif (is_master(r)) {\n\t\t\tpurge_dead_list(ls, r, &r->res_grantqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t\tpurge_dead_list(ls, r, &r->res_convertqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t\tpurge_dead_list(ls, r, &r->res_waitqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t}\n\t\tunlock_rsb(r);\n\t\tunhold_rsb(r);\n\t\tcond_resched();\n\t}\n\tup_write(&ls->ls_root_sem);\n\n\tif (lkb_count)\n\t\tlog_rinfo(ls, \"dlm_recover_purge %u locks for %u nodes\",\n\t\t\t  lkb_count, nodes_count);\n}"
  },
  {
    "function_name": "purge_dead_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5393-5424",
    "snippet": "static void purge_dead_list(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t    struct list_head *list,\n\t\t\t    int nodeid_gone, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\n\t\tif (!is_master_copy(lkb))\n\t\t\tcontinue;\n\n\t\tif ((lkb->lkb_nodeid == nodeid_gone) ||\n\t\t    dlm_is_removed(ls, lkb->lkb_nodeid)) {\n\n\t\t\t/* tell recover_lvb to invalidate the lvb\n\t\t\t   because a node holding EX/PW failed */\n\t\t\tif ((lkb->lkb_exflags & DLM_LKF_VALBLK) &&\n\t\t\t    (lkb->lkb_grmode >= DLM_LOCK_PW)) {\n\t\t\t\trsb_set_flag(r, RSB_RECOVER_LVB_INVAL);\n\t\t\t}\n\n\t\t\tdel_lkb(r, lkb);\n\n\t\t\t/* this put should free the lkb */\n\t\t\tif (!dlm_put_lkb(lkb))\n\t\t\t\tlog_error(ls, \"purged dead lkb not released\");\n\n\t\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n\n\t\t\t(*count)++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "r",
            "RSB_RECOVER_GRANT"
          ],
          "line": 5419
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"purged dead lkb not released\""
          ],
          "line": 5417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 5416
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_lkb",
          "args": [
            "r",
            "lkb"
          ],
          "line": 5413
        },
        "resolved": true,
        "details": {
          "function_name": "del_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1348-1353",
          "snippet": "static void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_removed",
          "args": [
            "ls",
            "lkb->lkb_nodeid"
          ],
          "line": 5404
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "358-363",
          "snippet": "int dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master_copy",
          "args": [
            "lkb"
          ],
          "line": 5400
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "safe",
            "list",
            "lkb_statequeue"
          ],
          "line": 5399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void purge_dead_list(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t    struct list_head *list,\n\t\t\t    int nodeid_gone, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\n\t\tif (!is_master_copy(lkb))\n\t\t\tcontinue;\n\n\t\tif ((lkb->lkb_nodeid == nodeid_gone) ||\n\t\t    dlm_is_removed(ls, lkb->lkb_nodeid)) {\n\n\t\t\t/* tell recover_lvb to invalidate the lvb\n\t\t\t   because a node holding EX/PW failed */\n\t\t\tif ((lkb->lkb_exflags & DLM_LKF_VALBLK) &&\n\t\t\t    (lkb->lkb_grmode >= DLM_LOCK_PW)) {\n\t\t\t\trsb_set_flag(r, RSB_RECOVER_LVB_INVAL);\n\t\t\t}\n\n\t\t\tdel_lkb(r, lkb);\n\n\t\t\t/* this put should free the lkb */\n\t\t\tif (!dlm_put_lkb(lkb))\n\t\t\t\tlog_error(ls, \"purged dead lkb not released\");\n\n\t\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n\n\t\t\t(*count)++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "dlm_purge_mstcpy_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5384-5391",
    "snippet": "void dlm_purge_mstcpy_locks(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tpurge_mstcpy_list(ls, r, &r->res_grantqueue);\n\tpurge_mstcpy_list(ls, r, &r->res_convertqueue);\n\tpurge_mstcpy_list(ls, r, &r->res_waitqueue);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "purge_mstcpy_list",
          "args": [
            "ls",
            "r",
            "&r->res_waitqueue"
          ],
          "line": 5390
        },
        "resolved": true,
        "details": {
          "function_name": "purge_mstcpy_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5361-5382",
          "snippet": "static void purge_mstcpy_list(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t      struct list_head *list)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\n\t\tif (!is_master_copy(lkb))\n\t\t\tcontinue;\n\n\t\t/* don't purge lkbs we've added in recover_master_copy for\n\t\t   the current recovery seq */\n\n\t\tif (lkb->lkb_recover_seq == ls->ls_recover_seq)\n\t\t\tcontinue;\n\n\t\tdel_lkb(r, lkb);\n\n\t\t/* this put should free the lkb */\n\t\tif (!dlm_put_lkb(lkb))\n\t\t\tlog_error(ls, \"purged mstcpy lkb not released\");\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void purge_mstcpy_list(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t      struct list_head *list)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\n\t\tif (!is_master_copy(lkb))\n\t\t\tcontinue;\n\n\t\t/* don't purge lkbs we've added in recover_master_copy for\n\t\t   the current recovery seq */\n\n\t\tif (lkb->lkb_recover_seq == ls->ls_recover_seq)\n\t\t\tcontinue;\n\n\t\tdel_lkb(r, lkb);\n\n\t\t/* this put should free the lkb */\n\t\tif (!dlm_put_lkb(lkb))\n\t\t\tlog_error(ls, \"purged mstcpy lkb not released\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_purge_mstcpy_locks(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tpurge_mstcpy_list(ls, r, &r->res_grantqueue);\n\tpurge_mstcpy_list(ls, r, &r->res_convertqueue);\n\tpurge_mstcpy_list(ls, r, &r->res_waitqueue);\n}"
  },
  {
    "function_name": "purge_mstcpy_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5361-5382",
    "snippet": "static void purge_mstcpy_list(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t      struct list_head *list)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\n\t\tif (!is_master_copy(lkb))\n\t\t\tcontinue;\n\n\t\t/* don't purge lkbs we've added in recover_master_copy for\n\t\t   the current recovery seq */\n\n\t\tif (lkb->lkb_recover_seq == ls->ls_recover_seq)\n\t\t\tcontinue;\n\n\t\tdel_lkb(r, lkb);\n\n\t\t/* this put should free the lkb */\n\t\tif (!dlm_put_lkb(lkb))\n\t\t\tlog_error(ls, \"purged mstcpy lkb not released\");\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"purged mstcpy lkb not released\""
          ],
          "line": 5380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 5379
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_lkb",
          "args": [
            "r",
            "lkb"
          ],
          "line": 5376
        },
        "resolved": true,
        "details": {
          "function_name": "del_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1348-1353",
          "snippet": "static void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master_copy",
          "args": [
            "lkb"
          ],
          "line": 5367
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "safe",
            "list",
            "lkb_statequeue"
          ],
          "line": 5366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void purge_mstcpy_list(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t      struct list_head *list)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\n\t\tif (!is_master_copy(lkb))\n\t\t\tcontinue;\n\n\t\t/* don't purge lkbs we've added in recover_master_copy for\n\t\t   the current recovery seq */\n\n\t\tif (lkb->lkb_recover_seq == ls->ls_recover_seq)\n\t\t\tcontinue;\n\n\t\tdel_lkb(r, lkb);\n\n\t\t/* this put should free the lkb */\n\t\tif (!dlm_put_lkb(lkb))\n\t\t\tlog_error(ls, \"purged mstcpy lkb not released\");\n\t}\n}"
  },
  {
    "function_name": "dlm_recover_waiters_post",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5265-5359",
    "snippet": "int dlm_recover_waiters_post(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error = 0, mstype, err, oc, ou;\n\n\twhile (1) {\n\t\tif (dlm_locking_stopped(ls)) {\n\t\t\tlog_debug(ls, \"recover_waiters_post aborted\");\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tlkb = find_resend_waiter(ls);\n\t\tif (!lkb)\n\t\t\tbreak;\n\n\t\tr = lkb->lkb_resource;\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\n\t\tmstype = lkb->lkb_wait_type;\n\t\toc = is_overlap_cancel(lkb);\n\t\tou = is_overlap_unlock(lkb);\n\t\terr = 0;\n\n\t\tlog_debug(ls, \"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d \"\n\t\t\t  \"overlap %d %d\", lkb->lkb_id, lkb->lkb_remid, mstype,\n\t\t\t  r->res_nodeid, lkb->lkb_nodeid, lkb->lkb_wait_nodeid,\n\t\t\t  dlm_dir_nodeid(r), oc, ou);\n\n\t\t/* At this point we assume that we won't get a reply to any\n\t\t   previous op or overlap op on this lock.  First, do a big\n\t\t   remove_from_waiters() for all previous ops. */\n\n\t\tlkb->lkb_flags &= ~DLM_IFL_RESEND;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_wait_type = 0;\n\t\tlkb->lkb_wait_count = 0;\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\t\tunhold_lkb(lkb); /* for waiters list */\n\n\t\tif (oc || ou) {\n\t\t\t/* do an unlock or cancel instead of resending */\n\t\t\tswitch (mstype) {\n\t\t\tcase DLM_MSG_LOOKUP:\n\t\t\tcase DLM_MSG_REQUEST:\n\t\t\t\tqueue_cast(r, lkb, ou ? -DLM_EUNLOCK :\n\t\t\t\t\t\t\t-DLM_ECANCEL);\n\t\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t\t\tbreak;\n\t\t\tcase DLM_MSG_CONVERT:\n\t\t\t\tif (oc) {\n\t\t\t\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\t\t\t} else {\n\t\t\t\t\tlkb->lkb_exflags |= DLM_LKF_FORCEUNLOCK;\n\t\t\t\t\t_unlock_lock(r, lkb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (mstype) {\n\t\t\tcase DLM_MSG_LOOKUP:\n\t\t\tcase DLM_MSG_REQUEST:\n\t\t\t\t_request_lock(r, lkb);\n\t\t\t\tif (is_master(r))\n\t\t\t\t\tconfirm_master(r, 0);\n\t\t\t\tbreak;\n\t\t\tcase DLM_MSG_CONVERT:\n\t\t\t\t_convert_lock(r, lkb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (err) {\n\t\t\tlog_error(ls, \"waiter %x msg %d r_nodeid %d \"\n\t\t\t\t  \"dir_nodeid %d overlap %d %d\",\n\t\t\t\t  lkb->lkb_id, mstype, r->res_nodeid,\n\t\t\t\t  dlm_dir_nodeid(r), oc, ou);\n\t\t}\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 5355
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 5354
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 5353
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"waiter %x msg %d r_nodeid %d \"\n\t\t\t\t  \"dir_nodeid %d overlap %d %d\"",
            "lkb->lkb_id",
            "mstype",
            "r->res_nodeid",
            "dlm_dir_nodeid(r)",
            "oc",
            "ou"
          ],
          "line": 5348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dir_nodeid",
          "args": [
            "r"
          ],
          "line": 5351
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "47-50",
          "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_convert_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 5340
        },
        "resolved": true,
        "details": {
          "function_name": "_convert_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3253-3268",
          "snippet": "static int _convert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_convert() calls do_convert() on remote node */\n\t\terror = send_convert(r, lkb);\n\t} else {\n\t\terror = do_convert(r, lkb);\n\t\t/* for remote locks the convert_reply is sent\n\t\t   between do_convert and do_convert_effects */\n\t\tdo_convert_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _convert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_convert() calls do_convert() on remote node */\n\t\terror = send_convert(r, lkb);\n\t} else {\n\t\terror = do_convert(r, lkb);\n\t\t/* for remote locks the convert_reply is sent\n\t\t   between do_convert and do_convert_effects */\n\t\tdo_convert_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "confirm_master",
          "args": [
            "r",
            "0"
          ],
          "line": 5337
        },
        "resolved": true,
        "details": {
          "function_name": "confirm_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2768-2803",
          "snippet": "static void confirm_master(struct dlm_rsb *r, int error)\n{\n\tstruct dlm_lkb *lkb;\n\n\tif (!r->res_first_lkid)\n\t\treturn;\n\n\tswitch (error) {\n\tcase 0:\n\tcase -EINPROGRESS:\n\t\tr->res_first_lkid = 0;\n\t\tprocess_lookup_list(r);\n\t\tbreak;\n\n\tcase -EAGAIN:\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* the remote request failed and won't be retried (it was\n\t\t   a NOQUEUE, or has been canceled/unlocked); make a waiting\n\t\t   lkb the first_lkid */\n\n\t\tr->res_first_lkid = 0;\n\n\t\tif (!list_empty(&r->res_lookup)) {\n\t\t\tlkb = list_entry(r->res_lookup.next, struct dlm_lkb,\n\t\t\t\t\t lkb_rsb_lookup);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tr->res_first_lkid = lkb->lkb_id;\n\t\t\t_request_lock(r, lkb);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"confirm_master unknown error %d\", error);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void confirm_master(struct dlm_rsb *r, int error)\n{\n\tstruct dlm_lkb *lkb;\n\n\tif (!r->res_first_lkid)\n\t\treturn;\n\n\tswitch (error) {\n\tcase 0:\n\tcase -EINPROGRESS:\n\t\tr->res_first_lkid = 0;\n\t\tprocess_lookup_list(r);\n\t\tbreak;\n\n\tcase -EAGAIN:\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* the remote request failed and won't be retried (it was\n\t\t   a NOQUEUE, or has been canceled/unlocked); make a waiting\n\t\t   lkb the first_lkid */\n\n\t\tr->res_first_lkid = 0;\n\n\t\tif (!list_empty(&r->res_lookup)) {\n\t\t\tlkb = list_entry(r->res_lookup.next, struct dlm_lkb,\n\t\t\t\t\t lkb_rsb_lookup);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tr->res_first_lkid = lkb->lkb_id;\n\t\t\t_request_lock(r, lkb);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"confirm_master unknown error %d\", error);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master",
          "args": [
            "r"
          ],
          "line": 5336
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_request_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 5335
        },
        "resolved": true,
        "details": {
          "function_name": "_request_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3224-3249",
          "snippet": "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_unlock_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 5325
        },
        "resolved": true,
        "details": {
          "function_name": "_unlock_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3272-3287",
          "snippet": "static int _unlock_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_unlock() calls do_unlock() on remote node */\n\t\terror = send_unlock(r, lkb);\n\t} else {\n\t\terror = do_unlock(r, lkb);\n\t\t/* for remote locks the unlock_reply is sent\n\t\t   between do_unlock and do_unlock_effects */\n\t\tdo_unlock_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _unlock_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_unlock() calls do_unlock() on remote node */\n\t\terror = send_unlock(r, lkb);\n\t} else {\n\t\terror = do_unlock(r, lkb);\n\t\t/* for remote locks the unlock_reply is sent\n\t\t   between do_unlock and do_unlock_effects */\n\t\tdo_unlock_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "-DLM_ECANCEL"
          ],
          "line": 5322
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 5318
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 5308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_wait_reply"
          ],
          "line": 5307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 5306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d \"\n\t\t\t  \"overlap %d %d\"",
            "lkb->lkb_id",
            "lkb->lkb_remid",
            "mstype",
            "r->res_nodeid",
            "lkb->lkb_nodeid",
            "lkb->lkb_wait_nodeid",
            "dlm_dir_nodeid(r)",
            "oc",
            "ou"
          ],
          "line": 5291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_overlap_unlock",
          "args": [
            "lkb"
          ],
          "line": 5288
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "274-277",
          "snippet": "static inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_overlap_cancel",
          "args": [
            "lkb"
          ],
          "line": 5287
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "279-282",
          "snippet": "static inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 5283
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_resend_waiter",
          "args": [
            "ls"
          ],
          "line": 5278
        },
        "resolved": true,
        "details": {
          "function_name": "find_resend_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5229-5247",
          "snippet": "static struct dlm_lkb *find_resend_waiter(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tint found = 0;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\thold_lkb(lkb);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\n\tif (!found)\n\t\tlkb = NULL;\n\treturn lkb;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic struct dlm_lkb *find_resend_waiter(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tint found = 0;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\thold_lkb(lkb);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\n\tif (!found)\n\t\tlkb = NULL;\n\treturn lkb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"recover_waiters_post aborted\""
          ],
          "line": 5273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_locking_stopped",
          "args": [
            "ls"
          ],
          "line": 5272
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_locking_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "695-698",
          "snippet": "static inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RUNNING\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RUNNING\t\t4\n\nstatic inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_recover_waiters_post(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error = 0, mstype, err, oc, ou;\n\n\twhile (1) {\n\t\tif (dlm_locking_stopped(ls)) {\n\t\t\tlog_debug(ls, \"recover_waiters_post aborted\");\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tlkb = find_resend_waiter(ls);\n\t\tif (!lkb)\n\t\t\tbreak;\n\n\t\tr = lkb->lkb_resource;\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\n\t\tmstype = lkb->lkb_wait_type;\n\t\toc = is_overlap_cancel(lkb);\n\t\tou = is_overlap_unlock(lkb);\n\t\terr = 0;\n\n\t\tlog_debug(ls, \"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d \"\n\t\t\t  \"overlap %d %d\", lkb->lkb_id, lkb->lkb_remid, mstype,\n\t\t\t  r->res_nodeid, lkb->lkb_nodeid, lkb->lkb_wait_nodeid,\n\t\t\t  dlm_dir_nodeid(r), oc, ou);\n\n\t\t/* At this point we assume that we won't get a reply to any\n\t\t   previous op or overlap op on this lock.  First, do a big\n\t\t   remove_from_waiters() for all previous ops. */\n\n\t\tlkb->lkb_flags &= ~DLM_IFL_RESEND;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_wait_type = 0;\n\t\tlkb->lkb_wait_count = 0;\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\t\tunhold_lkb(lkb); /* for waiters list */\n\n\t\tif (oc || ou) {\n\t\t\t/* do an unlock or cancel instead of resending */\n\t\t\tswitch (mstype) {\n\t\t\tcase DLM_MSG_LOOKUP:\n\t\t\tcase DLM_MSG_REQUEST:\n\t\t\t\tqueue_cast(r, lkb, ou ? -DLM_EUNLOCK :\n\t\t\t\t\t\t\t-DLM_ECANCEL);\n\t\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t\t\tbreak;\n\t\t\tcase DLM_MSG_CONVERT:\n\t\t\t\tif (oc) {\n\t\t\t\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\t\t\t} else {\n\t\t\t\t\tlkb->lkb_exflags |= DLM_LKF_FORCEUNLOCK;\n\t\t\t\t\t_unlock_lock(r, lkb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (mstype) {\n\t\t\tcase DLM_MSG_LOOKUP:\n\t\t\tcase DLM_MSG_REQUEST:\n\t\t\t\t_request_lock(r, lkb);\n\t\t\t\tif (is_master(r))\n\t\t\t\t\tconfirm_master(r, 0);\n\t\t\t\tbreak;\n\t\t\tcase DLM_MSG_CONVERT:\n\t\t\t\t_convert_lock(r, lkb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (err) {\n\t\t\tlog_error(ls, \"waiter %x msg %d r_nodeid %d \"\n\t\t\t\t  \"dir_nodeid %d overlap %d %d\",\n\t\t\t\t  lkb->lkb_id, mstype, r->res_nodeid,\n\t\t\t\t  dlm_dir_nodeid(r), oc, ou);\n\t\t}\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "find_resend_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5229-5247",
    "snippet": "static struct dlm_lkb *find_resend_waiter(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tint found = 0;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\thold_lkb(lkb);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\n\tif (!found)\n\t\tlkb = NULL;\n\treturn lkb;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 5242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hold_lkb",
          "args": [
            "lkb"
          ],
          "line": 5237
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&ls->ls_waiters",
            "lkb_wait_reply"
          ],
          "line": 5235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 5234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic struct dlm_lkb *find_resend_waiter(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tint found = 0;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\thold_lkb(lkb);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\n\tif (!found)\n\t\tlkb = NULL;\n\treturn lkb;\n}"
  },
  {
    "function_name": "dlm_recover_waiters_pre",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5116-5227",
    "snippet": "void dlm_recover_waiters_pre(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\tstruct dlm_message *ms_stub;\n\tint wait_type, stub_unlock_result, stub_cancel_result;\n\tint dir_nodeid;\n\n\tms_stub = kmalloc(sizeof(struct dlm_message), GFP_KERNEL);\n\tif (!ms_stub) {\n\t\tlog_error(ls, \"dlm_recover_waiters_pre no mem\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_waiters, lkb_wait_reply) {\n\n\t\tdir_nodeid = dlm_dir_nodeid(lkb->lkb_resource);\n\n\t\t/* exclude debug messages about unlocks because there can be so\n\t\t   many and they aren't very interesting */\n\n\t\tif (lkb->lkb_wait_type != DLM_MSG_UNLOCK) {\n\t\t\tlog_debug(ls, \"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d\",\n\t\t\t\t  lkb->lkb_id,\n\t\t\t\t  lkb->lkb_remid,\n\t\t\t\t  lkb->lkb_wait_type,\n\t\t\t\t  lkb->lkb_resource->res_nodeid,\n\t\t\t\t  lkb->lkb_nodeid,\n\t\t\t\t  lkb->lkb_wait_nodeid,\n\t\t\t\t  dir_nodeid);\n\t\t}\n\n\t\t/* all outstanding lookups, regardless of destination  will be\n\t\t   resent after recovery is done */\n\n\t\tif (lkb->lkb_wait_type == DLM_MSG_LOOKUP) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!waiter_needs_recovery(ls, lkb, dir_nodeid))\n\t\t\tcontinue;\n\n\t\twait_type = lkb->lkb_wait_type;\n\t\tstub_unlock_result = -DLM_EUNLOCK;\n\t\tstub_cancel_result = -DLM_ECANCEL;\n\n\t\t/* Main reply may have been received leaving a zero wait_type,\n\t\t   but a reply for the overlapping op may not have been\n\t\t   received.  In that case we need to fake the appropriate\n\t\t   reply for the overlap op. */\n\n\t\tif (!wait_type) {\n\t\t\tif (is_overlap_cancel(lkb)) {\n\t\t\t\twait_type = DLM_MSG_CANCEL;\n\t\t\t\tif (lkb->lkb_grmode == DLM_LOCK_IV)\n\t\t\t\t\tstub_cancel_result = 0;\n\t\t\t}\n\t\t\tif (is_overlap_unlock(lkb)) {\n\t\t\t\twait_type = DLM_MSG_UNLOCK;\n\t\t\t\tif (lkb->lkb_grmode == DLM_LOCK_IV)\n\t\t\t\t\tstub_unlock_result = -ENOENT;\n\t\t\t}\n\n\t\t\tlog_debug(ls, \"rwpre overlap %x %x %d %d %d\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_flags, wait_type,\n\t\t\t\t  stub_cancel_result, stub_unlock_result);\n\t\t}\n\n\t\tswitch (wait_type) {\n\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_CONVERT:\n\t\t\trecover_convert_waiter(ls, lkb, ms_stub);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\thold_lkb(lkb);\n\t\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\t\tms_stub->m_type = DLM_MSG_UNLOCK_REPLY;\n\t\t\tms_stub->m_result = stub_unlock_result;\n\t\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t\t_receive_unlock_reply(lkb, ms_stub);\n\t\t\tdlm_put_lkb(lkb);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_CANCEL:\n\t\t\thold_lkb(lkb);\n\t\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\t\tms_stub->m_type = DLM_MSG_CANCEL_REPLY;\n\t\t\tms_stub->m_result = stub_cancel_result;\n\t\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t\t_receive_cancel_reply(lkb, ms_stub);\n\t\t\tdlm_put_lkb(lkb);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog_error(ls, \"invalid lkb wait_type %d %d\",\n\t\t\t\t  lkb->lkb_wait_type, wait_type);\n\t\t}\n\t\tschedule();\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\tkfree(ms_stub);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ms_stub"
          ],
          "line": 5226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 5225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 5223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"invalid lkb wait_type %d %d\"",
            "lkb->lkb_wait_type",
            "wait_type"
          ],
          "line": 5220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 5216
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_receive_cancel_reply",
          "args": [
            "lkb",
            "ms_stub"
          ],
          "line": 5215
        },
        "resolved": true,
        "details": {
          "function_name": "_receive_cancel_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4727-4761",
          "snippet": "static void _receive_cancel_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_cancel() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_ECANCEL:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_cancel_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _receive_cancel_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_cancel() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_ECANCEL:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_cancel_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ms_stub",
            "0",
            "sizeof(struct dlm_message)"
          ],
          "line": 5210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hold_lkb",
          "args": [
            "lkb"
          ],
          "line": 5209
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "_receive_unlock_reply",
          "args": [
            "lkb",
            "ms_stub"
          ],
          "line": 5204
        },
        "resolved": true,
        "details": {
          "function_name": "_receive_unlock_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4677-4711",
          "snippet": "static void _receive_unlock_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_unlock() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_EUNLOCK:\n\t\treceive_flags_reply(lkb, ms);\n\t\tremove_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\t\tbreak;\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_unlock_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _receive_unlock_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_unlock() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_EUNLOCK:\n\t\treceive_flags_reply(lkb, ms);\n\t\tremove_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\t\tbreak;\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_unlock_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ms_stub",
            "0",
            "sizeof(struct dlm_message)"
          ],
          "line": 5199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recover_convert_waiter",
          "args": [
            "ls",
            "lkb",
            "ms_stub"
          ],
          "line": 5194
        },
        "resolved": true,
        "details": {
          "function_name": "recover_convert_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5070-5093",
          "snippet": "static void recover_convert_waiter(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t   struct dlm_message *ms_stub)\n{\n\tif (middle_conversion(lkb)) {\n\t\thold_lkb(lkb);\n\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\tms_stub->m_type = DLM_MSG_CONVERT_REPLY;\n\t\tms_stub->m_result = -EINPROGRESS;\n\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t_receive_convert_reply(lkb, ms_stub);\n\n\t\t/* Same special case as in receive_rcom_lock_args() */\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\trsb_set_flag(lkb->lkb_resource, RSB_RECOVER_CONVERT);\n\t\tunhold_lkb(lkb);\n\n\t} else if (lkb->lkb_rqmode >= lkb->lkb_grmode) {\n\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t}\n\n\t/* lkb->lkb_rqmode < lkb->lkb_grmode shouldn't happen since down\n\t   conversions are async; there's no reply from the remote master */\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void recover_convert_waiter(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t   struct dlm_message *ms_stub)\n{\n\tif (middle_conversion(lkb)) {\n\t\thold_lkb(lkb);\n\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\tms_stub->m_type = DLM_MSG_CONVERT_REPLY;\n\t\tms_stub->m_result = -EINPROGRESS;\n\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t_receive_convert_reply(lkb, ms_stub);\n\n\t\t/* Same special case as in receive_rcom_lock_args() */\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\trsb_set_flag(lkb->lkb_resource, RSB_RECOVER_CONVERT);\n\t\tunhold_lkb(lkb);\n\n\t} else if (lkb->lkb_rqmode >= lkb->lkb_grmode) {\n\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t}\n\n\t/* lkb->lkb_rqmode < lkb->lkb_grmode shouldn't happen since down\n\t   conversions are async; there's no reply from the remote master */\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"rwpre overlap %x %x %d %d %d\"",
            "lkb->lkb_id",
            "lkb->lkb_flags",
            "wait_type",
            "stub_cancel_result",
            "stub_unlock_result"
          ],
          "line": 5182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_overlap_unlock",
          "args": [
            "lkb"
          ],
          "line": 5176
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "274-277",
          "snippet": "static inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_overlap_cancel",
          "args": [
            "lkb"
          ],
          "line": 5171
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "279-282",
          "snippet": "static inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waiter_needs_recovery",
          "args": [
            "ls",
            "lkb",
            "dir_nodeid"
          ],
          "line": 5158
        },
        "resolved": true,
        "details": {
          "function_name": "waiter_needs_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5098-5108",
          "snippet": "static int waiter_needs_recovery(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t int dir_nodeid)\n{\n\tif (dlm_no_directory(ls))\n\t\treturn 1;\n\n\tif (dlm_is_removed(ls, lkb->lkb_wait_nodeid))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int waiter_needs_recovery(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t int dir_nodeid)\n{\n\tif (dlm_no_directory(ls))\n\t\treturn 1;\n\n\tif (dlm_is_removed(ls, lkb->lkb_wait_nodeid))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d\"",
            "lkb->lkb_id",
            "lkb->lkb_remid",
            "lkb->lkb_wait_type",
            "lkb->lkb_resource->res_nodeid",
            "lkb->lkb_nodeid",
            "lkb->lkb_wait_nodeid",
            "dir_nodeid"
          ],
          "line": 5139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dir_nodeid",
          "args": [
            "lkb->lkb_resource"
          ],
          "line": 5133
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "47-50",
          "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "safe",
            "&ls->ls_waiters",
            "lkb_wait_reply"
          ],
          "line": 5131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 5129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_recover_waiters_pre no mem\""
          ],
          "line": 5125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct dlm_message)",
            "GFP_KERNEL"
          ],
          "line": 5123
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_recover_waiters_pre(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\tstruct dlm_message *ms_stub;\n\tint wait_type, stub_unlock_result, stub_cancel_result;\n\tint dir_nodeid;\n\n\tms_stub = kmalloc(sizeof(struct dlm_message), GFP_KERNEL);\n\tif (!ms_stub) {\n\t\tlog_error(ls, \"dlm_recover_waiters_pre no mem\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_waiters, lkb_wait_reply) {\n\n\t\tdir_nodeid = dlm_dir_nodeid(lkb->lkb_resource);\n\n\t\t/* exclude debug messages about unlocks because there can be so\n\t\t   many and they aren't very interesting */\n\n\t\tif (lkb->lkb_wait_type != DLM_MSG_UNLOCK) {\n\t\t\tlog_debug(ls, \"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d\",\n\t\t\t\t  lkb->lkb_id,\n\t\t\t\t  lkb->lkb_remid,\n\t\t\t\t  lkb->lkb_wait_type,\n\t\t\t\t  lkb->lkb_resource->res_nodeid,\n\t\t\t\t  lkb->lkb_nodeid,\n\t\t\t\t  lkb->lkb_wait_nodeid,\n\t\t\t\t  dir_nodeid);\n\t\t}\n\n\t\t/* all outstanding lookups, regardless of destination  will be\n\t\t   resent after recovery is done */\n\n\t\tif (lkb->lkb_wait_type == DLM_MSG_LOOKUP) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!waiter_needs_recovery(ls, lkb, dir_nodeid))\n\t\t\tcontinue;\n\n\t\twait_type = lkb->lkb_wait_type;\n\t\tstub_unlock_result = -DLM_EUNLOCK;\n\t\tstub_cancel_result = -DLM_ECANCEL;\n\n\t\t/* Main reply may have been received leaving a zero wait_type,\n\t\t   but a reply for the overlapping op may not have been\n\t\t   received.  In that case we need to fake the appropriate\n\t\t   reply for the overlap op. */\n\n\t\tif (!wait_type) {\n\t\t\tif (is_overlap_cancel(lkb)) {\n\t\t\t\twait_type = DLM_MSG_CANCEL;\n\t\t\t\tif (lkb->lkb_grmode == DLM_LOCK_IV)\n\t\t\t\t\tstub_cancel_result = 0;\n\t\t\t}\n\t\t\tif (is_overlap_unlock(lkb)) {\n\t\t\t\twait_type = DLM_MSG_UNLOCK;\n\t\t\t\tif (lkb->lkb_grmode == DLM_LOCK_IV)\n\t\t\t\t\tstub_unlock_result = -ENOENT;\n\t\t\t}\n\n\t\t\tlog_debug(ls, \"rwpre overlap %x %x %d %d %d\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_flags, wait_type,\n\t\t\t\t  stub_cancel_result, stub_unlock_result);\n\t\t}\n\n\t\tswitch (wait_type) {\n\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_CONVERT:\n\t\t\trecover_convert_waiter(ls, lkb, ms_stub);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\thold_lkb(lkb);\n\t\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\t\tms_stub->m_type = DLM_MSG_UNLOCK_REPLY;\n\t\t\tms_stub->m_result = stub_unlock_result;\n\t\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t\t_receive_unlock_reply(lkb, ms_stub);\n\t\t\tdlm_put_lkb(lkb);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_CANCEL:\n\t\t\thold_lkb(lkb);\n\t\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\t\tms_stub->m_type = DLM_MSG_CANCEL_REPLY;\n\t\t\tms_stub->m_result = stub_cancel_result;\n\t\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t\t_receive_cancel_reply(lkb, ms_stub);\n\t\t\tdlm_put_lkb(lkb);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog_error(ls, \"invalid lkb wait_type %d %d\",\n\t\t\t\t  lkb->lkb_wait_type, wait_type);\n\t\t}\n\t\tschedule();\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\tkfree(ms_stub);\n}"
  },
  {
    "function_name": "waiter_needs_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5098-5108",
    "snippet": "static int waiter_needs_recovery(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t int dir_nodeid)\n{\n\tif (dlm_no_directory(ls))\n\t\treturn 1;\n\n\tif (dlm_is_removed(ls, lkb->lkb_wait_nodeid))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_is_removed",
          "args": [
            "ls",
            "lkb->lkb_wait_nodeid"
          ],
          "line": 5104
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "358-363",
          "snippet": "int dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_no_directory",
          "args": [
            "ls"
          ],
          "line": 5101
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "705-708",
          "snippet": "static inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_NODIR\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_NODIR\t\t10\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int waiter_needs_recovery(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t int dir_nodeid)\n{\n\tif (dlm_no_directory(ls))\n\t\treturn 1;\n\n\tif (dlm_is_removed(ls, lkb->lkb_wait_nodeid))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "recover_convert_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5070-5093",
    "snippet": "static void recover_convert_waiter(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t   struct dlm_message *ms_stub)\n{\n\tif (middle_conversion(lkb)) {\n\t\thold_lkb(lkb);\n\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\tms_stub->m_type = DLM_MSG_CONVERT_REPLY;\n\t\tms_stub->m_result = -EINPROGRESS;\n\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t_receive_convert_reply(lkb, ms_stub);\n\n\t\t/* Same special case as in receive_rcom_lock_args() */\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\trsb_set_flag(lkb->lkb_resource, RSB_RECOVER_CONVERT);\n\t\tunhold_lkb(lkb);\n\n\t} else if (lkb->lkb_rqmode >= lkb->lkb_grmode) {\n\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t}\n\n\t/* lkb->lkb_rqmode < lkb->lkb_grmode shouldn't happen since down\n\t   conversions are async; there's no reply from the remote master */\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 5085
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "lkb->lkb_resource",
            "RSB_RECOVER_CONVERT"
          ],
          "line": 5084
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_receive_convert_reply",
          "args": [
            "lkb",
            "ms_stub"
          ],
          "line": 5080
        },
        "resolved": true,
        "details": {
          "function_name": "_receive_convert_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4640-4661",
          "snippet": "static void _receive_convert_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t__receive_convert_reply(r, lkb, ms);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _receive_convert_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t__receive_convert_reply(r, lkb, ms);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ms_stub",
            "0",
            "sizeof(struct dlm_message)"
          ],
          "line": 5075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "middle_conversion",
          "args": [
            "lkb"
          ],
          "line": 5073
        },
        "resolved": true,
        "details": {
          "function_name": "middle_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "261-267",
          "snippet": "static inline int middle_conversion(struct dlm_lkb *lkb)\n{\n\tif ((lkb->lkb_grmode==DLM_LOCK_PR && lkb->lkb_rqmode==DLM_LOCK_CW) ||\n\t    (lkb->lkb_rqmode==DLM_LOCK_PR && lkb->lkb_grmode==DLM_LOCK_CW))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int middle_conversion(struct dlm_lkb *lkb)\n{\n\tif ((lkb->lkb_grmode==DLM_LOCK_PR && lkb->lkb_rqmode==DLM_LOCK_CW) ||\n\t    (lkb->lkb_rqmode==DLM_LOCK_PR && lkb->lkb_grmode==DLM_LOCK_CW))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void recover_convert_waiter(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t   struct dlm_message *ms_stub)\n{\n\tif (middle_conversion(lkb)) {\n\t\thold_lkb(lkb);\n\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\tms_stub->m_type = DLM_MSG_CONVERT_REPLY;\n\t\tms_stub->m_result = -EINPROGRESS;\n\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t_receive_convert_reply(lkb, ms_stub);\n\n\t\t/* Same special case as in receive_rcom_lock_args() */\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\trsb_set_flag(lkb->lkb_resource, RSB_RECOVER_CONVERT);\n\t\tunhold_lkb(lkb);\n\n\t} else if (lkb->lkb_rqmode >= lkb->lkb_grmode) {\n\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t}\n\n\t/* lkb->lkb_rqmode < lkb->lkb_grmode shouldn't happen since down\n\t   conversions are async; there's no reply from the remote master */\n}"
  },
  {
    "function_name": "dlm_receive_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5018-5068",
    "snippet": "void dlm_receive_buffer(union dlm_packet *p, int nodeid)\n{\n\tstruct dlm_header *hd = &p->header;\n\tstruct dlm_ls *ls;\n\tint type = 0;\n\n\tswitch (hd->h_cmd) {\n\tcase DLM_MSG:\n\t\tdlm_message_in(&p->message);\n\t\ttype = p->message.m_type;\n\t\tbreak;\n\tcase DLM_RCOM:\n\t\tdlm_rcom_in(&p->rcom);\n\t\ttype = p->rcom.rc_type;\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"invalid h_cmd %d from %u\", hd->h_cmd, nodeid);\n\t\treturn;\n\t}\n\n\tif (hd->h_nodeid != nodeid) {\n\t\tlog_print(\"invalid h_nodeid %d from %d lockspace %x\",\n\t\t\t  hd->h_nodeid, nodeid, hd->h_lockspace);\n\t\treturn;\n\t}\n\n\tls = dlm_find_lockspace_global(hd->h_lockspace);\n\tif (!ls) {\n\t\tif (dlm_config.ci_log_debug) {\n\t\t\tprintk_ratelimited(KERN_DEBUG \"dlm: invalid lockspace \"\n\t\t\t\t\"%u from %d cmd %d type %d\\n\",\n\t\t\t\thd->h_lockspace, nodeid, hd->h_cmd, type);\n\t\t}\n\n\t\tif (hd->h_cmd == DLM_RCOM && type == DLM_RCOM_STATUS)\n\t\t\tdlm_send_ls_not_ready(nodeid, &p->rcom);\n\t\treturn;\n\t}\n\n\t/* this rwsem allows dlm_ls_stop() to wait for all dlm_recv threads to\n\t   be inactive (in this ls) before transitioning to recovery mode */\n\n\tdown_read(&ls->ls_recv_active);\n\tif (hd->h_cmd == DLM_MSG)\n\t\tdlm_receive_message(ls, &p->message, nodeid);\n\telse\n\t\tdlm_receive_rcom(ls, &p->rcom, nodeid);\n\tup_read(&ls->ls_recv_active);\n\n\tdlm_put_lockspace(ls);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 5067
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_recv_active"
          ],
          "line": 5065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_receive_rcom",
          "args": [
            "ls",
            "&p->rcom",
            "nodeid"
          ],
          "line": 5064
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_receive_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "548-655",
          "snippet": "void dlm_receive_rcom(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\n{\n\tint lock_size = sizeof(struct dlm_rcom) + sizeof(struct rcom_lock);\n\tint stop, reply = 0, names = 0, lookup = 0, lock = 0;\n\tuint32_t status;\n\tuint64_t seq;\n\n\tswitch (rc->rc_type) {\n\tcase DLM_RCOM_STATUS_REPLY:\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_NAMES:\n\t\tnames = 1;\n\t\tbreak;\n\tcase DLM_RCOM_NAMES_REPLY:\n\t\tnames = 1;\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOOKUP:\n\t\tlookup = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOOKUP_REPLY:\n\t\tlookup = 1;\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOCK:\n\t\tlock = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOCK_REPLY:\n\t\tlock = 1;\n\t\treply = 1;\n\t\tbreak;\n\t};\n\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tstop = test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tseq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (stop && (rc->rc_type != DLM_RCOM_STATUS))\n\t\tgoto ignore;\n\n\tif (reply && (rc->rc_seq_reply != seq))\n\t\tgoto ignore;\n\n\tif (!(status & DLM_RS_NODES) && (names || lookup || lock))\n\t\tgoto ignore;\n\n\tif (!(status & DLM_RS_DIR) && (lookup || lock))\n\t\tgoto ignore;\n\n\tswitch (rc->rc_type) {\n\tcase DLM_RCOM_STATUS:\n\t\treceive_rcom_status(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_NAMES:\n\t\treceive_rcom_names(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOOKUP:\n\t\treceive_rcom_lookup(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOCK:\n\t\tif (rc->rc_header.h_length < lock_size)\n\t\t\tgoto Eshort;\n\t\treceive_rcom_lock(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_STATUS_REPLY:\n\t\treceive_sync_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_NAMES_REPLY:\n\t\treceive_sync_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOOKUP_REPLY:\n\t\treceive_rcom_lookup_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOCK_REPLY:\n\t\tif (rc->rc_header.h_length < lock_size)\n\t\t\tgoto Eshort;\n\t\tdlm_recover_process_copy(ls, rc);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_rcom bad type %d\", rc->rc_type);\n\t}\n\treturn;\n\nignore:\n\tlog_limit(ls, \"dlm_receive_rcom ignore msg %d \"\n\t\t  \"from %d %llu %llu recover seq %llu sts %x gen %u\",\n\t\t   rc->rc_type,\n\t\t   nodeid,\n\t\t   (unsigned long long)rc->rc_seq,\n\t\t   (unsigned long long)rc->rc_seq_reply,\n\t\t   (unsigned long long)seq,\n\t\t   status, ls->ls_generation);\n\treturn;\nEshort:\n\tlog_error(ls, \"recovery message %d from %d is too short\",\n\t\t  rc->rc_type, nodeid);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_receive_rcom(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\n{\n\tint lock_size = sizeof(struct dlm_rcom) + sizeof(struct rcom_lock);\n\tint stop, reply = 0, names = 0, lookup = 0, lock = 0;\n\tuint32_t status;\n\tuint64_t seq;\n\n\tswitch (rc->rc_type) {\n\tcase DLM_RCOM_STATUS_REPLY:\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_NAMES:\n\t\tnames = 1;\n\t\tbreak;\n\tcase DLM_RCOM_NAMES_REPLY:\n\t\tnames = 1;\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOOKUP:\n\t\tlookup = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOOKUP_REPLY:\n\t\tlookup = 1;\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOCK:\n\t\tlock = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOCK_REPLY:\n\t\tlock = 1;\n\t\treply = 1;\n\t\tbreak;\n\t};\n\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tstop = test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tseq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (stop && (rc->rc_type != DLM_RCOM_STATUS))\n\t\tgoto ignore;\n\n\tif (reply && (rc->rc_seq_reply != seq))\n\t\tgoto ignore;\n\n\tif (!(status & DLM_RS_NODES) && (names || lookup || lock))\n\t\tgoto ignore;\n\n\tif (!(status & DLM_RS_DIR) && (lookup || lock))\n\t\tgoto ignore;\n\n\tswitch (rc->rc_type) {\n\tcase DLM_RCOM_STATUS:\n\t\treceive_rcom_status(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_NAMES:\n\t\treceive_rcom_names(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOOKUP:\n\t\treceive_rcom_lookup(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOCK:\n\t\tif (rc->rc_header.h_length < lock_size)\n\t\t\tgoto Eshort;\n\t\treceive_rcom_lock(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_STATUS_REPLY:\n\t\treceive_sync_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_NAMES_REPLY:\n\t\treceive_sync_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOOKUP_REPLY:\n\t\treceive_rcom_lookup_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOCK_REPLY:\n\t\tif (rc->rc_header.h_length < lock_size)\n\t\t\tgoto Eshort;\n\t\tdlm_recover_process_copy(ls, rc);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_rcom bad type %d\", rc->rc_type);\n\t}\n\treturn;\n\nignore:\n\tlog_limit(ls, \"dlm_receive_rcom ignore msg %d \"\n\t\t  \"from %d %llu %llu recover seq %llu sts %x gen %u\",\n\t\t   rc->rc_type,\n\t\t   nodeid,\n\t\t   (unsigned long long)rc->rc_seq,\n\t\t   (unsigned long long)rc->rc_seq_reply,\n\t\t   (unsigned long long)seq,\n\t\t   status, ls->ls_generation);\n\treturn;\nEshort:\n\tlog_error(ls, \"recovery message %d from %d is too short\",\n\t\t  rc->rc_type, nodeid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_receive_message",
          "args": [
            "ls",
            "&p->message",
            "nodeid"
          ],
          "line": 5062
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_receive_message_saved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5007-5011",
          "snippet": "void dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq)\n{\n\t_receive_message(ls, ms, saved_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nvoid dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq)\n{\n\t_receive_message(ls, ms, saved_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ls->ls_recv_active"
          ],
          "line": 5060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_send_ls_not_ready",
          "args": [
            "nodeid",
            "&p->rcom"
          ],
          "line": 5053
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_ls_not_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "468-501",
          "snippet": "int dlm_send_ls_not_ready(int nodeid, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct rcom_config *rf;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + sizeof(struct rcom_config);\n\n\tmh = dlm_lowcomms_get_buffer(nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = rc_in->rc_header.h_lockspace;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = DLM_RCOM_STATUS_REPLY;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\trc->rc_result = -ESRCH;\n\n\trf = (struct rcom_config *) rc->rc_buf;\n\trf->rf_lvblen = cpu_to_le32(~0U);\n\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_send_ls_not_ready(int nodeid, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct rcom_config *rf;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + sizeof(struct rcom_config);\n\n\tmh = dlm_lowcomms_get_buffer(nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = rc_in->rc_header.h_lockspace;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = DLM_RCOM_STATUS_REPLY;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\trc->rc_result = -ESRCH;\n\n\trf = (struct rcom_config *) rc->rc_buf;\n\trf->rf_lvblen = cpu_to_le32(~0U);\n\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_DEBUG \"dlm: invalid lockspace \"\n\t\t\t\t\"%u from %d cmd %d type %d\\n\"",
            "hd->h_lockspace",
            "nodeid",
            "hd->h_cmd",
            "type"
          ],
          "line": 5047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_global",
          "args": [
            "hd->h_lockspace"
          ],
          "line": 5044
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_global",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "317-333",
          "snippet": "struct dlm_ls *dlm_find_lockspace_global(uint32_t id)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_global_id == id) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_global(uint32_t id)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_global_id == id) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"invalid h_nodeid %d from %d lockspace %x\"",
            "hd->h_nodeid",
            "nodeid",
            "hd->h_lockspace"
          ],
          "line": 5039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"invalid h_cmd %d from %u\"",
            "hd->h_cmd",
            "nodeid"
          ],
          "line": 5034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_rcom_in",
          "args": [
            "&p->rcom"
          ],
          "line": 5030
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_rcom_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/util.c",
          "lines": "145-154",
          "snippet": "void dlm_rcom_in(struct dlm_rcom *rc)\n{\n\theader_in(&rc->rc_header);\n\n\trc->rc_type\t\t= le32_to_cpu(rc->rc_type);\n\trc->rc_result\t\t= le32_to_cpu(rc->rc_result);\n\trc->rc_id\t\t= le64_to_cpu(rc->rc_id);\n\trc->rc_seq\t\t= le64_to_cpu(rc->rc_seq);\n\trc->rc_seq_reply\t= le64_to_cpu(rc->rc_seq_reply);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"rcom.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"rcom.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_rcom_in(struct dlm_rcom *rc)\n{\n\theader_in(&rc->rc_header);\n\n\trc->rc_type\t\t= le32_to_cpu(rc->rc_type);\n\trc->rc_result\t\t= le32_to_cpu(rc->rc_result);\n\trc->rc_id\t\t= le64_to_cpu(rc->rc_id);\n\trc->rc_seq\t\t= le64_to_cpu(rc->rc_seq);\n\trc->rc_seq_reply\t= le64_to_cpu(rc->rc_seq_reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_message_in",
          "args": [
            "&p->message"
          ],
          "line": 5026
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_message_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/util.c",
          "lines": "110-132",
          "snippet": "void dlm_message_in(struct dlm_message *ms)\n{\n\theader_in(&ms->m_header);\n\n\tms->m_type\t\t= le32_to_cpu(ms->m_type);\n\tms->m_nodeid\t\t= le32_to_cpu(ms->m_nodeid);\n\tms->m_pid\t\t= le32_to_cpu(ms->m_pid);\n\tms->m_lkid\t\t= le32_to_cpu(ms->m_lkid);\n\tms->m_remid\t\t= le32_to_cpu(ms->m_remid);\n\tms->m_parent_lkid\t= le32_to_cpu(ms->m_parent_lkid);\n\tms->m_parent_remid\t= le32_to_cpu(ms->m_parent_remid);\n\tms->m_exflags\t\t= le32_to_cpu(ms->m_exflags);\n\tms->m_sbflags\t\t= le32_to_cpu(ms->m_sbflags);\n\tms->m_flags\t\t= le32_to_cpu(ms->m_flags);\n\tms->m_lvbseq\t\t= le32_to_cpu(ms->m_lvbseq);\n\tms->m_hash\t\t= le32_to_cpu(ms->m_hash);\n\tms->m_status\t\t= le32_to_cpu(ms->m_status);\n\tms->m_grmode\t\t= le32_to_cpu(ms->m_grmode);\n\tms->m_rqmode\t\t= le32_to_cpu(ms->m_rqmode);\n\tms->m_bastmode\t\t= le32_to_cpu(ms->m_bastmode);\n\tms->m_asts\t\t= le32_to_cpu(ms->m_asts);\n\tms->m_result\t\t= from_dlm_errno(le32_to_cpu(ms->m_result));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"rcom.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"rcom.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_message_in(struct dlm_message *ms)\n{\n\theader_in(&ms->m_header);\n\n\tms->m_type\t\t= le32_to_cpu(ms->m_type);\n\tms->m_nodeid\t\t= le32_to_cpu(ms->m_nodeid);\n\tms->m_pid\t\t= le32_to_cpu(ms->m_pid);\n\tms->m_lkid\t\t= le32_to_cpu(ms->m_lkid);\n\tms->m_remid\t\t= le32_to_cpu(ms->m_remid);\n\tms->m_parent_lkid\t= le32_to_cpu(ms->m_parent_lkid);\n\tms->m_parent_remid\t= le32_to_cpu(ms->m_parent_remid);\n\tms->m_exflags\t\t= le32_to_cpu(ms->m_exflags);\n\tms->m_sbflags\t\t= le32_to_cpu(ms->m_sbflags);\n\tms->m_flags\t\t= le32_to_cpu(ms->m_flags);\n\tms->m_lvbseq\t\t= le32_to_cpu(ms->m_lvbseq);\n\tms->m_hash\t\t= le32_to_cpu(ms->m_hash);\n\tms->m_status\t\t= le32_to_cpu(ms->m_status);\n\tms->m_grmode\t\t= le32_to_cpu(ms->m_grmode);\n\tms->m_rqmode\t\t= le32_to_cpu(ms->m_rqmode);\n\tms->m_bastmode\t\t= le32_to_cpu(ms->m_bastmode);\n\tms->m_asts\t\t= le32_to_cpu(ms->m_asts);\n\tms->m_result\t\t= from_dlm_errno(le32_to_cpu(ms->m_result));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\n\nvoid dlm_receive_buffer(union dlm_packet *p, int nodeid)\n{\n\tstruct dlm_header *hd = &p->header;\n\tstruct dlm_ls *ls;\n\tint type = 0;\n\n\tswitch (hd->h_cmd) {\n\tcase DLM_MSG:\n\t\tdlm_message_in(&p->message);\n\t\ttype = p->message.m_type;\n\t\tbreak;\n\tcase DLM_RCOM:\n\t\tdlm_rcom_in(&p->rcom);\n\t\ttype = p->rcom.rc_type;\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"invalid h_cmd %d from %u\", hd->h_cmd, nodeid);\n\t\treturn;\n\t}\n\n\tif (hd->h_nodeid != nodeid) {\n\t\tlog_print(\"invalid h_nodeid %d from %d lockspace %x\",\n\t\t\t  hd->h_nodeid, nodeid, hd->h_lockspace);\n\t\treturn;\n\t}\n\n\tls = dlm_find_lockspace_global(hd->h_lockspace);\n\tif (!ls) {\n\t\tif (dlm_config.ci_log_debug) {\n\t\t\tprintk_ratelimited(KERN_DEBUG \"dlm: invalid lockspace \"\n\t\t\t\t\"%u from %d cmd %d type %d\\n\",\n\t\t\t\thd->h_lockspace, nodeid, hd->h_cmd, type);\n\t\t}\n\n\t\tif (hd->h_cmd == DLM_RCOM && type == DLM_RCOM_STATUS)\n\t\t\tdlm_send_ls_not_ready(nodeid, &p->rcom);\n\t\treturn;\n\t}\n\n\t/* this rwsem allows dlm_ls_stop() to wait for all dlm_recv threads to\n\t   be inactive (in this ls) before transitioning to recovery mode */\n\n\tdown_read(&ls->ls_recv_active);\n\tif (hd->h_cmd == DLM_MSG)\n\t\tdlm_receive_message(ls, &p->message, nodeid);\n\telse\n\t\tdlm_receive_rcom(ls, &p->rcom, nodeid);\n\tup_read(&ls->ls_recv_active);\n\n\tdlm_put_lockspace(ls);\n}"
  },
  {
    "function_name": "dlm_receive_message_saved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "5007-5011",
    "snippet": "void dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq)\n{\n\t_receive_message(ls, ms, saved_seq);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_receive_message",
          "args": [
            "ls",
            "ms",
            "saved_seq"
          ],
          "line": 5010
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_receive_message_saved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5007-5011",
          "snippet": "void dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq)\n{\n\t_receive_message(ls, ms, saved_seq);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nvoid dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq)\n{\n\t_receive_message(ls, ms, saved_seq);\n}"
  },
  {
    "function_name": "dlm_receive_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4984-5002",
    "snippet": "static void dlm_receive_message(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t\tint nodeid)\n{\n\tif (dlm_locking_stopped(ls)) {\n\t\t/* If we were a member of this lockspace, left, and rejoined,\n\t\t   other nodes may still be sending us messages from the\n\t\t   lockspace generation before we left. */\n\t\tif (!ls->ls_generation) {\n\t\t\tlog_limit(ls, \"receive %d from %d ignore old gen\",\n\t\t\t\t  ms->m_type, nodeid);\n\t\t\treturn;\n\t\t}\n\n\t\tdlm_add_requestqueue(ls, nodeid, ms);\n\t} else {\n\t\tdlm_wait_requestqueue(ls);\n\t\t_receive_message(ls, ms, 0);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_receive_message",
          "args": [
            "ls",
            "ms",
            "0"
          ],
          "line": 5000
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_receive_message_saved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5007-5011",
          "snippet": "void dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq)\n{\n\t_receive_message(ls, ms, saved_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nvoid dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq)\n{\n\t_receive_message(ls, ms, saved_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_wait_requestqueue",
          "args": [
            "ls"
          ],
          "line": 4999
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_requestqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
          "lines": "118-128",
          "snippet": "void dlm_wait_requestqueue(struct dlm_ls *ls)\n{\n\tfor (;;) {\n\t\tmutex_lock(&ls->ls_requestqueue_mutex);\n\t\tif (list_empty(&ls->ls_requestqueue))\n\t\t\tbreak;\n\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\tschedule();\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}",
          "includes": [
            "#include \"requestqueue.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"member.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_wait_requestqueue(struct dlm_ls *ls)\n{\n\tfor (;;) {\n\t\tmutex_lock(&ls->ls_requestqueue_mutex);\n\t\tif (list_empty(&ls->ls_requestqueue))\n\t\t\tbreak;\n\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\tschedule();\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_add_requestqueue",
          "args": [
            "ls",
            "nodeid",
            "ms"
          ],
          "line": 4997
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_requestqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
          "lines": "34-52",
          "snippet": "void dlm_add_requestqueue(struct dlm_ls *ls, int nodeid, struct dlm_message *ms)\n{\n\tstruct rq_entry *e;\n\tint length = ms->m_header.h_length - sizeof(struct dlm_message);\n\n\te = kmalloc(sizeof(struct rq_entry) + length, GFP_NOFS);\n\tif (!e) {\n\t\tlog_print(\"dlm_add_requestqueue: out of memory len %d\", length);\n\t\treturn;\n\t}\n\n\te->recover_seq = ls->ls_recover_seq & 0xFFFFFFFF;\n\te->nodeid = nodeid;\n\tmemcpy(&e->request, ms, ms->m_header.h_length);\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_add_tail(&e->list, &ls->ls_requestqueue);\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}",
          "includes": [
            "#include \"requestqueue.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"member.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_add_requestqueue(struct dlm_ls *ls, int nodeid, struct dlm_message *ms)\n{\n\tstruct rq_entry *e;\n\tint length = ms->m_header.h_length - sizeof(struct dlm_message);\n\n\te = kmalloc(sizeof(struct rq_entry) + length, GFP_NOFS);\n\tif (!e) {\n\t\tlog_print(\"dlm_add_requestqueue: out of memory len %d\", length);\n\t\treturn;\n\t}\n\n\te->recover_seq = ls->ls_recover_seq & 0xFFFFFFFF;\n\te->nodeid = nodeid;\n\tmemcpy(&e->request, ms, ms->m_header.h_length);\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_add_tail(&e->list, &ls->ls_requestqueue);\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_limit",
          "args": [
            "ls",
            "\"receive %d from %d ignore old gen\"",
            "ms->m_type",
            "nodeid"
          ],
          "line": 4992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_locking_stopped",
          "args": [
            "ls"
          ],
          "line": 4987
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_locking_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "695-698",
          "snippet": "static inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RUNNING\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RUNNING\t\t4\n\nstatic inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic void dlm_receive_message(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t\tint nodeid)\n{\n\tif (dlm_locking_stopped(ls)) {\n\t\t/* If we were a member of this lockspace, left, and rejoined,\n\t\t   other nodes may still be sending us messages from the\n\t\t   lockspace generation before we left. */\n\t\tif (!ls->ls_generation) {\n\t\t\tlog_limit(ls, \"receive %d from %d ignore old gen\",\n\t\t\t\t  ms->m_type, nodeid);\n\t\t\treturn;\n\t\t}\n\n\t\tdlm_add_requestqueue(ls, nodeid, ms);\n\t} else {\n\t\tdlm_wait_requestqueue(ls);\n\t\t_receive_message(ls, ms, 0);\n\t}\n}"
  },
  {
    "function_name": "_receive_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4855-4974",
    "snippet": "static void _receive_message(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t     uint32_t saved_seq)\n{\n\tint error = 0, noent = 0;\n\n\tif (!dlm_is_member(ls, ms->m_header.h_nodeid)) {\n\t\tlog_limit(ls, \"receive %d from non-member %d %x %x %d\",\n\t\t\t  ms->m_type, ms->m_header.h_nodeid, ms->m_lkid,\n\t\t\t  ms->m_remid, ms->m_result);\n\t\treturn;\n\t}\n\n\tswitch (ms->m_type) {\n\n\t/* messages sent to a master node */\n\n\tcase DLM_MSG_REQUEST:\n\t\terror = receive_request(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT:\n\t\terror = receive_convert(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_UNLOCK:\n\t\terror = receive_unlock(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_CANCEL:\n\t\tnoent = 1;\n\t\terror = receive_cancel(ls, ms);\n\t\tbreak;\n\n\t/* messages sent from a master node (replies to above) */\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\terror = receive_request_reply(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\t\terror = receive_convert_reply(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_UNLOCK_REPLY:\n\t\terror = receive_unlock_reply(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_CANCEL_REPLY:\n\t\terror = receive_cancel_reply(ls, ms);\n\t\tbreak;\n\n\t/* messages sent from a master node (only two types of async msg) */\n\n\tcase DLM_MSG_GRANT:\n\t\tnoent = 1;\n\t\terror = receive_grant(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_BAST:\n\t\tnoent = 1;\n\t\terror = receive_bast(ls, ms);\n\t\tbreak;\n\n\t/* messages sent to a dir node */\n\n\tcase DLM_MSG_LOOKUP:\n\t\treceive_lookup(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_REMOVE:\n\t\treceive_remove(ls, ms);\n\t\tbreak;\n\n\t/* messages sent from a dir node (remove has no reply) */\n\n\tcase DLM_MSG_LOOKUP_REPLY:\n\t\treceive_lookup_reply(ls, ms);\n\t\tbreak;\n\n\t/* other messages */\n\n\tcase DLM_MSG_PURGE:\n\t\treceive_purge(ls, ms);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"unknown message type %d\", ms->m_type);\n\t}\n\n\t/*\n\t * When checking for ENOENT, we're checking the result of\n\t * find_lkb(m_remid):\n\t *\n\t * The lock id referenced in the message wasn't found.  This may\n\t * happen in normal usage for the async messages and cancel, so\n\t * only use log_debug for them.\n\t *\n\t * Some errors are expected and normal.\n\t */\n\n\tif (error == -ENOENT && noent) {\n\t\tlog_debug(ls, \"receive %d no %x remote %d %x saved_seq %u\",\n\t\t\t  ms->m_type, ms->m_remid, ms->m_header.h_nodeid,\n\t\t\t  ms->m_lkid, saved_seq);\n\t} else if (error == -ENOENT) {\n\t\tlog_error(ls, \"receive %d no %x remote %d %x saved_seq %u\",\n\t\t\t  ms->m_type, ms->m_remid, ms->m_header.h_nodeid,\n\t\t\t  ms->m_lkid, saved_seq);\n\n\t\tif (ms->m_type == DLM_MSG_CONVERT)\n\t\t\tdlm_dump_rsb_hash(ls, ms->m_hash);\n\t}\n\n\tif (error == -EINVAL) {\n\t\tlog_error(ls, \"receive %d inval from %d lkid %x remid %x \"\n\t\t\t  \"saved_seq %u\",\n\t\t\t  ms->m_type, ms->m_header.h_nodeid,\n\t\t\t  ms->m_lkid, ms->m_remid, saved_seq);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive %d inval from %d lkid %x remid %x \"\n\t\t\t  \"saved_seq %u\"",
            "ms->m_type",
            "ms->m_header.h_nodeid",
            "ms->m_lkid",
            "ms->m_remid",
            "saved_seq"
          ],
          "line": 4969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb_hash",
          "args": [
            "ls",
            "ms->m_hash"
          ],
          "line": 4965
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1086-1101",
          "snippet": "static void dlm_dump_rsb_hash(struct dlm_ls *ls, uint32_t hash)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\tif (r->res_hash == hash)\n\t\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_dump_rsb_hash(struct dlm_ls *ls, uint32_t hash)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\tif (r->res_hash == hash)\n\t\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive %d no %x remote %d %x saved_seq %u\"",
            "ms->m_type",
            "ms->m_remid",
            "ms->m_header.h_nodeid",
            "ms->m_lkid",
            "saved_seq"
          ],
          "line": 4960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"receive %d no %x remote %d %x saved_seq %u\"",
            "ms->m_type",
            "ms->m_remid",
            "ms->m_header.h_nodeid",
            "ms->m_lkid",
            "saved_seq"
          ],
          "line": 4956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"unknown message type %d\"",
            "ms->m_type"
          ],
          "line": 4941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_purge",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4937
        },
        "resolved": true,
        "details": {
          "function_name": "receive_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4471-4474",
          "snippet": "static void receive_purge(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tdo_purge(ls, ms->m_nodeid, ms->m_pid);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic void receive_purge(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tdo_purge(ls, ms->m_nodeid, ms->m_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_lookup_reply",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4931
        },
        "resolved": true,
        "details": {
          "function_name": "receive_lookup_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4777-4853",
          "snippet": "static void receive_lookup_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, ret_nodeid;\n\tint do_lookup_list = 0;\n\n\terror = find_lkb(ls, ms->m_lkid, &lkb);\n\tif (error) {\n\t\tlog_error(ls, \"receive_lookup_reply no lkid %x\", ms->m_lkid);\n\t\treturn;\n\t}\n\n\t/* ms->m_result is the value returned by dlm_master_lookup on dir node\n\t   FIXME: will a non-zero error ever be returned? */\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = remove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\n\tif (error)\n\t\tgoto out;\n\n\tret_nodeid = ms->m_nodeid;\n\n\t/* We sometimes receive a request from the dir node for this\n\t   rsb before we've received the dir node's loookup_reply for it.\n\t   The request from the dir node implies we're the master, so we set\n\t   ourself as master in receive_request_reply, and verify here that\n\t   we are indeed the master. */\n\n\tif (r->res_master_nodeid && (r->res_master_nodeid != ret_nodeid)) {\n\t\t/* This should never happen */\n\t\tlog_error(ls, \"receive_lookup_reply %x from %d ret %d \"\n\t\t\t  \"master %d dir %d our %d first %x %s\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid, ret_nodeid,\n\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t  dlm_our_nodeid(), r->res_first_lkid, r->res_name);\n\t}\n\n\tif (ret_nodeid == dlm_our_nodeid()) {\n\t\tr->res_master_nodeid = ret_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tdo_lookup_list = 1;\n\t\tr->res_first_lkid = 0;\n\t} else if (ret_nodeid == -1) {\n\t\t/* the remote node doesn't believe it's the dir node */\n\t\tlog_error(ls, \"receive_lookup_reply %x from %d bad ret_nodeid\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid);\n\t\tr->res_master_nodeid = 0;\n\t\tr->res_nodeid = -1;\n\t\tlkb->lkb_nodeid = -1;\n\t} else {\n\t\t/* set_master() will set lkb_nodeid from r */\n\t\tr->res_master_nodeid = ret_nodeid;\n\t\tr->res_nodeid = ret_nodeid;\n\t}\n\n\tif (is_overlap(lkb)) {\n\t\tlog_debug(ls, \"receive_lookup_reply %x unlock %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_flags);\n\t\tqueue_cast_overlap(r, lkb);\n\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\tgoto out_list;\n\t}\n\n\t_request_lock(r, lkb);\n\n out_list:\n\tif (do_lookup_list)\n\t\tprocess_lookup_list(r);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_lookup_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, ret_nodeid;\n\tint do_lookup_list = 0;\n\n\terror = find_lkb(ls, ms->m_lkid, &lkb);\n\tif (error) {\n\t\tlog_error(ls, \"receive_lookup_reply no lkid %x\", ms->m_lkid);\n\t\treturn;\n\t}\n\n\t/* ms->m_result is the value returned by dlm_master_lookup on dir node\n\t   FIXME: will a non-zero error ever be returned? */\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = remove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\n\tif (error)\n\t\tgoto out;\n\n\tret_nodeid = ms->m_nodeid;\n\n\t/* We sometimes receive a request from the dir node for this\n\t   rsb before we've received the dir node's loookup_reply for it.\n\t   The request from the dir node implies we're the master, so we set\n\t   ourself as master in receive_request_reply, and verify here that\n\t   we are indeed the master. */\n\n\tif (r->res_master_nodeid && (r->res_master_nodeid != ret_nodeid)) {\n\t\t/* This should never happen */\n\t\tlog_error(ls, \"receive_lookup_reply %x from %d ret %d \"\n\t\t\t  \"master %d dir %d our %d first %x %s\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid, ret_nodeid,\n\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t  dlm_our_nodeid(), r->res_first_lkid, r->res_name);\n\t}\n\n\tif (ret_nodeid == dlm_our_nodeid()) {\n\t\tr->res_master_nodeid = ret_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tdo_lookup_list = 1;\n\t\tr->res_first_lkid = 0;\n\t} else if (ret_nodeid == -1) {\n\t\t/* the remote node doesn't believe it's the dir node */\n\t\tlog_error(ls, \"receive_lookup_reply %x from %d bad ret_nodeid\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid);\n\t\tr->res_master_nodeid = 0;\n\t\tr->res_nodeid = -1;\n\t\tlkb->lkb_nodeid = -1;\n\t} else {\n\t\t/* set_master() will set lkb_nodeid from r */\n\t\tr->res_master_nodeid = ret_nodeid;\n\t\tr->res_nodeid = ret_nodeid;\n\t}\n\n\tif (is_overlap(lkb)) {\n\t\tlog_debug(ls, \"receive_lookup_reply %x unlock %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_flags);\n\t\tqueue_cast_overlap(r, lkb);\n\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\tgoto out_list;\n\t}\n\n\t_request_lock(r, lkb);\n\n out_list:\n\tif (do_lookup_list)\n\t\tprocess_lookup_list(r);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_remove",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4925
        },
        "resolved": true,
        "details": {
          "function_name": "receive_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4383-4469",
          "snippet": "static void receive_remove(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tchar name[DLM_RESNAME_MAXLEN+1];\n\tstruct dlm_rsb *r;\n\tuint32_t hash, b;\n\tint rv, len, dir_nodeid, from_nodeid;\n\n\tfrom_nodeid = ms->m_header.h_nodeid;\n\n\tlen = receive_extralen(ms);\n\n\tif (len > DLM_RESNAME_MAXLEN) {\n\t\tlog_error(ls, \"receive_remove from %d bad len %d\",\n\t\t\t  from_nodeid, len);\n\t\treturn;\n\t}\n\n\tdir_nodeid = dlm_hash2nodeid(ls, ms->m_hash);\n\tif (dir_nodeid != dlm_our_nodeid()) {\n\t\tlog_error(ls, \"receive_remove from %d bad nodeid %d\",\n\t\t\t  from_nodeid, dir_nodeid);\n\t\treturn;\n\t}\n\n\t/* Look for name on rsbtbl.toss, if it's there, kill it.\n\t   If it's on rsbtbl.keep, it's being used, and we should ignore this\n\t   message.  This is an expected race between the dir node sending a\n\t   request to the master node at the same time as the master node sends\n\t   a remove to the dir node.  The resolution to that race is for the\n\t   dir node to ignore the remove message, and the master node to\n\t   recreate the master rsb when it gets a request from the dir node for\n\t   an rsb it doesn't have. */\n\n\tmemset(name, 0, sizeof(name));\n\tmemcpy(name, ms->m_extra, len);\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (rv) {\n\t\t/* verify the rsb is on keep list per comment above */\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\t\tif (rv) {\n\t\t\t/* should not happen */\n\t\t\tlog_error(ls, \"receive_remove from %d not found %s\",\n\t\t\t\t  from_nodeid, name);\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\treturn;\n\t\t}\n\t\tif (r->res_master_nodeid != from_nodeid) {\n\t\t\t/* should not happen */\n\t\t\tlog_error(ls, \"receive_remove keep from %d master %d\",\n\t\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\t\tdlm_print_rsb(r);\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\treturn;\n\t\t}\n\n\t\tlog_debug(ls, \"receive_remove from %d master %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_first_lkid,\n\t\t\t  name);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tif (r->res_master_nodeid != from_nodeid) {\n\t\tlog_error(ls, \"receive_remove toss from %d master %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tif (kref_put(&r->res_ref, kill_rsb)) {\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tdlm_free_rsb(r);\n\t} else {\n\t\tlog_error(ls, \"receive_remove from %d rsb ref error\",\n\t\t\t  from_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic void receive_remove(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tchar name[DLM_RESNAME_MAXLEN+1];\n\tstruct dlm_rsb *r;\n\tuint32_t hash, b;\n\tint rv, len, dir_nodeid, from_nodeid;\n\n\tfrom_nodeid = ms->m_header.h_nodeid;\n\n\tlen = receive_extralen(ms);\n\n\tif (len > DLM_RESNAME_MAXLEN) {\n\t\tlog_error(ls, \"receive_remove from %d bad len %d\",\n\t\t\t  from_nodeid, len);\n\t\treturn;\n\t}\n\n\tdir_nodeid = dlm_hash2nodeid(ls, ms->m_hash);\n\tif (dir_nodeid != dlm_our_nodeid()) {\n\t\tlog_error(ls, \"receive_remove from %d bad nodeid %d\",\n\t\t\t  from_nodeid, dir_nodeid);\n\t\treturn;\n\t}\n\n\t/* Look for name on rsbtbl.toss, if it's there, kill it.\n\t   If it's on rsbtbl.keep, it's being used, and we should ignore this\n\t   message.  This is an expected race between the dir node sending a\n\t   request to the master node at the same time as the master node sends\n\t   a remove to the dir node.  The resolution to that race is for the\n\t   dir node to ignore the remove message, and the master node to\n\t   recreate the master rsb when it gets a request from the dir node for\n\t   an rsb it doesn't have. */\n\n\tmemset(name, 0, sizeof(name));\n\tmemcpy(name, ms->m_extra, len);\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (rv) {\n\t\t/* verify the rsb is on keep list per comment above */\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\t\tif (rv) {\n\t\t\t/* should not happen */\n\t\t\tlog_error(ls, \"receive_remove from %d not found %s\",\n\t\t\t\t  from_nodeid, name);\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\treturn;\n\t\t}\n\t\tif (r->res_master_nodeid != from_nodeid) {\n\t\t\t/* should not happen */\n\t\t\tlog_error(ls, \"receive_remove keep from %d master %d\",\n\t\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\t\tdlm_print_rsb(r);\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\treturn;\n\t\t}\n\n\t\tlog_debug(ls, \"receive_remove from %d master %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_first_lkid,\n\t\t\t  name);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tif (r->res_master_nodeid != from_nodeid) {\n\t\tlog_error(ls, \"receive_remove toss from %d master %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tif (kref_put(&r->res_ref, kill_rsb)) {\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tdlm_free_rsb(r);\n\t} else {\n\t\tlog_error(ls, \"receive_remove from %d rsb ref error\",\n\t\t\t  from_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_bast",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4915
        },
        "resolved": true,
        "details": {
          "function_name": "receive_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4335-4361",
          "snippet": "static int receive_bast(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tqueue_bast(r, lkb, ms->m_bastmode);\n\tlkb->lkb_highbast = ms->m_bastmode;\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_bast(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tqueue_bast(r, lkb, ms->m_bastmode);\n\tlkb->lkb_highbast = ms->m_bastmode;\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_grant",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4910
        },
        "resolved": true,
        "details": {
          "function_name": "receive_grant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4304-4333",
          "snippet": "static int receive_grant(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags_reply(lkb, ms);\n\tif (is_altmode(lkb))\n\t\tmunge_altmode(lkb, ms);\n\tgrant_lock_pc(r, lkb, ms);\n\tqueue_cast(r, lkb, 0);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_grant(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags_reply(lkb, ms);\n\tif (is_altmode(lkb))\n\t\tmunge_altmode(lkb, ms);\n\tgrant_lock_pc(r, lkb, ms);\n\tqueue_cast(r, lkb, 0);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_cancel_reply",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4903
        },
        "resolved": true,
        "details": {
          "function_name": "receive_cancel_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4763-4775",
          "snippet": "static int receive_cancel_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_cancel_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_cancel_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_cancel_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_unlock_reply",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4899
        },
        "resolved": true,
        "details": {
          "function_name": "receive_unlock_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4713-4725",
          "snippet": "static int receive_unlock_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_unlock_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_unlock_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_unlock_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_convert_reply",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4895
        },
        "resolved": true,
        "details": {
          "function_name": "receive_convert_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4663-4675",
          "snippet": "static int receive_convert_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_convert_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_convert_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_convert_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_request_reply",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4891
        },
        "resolved": true,
        "details": {
          "function_name": "receive_request_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4476-4594",
          "snippet": "static int receive_request_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, mstype, result;\n\tint from_nodeid = ms->m_header.h_nodeid;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tmstype = lkb->lkb_wait_type;\n\terror = remove_from_waiters(lkb, DLM_MSG_REQUEST_REPLY);\n\tif (error) {\n\t\tlog_error(ls, \"receive_request_reply %x remote %d %x result %d\",\n\t\t\t  lkb->lkb_id, from_nodeid, ms->m_lkid, ms->m_result);\n\t\tdlm_dump_rsb(r);\n\t\tgoto out;\n\t}\n\n\t/* Optimization: the dir node was also the master, so it took our\n\t   lookup as a request and sent request reply instead of lookup reply */\n\tif (mstype == DLM_MSG_LOOKUP) {\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\tlkb->lkb_nodeid = from_nodeid;\n\t}\n\n\t/* this is the value returned from do_request() on the master */\n\tresult = ms->m_result;\n\n\tswitch (result) {\n\tcase -EAGAIN:\n\t\t/* request would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tconfirm_master(r, -EAGAIN);\n\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\tcase 0:\n\t\t/* request was queued or granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tlkb->lkb_remid = ms->m_lkid;\n\t\tif (is_altmode(lkb))\n\t\t\tmunge_altmode(lkb, ms);\n\t\tif (result) {\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\t\tadd_timeout(lkb);\n\t\t} else {\n\t\t\tgrant_lock_pc(r, lkb, ms);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t}\n\t\tconfirm_master(r, result);\n\t\tbreak;\n\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* find_rsb failed to find rsb or rsb wasn't master */\n\t\tlog_limit(ls, \"receive_request_reply %x from %d %d \"\n\t\t\t  \"master %d dir %d first %x %s\", lkb->lkb_id,\n\t\t\t  from_nodeid, result, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid, r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_dir_nodeid != dlm_our_nodeid() &&\n\t\t    r->res_master_nodeid != dlm_our_nodeid()) {\n\t\t\t/* cause _request_lock->set_master->send_lookup */\n\t\t\tr->res_master_nodeid = 0;\n\t\t\tr->res_nodeid = -1;\n\t\t\tlkb->lkb_nodeid = -1;\n\t\t}\n\n\t\tif (is_overlap(lkb)) {\n\t\t\t/* we'll ignore error in cancel/unlock reply */\n\t\t\tqueue_cast_overlap(r, lkb);\n\t\t\tconfirm_master(r, result);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t} else {\n\t\t\t_request_lock(r, lkb);\n\n\t\t\tif (r->res_master_nodeid == dlm_our_nodeid())\n\t\t\t\tconfirm_master(r, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_request_reply %x error %d\",\n\t\t\t  lkb->lkb_id, result);\n\t}\n\n\tif (is_overlap_unlock(lkb) && (result == 0 || result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x result %d unlock\",\n\t\t\t  lkb->lkb_id, result);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_unlock(r, lkb);\n\t} else if (is_overlap_cancel(lkb) && (result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x cancel\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_cancel(r, lkb);\n\t} else {\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_request_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, mstype, result;\n\tint from_nodeid = ms->m_header.h_nodeid;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tmstype = lkb->lkb_wait_type;\n\terror = remove_from_waiters(lkb, DLM_MSG_REQUEST_REPLY);\n\tif (error) {\n\t\tlog_error(ls, \"receive_request_reply %x remote %d %x result %d\",\n\t\t\t  lkb->lkb_id, from_nodeid, ms->m_lkid, ms->m_result);\n\t\tdlm_dump_rsb(r);\n\t\tgoto out;\n\t}\n\n\t/* Optimization: the dir node was also the master, so it took our\n\t   lookup as a request and sent request reply instead of lookup reply */\n\tif (mstype == DLM_MSG_LOOKUP) {\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\tlkb->lkb_nodeid = from_nodeid;\n\t}\n\n\t/* this is the value returned from do_request() on the master */\n\tresult = ms->m_result;\n\n\tswitch (result) {\n\tcase -EAGAIN:\n\t\t/* request would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tconfirm_master(r, -EAGAIN);\n\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\tcase 0:\n\t\t/* request was queued or granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tlkb->lkb_remid = ms->m_lkid;\n\t\tif (is_altmode(lkb))\n\t\t\tmunge_altmode(lkb, ms);\n\t\tif (result) {\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\t\tadd_timeout(lkb);\n\t\t} else {\n\t\t\tgrant_lock_pc(r, lkb, ms);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t}\n\t\tconfirm_master(r, result);\n\t\tbreak;\n\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* find_rsb failed to find rsb or rsb wasn't master */\n\t\tlog_limit(ls, \"receive_request_reply %x from %d %d \"\n\t\t\t  \"master %d dir %d first %x %s\", lkb->lkb_id,\n\t\t\t  from_nodeid, result, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid, r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_dir_nodeid != dlm_our_nodeid() &&\n\t\t    r->res_master_nodeid != dlm_our_nodeid()) {\n\t\t\t/* cause _request_lock->set_master->send_lookup */\n\t\t\tr->res_master_nodeid = 0;\n\t\t\tr->res_nodeid = -1;\n\t\t\tlkb->lkb_nodeid = -1;\n\t\t}\n\n\t\tif (is_overlap(lkb)) {\n\t\t\t/* we'll ignore error in cancel/unlock reply */\n\t\t\tqueue_cast_overlap(r, lkb);\n\t\t\tconfirm_master(r, result);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t} else {\n\t\t\t_request_lock(r, lkb);\n\n\t\t\tif (r->res_master_nodeid == dlm_our_nodeid())\n\t\t\t\tconfirm_master(r, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_request_reply %x error %d\",\n\t\t\t  lkb->lkb_id, result);\n\t}\n\n\tif (is_overlap_unlock(lkb) && (result == 0 || result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x result %d unlock\",\n\t\t\t  lkb->lkb_id, result);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_unlock(r, lkb);\n\t} else if (is_overlap_cancel(lkb) && (result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x cancel\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_cancel(r, lkb);\n\t} else {\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_limit",
          "args": [
            "ls",
            "\"receive %d from non-member %d %x %x %d\"",
            "ms->m_type",
            "ms->m_header.h_nodeid",
            "ms->m_lkid",
            "ms->m_remid",
            "ms->m_result"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_member",
          "args": [
            "ls",
            "ms->m_header.h_nodeid"
          ],
          "line": 4860
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "351-356",
          "snippet": "int dlm_is_member(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes, nodeid))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_is_member(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes, nodeid))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic void _receive_message(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t     uint32_t saved_seq)\n{\n\tint error = 0, noent = 0;\n\n\tif (!dlm_is_member(ls, ms->m_header.h_nodeid)) {\n\t\tlog_limit(ls, \"receive %d from non-member %d %x %x %d\",\n\t\t\t  ms->m_type, ms->m_header.h_nodeid, ms->m_lkid,\n\t\t\t  ms->m_remid, ms->m_result);\n\t\treturn;\n\t}\n\n\tswitch (ms->m_type) {\n\n\t/* messages sent to a master node */\n\n\tcase DLM_MSG_REQUEST:\n\t\terror = receive_request(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT:\n\t\terror = receive_convert(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_UNLOCK:\n\t\terror = receive_unlock(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_CANCEL:\n\t\tnoent = 1;\n\t\terror = receive_cancel(ls, ms);\n\t\tbreak;\n\n\t/* messages sent from a master node (replies to above) */\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\terror = receive_request_reply(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\t\terror = receive_convert_reply(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_UNLOCK_REPLY:\n\t\terror = receive_unlock_reply(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_CANCEL_REPLY:\n\t\terror = receive_cancel_reply(ls, ms);\n\t\tbreak;\n\n\t/* messages sent from a master node (only two types of async msg) */\n\n\tcase DLM_MSG_GRANT:\n\t\tnoent = 1;\n\t\terror = receive_grant(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_BAST:\n\t\tnoent = 1;\n\t\terror = receive_bast(ls, ms);\n\t\tbreak;\n\n\t/* messages sent to a dir node */\n\n\tcase DLM_MSG_LOOKUP:\n\t\treceive_lookup(ls, ms);\n\t\tbreak;\n\n\tcase DLM_MSG_REMOVE:\n\t\treceive_remove(ls, ms);\n\t\tbreak;\n\n\t/* messages sent from a dir node (remove has no reply) */\n\n\tcase DLM_MSG_LOOKUP_REPLY:\n\t\treceive_lookup_reply(ls, ms);\n\t\tbreak;\n\n\t/* other messages */\n\n\tcase DLM_MSG_PURGE:\n\t\treceive_purge(ls, ms);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"unknown message type %d\", ms->m_type);\n\t}\n\n\t/*\n\t * When checking for ENOENT, we're checking the result of\n\t * find_lkb(m_remid):\n\t *\n\t * The lock id referenced in the message wasn't found.  This may\n\t * happen in normal usage for the async messages and cancel, so\n\t * only use log_debug for them.\n\t *\n\t * Some errors are expected and normal.\n\t */\n\n\tif (error == -ENOENT && noent) {\n\t\tlog_debug(ls, \"receive %d no %x remote %d %x saved_seq %u\",\n\t\t\t  ms->m_type, ms->m_remid, ms->m_header.h_nodeid,\n\t\t\t  ms->m_lkid, saved_seq);\n\t} else if (error == -ENOENT) {\n\t\tlog_error(ls, \"receive %d no %x remote %d %x saved_seq %u\",\n\t\t\t  ms->m_type, ms->m_remid, ms->m_header.h_nodeid,\n\t\t\t  ms->m_lkid, saved_seq);\n\n\t\tif (ms->m_type == DLM_MSG_CONVERT)\n\t\t\tdlm_dump_rsb_hash(ls, ms->m_hash);\n\t}\n\n\tif (error == -EINVAL) {\n\t\tlog_error(ls, \"receive %d inval from %d lkid %x remid %x \"\n\t\t\t  \"saved_seq %u\",\n\t\t\t  ms->m_type, ms->m_header.h_nodeid,\n\t\t\t  ms->m_lkid, ms->m_remid, saved_seq);\n\t}\n}"
  },
  {
    "function_name": "receive_lookup_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4777-4853",
    "snippet": "static void receive_lookup_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, ret_nodeid;\n\tint do_lookup_list = 0;\n\n\terror = find_lkb(ls, ms->m_lkid, &lkb);\n\tif (error) {\n\t\tlog_error(ls, \"receive_lookup_reply no lkid %x\", ms->m_lkid);\n\t\treturn;\n\t}\n\n\t/* ms->m_result is the value returned by dlm_master_lookup on dir node\n\t   FIXME: will a non-zero error ever be returned? */\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = remove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\n\tif (error)\n\t\tgoto out;\n\n\tret_nodeid = ms->m_nodeid;\n\n\t/* We sometimes receive a request from the dir node for this\n\t   rsb before we've received the dir node's loookup_reply for it.\n\t   The request from the dir node implies we're the master, so we set\n\t   ourself as master in receive_request_reply, and verify here that\n\t   we are indeed the master. */\n\n\tif (r->res_master_nodeid && (r->res_master_nodeid != ret_nodeid)) {\n\t\t/* This should never happen */\n\t\tlog_error(ls, \"receive_lookup_reply %x from %d ret %d \"\n\t\t\t  \"master %d dir %d our %d first %x %s\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid, ret_nodeid,\n\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t  dlm_our_nodeid(), r->res_first_lkid, r->res_name);\n\t}\n\n\tif (ret_nodeid == dlm_our_nodeid()) {\n\t\tr->res_master_nodeid = ret_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tdo_lookup_list = 1;\n\t\tr->res_first_lkid = 0;\n\t} else if (ret_nodeid == -1) {\n\t\t/* the remote node doesn't believe it's the dir node */\n\t\tlog_error(ls, \"receive_lookup_reply %x from %d bad ret_nodeid\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid);\n\t\tr->res_master_nodeid = 0;\n\t\tr->res_nodeid = -1;\n\t\tlkb->lkb_nodeid = -1;\n\t} else {\n\t\t/* set_master() will set lkb_nodeid from r */\n\t\tr->res_master_nodeid = ret_nodeid;\n\t\tr->res_nodeid = ret_nodeid;\n\t}\n\n\tif (is_overlap(lkb)) {\n\t\tlog_debug(ls, \"receive_lookup_reply %x unlock %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_flags);\n\t\tqueue_cast_overlap(r, lkb);\n\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\tgoto out_list;\n\t}\n\n\t_request_lock(r, lkb);\n\n out_list:\n\tif (do_lookup_list)\n\t\tprocess_lookup_list(r);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4852
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4851
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4850
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_lookup_list",
          "args": [
            "r"
          ],
          "line": 4848
        },
        "resolved": true,
        "details": {
          "function_name": "process_lookup_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2755-2764",
          "snippet": "static void process_lookup_list(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, &r->res_lookup, lkb_rsb_lookup) {\n\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t_request_lock(r, lkb);\n\t\tschedule();\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void process_lookup_list(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, &r->res_lookup, lkb_rsb_lookup) {\n\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t_request_lock(r, lkb);\n\t\tschedule();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_request_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4844
        },
        "resolved": true,
        "details": {
          "function_name": "_request_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3224-3249",
          "snippet": "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 4840
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_cast_overlap",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4839
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "314-318",
          "snippet": "static inline void queue_cast_overlap(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tqueue_cast(r, lkb,\n\t\t   is_overlap_unlock(lkb) ? -DLM_EUNLOCK : -DLM_ECANCEL);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void queue_cast_overlap(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tqueue_cast(r, lkb,\n\t\t   is_overlap_unlock(lkb) ? -DLM_EUNLOCK : -DLM_ECANCEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"receive_lookup_reply %x unlock %x\"",
            "lkb->lkb_id",
            "lkb->lkb_flags"
          ],
          "line": 4837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_overlap",
          "args": [
            "lkb"
          ],
          "line": 4836
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "284-288",
          "snippet": "static inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\n\t\t\t\t  DLM_IFL_OVERLAP_CANCEL));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\n\t\t\t\t  DLM_IFL_OVERLAP_CANCEL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_lookup_reply %x from %d bad ret_nodeid\"",
            "lkb->lkb_id",
            "ms->m_header.h_nodeid"
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 4818
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_lookup_reply %x from %d ret %d \"\n\t\t\t  \"master %d dir %d our %d first %x %s\"",
            "lkb->lkb_id",
            "ms->m_header.h_nodeid",
            "ret_nodeid",
            "r->res_master_nodeid",
            "r->res_dir_nodeid",
            "dlm_our_nodeid()",
            "r->res_first_lkid",
            "r->res_name"
          ],
          "line": 4811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_from_waiters",
          "args": [
            "lkb",
            "DLM_MSG_LOOKUP_REPLY"
          ],
          "line": 4797
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_waiters_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1610-1621",
          "snippet": "static int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 4794
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_lookup_reply no lkid %x\"",
            "ms->m_lkid"
          ],
          "line": 4786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "ms->m_lkid",
            "&lkb"
          ],
          "line": 4784
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_lookup_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, ret_nodeid;\n\tint do_lookup_list = 0;\n\n\terror = find_lkb(ls, ms->m_lkid, &lkb);\n\tif (error) {\n\t\tlog_error(ls, \"receive_lookup_reply no lkid %x\", ms->m_lkid);\n\t\treturn;\n\t}\n\n\t/* ms->m_result is the value returned by dlm_master_lookup on dir node\n\t   FIXME: will a non-zero error ever be returned? */\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = remove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\n\tif (error)\n\t\tgoto out;\n\n\tret_nodeid = ms->m_nodeid;\n\n\t/* We sometimes receive a request from the dir node for this\n\t   rsb before we've received the dir node's loookup_reply for it.\n\t   The request from the dir node implies we're the master, so we set\n\t   ourself as master in receive_request_reply, and verify here that\n\t   we are indeed the master. */\n\n\tif (r->res_master_nodeid && (r->res_master_nodeid != ret_nodeid)) {\n\t\t/* This should never happen */\n\t\tlog_error(ls, \"receive_lookup_reply %x from %d ret %d \"\n\t\t\t  \"master %d dir %d our %d first %x %s\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid, ret_nodeid,\n\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t  dlm_our_nodeid(), r->res_first_lkid, r->res_name);\n\t}\n\n\tif (ret_nodeid == dlm_our_nodeid()) {\n\t\tr->res_master_nodeid = ret_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tdo_lookup_list = 1;\n\t\tr->res_first_lkid = 0;\n\t} else if (ret_nodeid == -1) {\n\t\t/* the remote node doesn't believe it's the dir node */\n\t\tlog_error(ls, \"receive_lookup_reply %x from %d bad ret_nodeid\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid);\n\t\tr->res_master_nodeid = 0;\n\t\tr->res_nodeid = -1;\n\t\tlkb->lkb_nodeid = -1;\n\t} else {\n\t\t/* set_master() will set lkb_nodeid from r */\n\t\tr->res_master_nodeid = ret_nodeid;\n\t\tr->res_nodeid = ret_nodeid;\n\t}\n\n\tif (is_overlap(lkb)) {\n\t\tlog_debug(ls, \"receive_lookup_reply %x unlock %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_flags);\n\t\tqueue_cast_overlap(r, lkb);\n\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\tgoto out_list;\n\t}\n\n\t_request_lock(r, lkb);\n\n out_list:\n\tif (do_lookup_list)\n\t\tprocess_lookup_list(r);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n}"
  },
  {
    "function_name": "receive_cancel_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4763-4775",
    "snippet": "static int receive_cancel_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_cancel_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4773
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_receive_cancel_reply",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4772
        },
        "resolved": true,
        "details": {
          "function_name": "_receive_cancel_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4727-4761",
          "snippet": "static void _receive_cancel_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_cancel() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_ECANCEL:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_cancel_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _receive_cancel_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_cancel() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_ECANCEL:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_cancel_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "ms->m_remid",
            "&lkb"
          ],
          "line": 4768
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_cancel_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_cancel_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
  },
  {
    "function_name": "_receive_cancel_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4727-4761",
    "snippet": "static void _receive_cancel_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_cancel() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_ECANCEL:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_cancel_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4760
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4759
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "r->res_ls",
            "\"receive_cancel_reply %x error %d\"",
            "lkb->lkb_id",
            "ms->m_result"
          ],
          "line": 4755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "-DLM_ECANCEL"
          ],
          "line": 4750
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "revert_lock_pc",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4749
        },
        "resolved": true,
        "details": {
          "function_name": "revert_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2110-2113",
          "snippet": "static int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_flags_reply",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4748
        },
        "resolved": true,
        "details": {
          "function_name": "receive_flags_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3871-3879",
          "snippet": "static void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_waiters_ms",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4740
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_waiters_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1610-1621",
          "snippet": "static int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_message",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4735
        },
        "resolved": true,
        "details": {
          "function_name": "validate_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3972-4011",
          "snippet": "static int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 4732
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _receive_cancel_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_cancel() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_ECANCEL:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_cancel_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}"
  },
  {
    "function_name": "receive_unlock_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4713-4725",
    "snippet": "static int receive_unlock_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_unlock_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4723
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_receive_unlock_reply",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4722
        },
        "resolved": true,
        "details": {
          "function_name": "_receive_unlock_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4677-4711",
          "snippet": "static void _receive_unlock_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_unlock() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_EUNLOCK:\n\t\treceive_flags_reply(lkb, ms);\n\t\tremove_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\t\tbreak;\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_unlock_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _receive_unlock_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_unlock() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_EUNLOCK:\n\t\treceive_flags_reply(lkb, ms);\n\t\tremove_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\t\tbreak;\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_unlock_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "ms->m_remid",
            "&lkb"
          ],
          "line": 4718
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_unlock_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_unlock_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
  },
  {
    "function_name": "_receive_unlock_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4677-4711",
    "snippet": "static void _receive_unlock_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_unlock() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_EUNLOCK:\n\t\treceive_flags_reply(lkb, ms);\n\t\tremove_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\t\tbreak;\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_unlock_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4710
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "r->res_ls",
            "\"receive_unlock_reply %x error %d\"",
            "lkb->lkb_id",
            "ms->m_result"
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "-DLM_EUNLOCK"
          ],
          "line": 4700
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_lock_pc",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4699
        },
        "resolved": true,
        "details": {
          "function_name": "remove_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2074-2077",
          "snippet": "static void remove_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\t_remove_lock(r, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void remove_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\t_remove_lock(r, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_flags_reply",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4698
        },
        "resolved": true,
        "details": {
          "function_name": "receive_flags_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3871-3879",
          "snippet": "static void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_waiters_ms",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4690
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_waiters_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1610-1621",
          "snippet": "static int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_message",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4685
        },
        "resolved": true,
        "details": {
          "function_name": "validate_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3972-4011",
          "snippet": "static int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 4682
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _receive_unlock_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* this is the value returned from do_unlock() on the master */\n\n\tswitch (ms->m_result) {\n\tcase -DLM_EUNLOCK:\n\t\treceive_flags_reply(lkb, ms);\n\t\tremove_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\t\tbreak;\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_unlock_reply %x error %d\",\n\t\t\t  lkb->lkb_id, ms->m_result);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}"
  },
  {
    "function_name": "receive_convert_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4663-4675",
    "snippet": "static int receive_convert_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_convert_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4673
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_receive_convert_reply",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4672
        },
        "resolved": true,
        "details": {
          "function_name": "_receive_convert_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4640-4661",
          "snippet": "static void _receive_convert_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t__receive_convert_reply(r, lkb, ms);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _receive_convert_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t__receive_convert_reply(r, lkb, ms);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "ms->m_remid",
            "&lkb"
          ],
          "line": 4668
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_convert_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_convert_reply(lkb, ms);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
  },
  {
    "function_name": "_receive_convert_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4640-4661",
    "snippet": "static void _receive_convert_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t__receive_convert_reply(r, lkb, ms);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4660
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4659
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__receive_convert_reply",
          "args": [
            "r",
            "lkb",
            "ms"
          ],
          "line": 4657
        },
        "resolved": true,
        "details": {
          "function_name": "__receive_convert_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4596-4638",
          "snippet": "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms)\n{\n\t/* this is the value returned from do_convert() on the master */\n\tswitch (ms->m_result) {\n\tcase -EAGAIN:\n\t\t/* convert would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tbreak;\n\n\tcase -EDEADLK:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\t\t/* convert was queued on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tbreak;\n\n\tcase 0:\n\t\t/* convert was granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tgrant_lock_pc(r, lkb, ms);\n\t\tqueue_cast(r, lkb, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_convert_reply %x remote %d %x %d\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid, ms->m_lkid,\n\t\t\t  ms->m_result);\n\t\tdlm_print_rsb(r);\n\t\tdlm_print_lkb(lkb);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms)\n{\n\t/* this is the value returned from do_convert() on the master */\n\tswitch (ms->m_result) {\n\tcase -EAGAIN:\n\t\t/* convert would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tbreak;\n\n\tcase -EDEADLK:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\t\t/* convert was queued on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tbreak;\n\n\tcase 0:\n\t\t/* convert was granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tgrant_lock_pc(r, lkb, ms);\n\t\tqueue_cast(r, lkb, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_convert_reply %x remote %d %x %d\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid, ms->m_lkid,\n\t\t\t  ms->m_result);\n\t\tdlm_print_rsb(r);\n\t\tdlm_print_lkb(lkb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_waiters_ms",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4653
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_waiters_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1610-1621",
          "snippet": "static int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_message",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4648
        },
        "resolved": true,
        "details": {
          "function_name": "validate_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3972-4011",
          "snippet": "static int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 4645
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _receive_convert_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t/* stub reply can happen with waiters_mutex held */\n\terror = remove_from_waiters_ms(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t__receive_convert_reply(r, lkb, ms);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}"
  },
  {
    "function_name": "__receive_convert_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4596-4638",
    "snippet": "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms)\n{\n\t/* this is the value returned from do_convert() on the master */\n\tswitch (ms->m_result) {\n\tcase -EAGAIN:\n\t\t/* convert would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tbreak;\n\n\tcase -EDEADLK:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\t\t/* convert was queued on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tbreak;\n\n\tcase 0:\n\t\t/* convert was granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tgrant_lock_pc(r, lkb, ms);\n\t\tqueue_cast(r, lkb, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_convert_reply %x remote %d %x %d\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid, ms->m_lkid,\n\t\t\t  ms->m_result);\n\t\tdlm_print_rsb(r);\n\t\tdlm_print_lkb(lkb);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 4636
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_rsb",
          "args": [
            "r"
          ],
          "line": 4635
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "172-179",
          "snippet": "static void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "r->res_ls",
            "\"receive_convert_reply %x remote %d %x %d\"",
            "lkb->lkb_id",
            "ms->m_header.h_nodeid",
            "ms->m_lkid",
            "ms->m_result"
          ],
          "line": 4632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "0"
          ],
          "line": 4628
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_lock_pc",
          "args": [
            "r",
            "lkb",
            "ms"
          ],
          "line": 4627
        },
        "resolved": true,
        "details": {
          "function_name": "grant_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2135-2140",
          "snippet": "static void grant_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  struct dlm_message *ms)\n{\n\tset_lvb_lock_pc(r, lkb, ms);\n\t_grant_lock(r, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  struct dlm_message *ms)\n{\n\tset_lvb_lock_pc(r, lkb, ms);\n\t_grant_lock(r, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "munge_demoted",
          "args": [
            "lkb"
          ],
          "line": 4626
        },
        "resolved": true,
        "details": {
          "function_name": "munge_demoted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2163-2172",
          "snippet": "static void munge_demoted(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_rqmode == DLM_LOCK_IV || lkb->lkb_grmode == DLM_LOCK_IV) {\n\t\tlog_print(\"munge_demoted %x invalid modes gr %d rq %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_grmode, lkb->lkb_rqmode);\n\t\treturn;\n\t}\n\n\tlkb->lkb_grmode = DLM_LOCK_NL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void munge_demoted(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_rqmode == DLM_LOCK_IV || lkb->lkb_grmode == DLM_LOCK_IV) {\n\t\tlog_print(\"munge_demoted %x invalid modes gr %d rq %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_grmode, lkb->lkb_rqmode);\n\t\treturn;\n\t}\n\n\tlkb->lkb_grmode = DLM_LOCK_NL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_demoted",
          "args": [
            "lkb"
          ],
          "line": 4625
        },
        "resolved": true,
        "details": {
          "function_name": "is_demoted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "230-233",
          "snippet": "static inline int is_demoted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_DEMOTED);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_demoted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_DEMOTED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_flags_reply",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4624
        },
        "resolved": true,
        "details": {
          "function_name": "receive_flags_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3871-3879",
          "snippet": "static void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timeout",
          "args": [
            "lkb"
          ],
          "line": 4619
        },
        "resolved": true,
        "details": {
          "function_name": "add_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1815-1837",
          "snippet": "static void add_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\n\t    !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\tlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\n\t\tgoto add_it;\n\t}\n\tif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\n\t\tgoto add_it;\n\treturn;\n\n add_it:\n\tDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\n\tmutex_lock(&ls->ls_timeout_mutex);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\n\t    !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\tlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\n\t\tgoto add_it;\n\t}\n\tif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\n\t\tgoto add_it;\n\treturn;\n\n add_it:\n\tDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\n\tmutex_lock(&ls->ls_timeout_mutex);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_lkb",
          "args": [
            "r",
            "lkb",
            "DLM_LKSTS_CONVERT"
          ],
          "line": 4618
        },
        "resolved": true,
        "details": {
          "function_name": "add_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1314-1346",
          "snippet": "static void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_lkb",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4617
        },
        "resolved": true,
        "details": {
          "function_name": "del_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1348-1353",
          "snippet": "static void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "revert_lock_pc",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4608
        },
        "resolved": true,
        "details": {
          "function_name": "revert_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2110-2113",
          "snippet": "static int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms)\n{\n\t/* this is the value returned from do_convert() on the master */\n\tswitch (ms->m_result) {\n\tcase -EAGAIN:\n\t\t/* convert would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tbreak;\n\n\tcase -EDEADLK:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\t\t/* convert was queued on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tbreak;\n\n\tcase 0:\n\t\t/* convert was granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tgrant_lock_pc(r, lkb, ms);\n\t\tqueue_cast(r, lkb, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_convert_reply %x remote %d %x %d\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid, ms->m_lkid,\n\t\t\t  ms->m_result);\n\t\tdlm_print_rsb(r);\n\t\tdlm_print_lkb(lkb);\n\t}\n}"
  },
  {
    "function_name": "receive_request_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4476-4594",
    "snippet": "static int receive_request_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, mstype, result;\n\tint from_nodeid = ms->m_header.h_nodeid;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tmstype = lkb->lkb_wait_type;\n\terror = remove_from_waiters(lkb, DLM_MSG_REQUEST_REPLY);\n\tif (error) {\n\t\tlog_error(ls, \"receive_request_reply %x remote %d %x result %d\",\n\t\t\t  lkb->lkb_id, from_nodeid, ms->m_lkid, ms->m_result);\n\t\tdlm_dump_rsb(r);\n\t\tgoto out;\n\t}\n\n\t/* Optimization: the dir node was also the master, so it took our\n\t   lookup as a request and sent request reply instead of lookup reply */\n\tif (mstype == DLM_MSG_LOOKUP) {\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\tlkb->lkb_nodeid = from_nodeid;\n\t}\n\n\t/* this is the value returned from do_request() on the master */\n\tresult = ms->m_result;\n\n\tswitch (result) {\n\tcase -EAGAIN:\n\t\t/* request would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tconfirm_master(r, -EAGAIN);\n\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\tcase 0:\n\t\t/* request was queued or granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tlkb->lkb_remid = ms->m_lkid;\n\t\tif (is_altmode(lkb))\n\t\t\tmunge_altmode(lkb, ms);\n\t\tif (result) {\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\t\tadd_timeout(lkb);\n\t\t} else {\n\t\t\tgrant_lock_pc(r, lkb, ms);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t}\n\t\tconfirm_master(r, result);\n\t\tbreak;\n\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* find_rsb failed to find rsb or rsb wasn't master */\n\t\tlog_limit(ls, \"receive_request_reply %x from %d %d \"\n\t\t\t  \"master %d dir %d first %x %s\", lkb->lkb_id,\n\t\t\t  from_nodeid, result, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid, r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_dir_nodeid != dlm_our_nodeid() &&\n\t\t    r->res_master_nodeid != dlm_our_nodeid()) {\n\t\t\t/* cause _request_lock->set_master->send_lookup */\n\t\t\tr->res_master_nodeid = 0;\n\t\t\tr->res_nodeid = -1;\n\t\t\tlkb->lkb_nodeid = -1;\n\t\t}\n\n\t\tif (is_overlap(lkb)) {\n\t\t\t/* we'll ignore error in cancel/unlock reply */\n\t\t\tqueue_cast_overlap(r, lkb);\n\t\t\tconfirm_master(r, result);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t} else {\n\t\t\t_request_lock(r, lkb);\n\n\t\t\tif (r->res_master_nodeid == dlm_our_nodeid())\n\t\t\t\tconfirm_master(r, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_request_reply %x error %d\",\n\t\t\t  lkb->lkb_id, result);\n\t}\n\n\tif (is_overlap_unlock(lkb) && (result == 0 || result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x result %d unlock\",\n\t\t\t  lkb->lkb_id, result);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_unlock(r, lkb);\n\t} else if (is_overlap_cancel(lkb) && (result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x cancel\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_cancel(r, lkb);\n\t} else {\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4592
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4591
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4590
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cancel",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4584
        },
        "resolved": true,
        "details": {
          "function_name": "send_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3701-3704",
          "snippet": "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_CANCEL);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_CANCEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"receive_request_reply %x cancel\"",
            "lkb->lkb_id"
          ],
          "line": 4581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_overlap_cancel",
          "args": [
            "lkb"
          ],
          "line": 4580
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "279-282",
          "snippet": "static inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_unlock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4579
        },
        "resolved": true,
        "details": {
          "function_name": "send_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3696-3699",
          "snippet": "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_UNLOCK);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_UNLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"receive_request_reply %x result %d unlock\"",
            "lkb->lkb_id",
            "result"
          ],
          "line": 4575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_overlap_unlock",
          "args": [
            "lkb"
          ],
          "line": 4574
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "274-277",
          "snippet": "static inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_request_reply %x error %d\"",
            "lkb->lkb_id",
            "result"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "confirm_master",
          "args": [
            "r",
            "0"
          ],
          "line": 4565
        },
        "resolved": true,
        "details": {
          "function_name": "confirm_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2768-2803",
          "snippet": "static void confirm_master(struct dlm_rsb *r, int error)\n{\n\tstruct dlm_lkb *lkb;\n\n\tif (!r->res_first_lkid)\n\t\treturn;\n\n\tswitch (error) {\n\tcase 0:\n\tcase -EINPROGRESS:\n\t\tr->res_first_lkid = 0;\n\t\tprocess_lookup_list(r);\n\t\tbreak;\n\n\tcase -EAGAIN:\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* the remote request failed and won't be retried (it was\n\t\t   a NOQUEUE, or has been canceled/unlocked); make a waiting\n\t\t   lkb the first_lkid */\n\n\t\tr->res_first_lkid = 0;\n\n\t\tif (!list_empty(&r->res_lookup)) {\n\t\t\tlkb = list_entry(r->res_lookup.next, struct dlm_lkb,\n\t\t\t\t\t lkb_rsb_lookup);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tr->res_first_lkid = lkb->lkb_id;\n\t\t\t_request_lock(r, lkb);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"confirm_master unknown error %d\", error);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void confirm_master(struct dlm_rsb *r, int error)\n{\n\tstruct dlm_lkb *lkb;\n\n\tif (!r->res_first_lkid)\n\t\treturn;\n\n\tswitch (error) {\n\tcase 0:\n\tcase -EINPROGRESS:\n\t\tr->res_first_lkid = 0;\n\t\tprocess_lookup_list(r);\n\t\tbreak;\n\n\tcase -EAGAIN:\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* the remote request failed and won't be retried (it was\n\t\t   a NOQUEUE, or has been canceled/unlocked); make a waiting\n\t\t   lkb the first_lkid */\n\n\t\tr->res_first_lkid = 0;\n\n\t\tif (!list_empty(&r->res_lookup)) {\n\t\t\tlkb = list_entry(r->res_lookup.next, struct dlm_lkb,\n\t\t\t\t\t lkb_rsb_lookup);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tr->res_first_lkid = lkb->lkb_id;\n\t\t\t_request_lock(r, lkb);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"confirm_master unknown error %d\", error);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 4564
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_request_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4562
        },
        "resolved": true,
        "details": {
          "function_name": "_request_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3224-3249",
          "snippet": "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 4560
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_cast_overlap",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4558
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "314-318",
          "snippet": "static inline void queue_cast_overlap(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tqueue_cast(r, lkb,\n\t\t   is_overlap_unlock(lkb) ? -DLM_EUNLOCK : -DLM_ECANCEL);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void queue_cast_overlap(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tqueue_cast(r, lkb,\n\t\t   is_overlap_unlock(lkb) ? -DLM_EUNLOCK : -DLM_ECANCEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_overlap",
          "args": [
            "lkb"
          ],
          "line": 4556
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "284-288",
          "snippet": "static inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\n\t\t\t\t  DLM_IFL_OVERLAP_CANCEL));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\n\t\t\t\t  DLM_IFL_OVERLAP_CANCEL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_limit",
          "args": [
            "ls",
            "\"receive_request_reply %x from %d %d \"\n\t\t\t  \"master %d dir %d first %x %s\"",
            "lkb->lkb_id",
            "from_nodeid",
            "result",
            "r->res_master_nodeid",
            "r->res_dir_nodeid",
            "r->res_first_lkid",
            "r->res_name"
          ],
          "line": 4543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "0"
          ],
          "line": 4535
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_lock_pc",
          "args": [
            "r",
            "lkb",
            "ms"
          ],
          "line": 4534
        },
        "resolved": true,
        "details": {
          "function_name": "grant_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2135-2140",
          "snippet": "static void grant_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  struct dlm_message *ms)\n{\n\tset_lvb_lock_pc(r, lkb, ms);\n\t_grant_lock(r, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  struct dlm_message *ms)\n{\n\tset_lvb_lock_pc(r, lkb, ms);\n\t_grant_lock(r, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timeout",
          "args": [
            "lkb"
          ],
          "line": 4532
        },
        "resolved": true,
        "details": {
          "function_name": "add_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1815-1837",
          "snippet": "static void add_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\n\t    !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\tlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\n\t\tgoto add_it;\n\t}\n\tif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\n\t\tgoto add_it;\n\treturn;\n\n add_it:\n\tDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\n\tmutex_lock(&ls->ls_timeout_mutex);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\n\t    !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\tlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\n\t\tgoto add_it;\n\t}\n\tif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\n\t\tgoto add_it;\n\treturn;\n\n add_it:\n\tDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\n\tmutex_lock(&ls->ls_timeout_mutex);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_lkb",
          "args": [
            "r",
            "lkb",
            "DLM_LKSTS_WAITING"
          ],
          "line": 4531
        },
        "resolved": true,
        "details": {
          "function_name": "add_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1314-1346",
          "snippet": "static void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "munge_altmode",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4529
        },
        "resolved": true,
        "details": {
          "function_name": "munge_altmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2174-2191",
          "snippet": "static void munge_altmode(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_type != DLM_MSG_REQUEST_REPLY &&\n\t    ms->m_type != DLM_MSG_GRANT) {\n\t\tlog_print(\"munge_altmode %x invalid reply type %d\",\n\t\t\t  lkb->lkb_id, ms->m_type);\n\t\treturn;\n\t}\n\n\tif (lkb->lkb_exflags & DLM_LKF_ALTPR)\n\t\tlkb->lkb_rqmode = DLM_LOCK_PR;\n\telse if (lkb->lkb_exflags & DLM_LKF_ALTCW)\n\t\tlkb->lkb_rqmode = DLM_LOCK_CW;\n\telse {\n\t\tlog_print(\"munge_altmode invalid exflags %x\", lkb->lkb_exflags);\n\t\tdlm_print_lkb(lkb);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void munge_altmode(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_type != DLM_MSG_REQUEST_REPLY &&\n\t    ms->m_type != DLM_MSG_GRANT) {\n\t\tlog_print(\"munge_altmode %x invalid reply type %d\",\n\t\t\t  lkb->lkb_id, ms->m_type);\n\t\treturn;\n\t}\n\n\tif (lkb->lkb_exflags & DLM_LKF_ALTPR)\n\t\tlkb->lkb_rqmode = DLM_LOCK_PR;\n\telse if (lkb->lkb_exflags & DLM_LKF_ALTCW)\n\t\tlkb->lkb_rqmode = DLM_LOCK_CW;\n\telse {\n\t\tlog_print(\"munge_altmode invalid exflags %x\", lkb->lkb_exflags);\n\t\tdlm_print_lkb(lkb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_altmode",
          "args": [
            "lkb"
          ],
          "line": 4528
        },
        "resolved": true,
        "details": {
          "function_name": "is_altmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "235-238",
          "snippet": "static inline int is_altmode(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_ALTMODE);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_altmode(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_ALTMODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_flags_reply",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4526
        },
        "resolved": true,
        "details": {
          "function_name": "receive_flags_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3871-3879",
          "snippet": "static void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 4500
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_request_reply %x remote %d %x result %d\"",
            "lkb->lkb_id",
            "from_nodeid",
            "ms->m_lkid",
            "ms->m_result"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_from_waiters",
          "args": [
            "lkb",
            "DLM_MSG_REQUEST_REPLY"
          ],
          "line": 4496
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_waiters_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1610-1621",
          "snippet": "static int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_message",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4491
        },
        "resolved": true,
        "details": {
          "function_name": "validate_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3972-4011",
          "snippet": "static int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "ms->m_remid",
            "&lkb"
          ],
          "line": 4483
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_request_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, mstype, result;\n\tint from_nodeid = ms->m_header.h_nodeid;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tmstype = lkb->lkb_wait_type;\n\terror = remove_from_waiters(lkb, DLM_MSG_REQUEST_REPLY);\n\tif (error) {\n\t\tlog_error(ls, \"receive_request_reply %x remote %d %x result %d\",\n\t\t\t  lkb->lkb_id, from_nodeid, ms->m_lkid, ms->m_result);\n\t\tdlm_dump_rsb(r);\n\t\tgoto out;\n\t}\n\n\t/* Optimization: the dir node was also the master, so it took our\n\t   lookup as a request and sent request reply instead of lookup reply */\n\tif (mstype == DLM_MSG_LOOKUP) {\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\tlkb->lkb_nodeid = from_nodeid;\n\t}\n\n\t/* this is the value returned from do_request() on the master */\n\tresult = ms->m_result;\n\n\tswitch (result) {\n\tcase -EAGAIN:\n\t\t/* request would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tconfirm_master(r, -EAGAIN);\n\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\tcase 0:\n\t\t/* request was queued or granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tlkb->lkb_remid = ms->m_lkid;\n\t\tif (is_altmode(lkb))\n\t\t\tmunge_altmode(lkb, ms);\n\t\tif (result) {\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\t\tadd_timeout(lkb);\n\t\t} else {\n\t\t\tgrant_lock_pc(r, lkb, ms);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t}\n\t\tconfirm_master(r, result);\n\t\tbreak;\n\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* find_rsb failed to find rsb or rsb wasn't master */\n\t\tlog_limit(ls, \"receive_request_reply %x from %d %d \"\n\t\t\t  \"master %d dir %d first %x %s\", lkb->lkb_id,\n\t\t\t  from_nodeid, result, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid, r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_dir_nodeid != dlm_our_nodeid() &&\n\t\t    r->res_master_nodeid != dlm_our_nodeid()) {\n\t\t\t/* cause _request_lock->set_master->send_lookup */\n\t\t\tr->res_master_nodeid = 0;\n\t\t\tr->res_nodeid = -1;\n\t\t\tlkb->lkb_nodeid = -1;\n\t\t}\n\n\t\tif (is_overlap(lkb)) {\n\t\t\t/* we'll ignore error in cancel/unlock reply */\n\t\t\tqueue_cast_overlap(r, lkb);\n\t\t\tconfirm_master(r, result);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t} else {\n\t\t\t_request_lock(r, lkb);\n\n\t\t\tif (r->res_master_nodeid == dlm_our_nodeid())\n\t\t\t\tconfirm_master(r, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_request_reply %x error %d\",\n\t\t\t  lkb->lkb_id, result);\n\t}\n\n\tif (is_overlap_unlock(lkb) && (result == 0 || result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x result %d unlock\",\n\t\t\t  lkb->lkb_id, result);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_unlock(r, lkb);\n\t} else if (is_overlap_cancel(lkb) && (result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x cancel\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_cancel(r, lkb);\n\t} else {\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
  },
  {
    "function_name": "receive_purge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4471-4474",
    "snippet": "static void receive_purge(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tdo_purge(ls, ms->m_nodeid, ms->m_pid);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_purge",
          "args": [
            "ls",
            "ms->m_nodeid",
            "ms->m_pid"
          ],
          "line": 4473
        },
        "resolved": true,
        "details": {
          "function_name": "do_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6256-6269",
          "snippet": "static void do_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (pid && lkb->lkb_ownpid != pid)\n\t\t\tcontinue;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (pid && lkb->lkb_ownpid != pid)\n\t\t\tcontinue;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic void receive_purge(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tdo_purge(ls, ms->m_nodeid, ms->m_pid);\n}"
  },
  {
    "function_name": "receive_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4383-4469",
    "snippet": "static void receive_remove(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tchar name[DLM_RESNAME_MAXLEN+1];\n\tstruct dlm_rsb *r;\n\tuint32_t hash, b;\n\tint rv, len, dir_nodeid, from_nodeid;\n\n\tfrom_nodeid = ms->m_header.h_nodeid;\n\n\tlen = receive_extralen(ms);\n\n\tif (len > DLM_RESNAME_MAXLEN) {\n\t\tlog_error(ls, \"receive_remove from %d bad len %d\",\n\t\t\t  from_nodeid, len);\n\t\treturn;\n\t}\n\n\tdir_nodeid = dlm_hash2nodeid(ls, ms->m_hash);\n\tif (dir_nodeid != dlm_our_nodeid()) {\n\t\tlog_error(ls, \"receive_remove from %d bad nodeid %d\",\n\t\t\t  from_nodeid, dir_nodeid);\n\t\treturn;\n\t}\n\n\t/* Look for name on rsbtbl.toss, if it's there, kill it.\n\t   If it's on rsbtbl.keep, it's being used, and we should ignore this\n\t   message.  This is an expected race between the dir node sending a\n\t   request to the master node at the same time as the master node sends\n\t   a remove to the dir node.  The resolution to that race is for the\n\t   dir node to ignore the remove message, and the master node to\n\t   recreate the master rsb when it gets a request from the dir node for\n\t   an rsb it doesn't have. */\n\n\tmemset(name, 0, sizeof(name));\n\tmemcpy(name, ms->m_extra, len);\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (rv) {\n\t\t/* verify the rsb is on keep list per comment above */\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\t\tif (rv) {\n\t\t\t/* should not happen */\n\t\t\tlog_error(ls, \"receive_remove from %d not found %s\",\n\t\t\t\t  from_nodeid, name);\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\treturn;\n\t\t}\n\t\tif (r->res_master_nodeid != from_nodeid) {\n\t\t\t/* should not happen */\n\t\t\tlog_error(ls, \"receive_remove keep from %d master %d\",\n\t\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\t\tdlm_print_rsb(r);\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\treturn;\n\t\t}\n\n\t\tlog_debug(ls, \"receive_remove from %d master %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_first_lkid,\n\t\t\t  name);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tif (r->res_master_nodeid != from_nodeid) {\n\t\tlog_error(ls, \"receive_remove toss from %d master %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tif (kref_put(&r->res_ref, kill_rsb)) {\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tdlm_free_rsb(r);\n\t} else {\n\t\tlog_error(ls, \"receive_remove from %d rsb ref error\",\n\t\t\t  from_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[b].lock"
          ],
          "line": 4467
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_rsb",
          "args": [
            "r"
          ],
          "line": 4466
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "172-179",
          "snippet": "static void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_remove from %d rsb ref error\"",
            "from_nodeid"
          ],
          "line": 4464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_free_rsb",
          "args": [
            "r"
          ],
          "line": 4462
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "68-73",
          "snippet": "void dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rsb_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kmem_cache *rsb_cache;\n\nvoid dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&r->res_hashnode",
            "&ls->ls_rsbtbl[b].toss"
          ],
          "line": 4460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&r->res_ref",
            "kill_rsb"
          ],
          "line": 4459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_remove toss from %d master %d\"",
            "from_nodeid",
            "r->res_master_nodeid"
          ],
          "line": 4452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"receive_remove from %d master %d first %x %s\"",
            "from_nodeid",
            "r->res_master_nodeid",
            "r->res_first_lkid",
            "name"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_remove keep from %d master %d\"",
            "from_nodeid",
            "r->res_master_nodeid"
          ],
          "line": 4437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_remove from %d not found %s\"",
            "from_nodeid",
            "name"
          ],
          "line": 4430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_search_rsb_tree",
          "args": [
            "&ls->ls_rsbtbl[b].keep",
            "name",
            "len",
            "&r"
          ],
          "line": 4427
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_search_rsb_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "447-470",
          "snippet": "int dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[b].lock"
          ],
          "line": 4422
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "name",
            "len",
            "0"
          ],
          "line": 4419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name",
            "ms->m_extra",
            "len"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "name",
            "0",
            "sizeof(name)"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_remove from %d bad nodeid %d\"",
            "from_nodeid",
            "dir_nodeid"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 4401
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_hash2nodeid",
          "args": [
            "ls",
            "ms->m_hash"
          ],
          "line": 4400
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hash2nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "35-45",
          "snippet": "int dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_remove from %d bad len %d\"",
            "from_nodeid",
            "len"
          ],
          "line": 4395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_extralen",
          "args": [
            "ms"
          ],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "receive_extralen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3881-3884",
          "snippet": "static int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic void receive_remove(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tchar name[DLM_RESNAME_MAXLEN+1];\n\tstruct dlm_rsb *r;\n\tuint32_t hash, b;\n\tint rv, len, dir_nodeid, from_nodeid;\n\n\tfrom_nodeid = ms->m_header.h_nodeid;\n\n\tlen = receive_extralen(ms);\n\n\tif (len > DLM_RESNAME_MAXLEN) {\n\t\tlog_error(ls, \"receive_remove from %d bad len %d\",\n\t\t\t  from_nodeid, len);\n\t\treturn;\n\t}\n\n\tdir_nodeid = dlm_hash2nodeid(ls, ms->m_hash);\n\tif (dir_nodeid != dlm_our_nodeid()) {\n\t\tlog_error(ls, \"receive_remove from %d bad nodeid %d\",\n\t\t\t  from_nodeid, dir_nodeid);\n\t\treturn;\n\t}\n\n\t/* Look for name on rsbtbl.toss, if it's there, kill it.\n\t   If it's on rsbtbl.keep, it's being used, and we should ignore this\n\t   message.  This is an expected race between the dir node sending a\n\t   request to the master node at the same time as the master node sends\n\t   a remove to the dir node.  The resolution to that race is for the\n\t   dir node to ignore the remove message, and the master node to\n\t   recreate the master rsb when it gets a request from the dir node for\n\t   an rsb it doesn't have. */\n\n\tmemset(name, 0, sizeof(name));\n\tmemcpy(name, ms->m_extra, len);\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (rv) {\n\t\t/* verify the rsb is on keep list per comment above */\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\t\tif (rv) {\n\t\t\t/* should not happen */\n\t\t\tlog_error(ls, \"receive_remove from %d not found %s\",\n\t\t\t\t  from_nodeid, name);\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\treturn;\n\t\t}\n\t\tif (r->res_master_nodeid != from_nodeid) {\n\t\t\t/* should not happen */\n\t\t\tlog_error(ls, \"receive_remove keep from %d master %d\",\n\t\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\t\tdlm_print_rsb(r);\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\treturn;\n\t\t}\n\n\t\tlog_debug(ls, \"receive_remove from %d master %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_first_lkid,\n\t\t\t  name);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tif (r->res_master_nodeid != from_nodeid) {\n\t\tlog_error(ls, \"receive_remove toss from %d master %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tif (kref_put(&r->res_ref, kill_rsb)) {\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tdlm_free_rsb(r);\n\t} else {\n\t\tlog_error(ls, \"receive_remove from %d rsb ref error\",\n\t\t\t  from_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t}\n}"
  },
  {
    "function_name": "receive_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4363-4381",
    "snippet": "static void receive_lookup(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tint len, error, ret_nodeid, from_nodeid, our_nodeid;\n\n\tfrom_nodeid = ms->m_header.h_nodeid;\n\tour_nodeid = dlm_our_nodeid();\n\n\tlen = receive_extralen(ms);\n\n\terror = dlm_master_lookup(ls, from_nodeid, ms->m_extra, len, 0,\n\t\t\t\t  &ret_nodeid, NULL);\n\n\t/* Optimization: we're master so treat lookup as a request */\n\tif (!error && ret_nodeid == our_nodeid) {\n\t\treceive_request(ls, ms);\n\t\treturn;\n\t}\n\tsend_lookup_reply(ls, ms, ret_nodeid, error);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_lookup_reply",
          "args": [
            "ls",
            "ms",
            "ret_nodeid",
            "error"
          ],
          "line": 4380
        },
        "resolved": true,
        "details": {
          "function_name": "send_lookup_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3838-3857",
          "snippet": "static int send_lookup_reply(struct dlm_ls *ls, struct dlm_message *ms_in,\n\t\t\t     int ret_nodeid, int rv)\n{\n\tstruct dlm_rsb *r = &ls->ls_stub_rsb;\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint error, nodeid = ms_in->m_header.h_nodeid;\n\n\terror = create_message(r, NULL, nodeid, DLM_MSG_LOOKUP_REPLY, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tms->m_lkid = ms_in->m_lkid;\n\tms->m_result = rv;\n\tms->m_nodeid = ret_nodeid;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_lookup_reply(struct dlm_ls *ls, struct dlm_message *ms_in,\n\t\t\t     int ret_nodeid, int rv)\n{\n\tstruct dlm_rsb *r = &ls->ls_stub_rsb;\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint error, nodeid = ms_in->m_header.h_nodeid;\n\n\terror = create_message(r, NULL, nodeid, DLM_MSG_LOOKUP_REPLY, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tms->m_lkid = ms_in->m_lkid;\n\tms->m_result = rv;\n\tms->m_nodeid = ret_nodeid;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_request",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4377
        },
        "resolved": true,
        "details": {
          "function_name": "receive_request_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4476-4594",
          "snippet": "static int receive_request_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, mstype, result;\n\tint from_nodeid = ms->m_header.h_nodeid;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tmstype = lkb->lkb_wait_type;\n\terror = remove_from_waiters(lkb, DLM_MSG_REQUEST_REPLY);\n\tif (error) {\n\t\tlog_error(ls, \"receive_request_reply %x remote %d %x result %d\",\n\t\t\t  lkb->lkb_id, from_nodeid, ms->m_lkid, ms->m_result);\n\t\tdlm_dump_rsb(r);\n\t\tgoto out;\n\t}\n\n\t/* Optimization: the dir node was also the master, so it took our\n\t   lookup as a request and sent request reply instead of lookup reply */\n\tif (mstype == DLM_MSG_LOOKUP) {\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\tlkb->lkb_nodeid = from_nodeid;\n\t}\n\n\t/* this is the value returned from do_request() on the master */\n\tresult = ms->m_result;\n\n\tswitch (result) {\n\tcase -EAGAIN:\n\t\t/* request would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tconfirm_master(r, -EAGAIN);\n\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\tcase 0:\n\t\t/* request was queued or granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tlkb->lkb_remid = ms->m_lkid;\n\t\tif (is_altmode(lkb))\n\t\t\tmunge_altmode(lkb, ms);\n\t\tif (result) {\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\t\tadd_timeout(lkb);\n\t\t} else {\n\t\t\tgrant_lock_pc(r, lkb, ms);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t}\n\t\tconfirm_master(r, result);\n\t\tbreak;\n\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* find_rsb failed to find rsb or rsb wasn't master */\n\t\tlog_limit(ls, \"receive_request_reply %x from %d %d \"\n\t\t\t  \"master %d dir %d first %x %s\", lkb->lkb_id,\n\t\t\t  from_nodeid, result, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid, r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_dir_nodeid != dlm_our_nodeid() &&\n\t\t    r->res_master_nodeid != dlm_our_nodeid()) {\n\t\t\t/* cause _request_lock->set_master->send_lookup */\n\t\t\tr->res_master_nodeid = 0;\n\t\t\tr->res_nodeid = -1;\n\t\t\tlkb->lkb_nodeid = -1;\n\t\t}\n\n\t\tif (is_overlap(lkb)) {\n\t\t\t/* we'll ignore error in cancel/unlock reply */\n\t\t\tqueue_cast_overlap(r, lkb);\n\t\t\tconfirm_master(r, result);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t} else {\n\t\t\t_request_lock(r, lkb);\n\n\t\t\tif (r->res_master_nodeid == dlm_our_nodeid())\n\t\t\t\tconfirm_master(r, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_request_reply %x error %d\",\n\t\t\t  lkb->lkb_id, result);\n\t}\n\n\tif (is_overlap_unlock(lkb) && (result == 0 || result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x result %d unlock\",\n\t\t\t  lkb->lkb_id, result);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_unlock(r, lkb);\n\t} else if (is_overlap_cancel(lkb) && (result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x cancel\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_cancel(r, lkb);\n\t} else {\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_request_reply(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, mstype, result;\n\tint from_nodeid = ms->m_header.h_nodeid;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tmstype = lkb->lkb_wait_type;\n\terror = remove_from_waiters(lkb, DLM_MSG_REQUEST_REPLY);\n\tif (error) {\n\t\tlog_error(ls, \"receive_request_reply %x remote %d %x result %d\",\n\t\t\t  lkb->lkb_id, from_nodeid, ms->m_lkid, ms->m_result);\n\t\tdlm_dump_rsb(r);\n\t\tgoto out;\n\t}\n\n\t/* Optimization: the dir node was also the master, so it took our\n\t   lookup as a request and sent request reply instead of lookup reply */\n\tif (mstype == DLM_MSG_LOOKUP) {\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\tlkb->lkb_nodeid = from_nodeid;\n\t}\n\n\t/* this is the value returned from do_request() on the master */\n\tresult = ms->m_result;\n\n\tswitch (result) {\n\tcase -EAGAIN:\n\t\t/* request would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tconfirm_master(r, -EAGAIN);\n\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\tcase 0:\n\t\t/* request was queued or granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tlkb->lkb_remid = ms->m_lkid;\n\t\tif (is_altmode(lkb))\n\t\t\tmunge_altmode(lkb, ms);\n\t\tif (result) {\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\t\tadd_timeout(lkb);\n\t\t} else {\n\t\t\tgrant_lock_pc(r, lkb, ms);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t}\n\t\tconfirm_master(r, result);\n\t\tbreak;\n\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* find_rsb failed to find rsb or rsb wasn't master */\n\t\tlog_limit(ls, \"receive_request_reply %x from %d %d \"\n\t\t\t  \"master %d dir %d first %x %s\", lkb->lkb_id,\n\t\t\t  from_nodeid, result, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid, r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_dir_nodeid != dlm_our_nodeid() &&\n\t\t    r->res_master_nodeid != dlm_our_nodeid()) {\n\t\t\t/* cause _request_lock->set_master->send_lookup */\n\t\t\tr->res_master_nodeid = 0;\n\t\t\tr->res_nodeid = -1;\n\t\t\tlkb->lkb_nodeid = -1;\n\t\t}\n\n\t\tif (is_overlap(lkb)) {\n\t\t\t/* we'll ignore error in cancel/unlock reply */\n\t\t\tqueue_cast_overlap(r, lkb);\n\t\t\tconfirm_master(r, result);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t} else {\n\t\t\t_request_lock(r, lkb);\n\n\t\t\tif (r->res_master_nodeid == dlm_our_nodeid())\n\t\t\t\tconfirm_master(r, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_request_reply %x error %d\",\n\t\t\t  lkb->lkb_id, result);\n\t}\n\n\tif (is_overlap_unlock(lkb) && (result == 0 || result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x result %d unlock\",\n\t\t\t  lkb->lkb_id, result);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_unlock(r, lkb);\n\t} else if (is_overlap_cancel(lkb) && (result == -EINPROGRESS)) {\n\t\tlog_debug(ls, \"receive_request_reply %x cancel\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tsend_cancel(r, lkb);\n\t} else {\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_master_lookup",
          "args": [
            "ls",
            "from_nodeid",
            "ms->m_extra",
            "len",
            "0",
            "&ret_nodeid",
            "NULL"
          ],
          "line": 4372
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_master_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "912-1084",
          "snippet": "int dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, char *name, int len,\n\t\t      unsigned int flags, int *r_nodeid, int *result)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint from_master = (flags & DLM_LU_RECOVER_DIR);\n\tint fix_master = (flags & DLM_LU_RECOVER_MASTER);\n\tint our_nodeid = dlm_our_nodeid();\n\tint dir_nodeid, error, toss_list = 0;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tif (from_nodeid == our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from our_nodeid %d flags %x\",\n\t\t\t  our_nodeid, flags);\n\t\treturn -EINVAL;\n\t}\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\tif (dir_nodeid != our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from %d dir %d our %d h %x %d\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, hash,\n\t\t\t  ls->ls_num_nodes);\n\t\t*r_nodeid = -1;\n\t\treturn -EINVAL;\n\t}\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\treturn error;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error) {\n\t\t/* because the rsb is active, we need to lock_rsb before\n\t\t   checking/changing re_master_nodeid */\n\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlock_rsb(r);\n\t\tgoto found;\n\t}\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto not_found;\n\n\t/* because the rsb is inactive (on toss list), it's not refcounted\n\t   and lock_rsb is not used, but is protected by the rsbtbl lock */\n\n\ttoss_list = 1;\n found:\n\tif (r->res_dir_nodeid != our_nodeid) {\n\t\t/* should not happen, but may as well fix it and carry on */\n\t\tlog_error(ls, \"dlm_master_lookup res_dir %d our %d %s\",\n\t\t\t  r->res_dir_nodeid, our_nodeid, r->res_name);\n\t\tr->res_dir_nodeid = our_nodeid;\n\t}\n\n\tif (fix_master && dlm_is_removed(ls, r->res_master_nodeid)) {\n\t\t/* Recovery uses this function to set a new master when\n\t\t   the previous master failed.  Setting NEW_MASTER will\n\t\t   force dlm_recover_masters to call recover_master on this\n\t\t   rsb even though the res_nodeid is no longer removed. */\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\n\t\tif (toss_list) {\n\t\t\t/* I don't think we should ever find it on toss list. */\n\t\t\tlog_error(ls, \"dlm_master_lookup fix_master on toss\");\n\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t}\n\n\tif (from_master && (r->res_master_nodeid != from_nodeid)) {\n\t\t/* this will happen if from_nodeid became master during\n\t\t   a previous recovery cycle, and we aborted the previous\n\t\t   cycle before recovering this master value */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from_master %d \"\n\t\t\t  \"master_nodeid %d res_nodeid %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_nodeid,\n\t\t\t  r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_master_nodeid == our_nodeid) {\n\t\t\tlog_error(ls, \"from_master %d our_master\", from_nodeid);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tdlm_send_rcom_lookup_dump(r, from_nodeid);\n\t\t\tgoto out_found;\n\t\t}\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\t}\n\n\tif (!r->res_master_nodeid) {\n\t\t/* this will happen if recovery happens while we're looking\n\t\t   up the master for this rsb */\n\n\t\tlog_debug(ls, \"dlm_master_lookup master 0 to %d first %x %s\",\n\t\t\t  from_nodeid, r->res_first_lkid, r->res_name);\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t}\n\n\tif (!from_master && !fix_master &&\n\t    (r->res_master_nodeid == from_nodeid)) {\n\t\t/* this can happen when the master sends remove, the dir node\n\t\t   finds the rsb on the keep list and ignores the remove,\n\t\t   and the former master sends a lookup */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from master %d flags %x \"\n\t\t\t  \"first %x %s\", from_nodeid, flags,\n\t\t\t  r->res_first_lkid, r->res_name);\n\t}\n\n out_found:\n\t*r_nodeid = r->res_master_nodeid;\n\tif (result)\n\t\t*result = DLM_LU_MATCH;\n\n\tif (toss_list) {\n\t\tr->res_toss_time = jiffies;\n\t\t/* the rsb was inactive (on toss list) */\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t} else {\n\t\t/* the rsb was active */\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t}\n\treturn 0;\n\n not_found:\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = our_nodeid;\n\tr->res_master_nodeid = from_nodeid;\n\tr->res_nodeid = from_nodeid;\n\tkref_init(&r->res_ref);\n\tr->res_toss_time = jiffies;\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].toss);\n\tif (error) {\n\t\t/* should never happen */\n\t\tdlm_free_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\n\tif (result)\n\t\t*result = DLM_LU_ADD;\n\t*r_nodeid = from_nodeid;\n\terror = 0;\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, char *name, int len,\n\t\t      unsigned int flags, int *r_nodeid, int *result)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint from_master = (flags & DLM_LU_RECOVER_DIR);\n\tint fix_master = (flags & DLM_LU_RECOVER_MASTER);\n\tint our_nodeid = dlm_our_nodeid();\n\tint dir_nodeid, error, toss_list = 0;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tif (from_nodeid == our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from our_nodeid %d flags %x\",\n\t\t\t  our_nodeid, flags);\n\t\treturn -EINVAL;\n\t}\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\tif (dir_nodeid != our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from %d dir %d our %d h %x %d\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, hash,\n\t\t\t  ls->ls_num_nodes);\n\t\t*r_nodeid = -1;\n\t\treturn -EINVAL;\n\t}\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\treturn error;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error) {\n\t\t/* because the rsb is active, we need to lock_rsb before\n\t\t   checking/changing re_master_nodeid */\n\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlock_rsb(r);\n\t\tgoto found;\n\t}\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto not_found;\n\n\t/* because the rsb is inactive (on toss list), it's not refcounted\n\t   and lock_rsb is not used, but is protected by the rsbtbl lock */\n\n\ttoss_list = 1;\n found:\n\tif (r->res_dir_nodeid != our_nodeid) {\n\t\t/* should not happen, but may as well fix it and carry on */\n\t\tlog_error(ls, \"dlm_master_lookup res_dir %d our %d %s\",\n\t\t\t  r->res_dir_nodeid, our_nodeid, r->res_name);\n\t\tr->res_dir_nodeid = our_nodeid;\n\t}\n\n\tif (fix_master && dlm_is_removed(ls, r->res_master_nodeid)) {\n\t\t/* Recovery uses this function to set a new master when\n\t\t   the previous master failed.  Setting NEW_MASTER will\n\t\t   force dlm_recover_masters to call recover_master on this\n\t\t   rsb even though the res_nodeid is no longer removed. */\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\n\t\tif (toss_list) {\n\t\t\t/* I don't think we should ever find it on toss list. */\n\t\t\tlog_error(ls, \"dlm_master_lookup fix_master on toss\");\n\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t}\n\n\tif (from_master && (r->res_master_nodeid != from_nodeid)) {\n\t\t/* this will happen if from_nodeid became master during\n\t\t   a previous recovery cycle, and we aborted the previous\n\t\t   cycle before recovering this master value */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from_master %d \"\n\t\t\t  \"master_nodeid %d res_nodeid %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_nodeid,\n\t\t\t  r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_master_nodeid == our_nodeid) {\n\t\t\tlog_error(ls, \"from_master %d our_master\", from_nodeid);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tdlm_send_rcom_lookup_dump(r, from_nodeid);\n\t\t\tgoto out_found;\n\t\t}\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\t}\n\n\tif (!r->res_master_nodeid) {\n\t\t/* this will happen if recovery happens while we're looking\n\t\t   up the master for this rsb */\n\n\t\tlog_debug(ls, \"dlm_master_lookup master 0 to %d first %x %s\",\n\t\t\t  from_nodeid, r->res_first_lkid, r->res_name);\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t}\n\n\tif (!from_master && !fix_master &&\n\t    (r->res_master_nodeid == from_nodeid)) {\n\t\t/* this can happen when the master sends remove, the dir node\n\t\t   finds the rsb on the keep list and ignores the remove,\n\t\t   and the former master sends a lookup */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from master %d flags %x \"\n\t\t\t  \"first %x %s\", from_nodeid, flags,\n\t\t\t  r->res_first_lkid, r->res_name);\n\t}\n\n out_found:\n\t*r_nodeid = r->res_master_nodeid;\n\tif (result)\n\t\t*result = DLM_LU_MATCH;\n\n\tif (toss_list) {\n\t\tr->res_toss_time = jiffies;\n\t\t/* the rsb was inactive (on toss list) */\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t} else {\n\t\t/* the rsb was active */\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t}\n\treturn 0;\n\n not_found:\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = our_nodeid;\n\tr->res_master_nodeid = from_nodeid;\n\tr->res_nodeid = from_nodeid;\n\tkref_init(&r->res_ref);\n\tr->res_toss_time = jiffies;\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].toss);\n\tif (error) {\n\t\t/* should never happen */\n\t\tdlm_free_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\n\tif (result)\n\t\t*result = DLM_LU_ADD;\n\t*r_nodeid = from_nodeid;\n\terror = 0;\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_extralen",
          "args": [
            "ms"
          ],
          "line": 4370
        },
        "resolved": true,
        "details": {
          "function_name": "receive_extralen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3881-3884",
          "snippet": "static int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 4368
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic void receive_lookup(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tint len, error, ret_nodeid, from_nodeid, our_nodeid;\n\n\tfrom_nodeid = ms->m_header.h_nodeid;\n\tour_nodeid = dlm_our_nodeid();\n\n\tlen = receive_extralen(ms);\n\n\terror = dlm_master_lookup(ls, from_nodeid, ms->m_extra, len, 0,\n\t\t\t\t  &ret_nodeid, NULL);\n\n\t/* Optimization: we're master so treat lookup as a request */\n\tif (!error && ret_nodeid == our_nodeid) {\n\t\treceive_request(ls, ms);\n\t\treturn;\n\t}\n\tsend_lookup_reply(ls, ms, ret_nodeid, error);\n}"
  },
  {
    "function_name": "receive_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4335-4361",
    "snippet": "static int receive_bast(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tqueue_bast(r, lkb, ms->m_bastmode);\n\tlkb->lkb_highbast = ms->m_bastmode;\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4359
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4358
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4357
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_bast",
          "args": [
            "r",
            "lkb",
            "ms->m_bastmode"
          ],
          "line": 4354
        },
        "resolved": true,
        "details": {
          "function_name": "queue_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "320-327",
          "snippet": "static void queue_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rqmode)\n{\n\tif (is_master_copy(lkb)) {\n\t\tsend_bast(r, lkb, rqmode);\n\t} else {\n\t\tdlm_add_cb(lkb, DLM_CB_BAST, rqmode, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rqmode)\n{\n\tif (is_master_copy(lkb)) {\n\t\tsend_bast(r, lkb, rqmode);\n\t} else {\n\t\tdlm_add_cb(lkb, DLM_CB_BAST, rqmode, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_message",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4350
        },
        "resolved": true,
        "details": {
          "function_name": "validate_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3972-4011",
          "snippet": "static int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 4347
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "ms->m_remid",
            "&lkb"
          ],
          "line": 4341
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_bast(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tqueue_bast(r, lkb, ms->m_bastmode);\n\tlkb->lkb_highbast = ms->m_bastmode;\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
  },
  {
    "function_name": "receive_grant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4304-4333",
    "snippet": "static int receive_grant(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags_reply(lkb, ms);\n\tif (is_altmode(lkb))\n\t\tmunge_altmode(lkb, ms);\n\tgrant_lock_pc(r, lkb, ms);\n\tqueue_cast(r, lkb, 0);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4331
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4330
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4329
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "0"
          ],
          "line": 4327
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_lock_pc",
          "args": [
            "r",
            "lkb",
            "ms"
          ],
          "line": 4326
        },
        "resolved": true,
        "details": {
          "function_name": "grant_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2135-2140",
          "snippet": "static void grant_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  struct dlm_message *ms)\n{\n\tset_lvb_lock_pc(r, lkb, ms);\n\t_grant_lock(r, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  struct dlm_message *ms)\n{\n\tset_lvb_lock_pc(r, lkb, ms);\n\t_grant_lock(r, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "munge_altmode",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4325
        },
        "resolved": true,
        "details": {
          "function_name": "munge_altmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2174-2191",
          "snippet": "static void munge_altmode(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_type != DLM_MSG_REQUEST_REPLY &&\n\t    ms->m_type != DLM_MSG_GRANT) {\n\t\tlog_print(\"munge_altmode %x invalid reply type %d\",\n\t\t\t  lkb->lkb_id, ms->m_type);\n\t\treturn;\n\t}\n\n\tif (lkb->lkb_exflags & DLM_LKF_ALTPR)\n\t\tlkb->lkb_rqmode = DLM_LOCK_PR;\n\telse if (lkb->lkb_exflags & DLM_LKF_ALTCW)\n\t\tlkb->lkb_rqmode = DLM_LOCK_CW;\n\telse {\n\t\tlog_print(\"munge_altmode invalid exflags %x\", lkb->lkb_exflags);\n\t\tdlm_print_lkb(lkb);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void munge_altmode(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_type != DLM_MSG_REQUEST_REPLY &&\n\t    ms->m_type != DLM_MSG_GRANT) {\n\t\tlog_print(\"munge_altmode %x invalid reply type %d\",\n\t\t\t  lkb->lkb_id, ms->m_type);\n\t\treturn;\n\t}\n\n\tif (lkb->lkb_exflags & DLM_LKF_ALTPR)\n\t\tlkb->lkb_rqmode = DLM_LOCK_PR;\n\telse if (lkb->lkb_exflags & DLM_LKF_ALTCW)\n\t\tlkb->lkb_rqmode = DLM_LOCK_CW;\n\telse {\n\t\tlog_print(\"munge_altmode invalid exflags %x\", lkb->lkb_exflags);\n\t\tdlm_print_lkb(lkb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_altmode",
          "args": [
            "lkb"
          ],
          "line": 4324
        },
        "resolved": true,
        "details": {
          "function_name": "is_altmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "235-238",
          "snippet": "static inline int is_altmode(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_ALTMODE);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_altmode(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_ALTMODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_flags_reply",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4323
        },
        "resolved": true,
        "details": {
          "function_name": "receive_flags_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3871-3879",
          "snippet": "static void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_message",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "validate_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3972-4011",
          "snippet": "static int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 4316
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "ms->m_remid",
            "&lkb"
          ],
          "line": 4310
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_grant(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags_reply(lkb, ms);\n\tif (is_altmode(lkb))\n\t\tmunge_altmode(lkb, ms);\n\tgrant_lock_pc(r, lkb, ms);\n\tqueue_cast(r, lkb, 0);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
  },
  {
    "function_name": "receive_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4268-4302",
    "snippet": "static int receive_cancel(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\treceive_flags(lkb, ms);\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_cancel(r, lkb);\n\tsend_cancel_reply(r, lkb, error);\n\tdo_cancel_effects(r, lkb, error);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\tsetup_stub_lkb(ls, ms);\n\tsend_cancel_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_cancel_reply",
          "args": [
            "&ls->ls_stub_rsb",
            "&ls->ls_stub_lkb",
            "error"
          ],
          "line": 4300
        },
        "resolved": true,
        "details": {
          "function_name": "send_cancel_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3833-3836",
          "snippet": "static int send_cancel_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_CANCEL_REPLY, rv);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_cancel_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_CANCEL_REPLY, rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_stub_lkb",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4299
        },
        "resolved": true,
        "details": {
          "function_name": "setup_stub_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3962-3967",
          "snippet": "static void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_remid = ms->m_lkid;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_remid = ms->m_lkid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4295
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4293
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cancel_effects",
          "args": [
            "r",
            "lkb",
            "error"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "do_cancel_effects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3210-3215",
          "snippet": "static void do_cancel_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tif (error)\n\t\tgrant_pending_locks(r, NULL);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_cancel_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tif (error)\n\t\tgrant_pending_locks(r, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cancel",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4289
        },
        "resolved": true,
        "details": {
          "function_name": "do_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3198-3208",
          "snippet": "static int do_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = revert_lock(r, lkb);\n\tif (error) {\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\treturn -DLM_ECANCEL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = revert_lock(r, lkb);\n\tif (error) {\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\treturn -DLM_ECANCEL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_message",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4285
        },
        "resolved": true,
        "details": {
          "function_name": "validate_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3972-4011",
          "snippet": "static int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 4282
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_flags",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4278
        },
        "resolved": true,
        "details": {
          "function_name": "receive_flags_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3871-3879",
          "snippet": "static void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "ms->m_remid",
            "&lkb"
          ],
          "line": 4274
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_cancel(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\treceive_flags(lkb, ms);\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_cancel(r, lkb);\n\tsend_cancel_reply(r, lkb, error);\n\tdo_cancel_effects(r, lkb, error);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\tsetup_stub_lkb(ls, ms);\n\tsend_cancel_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\n\treturn error;\n}"
  },
  {
    "function_name": "receive_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4218-4266",
    "snippet": "static int receive_unlock(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\tif (lkb->lkb_remid != ms->m_lkid) {\n\t\tlog_error(ls, \"receive_unlock %x remid %x remote %d %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  ms->m_header.h_nodeid, ms->m_lkid);\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags(lkb, ms);\n\n\terror = receive_unlock_args(ls, lkb, ms);\n\tif (error) {\n\t\tsend_unlock_reply(r, lkb, error);\n\t\tgoto out;\n\t}\n\n\terror = do_unlock(r, lkb);\n\tsend_unlock_reply(r, lkb, error);\n\tdo_unlock_effects(r, lkb, error);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\tsetup_stub_lkb(ls, ms);\n\tsend_unlock_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_unlock_reply",
          "args": [
            "&ls->ls_stub_rsb",
            "&ls->ls_stub_lkb",
            "error"
          ],
          "line": 4264
        },
        "resolved": true,
        "details": {
          "function_name": "send_unlock_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3828-3831",
          "snippet": "static int send_unlock_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_UNLOCK_REPLY, rv);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_unlock_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_UNLOCK_REPLY, rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_stub_lkb",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4263
        },
        "resolved": true,
        "details": {
          "function_name": "setup_stub_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3962-3967",
          "snippet": "static void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_remid = ms->m_lkid;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_remid = ms->m_lkid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4259
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4258
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4257
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_unlock_effects",
          "args": [
            "r",
            "lkb",
            "error"
          ],
          "line": 4255
        },
        "resolved": true,
        "details": {
          "function_name": "do_unlock_effects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3190-3194",
          "snippet": "static void do_unlock_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tgrant_pending_locks(r, NULL);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_unlock_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tgrant_pending_locks(r, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_unlock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4253
        },
        "resolved": true,
        "details": {
          "function_name": "do_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3183-3188",
          "snippet": "static int do_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tremove_lock(r, lkb);\n\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\treturn -DLM_EUNLOCK;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tremove_lock(r, lkb);\n\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\treturn -DLM_EUNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_unlock_args",
          "args": [
            "ls",
            "lkb",
            "ms"
          ],
          "line": 4247
        },
        "resolved": true,
        "details": {
          "function_name": "receive_unlock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3951-3957",
          "snippet": "static int receive_unlock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_message *ms)\n{\n\tif (receive_lvb(ls, lkb, ms))\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_unlock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_message *ms)\n{\n\tif (receive_lvb(ls, lkb, ms))\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_flags",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4245
        },
        "resolved": true,
        "details": {
          "function_name": "receive_flags_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3871-3879",
          "snippet": "static void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_message",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4241
        },
        "resolved": true,
        "details": {
          "function_name": "validate_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3972-4011",
          "snippet": "static int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 4238
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_unlock %x remid %x remote %d %x\"",
            "lkb->lkb_id",
            "lkb->lkb_remid",
            "ms->m_header.h_nodeid",
            "ms->m_lkid"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "ms->m_remid",
            "&lkb"
          ],
          "line": 4224
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_unlock(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\tif (lkb->lkb_remid != ms->m_lkid) {\n\t\tlog_error(ls, \"receive_unlock %x remid %x remote %d %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  ms->m_header.h_nodeid, ms->m_lkid);\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags(lkb, ms);\n\n\terror = receive_unlock_args(ls, lkb, ms);\n\tif (error) {\n\t\tsend_unlock_reply(r, lkb, error);\n\t\tgoto out;\n\t}\n\n\terror = do_unlock(r, lkb);\n\tsend_unlock_reply(r, lkb, error);\n\tdo_unlock_effects(r, lkb, error);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\tsetup_stub_lkb(ls, ms);\n\tsend_unlock_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\n\treturn error;\n}"
  },
  {
    "function_name": "receive_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4164-4216",
    "snippet": "static int receive_convert(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, reply = 1;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\tif (lkb->lkb_remid != ms->m_lkid) {\n\t\tlog_error(ls, \"receive_convert %x remid %x recover_seq %llu \"\n\t\t\t  \"remote %d %x\", lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  (unsigned long long)lkb->lkb_recover_seq,\n\t\t\t  ms->m_header.h_nodeid, ms->m_lkid);\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags(lkb, ms);\n\n\terror = receive_convert_args(ls, lkb, ms);\n\tif (error) {\n\t\tsend_convert_reply(r, lkb, error);\n\t\tgoto out;\n\t}\n\n\treply = !down_conversion(lkb);\n\n\terror = do_convert(r, lkb);\n\tif (reply)\n\t\tsend_convert_reply(r, lkb, error);\n\tdo_convert_effects(r, lkb, error);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\tsetup_stub_lkb(ls, ms);\n\tsend_convert_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_convert_reply",
          "args": [
            "&ls->ls_stub_rsb",
            "&ls->ls_stub_lkb",
            "error"
          ],
          "line": 4214
        },
        "resolved": true,
        "details": {
          "function_name": "send_convert_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3823-3826",
          "snippet": "static int send_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_CONVERT_REPLY, rv);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_CONVERT_REPLY, rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_stub_lkb",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4213
        },
        "resolved": true,
        "details": {
          "function_name": "setup_stub_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3962-3967",
          "snippet": "static void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_remid = ms->m_lkid;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_remid = ms->m_lkid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4209
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4208
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4207
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert_effects",
          "args": [
            "r",
            "lkb",
            "error"
          ],
          "line": 4205
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_effects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3165-3181",
          "snippet": "static void do_convert_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase 0:\n\t\tgrant_pending_locks(r, NULL);\n\t\t/* grant_pending_locks also sends basts */\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_convert_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase 0:\n\t\tgrant_pending_locks(r, NULL);\n\t\t/* grant_pending_locks also sends basts */\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4202
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3110-3163",
          "snippet": "static int do_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\tint deadlk = 0;\n\n\t/* changing an existing lock may allow others to be granted */\n\n\tif (can_be_granted(r, lkb, 1, 0, &deadlk)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\t/* can_be_granted() detected that this lock would block in a conversion\n\t   deadlock, so we leave it on the granted queue and return EDEADLK in\n\t   the ast for the convert. */\n\n\tif (deadlk) {\n\t\t/* it's left on the granted queue */\n\t\trevert_lock(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\terror = -EDEADLK;\n\t\tgoto out;\n\t}\n\n\t/* is_demoted() means the can_be_granted() above set the grmode\n\t   to NL, and left us on the granted queue.  This auto-demotion\n\t   (due to CONVDEADLK) might mean other locks, and/or this lock, are\n\t   now grantable.  We have to try to grant other converting locks\n\t   before we try again to grant this one. */\n\n\tif (is_demoted(lkb)) {\n\t\tgrant_pending_convert(r, DLM_LOCK_IV, NULL, NULL);\n\t\tif (_can_be_granted(r, lkb, 1, 0)) {\n\t\t\tgrant_lock(r, lkb);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t\tgoto out;\n\t\t}\n\t\t/* else fall through and move to convert queue */\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\tint deadlk = 0;\n\n\t/* changing an existing lock may allow others to be granted */\n\n\tif (can_be_granted(r, lkb, 1, 0, &deadlk)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\t/* can_be_granted() detected that this lock would block in a conversion\n\t   deadlock, so we leave it on the granted queue and return EDEADLK in\n\t   the ast for the convert. */\n\n\tif (deadlk) {\n\t\t/* it's left on the granted queue */\n\t\trevert_lock(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\terror = -EDEADLK;\n\t\tgoto out;\n\t}\n\n\t/* is_demoted() means the can_be_granted() above set the grmode\n\t   to NL, and left us on the granted queue.  This auto-demotion\n\t   (due to CONVDEADLK) might mean other locks, and/or this lock, are\n\t   now grantable.  We have to try to grant other converting locks\n\t   before we try again to grant this one. */\n\n\tif (is_demoted(lkb)) {\n\t\tgrant_pending_convert(r, DLM_LOCK_IV, NULL, NULL);\n\t\tif (_can_be_granted(r, lkb, 1, 0)) {\n\t\t\tgrant_lock(r, lkb);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t\tgoto out;\n\t\t}\n\t\t/* else fall through and move to convert queue */\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_conversion",
          "args": [
            "lkb"
          ],
          "line": 4200
        },
        "resolved": true,
        "details": {
          "function_name": "down_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "269-272",
          "snippet": "static inline int down_conversion(struct dlm_lkb *lkb)\n{\n\treturn (!middle_conversion(lkb) && lkb->lkb_rqmode < lkb->lkb_grmode);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int down_conversion(struct dlm_lkb *lkb)\n{\n\treturn (!middle_conversion(lkb) && lkb->lkb_rqmode < lkb->lkb_grmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_convert_args",
          "args": [
            "ls",
            "lkb",
            "ms"
          ],
          "line": 4194
        },
        "resolved": true,
        "details": {
          "function_name": "receive_convert_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3936-3949",
          "snippet": "static int receive_convert_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\treturn -EBUSY;\n\n\tif (receive_lvb(ls, lkb, ms))\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_rqmode = ms->m_rqmode;\n\tlkb->lkb_lvbseq = ms->m_lvbseq;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_convert_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\treturn -EBUSY;\n\n\tif (receive_lvb(ls, lkb, ms))\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_rqmode = ms->m_rqmode;\n\tlkb->lkb_lvbseq = ms->m_lvbseq;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_flags",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4192
        },
        "resolved": true,
        "details": {
          "function_name": "receive_flags_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3871-3879",
          "snippet": "static void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_message",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4188
        },
        "resolved": true,
        "details": {
          "function_name": "validate_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3972-4011",
          "snippet": "static int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 4185
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_convert %x remid %x recover_seq %llu \"\n\t\t\t  \"remote %d %x\"",
            "lkb->lkb_id",
            "lkb->lkb_remid",
            "(unsigned long long)lkb->lkb_recover_seq",
            "ms->m_header.h_nodeid",
            "ms->m_lkid"
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "ms->m_remid",
            "&lkb"
          ],
          "line": 4170
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_convert(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, reply = 1;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\tif (lkb->lkb_remid != ms->m_lkid) {\n\t\tlog_error(ls, \"receive_convert %x remid %x recover_seq %llu \"\n\t\t\t  \"remote %d %x\", lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  (unsigned long long)lkb->lkb_recover_seq,\n\t\t\t  ms->m_header.h_nodeid, ms->m_lkid);\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags(lkb, ms);\n\n\terror = receive_convert_args(ls, lkb, ms);\n\tif (error) {\n\t\tsend_convert_reply(r, lkb, error);\n\t\tgoto out;\n\t}\n\n\treply = !down_conversion(lkb);\n\n\terror = do_convert(r, lkb);\n\tif (reply)\n\t\tsend_convert_reply(r, lkb, error);\n\tdo_convert_effects(r, lkb, error);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\tsetup_stub_lkb(ls, ms);\n\tsend_convert_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\n\treturn error;\n}"
  },
  {
    "function_name": "receive_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4071-4162",
    "snippet": "static int receive_request(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint from_nodeid;\n\tint error, namelen = 0;\n\n\tfrom_nodeid = ms->m_header.h_nodeid;\n\n\terror = create_lkb(ls, &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\treceive_flags(lkb, ms);\n\tlkb->lkb_flags |= DLM_IFL_MSTCPY;\n\terror = receive_request_args(ls, lkb, ms);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto fail;\n\t}\n\n\t/* The dir node is the authority on whether we are the master\n\t   for this rsb or not, so if the master sends us a request, we should\n\t   recreate the rsb if we've destroyed it.   This race happens when we\n\t   send a remove message to the dir node at the same time that the dir\n\t   node sends us a request for the rsb. */\n\n\tnamelen = receive_extralen(ms);\n\n\terror = find_rsb(ls, ms->m_extra, namelen, from_nodeid,\n\t\t\t R_RECEIVE_REQUEST, &r);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto fail;\n\t}\n\n\tlock_rsb(r);\n\n\tif (r->res_master_nodeid != dlm_our_nodeid()) {\n\t\terror = validate_master_nodeid(ls, r, from_nodeid);\n\t\tif (error) {\n\t\t\tunlock_rsb(r);\n\t\t\tput_rsb(r);\n\t\t\t__put_lkb(ls, lkb);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tattach_lkb(r, lkb);\n\terror = do_request(r, lkb);\n\tsend_request_reply(r, lkb, error);\n\tdo_request_effects(r, lkb, error);\n\n\tunlock_rsb(r);\n\tput_rsb(r);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n\tif (error)\n\t\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\t/* TODO: instead of returning ENOTBLK, add the lkb to res_lookup\n\t   and do this receive_request again from process_lookup_list once\n\t   we get the lookup reply.  This would avoid a many repeated\n\t   ENOTBLK request failures when the lookup reply designating us\n\t   as master is delayed. */\n\n\t/* We could repeatedly return -EBADR here if our send_remove() is\n\t   delayed in being sent/arriving/being processed on the dir node.\n\t   Another node would repeatedly lookup up the master, and the dir\n\t   node would continue returning our nodeid until our send_remove\n\t   took effect.\n\n\t   We send another remove message in case our previous send_remove\n\t   was lost/ignored/missed somehow. */\n\n\tif (error != -ENOTBLK) {\n\t\tlog_limit(ls, \"receive_request %x from %d %d\",\n\t\t\t  ms->m_lkid, from_nodeid, error);\n\t}\n\n\tif (namelen && error == -EBADR) {\n\t\tsend_repeat_remove(ls, ms->m_extra, namelen);\n\t\tmsleep(1000);\n\t}\n\n\tsetup_stub_lkb(ls, ms);\n\tsend_request_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_request_reply",
          "args": [
            "&ls->ls_stub_rsb",
            "&ls->ls_stub_lkb",
            "error"
          ],
          "line": 4160
        },
        "resolved": true,
        "details": {
          "function_name": "send_request_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3818-3821",
          "snippet": "static int send_request_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_REQUEST_REPLY, rv);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_request_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_REQUEST_REPLY, rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_stub_lkb",
          "args": [
            "ls",
            "ms"
          ],
          "line": 4159
        },
        "resolved": true,
        "details": {
          "function_name": "setup_stub_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3962-3967",
          "snippet": "static void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_remid = ms->m_lkid;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_remid = ms->m_lkid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1000"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_repeat_remove",
          "args": [
            "ls",
            "ms->m_extra",
            "namelen"
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "send_repeat_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4013-4069",
          "snippet": "static void send_repeat_remove(struct dlm_ls *ls, char *ms_name, int len)\n{\n\tchar name[DLM_RESNAME_MAXLEN + 1];\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_rsb *r;\n\tuint32_t hash, b;\n\tint rv, dir_nodeid;\n\n\tmemset(name, 0, sizeof(name));\n\tmemcpy(name, ms_name, len);\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tlog_error(ls, \"send_repeat_remove dir %d %s\", dir_nodeid, name);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!rv) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlog_error(ls, \"repeat_remove on keep %s\", name);\n\t\treturn;\n\t}\n\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (!rv) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlog_error(ls, \"repeat_remove on toss %s\", name);\n\t\treturn;\n\t}\n\n\t/* use ls->remove_name2 to avoid conflict with shrink? */\n\n\tspin_lock(&ls->ls_remove_spin);\n\tls->ls_remove_len = len;\n\tmemcpy(ls->ls_remove_name, name, DLM_RESNAME_MAXLEN);\n\tspin_unlock(&ls->ls_remove_spin);\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\trv = _create_message(ls, sizeof(struct dlm_message) + len,\n\t\t\t     dir_nodeid, DLM_MSG_REMOVE, &ms, &mh);\n\tif (rv)\n\t\treturn;\n\n\tmemcpy(ms->m_extra, name, len);\n\tms->m_hash = hash;\n\n\tsend_message(mh, ms);\n\n\tspin_lock(&ls->ls_remove_spin);\n\tls->ls_remove_len = 0;\n\tmemset(ls->ls_remove_name, 0, DLM_RESNAME_MAXLEN);\n\tspin_unlock(&ls->ls_remove_spin);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic void send_repeat_remove(struct dlm_ls *ls, char *ms_name, int len)\n{\n\tchar name[DLM_RESNAME_MAXLEN + 1];\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_rsb *r;\n\tuint32_t hash, b;\n\tint rv, dir_nodeid;\n\n\tmemset(name, 0, sizeof(name));\n\tmemcpy(name, ms_name, len);\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tlog_error(ls, \"send_repeat_remove dir %d %s\", dir_nodeid, name);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!rv) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlog_error(ls, \"repeat_remove on keep %s\", name);\n\t\treturn;\n\t}\n\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (!rv) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlog_error(ls, \"repeat_remove on toss %s\", name);\n\t\treturn;\n\t}\n\n\t/* use ls->remove_name2 to avoid conflict with shrink? */\n\n\tspin_lock(&ls->ls_remove_spin);\n\tls->ls_remove_len = len;\n\tmemcpy(ls->ls_remove_name, name, DLM_RESNAME_MAXLEN);\n\tspin_unlock(&ls->ls_remove_spin);\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\trv = _create_message(ls, sizeof(struct dlm_message) + len,\n\t\t\t     dir_nodeid, DLM_MSG_REMOVE, &ms, &mh);\n\tif (rv)\n\t\treturn;\n\n\tmemcpy(ms->m_extra, name, len);\n\tms->m_hash = hash;\n\n\tsend_message(mh, ms);\n\n\tspin_lock(&ls->ls_remove_spin);\n\tls->ls_remove_len = 0;\n\tmemset(ls->ls_remove_name, 0, DLM_RESNAME_MAXLEN);\n\tspin_unlock(&ls->ls_remove_spin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_limit",
          "args": [
            "ls",
            "\"receive_request %x from %d %d\"",
            "ms->m_lkid",
            "from_nodeid",
            "error"
          ],
          "line": 4150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 4130
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 4125
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 4124
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_request_effects",
          "args": [
            "r",
            "lkb",
            "error"
          ],
          "line": 4122
        },
        "resolved": true,
        "details": {
          "function_name": "do_request_effects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3096-3108",
          "snippet": "static void do_request_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_request_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_request",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4120
        },
        "resolved": true,
        "details": {
          "function_name": "do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3073-3094",
          "snippet": "static int do_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\n\tif (can_be_granted(r, lkb, 1, 0, NULL)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\n\tif (can_be_granted(r, lkb, 1, 0, NULL)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_lkb",
          "args": [
            "r",
            "lkb"
          ],
          "line": 4119
        },
        "resolved": true,
        "details": {
          "function_name": "attach_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1170-1174",
          "snippet": "static void attach_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\thold_rsb(r);\n\tlkb->lkb_resource = r;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void attach_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\thold_rsb(r);\n\tlkb->lkb_resource = r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_lkb",
          "args": [
            "ls",
            "lkb"
          ],
          "line": 4114
        },
        "resolved": true,
        "details": {
          "function_name": "__put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1247-1267",
          "snippet": "static int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_master_nodeid",
          "args": [
            "ls",
            "r",
            "from_nodeid"
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "validate_master_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "843-881",
          "snippet": "static int validate_master_nodeid(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t\t  int from_nodeid)\n{\n\tif (dlm_no_directory(ls)) {\n\t\tlog_error(ls, \"find_rsb keep from_nodeid %d master %d dir %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\treturn -ENOTBLK;\n\t}\n\n\tif (from_nodeid != r->res_dir_nodeid) {\n\t\t/* our rsb is not master, and another node (not the dir node)\n\t   \t   has sent us a request.  this is much more common when our\n\t   \t   master_nodeid is zero, so limit debug to non-zero.  */\n\n\t\tif (r->res_master_nodeid) {\n\t\t\tlog_debug(ls, \"validate master from_other %d master %d \"\n\t\t\t\t  \"dir %d first %x %s\", from_nodeid,\n\t\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t\t  r->res_first_lkid, r->res_name);\n\t\t}\n\t\treturn -ENOTBLK;\n\t} else {\n\t\t/* our rsb is not master, but the dir nodeid has sent us a\n\t   \t   request; this could happen with master 0 / res_nodeid -1 */\n\n\t\tif (r->res_master_nodeid) {\n\t\t\tlog_error(ls, \"validate master from_dir %d master %d \"\n\t\t\t\t  \"first %x %s\",\n\t\t\t\t  from_nodeid, r->res_master_nodeid,\n\t\t\t\t  r->res_first_lkid, r->res_name);\n\t\t}\n\n\t\tr->res_master_nodeid = dlm_our_nodeid();\n\t\tr->res_nodeid = 0;\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int validate_master_nodeid(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t\t  int from_nodeid)\n{\n\tif (dlm_no_directory(ls)) {\n\t\tlog_error(ls, \"find_rsb keep from_nodeid %d master %d dir %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\treturn -ENOTBLK;\n\t}\n\n\tif (from_nodeid != r->res_dir_nodeid) {\n\t\t/* our rsb is not master, and another node (not the dir node)\n\t   \t   has sent us a request.  this is much more common when our\n\t   \t   master_nodeid is zero, so limit debug to non-zero.  */\n\n\t\tif (r->res_master_nodeid) {\n\t\t\tlog_debug(ls, \"validate master from_other %d master %d \"\n\t\t\t\t  \"dir %d first %x %s\", from_nodeid,\n\t\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t\t  r->res_first_lkid, r->res_name);\n\t\t}\n\t\treturn -ENOTBLK;\n\t} else {\n\t\t/* our rsb is not master, but the dir nodeid has sent us a\n\t   \t   request; this could happen with master 0 / res_nodeid -1 */\n\n\t\tif (r->res_master_nodeid) {\n\t\t\tlog_error(ls, \"validate master from_dir %d master %d \"\n\t\t\t\t  \"first %x %s\",\n\t\t\t\t  from_nodeid, r->res_master_nodeid,\n\t\t\t\t  r->res_first_lkid, r->res_name);\n\t\t}\n\n\t\tr->res_master_nodeid = dlm_our_nodeid();\n\t\tr->res_nodeid = 0;\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 4109
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_rsb",
          "args": [
            "ls",
            "ms->m_extra",
            "namelen",
            "from_nodeid",
            "R_RECEIVE_REQUEST",
            "&r"
          ],
          "line": 4100
        },
        "resolved": true,
        "details": {
          "function_name": "find_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "818-838",
          "snippet": "static int find_rsb(struct dlm_ls *ls, char *name, int len, int from_nodeid,\n\t\t    unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tuint32_t hash, b;\n\tint dir_nodeid;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tif (dlm_no_directory(ls))\n\t\treturn find_rsb_nodir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n\telse\n\t\treturn find_rsb_dir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int find_rsb(struct dlm_ls *ls, char *name, int len, int from_nodeid,\n\t\t    unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tuint32_t hash, b;\n\tint dir_nodeid;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tif (dlm_no_directory(ls))\n\t\treturn find_rsb_nodir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n\telse\n\t\treturn find_rsb_dir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_extralen",
          "args": [
            "ms"
          ],
          "line": 4098
        },
        "resolved": true,
        "details": {
          "function_name": "receive_extralen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3881-3884",
          "snippet": "static int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_request_args",
          "args": [
            "ls",
            "lkb",
            "ms"
          ],
          "line": 4086
        },
        "resolved": true,
        "details": {
          "function_name": "receive_request_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3914-3934",
          "snippet": "static int receive_request_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_ownpid = ms->m_pid;\n\tlkb->lkb_remid = ms->m_lkid;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tlkb->lkb_rqmode = ms->m_rqmode;\n\n\tlkb->lkb_bastfn = (ms->m_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\n\tlkb->lkb_astfn = (ms->m_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\t/* lkb was just created so there won't be an lvb yet */\n\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_request_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_ownpid = ms->m_pid;\n\tlkb->lkb_remid = ms->m_lkid;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tlkb->lkb_rqmode = ms->m_rqmode;\n\n\tlkb->lkb_bastfn = (ms->m_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\n\tlkb->lkb_astfn = (ms->m_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\t/* lkb was just created so there won't be an lvb yet */\n\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_flags",
          "args": [
            "lkb",
            "ms"
          ],
          "line": 4084
        },
        "resolved": true,
        "details": {
          "function_name": "receive_flags_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3871-3879",
          "snippet": "static void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_lkb",
          "args": [
            "ls",
            "&lkb"
          ],
          "line": 4080
        },
        "resolved": true,
        "details": {
          "function_name": "create_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1184-1218",
          "snippet": "static int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_time_list);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tmutex_init(&lkb->lkb_cb_mutex);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, 1, 0, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_time_list);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tmutex_init(&lkb->lkb_cb_mutex);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, 1, 0, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_request(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint from_nodeid;\n\tint error, namelen = 0;\n\n\tfrom_nodeid = ms->m_header.h_nodeid;\n\n\terror = create_lkb(ls, &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\treceive_flags(lkb, ms);\n\tlkb->lkb_flags |= DLM_IFL_MSTCPY;\n\terror = receive_request_args(ls, lkb, ms);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto fail;\n\t}\n\n\t/* The dir node is the authority on whether we are the master\n\t   for this rsb or not, so if the master sends us a request, we should\n\t   recreate the rsb if we've destroyed it.   This race happens when we\n\t   send a remove message to the dir node at the same time that the dir\n\t   node sends us a request for the rsb. */\n\n\tnamelen = receive_extralen(ms);\n\n\terror = find_rsb(ls, ms->m_extra, namelen, from_nodeid,\n\t\t\t R_RECEIVE_REQUEST, &r);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto fail;\n\t}\n\n\tlock_rsb(r);\n\n\tif (r->res_master_nodeid != dlm_our_nodeid()) {\n\t\terror = validate_master_nodeid(ls, r, from_nodeid);\n\t\tif (error) {\n\t\t\tunlock_rsb(r);\n\t\t\tput_rsb(r);\n\t\t\t__put_lkb(ls, lkb);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tattach_lkb(r, lkb);\n\terror = do_request(r, lkb);\n\tsend_request_reply(r, lkb, error);\n\tdo_request_effects(r, lkb, error);\n\n\tunlock_rsb(r);\n\tput_rsb(r);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n\tif (error)\n\t\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\t/* TODO: instead of returning ENOTBLK, add the lkb to res_lookup\n\t   and do this receive_request again from process_lookup_list once\n\t   we get the lookup reply.  This would avoid a many repeated\n\t   ENOTBLK request failures when the lookup reply designating us\n\t   as master is delayed. */\n\n\t/* We could repeatedly return -EBADR here if our send_remove() is\n\t   delayed in being sent/arriving/being processed on the dir node.\n\t   Another node would repeatedly lookup up the master, and the dir\n\t   node would continue returning our nodeid until our send_remove\n\t   took effect.\n\n\t   We send another remove message in case our previous send_remove\n\t   was lost/ignored/missed somehow. */\n\n\tif (error != -ENOTBLK) {\n\t\tlog_limit(ls, \"receive_request %x from %d %d\",\n\t\t\t  ms->m_lkid, from_nodeid, error);\n\t}\n\n\tif (namelen && error == -EBADR) {\n\t\tsend_repeat_remove(ls, ms->m_extra, namelen);\n\t\tmsleep(1000);\n\t}\n\n\tsetup_stub_lkb(ls, ms);\n\tsend_request_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\n\treturn error;\n}"
  },
  {
    "function_name": "send_repeat_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "4013-4069",
    "snippet": "static void send_repeat_remove(struct dlm_ls *ls, char *ms_name, int len)\n{\n\tchar name[DLM_RESNAME_MAXLEN + 1];\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_rsb *r;\n\tuint32_t hash, b;\n\tint rv, dir_nodeid;\n\n\tmemset(name, 0, sizeof(name));\n\tmemcpy(name, ms_name, len);\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tlog_error(ls, \"send_repeat_remove dir %d %s\", dir_nodeid, name);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!rv) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlog_error(ls, \"repeat_remove on keep %s\", name);\n\t\treturn;\n\t}\n\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (!rv) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlog_error(ls, \"repeat_remove on toss %s\", name);\n\t\treturn;\n\t}\n\n\t/* use ls->remove_name2 to avoid conflict with shrink? */\n\n\tspin_lock(&ls->ls_remove_spin);\n\tls->ls_remove_len = len;\n\tmemcpy(ls->ls_remove_name, name, DLM_RESNAME_MAXLEN);\n\tspin_unlock(&ls->ls_remove_spin);\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\trv = _create_message(ls, sizeof(struct dlm_message) + len,\n\t\t\t     dir_nodeid, DLM_MSG_REMOVE, &ms, &mh);\n\tif (rv)\n\t\treturn;\n\n\tmemcpy(ms->m_extra, name, len);\n\tms->m_hash = hash;\n\n\tsend_message(mh, ms);\n\n\tspin_lock(&ls->ls_remove_spin);\n\tls->ls_remove_len = 0;\n\tmemset(ls->ls_remove_name, 0, DLM_RESNAME_MAXLEN);\n\tspin_unlock(&ls->ls_remove_spin);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_remove_spin"
          ],
          "line": 4068
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ls->ls_remove_name",
            "0",
            "DLM_RESNAME_MAXLEN"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_remove_spin"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_message",
          "args": [
            "mh",
            "ms"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3590-3595",
          "snippet": "static int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ms->m_extra",
            "name",
            "len"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_create_message",
          "args": [
            "ls",
            "sizeof(struct dlm_message) + len",
            "dir_nodeid",
            "DLM_MSG_REMOVE",
            "&ms",
            "&mh"
          ],
          "line": 4055
        },
        "resolved": true,
        "details": {
          "function_name": "_create_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3526-3558",
          "snippet": "static int _create_message(struct dlm_ls *ls, int mb_len,\n\t\t\t   int to_nodeid, int mstype,\n\t\t\t   struct dlm_message **ms_ret,\n\t\t\t   struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\n\t/* get_buffer gives us a message handle (mh) that we need to\n\t   pass into lowcomms_commit and a message buffer (mb) that we\n\t   write our data into */\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\n\tmemset(mb, 0, mb_len);\n\n\tms = (struct dlm_message *) mb;\n\n\tms->m_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tms->m_header.h_lockspace = ls->ls_global_id;\n\tms->m_header.h_nodeid = dlm_our_nodeid();\n\tms->m_header.h_length = mb_len;\n\tms->m_header.h_cmd = DLM_MSG;\n\n\tms->m_type = mstype;\n\n\t*mh_ret = mh;\n\t*ms_ret = ms;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int _create_message(struct dlm_ls *ls, int mb_len,\n\t\t\t   int to_nodeid, int mstype,\n\t\t\t   struct dlm_message **ms_ret,\n\t\t\t   struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\n\t/* get_buffer gives us a message handle (mh) that we need to\n\t   pass into lowcomms_commit and a message buffer (mb) that we\n\t   write our data into */\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\n\tmemset(mb, 0, mb_len);\n\n\tms = (struct dlm_message *) mb;\n\n\tms->m_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tms->m_header.h_lockspace = ls->ls_global_id;\n\tms->m_header.h_nodeid = dlm_our_nodeid();\n\tms->m_header.h_length = mb_len;\n\tms->m_header.h_cmd = DLM_MSG;\n\n\tms->m_type = mstype;\n\n\t*mh_ret = mh;\n\t*ms_ret = ms;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ls->ls_remove_name",
            "name",
            "DLM_RESNAME_MAXLEN"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"repeat_remove on toss %s\"",
            "name"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_search_rsb_tree",
          "args": [
            "&ls->ls_rsbtbl[b].toss",
            "name",
            "len",
            "&r"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_search_rsb_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "447-470",
          "snippet": "int dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"repeat_remove on keep %s\"",
            "name"
          ],
          "line": 4036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"send_repeat_remove dir %d %s\"",
            "dir_nodeid",
            "name"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_hash2nodeid",
          "args": [
            "ls",
            "hash"
          ],
          "line": 4028
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hash2nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "35-45",
          "snippet": "int dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "name",
            "len",
            "0"
          ],
          "line": 4025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name",
            "ms_name",
            "len"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "name",
            "0",
            "sizeof(name)"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic void send_repeat_remove(struct dlm_ls *ls, char *ms_name, int len)\n{\n\tchar name[DLM_RESNAME_MAXLEN + 1];\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_rsb *r;\n\tuint32_t hash, b;\n\tint rv, dir_nodeid;\n\n\tmemset(name, 0, sizeof(name));\n\tmemcpy(name, ms_name, len);\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tlog_error(ls, \"send_repeat_remove dir %d %s\", dir_nodeid, name);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!rv) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlog_error(ls, \"repeat_remove on keep %s\", name);\n\t\treturn;\n\t}\n\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (!rv) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlog_error(ls, \"repeat_remove on toss %s\", name);\n\t\treturn;\n\t}\n\n\t/* use ls->remove_name2 to avoid conflict with shrink? */\n\n\tspin_lock(&ls->ls_remove_spin);\n\tls->ls_remove_len = len;\n\tmemcpy(ls->ls_remove_name, name, DLM_RESNAME_MAXLEN);\n\tspin_unlock(&ls->ls_remove_spin);\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\trv = _create_message(ls, sizeof(struct dlm_message) + len,\n\t\t\t     dir_nodeid, DLM_MSG_REMOVE, &ms, &mh);\n\tif (rv)\n\t\treturn;\n\n\tmemcpy(ms->m_extra, name, len);\n\tms->m_hash = hash;\n\n\tsend_message(mh, ms);\n\n\tspin_lock(&ls->ls_remove_spin);\n\tls->ls_remove_len = 0;\n\tmemset(ls->ls_remove_name, 0, DLM_RESNAME_MAXLEN);\n\tspin_unlock(&ls->ls_remove_spin);\n}"
  },
  {
    "function_name": "validate_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3972-4011",
    "snippet": "static int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "lkb->lkb_resource->res_ls",
            "\"ignore invalid message %d from %d %x %x %x %d\"",
            "ms->m_type",
            "from",
            "lkb->lkb_id",
            "lkb->lkb_remid",
            "lkb->lkb_flags",
            "lkb->lkb_nodeid"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_process_copy",
          "args": [
            "lkb"
          ],
          "line": 3995
        },
        "resolved": true,
        "details": {
          "function_name": "is_process_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "251-254",
          "snippet": "static inline int is_process_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_nodeid && !(lkb->lkb_flags & DLM_IFL_MSTCPY));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_process_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_nodeid && !(lkb->lkb_flags & DLM_IFL_MSTCPY));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master_copy",
          "args": [
            "lkb"
          ],
          "line": 3981
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tint from = ms->m_header.h_nodeid;\n\tint error = 0;\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_CANCEL:\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_UNLOCK_REPLY:\n\tcase DLM_MSG_CANCEL_REPLY:\n\tcase DLM_MSG_GRANT:\n\tcase DLM_MSG_BAST:\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase DLM_MSG_REQUEST_REPLY:\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  ms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  lkb->lkb_flags, lkb->lkb_nodeid);\n\treturn error;\n}"
  },
  {
    "function_name": "setup_stub_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3962-3967",
    "snippet": "static void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_remid = ms->m_lkid;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_remid = ms->m_lkid;\n}"
  },
  {
    "function_name": "receive_unlock_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3951-3957",
    "snippet": "static int receive_unlock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_message *ms)\n{\n\tif (receive_lvb(ls, lkb, ms))\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "receive_lvb",
          "args": [
            "ls",
            "lkb",
            "ms"
          ],
          "line": 3954
        },
        "resolved": true,
        "details": {
          "function_name": "receive_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3886-3902",
          "snippet": "static int receive_lvb(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_message *ms)\n{\n\tint len;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tlen = receive_extralen(ms);\n\t\tif (len > ls->ls_lvblen)\n\t\t\tlen = ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_lvb(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_message *ms)\n{\n\tint len;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tlen = receive_extralen(ms);\n\t\tif (len > ls->ls_lvblen)\n\t\t\tlen = ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_unlock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_message *ms)\n{\n\tif (receive_lvb(ls, lkb, ms))\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "receive_convert_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3936-3949",
    "snippet": "static int receive_convert_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\treturn -EBUSY;\n\n\tif (receive_lvb(ls, lkb, ms))\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_rqmode = ms->m_rqmode;\n\tlkb->lkb_lvbseq = ms->m_lvbseq;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "receive_lvb",
          "args": [
            "ls",
            "lkb",
            "ms"
          ],
          "line": 3942
        },
        "resolved": true,
        "details": {
          "function_name": "receive_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3886-3902",
          "snippet": "static int receive_lvb(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_message *ms)\n{\n\tint len;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tlen = receive_extralen(ms);\n\t\tif (len > ls->ls_lvblen)\n\t\t\tlen = ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_lvb(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_message *ms)\n{\n\tint len;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tlen = receive_extralen(ms);\n\t\tif (len > ls->ls_lvblen)\n\t\t\tlen = ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_convert_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\treturn -EBUSY;\n\n\tif (receive_lvb(ls, lkb, ms))\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_rqmode = ms->m_rqmode;\n\tlkb->lkb_lvbseq = ms->m_lvbseq;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "receive_request_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3914-3934",
    "snippet": "static int receive_request_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_ownpid = ms->m_pid;\n\tlkb->lkb_remid = ms->m_lkid;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tlkb->lkb_rqmode = ms->m_rqmode;\n\n\tlkb->lkb_bastfn = (ms->m_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\n\tlkb->lkb_astfn = (ms->m_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\t/* lkb was just created so there won't be an lvb yet */\n\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_allocate_lvb",
          "args": [
            "ls"
          ],
          "line": 3928
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_allocate_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "47-53",
          "snippet": "char *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nchar *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_request_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tlkb->lkb_nodeid = ms->m_header.h_nodeid;\n\tlkb->lkb_ownpid = ms->m_pid;\n\tlkb->lkb_remid = ms->m_lkid;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tlkb->lkb_rqmode = ms->m_rqmode;\n\n\tlkb->lkb_bastfn = (ms->m_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\n\tlkb->lkb_astfn = (ms->m_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\t/* lkb was just created so there won't be an lvb yet */\n\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fake_astfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3909-3912",
    "snippet": "static void fake_astfn(void *astparam)\n{\n\tlog_print(\"fake_astfn should not be called\");\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"fake_astfn should not be called\""
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void fake_astfn(void *astparam)\n{\n\tlog_print(\"fake_astfn should not be called\");\n}"
  },
  {
    "function_name": "fake_bastfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3904-3907",
    "snippet": "static void fake_bastfn(void *astparam, int mode)\n{\n\tlog_print(\"fake_bastfn should not be called\");\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"fake_bastfn should not be called\""
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\n\nstatic void fake_bastfn(void *astparam, int mode)\n{\n\tlog_print(\"fake_bastfn should not be called\");\n}"
  },
  {
    "function_name": "receive_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3886-3902",
    "snippet": "static int receive_lvb(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_message *ms)\n{\n\tint len;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tlen = receive_extralen(ms);\n\t\tif (len > ls->ls_lvblen)\n\t\t\tlen = ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lkb->lkb_lvbptr",
            "ms->m_extra",
            "len"
          ],
          "line": 3899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_extralen",
          "args": [
            "ms"
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "receive_extralen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3881-3884",
          "snippet": "static int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_allocate_lvb",
          "args": [
            "ls"
          ],
          "line": 3893
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_allocate_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "47-53",
          "snippet": "char *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nchar *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_lvb(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_message *ms)\n{\n\tint len;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tlen = receive_extralen(ms);\n\t\tif (len > ls->ls_lvblen)\n\t\t\tlen = ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "receive_extralen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3881-3884",
    "snippet": "static int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}"
  },
  {
    "function_name": "receive_flags_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3871-3879",
    "snippet": "static void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_flags == DLM_IFL_STUB_MS)\n\t\treturn;\n\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
  },
  {
    "function_name": "receive_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3863-3869",
    "snippet": "static void receive_flags(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tlkb->lkb_exflags = ms->m_exflags;\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void receive_flags(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tlkb->lkb_exflags = ms->m_exflags;\n\tlkb->lkb_sbflags = ms->m_sbflags;\n\tlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\n\t\t         (ms->m_flags & 0x0000FFFF);\n}"
  },
  {
    "function_name": "send_lookup_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3838-3857",
    "snippet": "static int send_lookup_reply(struct dlm_ls *ls, struct dlm_message *ms_in,\n\t\t\t     int ret_nodeid, int rv)\n{\n\tstruct dlm_rsb *r = &ls->ls_stub_rsb;\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint error, nodeid = ms_in->m_header.h_nodeid;\n\n\terror = create_message(r, NULL, nodeid, DLM_MSG_LOOKUP_REPLY, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tms->m_lkid = ms_in->m_lkid;\n\tms->m_result = rv;\n\tms->m_nodeid = ret_nodeid;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_message",
          "args": [
            "mh",
            "ms"
          ],
          "line": 3854
        },
        "resolved": true,
        "details": {
          "function_name": "send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3590-3595",
          "snippet": "static int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_message",
          "args": [
            "r",
            "NULL",
            "nodeid",
            "DLM_MSG_LOOKUP_REPLY",
            "&ms",
            "&mh"
          ],
          "line": 3846
        },
        "resolved": true,
        "details": {
          "function_name": "create_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3560-3585",
          "snippet": "static int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_lookup_reply(struct dlm_ls *ls, struct dlm_message *ms_in,\n\t\t\t     int ret_nodeid, int rv)\n{\n\tstruct dlm_rsb *r = &ls->ls_stub_rsb;\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint error, nodeid = ms_in->m_header.h_nodeid;\n\n\terror = create_message(r, NULL, nodeid, DLM_MSG_LOOKUP_REPLY, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tms->m_lkid = ms_in->m_lkid;\n\tms->m_result = rv;\n\tms->m_nodeid = ret_nodeid;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "send_cancel_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3833-3836",
    "snippet": "static int send_cancel_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_CANCEL_REPLY, rv);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_common_reply",
          "args": [
            "r",
            "lkb",
            "DLM_MSG_CANCEL_REPLY",
            "rv"
          ],
          "line": 3835
        },
        "resolved": true,
        "details": {
          "function_name": "send_common_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3796-3816",
          "snippet": "static int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = rv;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = rv;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_cancel_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_CANCEL_REPLY, rv);\n}"
  },
  {
    "function_name": "send_unlock_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3828-3831",
    "snippet": "static int send_unlock_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_UNLOCK_REPLY, rv);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_common_reply",
          "args": [
            "r",
            "lkb",
            "DLM_MSG_UNLOCK_REPLY",
            "rv"
          ],
          "line": 3830
        },
        "resolved": true,
        "details": {
          "function_name": "send_common_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3796-3816",
          "snippet": "static int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = rv;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = rv;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_unlock_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_UNLOCK_REPLY, rv);\n}"
  },
  {
    "function_name": "send_convert_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3823-3826",
    "snippet": "static int send_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_CONVERT_REPLY, rv);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_common_reply",
          "args": [
            "r",
            "lkb",
            "DLM_MSG_CONVERT_REPLY",
            "rv"
          ],
          "line": 3825
        },
        "resolved": true,
        "details": {
          "function_name": "send_common_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3796-3816",
          "snippet": "static int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = rv;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = rv;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_CONVERT_REPLY, rv);\n}"
  },
  {
    "function_name": "send_request_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3818-3821",
    "snippet": "static int send_request_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_REQUEST_REPLY, rv);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_common_reply",
          "args": [
            "r",
            "lkb",
            "DLM_MSG_REQUEST_REPLY",
            "rv"
          ],
          "line": 3820
        },
        "resolved": true,
        "details": {
          "function_name": "send_common_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3796-3816",
          "snippet": "static int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = rv;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = rv;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_request_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_REQUEST_REPLY, rv);\n}"
  },
  {
    "function_name": "send_common_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3796-3816",
    "snippet": "static int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = rv;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_message",
          "args": [
            "mh",
            "ms"
          ],
          "line": 3813
        },
        "resolved": true,
        "details": {
          "function_name": "send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3590-3595",
          "snippet": "static int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_args",
          "args": [
            "r",
            "lkb",
            "ms"
          ],
          "line": 3809
        },
        "resolved": true,
        "details": {
          "function_name": "send_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3597-3639",
          "snippet": "static void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_message",
          "args": [
            "r",
            "lkb",
            "to_nodeid",
            "mstype",
            "&ms",
            "&mh"
          ],
          "line": 3805
        },
        "resolved": true,
        "details": {
          "function_name": "create_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3560-3585",
          "snippet": "static int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = rv;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "send_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3776-3794",
    "snippet": "static int send_remove(struct dlm_rsb *r)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = dlm_dir_nodeid(r);\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_REMOVE, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\tms->m_hash = r->res_hash;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_message",
          "args": [
            "mh",
            "ms"
          ],
          "line": 3791
        },
        "resolved": true,
        "details": {
          "function_name": "send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3590-3595",
          "snippet": "static int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ms->m_extra",
            "r->res_name",
            "r->res_length"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_message",
          "args": [
            "r",
            "NULL",
            "to_nodeid",
            "DLM_MSG_REMOVE",
            "&ms",
            "&mh"
          ],
          "line": 3784
        },
        "resolved": true,
        "details": {
          "function_name": "create_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3560-3585",
          "snippet": "static int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dir_nodeid",
          "args": [
            "r"
          ],
          "line": 3782
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "47-50",
          "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_remove(struct dlm_rsb *r)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = dlm_dir_nodeid(r);\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_REMOVE, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\tms->m_hash = r->res_hash;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "send_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3748-3774",
    "snippet": "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = dlm_dir_nodeid(r);\n\n\terror = add_to_waiters(lkb, DLM_MSG_LOOKUP, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_LOOKUP, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_from_waiters",
          "args": [
            "lkb",
            "DLM_MSG_LOOKUP_REPLY"
          ],
          "line": 3772
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_waiters_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1610-1621",
          "snippet": "static int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_message",
          "args": [
            "mh",
            "ms"
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3590-3595",
          "snippet": "static int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_args",
          "args": [
            "r",
            "lkb",
            "ms"
          ],
          "line": 3764
        },
        "resolved": true,
        "details": {
          "function_name": "send_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3597-3639",
          "snippet": "static void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_message",
          "args": [
            "r",
            "NULL",
            "to_nodeid",
            "DLM_MSG_LOOKUP",
            "&ms",
            "&mh"
          ],
          "line": 3760
        },
        "resolved": true,
        "details": {
          "function_name": "create_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3560-3585",
          "snippet": "static int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_waiters",
          "args": [
            "lkb",
            "DLM_MSG_LOOKUP",
            "to_nodeid"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_waiters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1453-1504",
          "snippet": "static int add_to_waiters(struct dlm_lkb *lkb, int mstype, int to_nodeid)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tif (is_overlap_unlock(lkb) ||\n\t    (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL))) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lkb->lkb_wait_type || is_overlap_cancel(lkb)) {\n\t\tswitch (mstype) {\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\tbreak;\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tlkb->lkb_wait_count++;\n\t\thold_lkb(lkb);\n\n\t\tlog_debug(ls, \"addwait %x cur %d overlap %d count %d f %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type, mstype,\n\t\t\t  lkb->lkb_wait_count, lkb->lkb_flags);\n\t\tgoto out;\n\t}\n\n\tDLM_ASSERT(!lkb->lkb_wait_count,\n\t\t   dlm_print_lkb(lkb);\n\t\t   printk(\"wait_count %d\\n\", lkb->lkb_wait_count););\n\n\tlkb->lkb_wait_count++;\n\tlkb->lkb_wait_type = mstype;\n\tlkb->lkb_wait_time = ktime_get();\n\tlkb->lkb_wait_nodeid = to_nodeid; /* for debugging */\n\thold_lkb(lkb);\n\tlist_add(&lkb->lkb_wait_reply, &ls->ls_waiters);\n out:\n\tif (error)\n\t\tlog_error(ls, \"addwait error %x %d flags %x %d %d %s\",\n\t\t\t  lkb->lkb_id, error, lkb->lkb_flags, mstype,\n\t\t\t  lkb->lkb_wait_type, lkb->lkb_resource->res_name);\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int add_to_waiters(struct dlm_lkb *lkb, int mstype, int to_nodeid)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tif (is_overlap_unlock(lkb) ||\n\t    (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL))) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lkb->lkb_wait_type || is_overlap_cancel(lkb)) {\n\t\tswitch (mstype) {\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\tbreak;\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tlkb->lkb_wait_count++;\n\t\thold_lkb(lkb);\n\n\t\tlog_debug(ls, \"addwait %x cur %d overlap %d count %d f %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type, mstype,\n\t\t\t  lkb->lkb_wait_count, lkb->lkb_flags);\n\t\tgoto out;\n\t}\n\n\tDLM_ASSERT(!lkb->lkb_wait_count,\n\t\t   dlm_print_lkb(lkb);\n\t\t   printk(\"wait_count %d\\n\", lkb->lkb_wait_count););\n\n\tlkb->lkb_wait_count++;\n\tlkb->lkb_wait_type = mstype;\n\tlkb->lkb_wait_time = ktime_get();\n\tlkb->lkb_wait_nodeid = to_nodeid; /* for debugging */\n\thold_lkb(lkb);\n\tlist_add(&lkb->lkb_wait_reply, &ls->ls_waiters);\n out:\n\tif (error)\n\t\tlog_error(ls, \"addwait error %x %d flags %x %d %d %s\",\n\t\t\t  lkb->lkb_id, error, lkb->lkb_flags, mstype,\n\t\t\t  lkb->lkb_wait_type, lkb->lkb_resource->res_name);\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dir_nodeid",
          "args": [
            "r"
          ],
          "line": 3754
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "47-50",
          "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = dlm_dir_nodeid(r);\n\n\terror = add_to_waiters(lkb, DLM_MSG_LOOKUP, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_LOOKUP, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\n\treturn error;\n}"
  },
  {
    "function_name": "send_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3727-3746",
    "snippet": "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_BAST, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_bastmode = mode;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_message",
          "args": [
            "mh",
            "ms"
          ],
          "line": 3743
        },
        "resolved": true,
        "details": {
          "function_name": "send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3590-3595",
          "snippet": "static int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_args",
          "args": [
            "r",
            "lkb",
            "ms"
          ],
          "line": 3739
        },
        "resolved": true,
        "details": {
          "function_name": "send_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3597-3639",
          "snippet": "static void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_message",
          "args": [
            "r",
            "NULL",
            "to_nodeid",
            "DLM_MSG_BAST",
            "&ms",
            "&mh"
          ],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "create_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3560-3585",
          "snippet": "static int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_BAST, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_bastmode = mode;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "send_grant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3706-3725",
    "snippet": "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, DLM_MSG_GRANT, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = 0;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_message",
          "args": [
            "mh",
            "ms"
          ],
          "line": 3722
        },
        "resolved": true,
        "details": {
          "function_name": "send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3590-3595",
          "snippet": "static int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_args",
          "args": [
            "r",
            "lkb",
            "ms"
          ],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "send_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3597-3639",
          "snippet": "static void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_message",
          "args": [
            "r",
            "lkb",
            "to_nodeid",
            "DLM_MSG_GRANT",
            "&ms",
            "&mh"
          ],
          "line": 3714
        },
        "resolved": true,
        "details": {
          "function_name": "create_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3560-3585",
          "snippet": "static int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, DLM_MSG_GRANT, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = 0;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "send_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3701-3704",
    "snippet": "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_CANCEL);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_common",
          "args": [
            "r",
            "lkb",
            "DLM_MSG_CANCEL"
          ],
          "line": 3703
        },
        "resolved": true,
        "details": {
          "function_name": "send_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3641-3667",
          "snippet": "static int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_CANCEL);\n}"
  },
  {
    "function_name": "send_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3696-3699",
    "snippet": "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_UNLOCK);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_common",
          "args": [
            "r",
            "lkb",
            "DLM_MSG_UNLOCK"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "send_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3641-3667",
          "snippet": "static int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_UNLOCK);\n}"
  },
  {
    "function_name": "send_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3674-3690",
    "snippet": "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = send_common(r, lkb, DLM_MSG_CONVERT);\n\n\t/* down conversions go without a reply from the master */\n\tif (!error && down_conversion(lkb)) {\n\t\tremove_from_waiters(lkb, DLM_MSG_CONVERT_REPLY);\n\t\tr->res_ls->ls_stub_ms.m_flags = DLM_IFL_STUB_MS;\n\t\tr->res_ls->ls_stub_ms.m_type = DLM_MSG_CONVERT_REPLY;\n\t\tr->res_ls->ls_stub_ms.m_result = 0;\n\t\t__receive_convert_reply(r, lkb, &r->res_ls->ls_stub_ms);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__receive_convert_reply",
          "args": [
            "r",
            "lkb",
            "&r->res_ls->ls_stub_ms"
          ],
          "line": 3686
        },
        "resolved": true,
        "details": {
          "function_name": "__receive_convert_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4596-4638",
          "snippet": "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms)\n{\n\t/* this is the value returned from do_convert() on the master */\n\tswitch (ms->m_result) {\n\tcase -EAGAIN:\n\t\t/* convert would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tbreak;\n\n\tcase -EDEADLK:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\t\t/* convert was queued on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tbreak;\n\n\tcase 0:\n\t\t/* convert was granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tgrant_lock_pc(r, lkb, ms);\n\t\tqueue_cast(r, lkb, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_convert_reply %x remote %d %x %d\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid, ms->m_lkid,\n\t\t\t  ms->m_result);\n\t\tdlm_print_rsb(r);\n\t\tdlm_print_lkb(lkb);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms)\n{\n\t/* this is the value returned from do_convert() on the master */\n\tswitch (ms->m_result) {\n\tcase -EAGAIN:\n\t\t/* convert would block (be queued) on remote master */\n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tbreak;\n\n\tcase -EDEADLK:\n\t\treceive_flags_reply(lkb, ms);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\t\t/* convert was queued on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tbreak;\n\n\tcase 0:\n\t\t/* convert was granted on remote master */\n\t\treceive_flags_reply(lkb, ms);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tgrant_lock_pc(r, lkb, ms);\n\t\tqueue_cast(r, lkb, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_convert_reply %x remote %d %x %d\",\n\t\t\t  lkb->lkb_id, ms->m_header.h_nodeid, ms->m_lkid,\n\t\t\t  ms->m_result);\n\t\tdlm_print_rsb(r);\n\t\tdlm_print_lkb(lkb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_waiters",
          "args": [
            "lkb",
            "DLM_MSG_CONVERT_REPLY"
          ],
          "line": 3682
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_waiters_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1610-1621",
          "snippet": "static int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_conversion",
          "args": [
            "lkb"
          ],
          "line": 3681
        },
        "resolved": true,
        "details": {
          "function_name": "down_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "269-272",
          "snippet": "static inline int down_conversion(struct dlm_lkb *lkb)\n{\n\treturn (!middle_conversion(lkb) && lkb->lkb_rqmode < lkb->lkb_grmode);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int down_conversion(struct dlm_lkb *lkb)\n{\n\treturn (!middle_conversion(lkb) && lkb->lkb_rqmode < lkb->lkb_grmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_common",
          "args": [
            "r",
            "lkb",
            "DLM_MSG_CONVERT"
          ],
          "line": 3678
        },
        "resolved": true,
        "details": {
          "function_name": "send_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3641-3667",
          "snippet": "static int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = send_common(r, lkb, DLM_MSG_CONVERT);\n\n\t/* down conversions go without a reply from the master */\n\tif (!error && down_conversion(lkb)) {\n\t\tremove_from_waiters(lkb, DLM_MSG_CONVERT_REPLY);\n\t\tr->res_ls->ls_stub_ms.m_flags = DLM_IFL_STUB_MS;\n\t\tr->res_ls->ls_stub_ms.m_type = DLM_MSG_CONVERT_REPLY;\n\t\tr->res_ls->ls_stub_ms.m_result = 0;\n\t\t__receive_convert_reply(r, lkb, &r->res_ls->ls_stub_ms);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "send_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3669-3672",
    "snippet": "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_REQUEST);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_common",
          "args": [
            "r",
            "lkb",
            "DLM_MSG_REQUEST"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "send_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3641-3667",
          "snippet": "static int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_REQUEST);\n}"
  },
  {
    "function_name": "send_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3641-3667",
    "snippet": "static int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_from_waiters",
          "args": [
            "lkb",
            "msg_reply_type(mstype)"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_waiters_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1610-1621",
          "snippet": "static int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg_reply_type",
          "args": [
            "mstype"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "msg_reply_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1363-1378",
          "snippet": "static int msg_reply_type(int mstype)\n{\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\t\treturn DLM_MSG_REQUEST_REPLY;\n\tcase DLM_MSG_CONVERT:\n\t\treturn DLM_MSG_CONVERT_REPLY;\n\tcase DLM_MSG_UNLOCK:\n\t\treturn DLM_MSG_UNLOCK_REPLY;\n\tcase DLM_MSG_CANCEL:\n\t\treturn DLM_MSG_CANCEL_REPLY;\n\tcase DLM_MSG_LOOKUP:\n\t\treturn DLM_MSG_LOOKUP_REPLY;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int msg_reply_type(int mstype)\n{\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\t\treturn DLM_MSG_REQUEST_REPLY;\n\tcase DLM_MSG_CONVERT:\n\t\treturn DLM_MSG_CONVERT_REPLY;\n\tcase DLM_MSG_UNLOCK:\n\t\treturn DLM_MSG_UNLOCK_REPLY;\n\tcase DLM_MSG_CANCEL:\n\t\treturn DLM_MSG_CANCEL_REPLY;\n\tcase DLM_MSG_LOOKUP:\n\t\treturn DLM_MSG_LOOKUP_REPLY;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_message",
          "args": [
            "mh",
            "ms"
          ],
          "line": 3659
        },
        "resolved": true,
        "details": {
          "function_name": "send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3590-3595",
          "snippet": "static int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_args",
          "args": [
            "r",
            "lkb",
            "ms"
          ],
          "line": 3657
        },
        "resolved": true,
        "details": {
          "function_name": "send_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3597-3639",
          "snippet": "static void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_message",
          "args": [
            "r",
            "lkb",
            "to_nodeid",
            "mstype",
            "&ms",
            "&mh"
          ],
          "line": 3653
        },
        "resolved": true,
        "details": {
          "function_name": "create_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3560-3585",
          "snippet": "static int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_waiters",
          "args": [
            "lkb",
            "mstype",
            "to_nodeid"
          ],
          "line": 3649
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_waiters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1453-1504",
          "snippet": "static int add_to_waiters(struct dlm_lkb *lkb, int mstype, int to_nodeid)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tif (is_overlap_unlock(lkb) ||\n\t    (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL))) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lkb->lkb_wait_type || is_overlap_cancel(lkb)) {\n\t\tswitch (mstype) {\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\tbreak;\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tlkb->lkb_wait_count++;\n\t\thold_lkb(lkb);\n\n\t\tlog_debug(ls, \"addwait %x cur %d overlap %d count %d f %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type, mstype,\n\t\t\t  lkb->lkb_wait_count, lkb->lkb_flags);\n\t\tgoto out;\n\t}\n\n\tDLM_ASSERT(!lkb->lkb_wait_count,\n\t\t   dlm_print_lkb(lkb);\n\t\t   printk(\"wait_count %d\\n\", lkb->lkb_wait_count););\n\n\tlkb->lkb_wait_count++;\n\tlkb->lkb_wait_type = mstype;\n\tlkb->lkb_wait_time = ktime_get();\n\tlkb->lkb_wait_nodeid = to_nodeid; /* for debugging */\n\thold_lkb(lkb);\n\tlist_add(&lkb->lkb_wait_reply, &ls->ls_waiters);\n out:\n\tif (error)\n\t\tlog_error(ls, \"addwait error %x %d flags %x %d %d %s\",\n\t\t\t  lkb->lkb_id, error, lkb->lkb_flags, mstype,\n\t\t\t  lkb->lkb_wait_type, lkb->lkb_resource->res_name);\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int add_to_waiters(struct dlm_lkb *lkb, int mstype, int to_nodeid)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tif (is_overlap_unlock(lkb) ||\n\t    (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL))) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lkb->lkb_wait_type || is_overlap_cancel(lkb)) {\n\t\tswitch (mstype) {\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\tbreak;\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tlkb->lkb_wait_count++;\n\t\thold_lkb(lkb);\n\n\t\tlog_debug(ls, \"addwait %x cur %d overlap %d count %d f %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type, mstype,\n\t\t\t  lkb->lkb_wait_count, lkb->lkb_flags);\n\t\tgoto out;\n\t}\n\n\tDLM_ASSERT(!lkb->lkb_wait_count,\n\t\t   dlm_print_lkb(lkb);\n\t\t   printk(\"wait_count %d\\n\", lkb->lkb_wait_count););\n\n\tlkb->lkb_wait_count++;\n\tlkb->lkb_wait_type = mstype;\n\tlkb->lkb_wait_time = ktime_get();\n\tlkb->lkb_wait_nodeid = to_nodeid; /* for debugging */\n\thold_lkb(lkb);\n\tlist_add(&lkb->lkb_wait_reply, &ls->ls_waiters);\n out:\n\tif (error)\n\t\tlog_error(ls, \"addwait error %x %d flags %x %d %d %s\",\n\t\t\t  lkb->lkb_id, error, lkb->lkb_flags, mstype,\n\t\t\t  lkb->lkb_wait_type, lkb->lkb_resource->res_name);\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}"
  },
  {
    "function_name": "send_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3597-3639",
    "snippet": "static void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ms->m_extra",
            "lkb->lkb_lvbptr",
            "r->res_ls->ls_lvblen"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ms->m_extra",
            "r->res_name",
            "r->res_length"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = lkb->lkb_nodeid;\n\tms->m_pid      = lkb->lkb_ownpid;\n\tms->m_lkid     = lkb->lkb_id;\n\tms->m_remid    = lkb->lkb_remid;\n\tms->m_exflags  = lkb->lkb_exflags;\n\tms->m_sbflags  = lkb->lkb_sbflags;\n\tms->m_flags    = lkb->lkb_flags;\n\tms->m_lvbseq   = lkb->lkb_lvbseq;\n\tms->m_status   = lkb->lkb_status;\n\tms->m_grmode   = lkb->lkb_grmode;\n\tms->m_rqmode   = lkb->lkb_rqmode;\n\tms->m_hash     = r->res_hash;\n\n\t/* m_result and m_bastmode are set from function args,\n\t   not from lkb fields */\n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= DLM_CB_CAST;\n\n\t/* compare with switch in create_message; send_remove() doesn't\n\t   use send_args() */\n\n\tswitch (ms->m_type) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "send_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3590-3595",
    "snippet": "static int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lowcomms_commit_buffer",
          "args": [
            "mh"
          ],
          "line": 3593
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_commit_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1531-1552",
          "snippet": "void dlm_lowcomms_commit_buffer(void *mh)\n{\n\tstruct writequeue_entry *e = (struct writequeue_entry *)mh;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock(&con->writequeue_lock);\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\te->len = e->end - e->offset;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\n\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n\treturn;\n\nout:\n\tspin_unlock(&con->writequeue_lock);\n\treturn;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_WRITE_PENDING 2"
          ],
          "globals_used": [
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nvoid dlm_lowcomms_commit_buffer(void *mh)\n{\n\tstruct writequeue_entry *e = (struct writequeue_entry *)mh;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock(&con->writequeue_lock);\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\te->len = e->end - e->offset;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\n\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n\treturn;\n\nout:\n\tspin_unlock(&con->writequeue_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_message_out",
          "args": [
            "ms"
          ],
          "line": 3592
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_message_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/util.c",
          "lines": "86-108",
          "snippet": "void dlm_message_out(struct dlm_message *ms)\n{\n\theader_out(&ms->m_header);\n\n\tms->m_type\t\t= cpu_to_le32(ms->m_type);\n\tms->m_nodeid\t\t= cpu_to_le32(ms->m_nodeid);\n\tms->m_pid\t\t= cpu_to_le32(ms->m_pid);\n\tms->m_lkid\t\t= cpu_to_le32(ms->m_lkid);\n\tms->m_remid\t\t= cpu_to_le32(ms->m_remid);\n\tms->m_parent_lkid\t= cpu_to_le32(ms->m_parent_lkid);\n\tms->m_parent_remid\t= cpu_to_le32(ms->m_parent_remid);\n\tms->m_exflags\t\t= cpu_to_le32(ms->m_exflags);\n\tms->m_sbflags\t\t= cpu_to_le32(ms->m_sbflags);\n\tms->m_flags\t\t= cpu_to_le32(ms->m_flags);\n\tms->m_lvbseq\t\t= cpu_to_le32(ms->m_lvbseq);\n\tms->m_hash\t\t= cpu_to_le32(ms->m_hash);\n\tms->m_status\t\t= cpu_to_le32(ms->m_status);\n\tms->m_grmode\t\t= cpu_to_le32(ms->m_grmode);\n\tms->m_rqmode\t\t= cpu_to_le32(ms->m_rqmode);\n\tms->m_bastmode\t\t= cpu_to_le32(ms->m_bastmode);\n\tms->m_asts\t\t= cpu_to_le32(ms->m_asts);\n\tms->m_result\t\t= cpu_to_le32(to_dlm_errno(ms->m_result));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"rcom.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"rcom.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_message_out(struct dlm_message *ms)\n{\n\theader_out(&ms->m_header);\n\n\tms->m_type\t\t= cpu_to_le32(ms->m_type);\n\tms->m_nodeid\t\t= cpu_to_le32(ms->m_nodeid);\n\tms->m_pid\t\t= cpu_to_le32(ms->m_pid);\n\tms->m_lkid\t\t= cpu_to_le32(ms->m_lkid);\n\tms->m_remid\t\t= cpu_to_le32(ms->m_remid);\n\tms->m_parent_lkid\t= cpu_to_le32(ms->m_parent_lkid);\n\tms->m_parent_remid\t= cpu_to_le32(ms->m_parent_remid);\n\tms->m_exflags\t\t= cpu_to_le32(ms->m_exflags);\n\tms->m_sbflags\t\t= cpu_to_le32(ms->m_sbflags);\n\tms->m_flags\t\t= cpu_to_le32(ms->m_flags);\n\tms->m_lvbseq\t\t= cpu_to_le32(ms->m_lvbseq);\n\tms->m_hash\t\t= cpu_to_le32(ms->m_hash);\n\tms->m_status\t\t= cpu_to_le32(ms->m_status);\n\tms->m_grmode\t\t= cpu_to_le32(ms->m_grmode);\n\tms->m_rqmode\t\t= cpu_to_le32(ms->m_rqmode);\n\tms->m_bastmode\t\t= cpu_to_le32(ms->m_bastmode);\n\tms->m_asts\t\t= cpu_to_le32(ms->m_asts);\n\tms->m_result\t\t= cpu_to_le32(to_dlm_errno(ms->m_result));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\n{\n\tdlm_message_out(ms);\n\tdlm_lowcomms_commit_buffer(mh);\n\treturn 0;\n}"
  },
  {
    "function_name": "create_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3560-3585",
    "snippet": "static int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_create_message",
          "args": [
            "r->res_ls",
            "mb_len",
            "to_nodeid",
            "mstype",
            "ms_ret",
            "mh_ret"
          ],
          "line": 3583
        },
        "resolved": true,
        "details": {
          "function_name": "_create_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3526-3558",
          "snippet": "static int _create_message(struct dlm_ls *ls, int mb_len,\n\t\t\t   int to_nodeid, int mstype,\n\t\t\t   struct dlm_message **ms_ret,\n\t\t\t   struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\n\t/* get_buffer gives us a message handle (mh) that we need to\n\t   pass into lowcomms_commit and a message buffer (mb) that we\n\t   write our data into */\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\n\tmemset(mb, 0, mb_len);\n\n\tms = (struct dlm_message *) mb;\n\n\tms->m_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tms->m_header.h_lockspace = ls->ls_global_id;\n\tms->m_header.h_nodeid = dlm_our_nodeid();\n\tms->m_header.h_length = mb_len;\n\tms->m_header.h_cmd = DLM_MSG;\n\n\tms->m_type = mstype;\n\n\t*mh_ret = mh;\n\t*ms_ret = ms;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int _create_message(struct dlm_ls *ls, int mb_len,\n\t\t\t   int to_nodeid, int mstype,\n\t\t\t   struct dlm_message **ms_ret,\n\t\t\t   struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\n\t/* get_buffer gives us a message handle (mh) that we need to\n\t   pass into lowcomms_commit and a message buffer (mb) that we\n\t   write our data into */\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\n\tmemset(mb, 0, mb_len);\n\n\tms = (struct dlm_message *) mb;\n\n\tms->m_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tms->m_header.h_lockspace = ls->ls_global_id;\n\tms->m_header.h_nodeid = dlm_our_nodeid();\n\tms->m_header.h_length = mb_len;\n\tms->m_header.h_cmd = DLM_MSG;\n\n\tms->m_type = mstype;\n\n\t*mh_ret = mh;\n\t*ms_ret = ms;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr)\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret);\n}"
  },
  {
    "function_name": "_create_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3526-3558",
    "snippet": "static int _create_message(struct dlm_ls *ls, int mb_len,\n\t\t\t   int to_nodeid, int mstype,\n\t\t\t   struct dlm_message **ms_ret,\n\t\t\t   struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\n\t/* get_buffer gives us a message handle (mh) that we need to\n\t   pass into lowcomms_commit and a message buffer (mb) that we\n\t   write our data into */\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\n\tmemset(mb, 0, mb_len);\n\n\tms = (struct dlm_message *) mb;\n\n\tms->m_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tms->m_header.h_lockspace = ls->ls_global_id;\n\tms->m_header.h_nodeid = dlm_our_nodeid();\n\tms->m_header.h_length = mb_len;\n\tms->m_header.h_cmd = DLM_MSG;\n\n\tms->m_type = mstype;\n\n\t*mh_ret = mh;\n\t*ms_ret = ms;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 3549
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mb",
            "0",
            "mb_len"
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lowcomms_get_buffer",
          "args": [
            "to_nodeid",
            "mb_len",
            "GFP_NOFS",
            "&mb"
          ],
          "line": 3539
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_get_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1490-1529",
          "snippet": "void *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\n{\n\tstruct connection *con;\n\tstruct writequeue_entry *e;\n\tint offset = 0;\n\n\tcon = nodeid2con(nodeid, allocation);\n\tif (!con)\n\t\treturn NULL;\n\n\tspin_lock(&con->writequeue_lock);\n\te = list_entry(con->writequeue.prev, struct writequeue_entry, list);\n\tif ((&e->list == &con->writequeue) ||\n\t    (PAGE_CACHE_SIZE - e->end < len)) {\n\t\te = NULL;\n\t} else {\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t}\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (e) {\n\tgot_one:\n\t\t*ppc = page_address(e->page) + offset;\n\t\treturn e;\n\t}\n\n\te = new_writequeue_entry(con, allocation);\n\tif (e) {\n\t\tspin_lock(&con->writequeue_lock);\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t\tlist_add_tail(&e->list, &con->writequeue);\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tgoto got_one;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nvoid *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\n{\n\tstruct connection *con;\n\tstruct writequeue_entry *e;\n\tint offset = 0;\n\n\tcon = nodeid2con(nodeid, allocation);\n\tif (!con)\n\t\treturn NULL;\n\n\tspin_lock(&con->writequeue_lock);\n\te = list_entry(con->writequeue.prev, struct writequeue_entry, list);\n\tif ((&e->list == &con->writequeue) ||\n\t    (PAGE_CACHE_SIZE - e->end < len)) {\n\t\te = NULL;\n\t} else {\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t}\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (e) {\n\tgot_one:\n\t\t*ppc = page_address(e->page) + offset;\n\t\treturn e;\n\t}\n\n\te = new_writequeue_entry(con, allocation);\n\tif (e) {\n\t\tspin_lock(&con->writequeue_lock);\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t\tlist_add_tail(&e->list, &con->writequeue);\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tgoto got_one;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int _create_message(struct dlm_ls *ls, int mb_len,\n\t\t\t   int to_nodeid, int mstype,\n\t\t\t   struct dlm_message **ms_ret,\n\t\t\t   struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\n\t/* get_buffer gives us a message handle (mh) that we need to\n\t   pass into lowcomms_commit and a message buffer (mb) that we\n\t   write our data into */\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\n\tmemset(mb, 0, mb_len);\n\n\tms = (struct dlm_message *) mb;\n\n\tms->m_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tms->m_header.h_lockspace = ls->ls_global_id;\n\tms->m_header.h_nodeid = dlm_our_nodeid();\n\tms->m_header.h_length = mb_len;\n\tms->m_header.h_cmd = DLM_MSG;\n\n\tms->m_type = mstype;\n\n\t*mh_ret = mh;\n\t*ms_ret = ms;\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3462-3502",
    "snippet": "int dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_unlock_recovery",
          "args": [
            "ls"
          ],
          "line": 3499
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "210-213",
          "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_lock",
          "args": [
            "ls",
            "lkb",
            "&args"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3361-3381",
          "snippet": "static int unlock_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _unlock_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int unlock_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _unlock_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_lock",
          "args": [
            "ls",
            "lkb",
            "&args"
          ],
          "line": 3488
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3383-3403",
          "snippet": "static int cancel_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _cancel_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int cancel_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _cancel_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_unlock_args",
          "args": [
            "flags",
            "astarg",
            "&args"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "set_unlock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2871-2883",
          "snippet": "static int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "lkid",
            "&lkb"
          ],
          "line": 3479
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_recovery",
          "args": [
            "ls"
          ],
          "line": 3477
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_recovery_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "215-218",
          "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "lockspace"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3409-3460",
    "snippet": "int dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\n\t\t\t      astarg, bast, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 3458
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_unlock_recovery",
          "args": [
            "ls"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "210-213",
          "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_lkb",
          "args": [
            "ls",
            "lkb"
          ],
          "line": 3453
        },
        "resolved": true,
        "details": {
          "function_name": "__put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1247-1267",
          "snippet": "static int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_lock",
          "args": [
            "ls",
            "lkb",
            "name",
            "namelen",
            "&args"
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "request_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3313-3337",
          "snippet": "static int request_lock(struct dlm_ls *ls, struct dlm_lkb *lkb, char *name,\n\t\t\tint len, struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\treturn error;\n\n\terror = find_rsb(ls, name, len, 0, R_REQUEST, &r);\n\tif (error)\n\t\treturn error;\n\n\tlock_rsb(r);\n\n\tattach_lkb(r, lkb);\n\tlkb->lkb_lksb->sb_lkid = lkb->lkb_id;\n\n\terror = _request_lock(r, lkb);\n\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int request_lock(struct dlm_ls *ls, struct dlm_lkb *lkb, char *name,\n\t\t\tint len, struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\treturn error;\n\n\terror = find_rsb(ls, name, len, 0, R_REQUEST, &r);\n\tif (error)\n\t\treturn error;\n\n\tlock_rsb(r);\n\n\tattach_lkb(r, lkb);\n\tlkb->lkb_lksb->sb_lkid = lkb->lkb_id;\n\n\terror = _request_lock(r, lkb);\n\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_lock",
          "args": [
            "ls",
            "lkb",
            "&args"
          ],
          "line": 3445
        },
        "resolved": true,
        "details": {
          "function_name": "convert_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3339-3359",
          "snippet": "static int convert_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\tstruct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _convert_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int convert_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\tstruct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _convert_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_lock_args",
          "args": [
            "mode",
            "lksb",
            "flags",
            "namelen",
            "0",
            "ast",
            "astarg",
            "bast",
            "&args"
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "set_lock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2805-2869",
          "snippet": "static int set_lock_args(int mode, struct dlm_lksb *lksb, uint32_t flags,\n\t\t\t int namelen, unsigned long timeout_cs,\n\t\t\t void (*ast) (void *astparam),\n\t\t\t void *astparam,\n\t\t\t void (*bast) (void *astparam, int mode),\n\t\t\t struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\t/* check for invalid arg usage */\n\n\tif (mode < 0 || mode > DLM_LOCK_EX)\n\t\tgoto out;\n\n\tif (!(flags & DLM_LKF_CONVERT) && (namelen > DLM_RESNAME_MAXLEN))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_QUECVT && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_CONVERT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_QUECVT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && mode != DLM_LOCK_NL)\n\t\tgoto out;\n\n\tif (!ast || !lksb)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_VALBLK && !lksb->sb_lvbptr)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVERT && !lksb->sb_lkid)\n\t\tgoto out;\n\n\t/* these args will be copied to the lkb in validate_lock_args,\n\t   it cannot be done now because when converting locks, fields in\n\t   an active lkb cannot be modified before locking the rsb */\n\n\targs->flags = flags;\n\targs->astfn = ast;\n\targs->astparam = astparam;\n\targs->bastfn = bast;\n\targs->timeout = timeout_cs;\n\targs->mode = mode;\n\targs->lksb = lksb;\n\trv = 0;\n out:\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int set_lock_args(int mode, struct dlm_lksb *lksb, uint32_t flags,\n\t\t\t int namelen, unsigned long timeout_cs,\n\t\t\t void (*ast) (void *astparam),\n\t\t\t void *astparam,\n\t\t\t void (*bast) (void *astparam, int mode),\n\t\t\t struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\t/* check for invalid arg usage */\n\n\tif (mode < 0 || mode > DLM_LOCK_EX)\n\t\tgoto out;\n\n\tif (!(flags & DLM_LKF_CONVERT) && (namelen > DLM_RESNAME_MAXLEN))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_QUECVT && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_CONVERT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_QUECVT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && mode != DLM_LOCK_NL)\n\t\tgoto out;\n\n\tif (!ast || !lksb)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_VALBLK && !lksb->sb_lvbptr)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVERT && !lksb->sb_lkid)\n\t\tgoto out;\n\n\t/* these args will be copied to the lkb in validate_lock_args,\n\t   it cannot be done now because when converting locks, fields in\n\t   an active lkb cannot be modified before locking the rsb */\n\n\targs->flags = flags;\n\targs->astfn = ast;\n\targs->astparam = astparam;\n\targs->bastfn = bast;\n\targs->timeout = timeout_cs;\n\targs->mode = mode;\n\targs->lksb = lksb;\n\trv = 0;\n out:\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_lkb",
          "args": [
            "ls",
            "&lkb"
          ],
          "line": 3434
        },
        "resolved": true,
        "details": {
          "function_name": "create_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1184-1218",
          "snippet": "static int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_time_list);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tmutex_init(&lkb->lkb_cb_mutex);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, 1, 0, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_time_list);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tmutex_init(&lkb->lkb_cb_mutex);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, 1, 0, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lkb",
          "args": [
            "ls",
            "lksb->sb_lkid",
            "&lkb"
          ],
          "line": 3432
        },
        "resolved": true,
        "details": {
          "function_name": "find_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1220-1232",
          "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_recovery",
          "args": [
            "ls"
          ],
          "line": 3429
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_recovery_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "215-218",
          "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "lockspace"
          ],
          "line": 3425
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\n\t\t\t      astarg, bast, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
  },
  {
    "function_name": "cancel_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3383-3403",
    "snippet": "static int cancel_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _cancel_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 3401
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_cancel_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "_cancel_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3291-3306",
          "snippet": "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_cancel() calls do_cancel() on remote node */\n\t\terror = send_cancel(r, lkb);\n\t} else {\n\t\terror = do_cancel(r, lkb);\n\t\t/* for remote locks the cancel_reply is sent\n\t\t   between do_cancel and do_cancel_effects */\n\t\tdo_cancel_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_cancel() calls do_cancel() on remote node */\n\t\terror = send_cancel(r, lkb);\n\t} else {\n\t\terror = do_cancel(r, lkb);\n\t\t/* for remote locks the cancel_reply is sent\n\t\t   between do_cancel and do_cancel_effects */\n\t\tdo_cancel_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_unlock_args",
          "args": [
            "lkb",
            "args"
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "validate_unlock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2936-3064",
          "snippet": "static int validate_unlock_args(struct dlm_lkb *lkb, struct dlm_args *args)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv = -EINVAL;\n\n\tif (lkb->lkb_flags & DLM_IFL_MSTCPY) {\n\t\tlog_error(ls, \"unlock on MSTCPY %x\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tgoto out;\n\t}\n\n\t/* an lkb may still exist even though the lock is EOL'ed due to a\n\t   cancel, unlock or failed noqueue request; an app can't use these\n\t   locks; return same error as if the lkid had not been found at all */\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\tlog_debug(ls, \"unlock on ENDOFLIFE %x\", lkb->lkb_id);\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* an lkb may be waiting for an rsb lookup to complete where the\n\t   lookup was initiated by another lock */\n\n\tif (!list_empty(&lkb->lkb_rsb_lookup)) {\n\t\tif (args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) {\n\t\t\tlog_debug(ls, \"unlock on rsb_lookup %x\", lkb->lkb_id);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tqueue_cast(lkb->lkb_resource, lkb,\n\t\t\t\t   args->flags & DLM_LKF_CANCEL ?\n\t\t\t\t   -DLM_ECANCEL : -DLM_EUNLOCK);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t}\n\t\t/* caller changes -EBUSY to 0 for CANCEL and FORCEUNLOCK */\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* cancel not allowed with another cancel/unlock in progress */\n\n\tif (args->flags & DLM_LKF_CANCEL) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CANCEL)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* there's nothing to cancel */\n\t\tif (lkb->lkb_status == DLM_LKSTS_GRANTED &&\n\t\t    !lkb->lkb_wait_type) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_CANCEL */\n\t\tgoto out_ok;\n\t}\n\n\t/* do we need to allow a force-unlock if there's a normal unlock\n\t   already in progress?  in what conditions could the normal unlock\n\t   fail such that we'd want to send a force-unlock to be sure? */\n\n\tif (args->flags & DLM_LKF_FORCEUNLOCK) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK)\n\t\t\tgoto out;\n\n\t\tif (is_overlap_unlock(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_UNLOCK */\n\t\tgoto out_ok;\n\t}\n\n\t/* normal unlock not allowed if there's any op in progress */\n\trv = -EBUSY;\n\tif (lkb->lkb_wait_type || lkb->lkb_wait_count)\n\t\tgoto out;\n\n out_ok:\n\t/* an overlapping op shouldn't blow away exflags from other op */\n\tlkb->lkb_exflags |= args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astparam = args->astparam;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_unlock_args %d %x %x %x %x %d %s\", rv,\n\t\t\t  lkb->lkb_id, lkb->lkb_flags, lkb->lkb_exflags,\n\t\t\t  args->flags, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_unlock_args(struct dlm_lkb *lkb, struct dlm_args *args)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv = -EINVAL;\n\n\tif (lkb->lkb_flags & DLM_IFL_MSTCPY) {\n\t\tlog_error(ls, \"unlock on MSTCPY %x\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tgoto out;\n\t}\n\n\t/* an lkb may still exist even though the lock is EOL'ed due to a\n\t   cancel, unlock or failed noqueue request; an app can't use these\n\t   locks; return same error as if the lkid had not been found at all */\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\tlog_debug(ls, \"unlock on ENDOFLIFE %x\", lkb->lkb_id);\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* an lkb may be waiting for an rsb lookup to complete where the\n\t   lookup was initiated by another lock */\n\n\tif (!list_empty(&lkb->lkb_rsb_lookup)) {\n\t\tif (args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) {\n\t\t\tlog_debug(ls, \"unlock on rsb_lookup %x\", lkb->lkb_id);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tqueue_cast(lkb->lkb_resource, lkb,\n\t\t\t\t   args->flags & DLM_LKF_CANCEL ?\n\t\t\t\t   -DLM_ECANCEL : -DLM_EUNLOCK);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t}\n\t\t/* caller changes -EBUSY to 0 for CANCEL and FORCEUNLOCK */\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* cancel not allowed with another cancel/unlock in progress */\n\n\tif (args->flags & DLM_LKF_CANCEL) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CANCEL)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* there's nothing to cancel */\n\t\tif (lkb->lkb_status == DLM_LKSTS_GRANTED &&\n\t\t    !lkb->lkb_wait_type) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_CANCEL */\n\t\tgoto out_ok;\n\t}\n\n\t/* do we need to allow a force-unlock if there's a normal unlock\n\t   already in progress?  in what conditions could the normal unlock\n\t   fail such that we'd want to send a force-unlock to be sure? */\n\n\tif (args->flags & DLM_LKF_FORCEUNLOCK) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK)\n\t\t\tgoto out;\n\n\t\tif (is_overlap_unlock(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_UNLOCK */\n\t\tgoto out_ok;\n\t}\n\n\t/* normal unlock not allowed if there's any op in progress */\n\trv = -EBUSY;\n\tif (lkb->lkb_wait_type || lkb->lkb_wait_count)\n\t\tgoto out;\n\n out_ok:\n\t/* an overlapping op shouldn't blow away exflags from other op */\n\tlkb->lkb_exflags |= args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astparam = args->astparam;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_unlock_args %d %x %x %x %x %d %s\", rv,\n\t\t\t  lkb->lkb_id, lkb->lkb_flags, lkb->lkb_exflags,\n\t\t\t  args->flags, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int cancel_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _cancel_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
  },
  {
    "function_name": "unlock_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3361-3381",
    "snippet": "static int unlock_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _unlock_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 3379
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_unlock_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "_unlock_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3272-3287",
          "snippet": "static int _unlock_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_unlock() calls do_unlock() on remote node */\n\t\terror = send_unlock(r, lkb);\n\t} else {\n\t\terror = do_unlock(r, lkb);\n\t\t/* for remote locks the unlock_reply is sent\n\t\t   between do_unlock and do_unlock_effects */\n\t\tdo_unlock_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _unlock_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_unlock() calls do_unlock() on remote node */\n\t\terror = send_unlock(r, lkb);\n\t} else {\n\t\terror = do_unlock(r, lkb);\n\t\t/* for remote locks the unlock_reply is sent\n\t\t   between do_unlock and do_unlock_effects */\n\t\tdo_unlock_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_unlock_args",
          "args": [
            "lkb",
            "args"
          ],
          "line": 3372
        },
        "resolved": true,
        "details": {
          "function_name": "validate_unlock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2936-3064",
          "snippet": "static int validate_unlock_args(struct dlm_lkb *lkb, struct dlm_args *args)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv = -EINVAL;\n\n\tif (lkb->lkb_flags & DLM_IFL_MSTCPY) {\n\t\tlog_error(ls, \"unlock on MSTCPY %x\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tgoto out;\n\t}\n\n\t/* an lkb may still exist even though the lock is EOL'ed due to a\n\t   cancel, unlock or failed noqueue request; an app can't use these\n\t   locks; return same error as if the lkid had not been found at all */\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\tlog_debug(ls, \"unlock on ENDOFLIFE %x\", lkb->lkb_id);\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* an lkb may be waiting for an rsb lookup to complete where the\n\t   lookup was initiated by another lock */\n\n\tif (!list_empty(&lkb->lkb_rsb_lookup)) {\n\t\tif (args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) {\n\t\t\tlog_debug(ls, \"unlock on rsb_lookup %x\", lkb->lkb_id);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tqueue_cast(lkb->lkb_resource, lkb,\n\t\t\t\t   args->flags & DLM_LKF_CANCEL ?\n\t\t\t\t   -DLM_ECANCEL : -DLM_EUNLOCK);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t}\n\t\t/* caller changes -EBUSY to 0 for CANCEL and FORCEUNLOCK */\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* cancel not allowed with another cancel/unlock in progress */\n\n\tif (args->flags & DLM_LKF_CANCEL) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CANCEL)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* there's nothing to cancel */\n\t\tif (lkb->lkb_status == DLM_LKSTS_GRANTED &&\n\t\t    !lkb->lkb_wait_type) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_CANCEL */\n\t\tgoto out_ok;\n\t}\n\n\t/* do we need to allow a force-unlock if there's a normal unlock\n\t   already in progress?  in what conditions could the normal unlock\n\t   fail such that we'd want to send a force-unlock to be sure? */\n\n\tif (args->flags & DLM_LKF_FORCEUNLOCK) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK)\n\t\t\tgoto out;\n\n\t\tif (is_overlap_unlock(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_UNLOCK */\n\t\tgoto out_ok;\n\t}\n\n\t/* normal unlock not allowed if there's any op in progress */\n\trv = -EBUSY;\n\tif (lkb->lkb_wait_type || lkb->lkb_wait_count)\n\t\tgoto out;\n\n out_ok:\n\t/* an overlapping op shouldn't blow away exflags from other op */\n\tlkb->lkb_exflags |= args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astparam = args->astparam;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_unlock_args %d %x %x %x %x %d %s\", rv,\n\t\t\t  lkb->lkb_id, lkb->lkb_flags, lkb->lkb_exflags,\n\t\t\t  args->flags, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_unlock_args(struct dlm_lkb *lkb, struct dlm_args *args)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv = -EINVAL;\n\n\tif (lkb->lkb_flags & DLM_IFL_MSTCPY) {\n\t\tlog_error(ls, \"unlock on MSTCPY %x\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tgoto out;\n\t}\n\n\t/* an lkb may still exist even though the lock is EOL'ed due to a\n\t   cancel, unlock or failed noqueue request; an app can't use these\n\t   locks; return same error as if the lkid had not been found at all */\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\tlog_debug(ls, \"unlock on ENDOFLIFE %x\", lkb->lkb_id);\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* an lkb may be waiting for an rsb lookup to complete where the\n\t   lookup was initiated by another lock */\n\n\tif (!list_empty(&lkb->lkb_rsb_lookup)) {\n\t\tif (args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) {\n\t\t\tlog_debug(ls, \"unlock on rsb_lookup %x\", lkb->lkb_id);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tqueue_cast(lkb->lkb_resource, lkb,\n\t\t\t\t   args->flags & DLM_LKF_CANCEL ?\n\t\t\t\t   -DLM_ECANCEL : -DLM_EUNLOCK);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t}\n\t\t/* caller changes -EBUSY to 0 for CANCEL and FORCEUNLOCK */\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* cancel not allowed with another cancel/unlock in progress */\n\n\tif (args->flags & DLM_LKF_CANCEL) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CANCEL)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* there's nothing to cancel */\n\t\tif (lkb->lkb_status == DLM_LKSTS_GRANTED &&\n\t\t    !lkb->lkb_wait_type) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_CANCEL */\n\t\tgoto out_ok;\n\t}\n\n\t/* do we need to allow a force-unlock if there's a normal unlock\n\t   already in progress?  in what conditions could the normal unlock\n\t   fail such that we'd want to send a force-unlock to be sure? */\n\n\tif (args->flags & DLM_LKF_FORCEUNLOCK) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK)\n\t\t\tgoto out;\n\n\t\tif (is_overlap_unlock(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_UNLOCK */\n\t\tgoto out_ok;\n\t}\n\n\t/* normal unlock not allowed if there's any op in progress */\n\trv = -EBUSY;\n\tif (lkb->lkb_wait_type || lkb->lkb_wait_count)\n\t\tgoto out;\n\n out_ok:\n\t/* an overlapping op shouldn't blow away exflags from other op */\n\tlkb->lkb_exflags |= args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astparam = args->astparam;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_unlock_args %d %x %x %x %x %d %s\", rv,\n\t\t\t  lkb->lkb_id, lkb->lkb_flags, lkb->lkb_exflags,\n\t\t\t  args->flags, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int unlock_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _unlock_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
  },
  {
    "function_name": "convert_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3339-3359",
    "snippet": "static int convert_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\tstruct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _convert_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 3356
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_convert_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3354
        },
        "resolved": true,
        "details": {
          "function_name": "_convert_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3253-3268",
          "snippet": "static int _convert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_convert() calls do_convert() on remote node */\n\t\terror = send_convert(r, lkb);\n\t} else {\n\t\terror = do_convert(r, lkb);\n\t\t/* for remote locks the convert_reply is sent\n\t\t   between do_convert and do_convert_effects */\n\t\tdo_convert_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _convert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_convert() calls do_convert() on remote node */\n\t\terror = send_convert(r, lkb);\n\t} else {\n\t\terror = do_convert(r, lkb);\n\t\t/* for remote locks the convert_reply is sent\n\t\t   between do_convert and do_convert_effects */\n\t\tdo_convert_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_lock_args",
          "args": [
            "ls",
            "lkb",
            "args"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "validate_lock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2885-2927",
          "snippet": "static int validate_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t      struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\tif (args->flags & DLM_LKF_CONVERT) {\n\t\tif (lkb->lkb_flags & DLM_IFL_MSTCPY)\n\t\t\tgoto out;\n\n\t\tif (args->flags & DLM_LKF_QUECVT &&\n\t\t    !__quecvt_compat_matrix[lkb->lkb_grmode+1][args->mode+1])\n\t\t\tgoto out;\n\n\t\trv = -EBUSY;\n\t\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\t\tgoto out;\n\n\t\tif (lkb->lkb_wait_type)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astfn = args->astfn;\n\tlkb->lkb_astparam = args->astparam;\n\tlkb->lkb_bastfn = args->bastfn;\n\tlkb->lkb_rqmode = args->mode;\n\tlkb->lkb_lksb = args->lksb;\n\tlkb->lkb_lvbptr = args->lksb->sb_lvbptr;\n\tlkb->lkb_ownpid = (int) current->pid;\n\tlkb->lkb_timeout_cs = args->timeout;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_lock_args %d %x %x %x %d %d %s\",\n\t\t\t  rv, lkb->lkb_id, lkb->lkb_flags, args->flags,\n\t\t\t  lkb->lkb_status, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);",
            "static void del_timeout(struct dlm_lkb *lkb);",
            "static const int __quecvt_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* UN */\n        {0, 0, 1, 1, 1, 1, 1, 0},       /* NL */\n        {0, 0, 0, 1, 1, 1, 1, 0},       /* CR */\n        {0, 0, 0, 0, 1, 1, 1, 0},       /* CW */\n        {0, 0, 0, 1, 0, 1, 1, 0},       /* PR */\n        {0, 0, 0, 0, 0, 0, 1, 0},       /* PW */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\nstatic void del_timeout(struct dlm_lkb *lkb);\nstatic const int __quecvt_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* UN */\n        {0, 0, 1, 1, 1, 1, 1, 0},       /* NL */\n        {0, 0, 0, 1, 1, 1, 1, 0},       /* CR */\n        {0, 0, 0, 0, 1, 1, 1, 0},       /* CW */\n        {0, 0, 0, 1, 0, 1, 1, 0},       /* PR */\n        {0, 0, 0, 0, 0, 0, 1, 0},       /* PW */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};\n\nstatic int validate_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t      struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\tif (args->flags & DLM_LKF_CONVERT) {\n\t\tif (lkb->lkb_flags & DLM_IFL_MSTCPY)\n\t\t\tgoto out;\n\n\t\tif (args->flags & DLM_LKF_QUECVT &&\n\t\t    !__quecvt_compat_matrix[lkb->lkb_grmode+1][args->mode+1])\n\t\t\tgoto out;\n\n\t\trv = -EBUSY;\n\t\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\t\tgoto out;\n\n\t\tif (lkb->lkb_wait_type)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astfn = args->astfn;\n\tlkb->lkb_astparam = args->astparam;\n\tlkb->lkb_bastfn = args->bastfn;\n\tlkb->lkb_rqmode = args->mode;\n\tlkb->lkb_lksb = args->lksb;\n\tlkb->lkb_lvbptr = args->lksb->sb_lvbptr;\n\tlkb->lkb_ownpid = (int) current->pid;\n\tlkb->lkb_timeout_cs = args->timeout;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_lock_args %d %x %x %x %d %d %s\",\n\t\t\t  rv, lkb->lkb_id, lkb->lkb_flags, args->flags,\n\t\t\t  lkb->lkb_status, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 3347
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int convert_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\tstruct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _convert_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
  },
  {
    "function_name": "request_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3313-3337",
    "snippet": "static int request_lock(struct dlm_ls *ls, struct dlm_lkb *lkb, char *name,\n\t\t\tint len, struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\treturn error;\n\n\terror = find_rsb(ls, name, len, 0, R_REQUEST, &r);\n\tif (error)\n\t\treturn error;\n\n\tlock_rsb(r);\n\n\tattach_lkb(r, lkb);\n\tlkb->lkb_lksb->sb_lkid = lkb->lkb_id;\n\n\terror = _request_lock(r, lkb);\n\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 3335
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_request_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3332
        },
        "resolved": true,
        "details": {
          "function_name": "_request_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3224-3249",
          "snippet": "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_lkb",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "attach_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1170-1174",
          "snippet": "static void attach_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\thold_rsb(r);\n\tlkb->lkb_resource = r;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void attach_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\thold_rsb(r);\n\tlkb->lkb_resource = r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_rsb",
          "args": [
            "ls",
            "name",
            "len",
            "0",
            "R_REQUEST",
            "&r"
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "find_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "818-838",
          "snippet": "static int find_rsb(struct dlm_ls *ls, char *name, int len, int from_nodeid,\n\t\t    unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tuint32_t hash, b;\n\tint dir_nodeid;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tif (dlm_no_directory(ls))\n\t\treturn find_rsb_nodir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n\telse\n\t\treturn find_rsb_dir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int find_rsb(struct dlm_ls *ls, char *name, int len, int from_nodeid,\n\t\t    unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tuint32_t hash, b;\n\tint dir_nodeid;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tif (dlm_no_directory(ls))\n\t\treturn find_rsb_nodir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n\telse\n\t\treturn find_rsb_dir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_lock_args",
          "args": [
            "ls",
            "lkb",
            "args"
          ],
          "line": 3319
        },
        "resolved": true,
        "details": {
          "function_name": "validate_lock_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2885-2927",
          "snippet": "static int validate_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t      struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\tif (args->flags & DLM_LKF_CONVERT) {\n\t\tif (lkb->lkb_flags & DLM_IFL_MSTCPY)\n\t\t\tgoto out;\n\n\t\tif (args->flags & DLM_LKF_QUECVT &&\n\t\t    !__quecvt_compat_matrix[lkb->lkb_grmode+1][args->mode+1])\n\t\t\tgoto out;\n\n\t\trv = -EBUSY;\n\t\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\t\tgoto out;\n\n\t\tif (lkb->lkb_wait_type)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astfn = args->astfn;\n\tlkb->lkb_astparam = args->astparam;\n\tlkb->lkb_bastfn = args->bastfn;\n\tlkb->lkb_rqmode = args->mode;\n\tlkb->lkb_lksb = args->lksb;\n\tlkb->lkb_lvbptr = args->lksb->sb_lvbptr;\n\tlkb->lkb_ownpid = (int) current->pid;\n\tlkb->lkb_timeout_cs = args->timeout;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_lock_args %d %x %x %x %d %d %s\",\n\t\t\t  rv, lkb->lkb_id, lkb->lkb_flags, args->flags,\n\t\t\t  lkb->lkb_status, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);",
            "static void del_timeout(struct dlm_lkb *lkb);",
            "static const int __quecvt_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* UN */\n        {0, 0, 1, 1, 1, 1, 1, 0},       /* NL */\n        {0, 0, 0, 1, 1, 1, 1, 0},       /* CR */\n        {0, 0, 0, 0, 1, 1, 1, 0},       /* CW */\n        {0, 0, 0, 1, 0, 1, 1, 0},       /* PR */\n        {0, 0, 0, 0, 0, 0, 1, 0},       /* PW */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\nstatic void del_timeout(struct dlm_lkb *lkb);\nstatic const int __quecvt_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* UN */\n        {0, 0, 1, 1, 1, 1, 1, 0},       /* NL */\n        {0, 0, 0, 1, 1, 1, 1, 0},       /* CR */\n        {0, 0, 0, 0, 1, 1, 1, 0},       /* CW */\n        {0, 0, 0, 1, 0, 1, 1, 0},       /* PR */\n        {0, 0, 0, 0, 0, 0, 1, 0},       /* PW */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};\n\nstatic int validate_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t      struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\tif (args->flags & DLM_LKF_CONVERT) {\n\t\tif (lkb->lkb_flags & DLM_IFL_MSTCPY)\n\t\t\tgoto out;\n\n\t\tif (args->flags & DLM_LKF_QUECVT &&\n\t\t    !__quecvt_compat_matrix[lkb->lkb_grmode+1][args->mode+1])\n\t\t\tgoto out;\n\n\t\trv = -EBUSY;\n\t\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\t\tgoto out;\n\n\t\tif (lkb->lkb_wait_type)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astfn = args->astfn;\n\tlkb->lkb_astparam = args->astparam;\n\tlkb->lkb_bastfn = args->bastfn;\n\tlkb->lkb_rqmode = args->mode;\n\tlkb->lkb_lksb = args->lksb;\n\tlkb->lkb_lvbptr = args->lksb->sb_lvbptr;\n\tlkb->lkb_ownpid = (int) current->pid;\n\tlkb->lkb_timeout_cs = args->timeout;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_lock_args %d %x %x %x %d %d %s\",\n\t\t\t  rv, lkb->lkb_id, lkb->lkb_flags, args->flags,\n\t\t\t  lkb->lkb_status, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int request_lock(struct dlm_ls *ls, struct dlm_lkb *lkb, char *name,\n\t\t\tint len, struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\treturn error;\n\n\terror = find_rsb(ls, name, len, 0, R_REQUEST, &r);\n\tif (error)\n\t\treturn error;\n\n\tlock_rsb(r);\n\n\tattach_lkb(r, lkb);\n\tlkb->lkb_lksb->sb_lkid = lkb->lkb_id;\n\n\terror = _request_lock(r, lkb);\n\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}"
  },
  {
    "function_name": "_cancel_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3291-3306",
    "snippet": "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_cancel() calls do_cancel() on remote node */\n\t\terror = send_cancel(r, lkb);\n\t} else {\n\t\terror = do_cancel(r, lkb);\n\t\t/* for remote locks the cancel_reply is sent\n\t\t   between do_cancel and do_cancel_effects */\n\t\tdo_cancel_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_cancel_effects",
          "args": [
            "r",
            "lkb",
            "error"
          ],
          "line": 3302
        },
        "resolved": true,
        "details": {
          "function_name": "do_cancel_effects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3210-3215",
          "snippet": "static void do_cancel_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tif (error)\n\t\tgrant_pending_locks(r, NULL);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_cancel_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tif (error)\n\t\tgrant_pending_locks(r, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cancel",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3299
        },
        "resolved": true,
        "details": {
          "function_name": "do_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3198-3208",
          "snippet": "static int do_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = revert_lock(r, lkb);\n\tif (error) {\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\treturn -DLM_ECANCEL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = revert_lock(r, lkb);\n\tif (error) {\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\treturn -DLM_ECANCEL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cancel",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3297
        },
        "resolved": true,
        "details": {
          "function_name": "send_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3701-3704",
          "snippet": "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_CANCEL);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_CANCEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_remote",
          "args": [
            "r"
          ],
          "line": 3295
        },
        "resolved": true,
        "details": {
          "function_name": "is_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "245-249",
          "snippet": "static inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_cancel() calls do_cancel() on remote node */\n\t\terror = send_cancel(r, lkb);\n\t} else {\n\t\terror = do_cancel(r, lkb);\n\t\t/* for remote locks the cancel_reply is sent\n\t\t   between do_cancel and do_cancel_effects */\n\t\tdo_cancel_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "_unlock_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3272-3287",
    "snippet": "static int _unlock_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_unlock() calls do_unlock() on remote node */\n\t\terror = send_unlock(r, lkb);\n\t} else {\n\t\terror = do_unlock(r, lkb);\n\t\t/* for remote locks the unlock_reply is sent\n\t\t   between do_unlock and do_unlock_effects */\n\t\tdo_unlock_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_unlock_effects",
          "args": [
            "r",
            "lkb",
            "error"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "do_unlock_effects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3190-3194",
          "snippet": "static void do_unlock_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tgrant_pending_locks(r, NULL);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_unlock_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tgrant_pending_locks(r, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_unlock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "do_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3183-3188",
          "snippet": "static int do_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tremove_lock(r, lkb);\n\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\treturn -DLM_EUNLOCK;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tremove_lock(r, lkb);\n\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\treturn -DLM_EUNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_unlock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3278
        },
        "resolved": true,
        "details": {
          "function_name": "send_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3696-3699",
          "snippet": "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_UNLOCK);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_UNLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_remote",
          "args": [
            "r"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "is_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "245-249",
          "snippet": "static inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _unlock_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_unlock() calls do_unlock() on remote node */\n\t\terror = send_unlock(r, lkb);\n\t} else {\n\t\terror = do_unlock(r, lkb);\n\t\t/* for remote locks the unlock_reply is sent\n\t\t   between do_unlock and do_unlock_effects */\n\t\tdo_unlock_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "_convert_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3253-3268",
    "snippet": "static int _convert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_convert() calls do_convert() on remote node */\n\t\terror = send_convert(r, lkb);\n\t} else {\n\t\terror = do_convert(r, lkb);\n\t\t/* for remote locks the convert_reply is sent\n\t\t   between do_convert and do_convert_effects */\n\t\tdo_convert_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_convert_effects",
          "args": [
            "r",
            "lkb",
            "error"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert_effects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3165-3181",
          "snippet": "static void do_convert_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase 0:\n\t\tgrant_pending_locks(r, NULL);\n\t\t/* grant_pending_locks also sends basts */\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_convert_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase 0:\n\t\tgrant_pending_locks(r, NULL);\n\t\t/* grant_pending_locks also sends basts */\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_convert",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "do_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3110-3163",
          "snippet": "static int do_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\tint deadlk = 0;\n\n\t/* changing an existing lock may allow others to be granted */\n\n\tif (can_be_granted(r, lkb, 1, 0, &deadlk)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\t/* can_be_granted() detected that this lock would block in a conversion\n\t   deadlock, so we leave it on the granted queue and return EDEADLK in\n\t   the ast for the convert. */\n\n\tif (deadlk) {\n\t\t/* it's left on the granted queue */\n\t\trevert_lock(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\terror = -EDEADLK;\n\t\tgoto out;\n\t}\n\n\t/* is_demoted() means the can_be_granted() above set the grmode\n\t   to NL, and left us on the granted queue.  This auto-demotion\n\t   (due to CONVDEADLK) might mean other locks, and/or this lock, are\n\t   now grantable.  We have to try to grant other converting locks\n\t   before we try again to grant this one. */\n\n\tif (is_demoted(lkb)) {\n\t\tgrant_pending_convert(r, DLM_LOCK_IV, NULL, NULL);\n\t\tif (_can_be_granted(r, lkb, 1, 0)) {\n\t\t\tgrant_lock(r, lkb);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t\tgoto out;\n\t\t}\n\t\t/* else fall through and move to convert queue */\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\tint deadlk = 0;\n\n\t/* changing an existing lock may allow others to be granted */\n\n\tif (can_be_granted(r, lkb, 1, 0, &deadlk)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\t/* can_be_granted() detected that this lock would block in a conversion\n\t   deadlock, so we leave it on the granted queue and return EDEADLK in\n\t   the ast for the convert. */\n\n\tif (deadlk) {\n\t\t/* it's left on the granted queue */\n\t\trevert_lock(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\terror = -EDEADLK;\n\t\tgoto out;\n\t}\n\n\t/* is_demoted() means the can_be_granted() above set the grmode\n\t   to NL, and left us on the granted queue.  This auto-demotion\n\t   (due to CONVDEADLK) might mean other locks, and/or this lock, are\n\t   now grantable.  We have to try to grant other converting locks\n\t   before we try again to grant this one. */\n\n\tif (is_demoted(lkb)) {\n\t\tgrant_pending_convert(r, DLM_LOCK_IV, NULL, NULL);\n\t\tif (_can_be_granted(r, lkb, 1, 0)) {\n\t\t\tgrant_lock(r, lkb);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t\tgoto out;\n\t\t}\n\t\t/* else fall through and move to convert queue */\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_convert",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3259
        },
        "resolved": true,
        "details": {
          "function_name": "send_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3674-3690",
          "snippet": "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = send_common(r, lkb, DLM_MSG_CONVERT);\n\n\t/* down conversions go without a reply from the master */\n\tif (!error && down_conversion(lkb)) {\n\t\tremove_from_waiters(lkb, DLM_MSG_CONVERT_REPLY);\n\t\tr->res_ls->ls_stub_ms.m_flags = DLM_IFL_STUB_MS;\n\t\tr->res_ls->ls_stub_ms.m_type = DLM_MSG_CONVERT_REPLY;\n\t\tr->res_ls->ls_stub_ms.m_result = 0;\n\t\t__receive_convert_reply(r, lkb, &r->res_ls->ls_stub_ms);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = send_common(r, lkb, DLM_MSG_CONVERT);\n\n\t/* down conversions go without a reply from the master */\n\tif (!error && down_conversion(lkb)) {\n\t\tremove_from_waiters(lkb, DLM_MSG_CONVERT_REPLY);\n\t\tr->res_ls->ls_stub_ms.m_flags = DLM_IFL_STUB_MS;\n\t\tr->res_ls->ls_stub_ms.m_type = DLM_MSG_CONVERT_REPLY;\n\t\tr->res_ls->ls_stub_ms.m_result = 0;\n\t\t__receive_convert_reply(r, lkb, &r->res_ls->ls_stub_ms);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_remote",
          "args": [
            "r"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "is_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "245-249",
          "snippet": "static inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _convert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_convert() calls do_convert() on remote node */\n\t\terror = send_convert(r, lkb);\n\t} else {\n\t\terror = do_convert(r, lkb);\n\t\t/* for remote locks the convert_reply is sent\n\t\t   between do_convert and do_convert_effects */\n\t\tdo_convert_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "_request_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3224-3249",
    "snippet": "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_request_effects",
          "args": [
            "r",
            "lkb",
            "error"
          ],
          "line": 3245
        },
        "resolved": true,
        "details": {
          "function_name": "do_request_effects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3096-3108",
          "snippet": "static void do_request_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_request_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_request",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3242
        },
        "resolved": true,
        "details": {
          "function_name": "do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3073-3094",
          "snippet": "static int do_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\n\tif (can_be_granted(r, lkb, 1, 0, NULL)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\n\tif (can_be_granted(r, lkb, 1, 0, NULL)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_request",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "send_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3669-3672",
          "snippet": "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_REQUEST);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_REQUEST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_remote",
          "args": [
            "r"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "is_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "245-249",
          "snippet": "static inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_master",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3230
        },
        "resolved": true,
        "details": {
          "function_name": "set_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2706-2753",
          "snippet": "static int set_master(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint our_nodeid = dlm_our_nodeid();\n\n\tif (rsb_flag(r, RSB_MASTER_UNCERTAIN)) {\n\t\trsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = lkb->lkb_id;\n\t\tlkb->lkb_nodeid = r->res_nodeid;\n\t\treturn 0;\n\t}\n\n\tif (r->res_first_lkid && r->res_first_lkid != lkb->lkb_id) {\n\t\tlist_add_tail(&lkb->lkb_rsb_lookup, &r->res_lookup);\n\t\treturn 1;\n\t}\n\n\tif (r->res_master_nodeid == our_nodeid) {\n\t\tlkb->lkb_nodeid = 0;\n\t\treturn 0;\n\t}\n\n\tif (r->res_master_nodeid) {\n\t\tlkb->lkb_nodeid = r->res_master_nodeid;\n\t\treturn 0;\n\t}\n\n\tif (dlm_dir_nodeid(r) == our_nodeid) {\n\t\t/* This is a somewhat unusual case; find_rsb will usually\n\t\t   have set res_master_nodeid when dir nodeid is local, but\n\t\t   there are cases where we become the dir node after we've\n\t\t   past find_rsb and go through _request_lock again.\n\t\t   confirm_master() or process_lookup_list() needs to be\n\t\t   called after this. */\n\t\tlog_debug(r->res_ls, \"set_master %x self master %d dir %d %s\",\n\t\t\t  lkb->lkb_id, r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t  r->res_name);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tlkb->lkb_nodeid = 0;\n\t\treturn 0;\n\t}\n\n\twait_pending_remove(r);\n\n\tr->res_first_lkid = lkb->lkb_id;\n\tsend_lookup(r, lkb);\n\treturn 1;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int set_master(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint our_nodeid = dlm_our_nodeid();\n\n\tif (rsb_flag(r, RSB_MASTER_UNCERTAIN)) {\n\t\trsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = lkb->lkb_id;\n\t\tlkb->lkb_nodeid = r->res_nodeid;\n\t\treturn 0;\n\t}\n\n\tif (r->res_first_lkid && r->res_first_lkid != lkb->lkb_id) {\n\t\tlist_add_tail(&lkb->lkb_rsb_lookup, &r->res_lookup);\n\t\treturn 1;\n\t}\n\n\tif (r->res_master_nodeid == our_nodeid) {\n\t\tlkb->lkb_nodeid = 0;\n\t\treturn 0;\n\t}\n\n\tif (r->res_master_nodeid) {\n\t\tlkb->lkb_nodeid = r->res_master_nodeid;\n\t\treturn 0;\n\t}\n\n\tif (dlm_dir_nodeid(r) == our_nodeid) {\n\t\t/* This is a somewhat unusual case; find_rsb will usually\n\t\t   have set res_master_nodeid when dir nodeid is local, but\n\t\t   there are cases where we become the dir node after we've\n\t\t   past find_rsb and go through _request_lock again.\n\t\t   confirm_master() or process_lookup_list() needs to be\n\t\t   called after this. */\n\t\tlog_debug(r->res_ls, \"set_master %x self master %d dir %d %s\",\n\t\t\t  lkb->lkb_id, r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t  r->res_name);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tlkb->lkb_nodeid = 0;\n\t\treturn 0;\n\t}\n\n\twait_pending_remove(r);\n\n\tr->res_first_lkid = lkb->lkb_id;\n\tsend_lookup(r, lkb);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "do_cancel_effects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3210-3215",
    "snippet": "static void do_cancel_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tif (error)\n\t\tgrant_pending_locks(r, NULL);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "grant_pending_locks",
          "args": [
            "r",
            "NULL"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "grant_pending_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2610-2644",
          "snippet": "static void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t/*\n\t * If there are locks left on the wait/convert queue then send blocking\n\t * ASTs to granted locks based on the largest requested mode (high)\n\t * found above.\n\t */\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t/*\n\t * If there are locks left on the wait/convert queue then send blocking\n\t * ASTs to granted locks based on the largest requested mode (high)\n\t * found above.\n\t */\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_cancel_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tif (error)\n\t\tgrant_pending_locks(r, NULL);\n}"
  },
  {
    "function_name": "do_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3198-3208",
    "snippet": "static int do_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = revert_lock(r, lkb);\n\tif (error) {\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\treturn -DLM_ECANCEL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "-DLM_ECANCEL"
          ],
          "line": 3204
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "revert_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "revert_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2110-2113",
          "snippet": "static int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = revert_lock(r, lkb);\n\tif (error) {\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\treturn -DLM_ECANCEL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_unlock_effects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3190-3194",
    "snippet": "static void do_unlock_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tgrant_pending_locks(r, NULL);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "grant_pending_locks",
          "args": [
            "r",
            "NULL"
          ],
          "line": 3193
        },
        "resolved": true,
        "details": {
          "function_name": "grant_pending_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2610-2644",
          "snippet": "static void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t/*\n\t * If there are locks left on the wait/convert queue then send blocking\n\t * ASTs to granted locks based on the largest requested mode (high)\n\t * found above.\n\t */\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t/*\n\t * If there are locks left on the wait/convert queue then send blocking\n\t * ASTs to granted locks based on the largest requested mode (high)\n\t * found above.\n\t */\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_unlock_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tgrant_pending_locks(r, NULL);\n}"
  },
  {
    "function_name": "do_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3183-3188",
    "snippet": "static int do_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tremove_lock(r, lkb);\n\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\treturn -DLM_EUNLOCK;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "-DLM_EUNLOCK"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3185
        },
        "resolved": true,
        "details": {
          "function_name": "remove_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2074-2077",
          "snippet": "static void remove_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\t_remove_lock(r, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void remove_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\t_remove_lock(r, lkb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tremove_lock(r, lkb);\n\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\treturn -DLM_EUNLOCK;\n}"
  },
  {
    "function_name": "do_convert_effects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3165-3181",
    "snippet": "static void do_convert_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase 0:\n\t\tgrant_pending_locks(r, NULL);\n\t\t/* grant_pending_locks also sends basts */\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_blocking_asts",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3178
        },
        "resolved": true,
        "details": {
          "function_name": "send_blocking_asts_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2681-2685",
          "snippet": "static void send_blocking_asts_all(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tsend_bast_queue(r, &r->res_grantqueue, lkb);\n\tsend_bast_queue(r, &r->res_convertqueue, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_blocking_asts_all(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tsend_bast_queue(r, &r->res_grantqueue, lkb);\n\tsend_bast_queue(r, &r->res_convertqueue, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_blocking_asts",
          "args": [
            "lkb"
          ],
          "line": 3174
        },
        "resolved": true,
        "details": {
          "function_name": "force_blocking_asts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "225-228",
          "snippet": "static inline int force_blocking_asts(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_exflags & DLM_LKF_NOQUEUEBAST);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int force_blocking_asts(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_exflags & DLM_LKF_NOQUEUEBAST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_pending_locks",
          "args": [
            "r",
            "NULL"
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "grant_pending_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2610-2644",
          "snippet": "static void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t/*\n\t * If there are locks left on the wait/convert queue then send blocking\n\t * ASTs to granted locks based on the largest requested mode (high)\n\t * found above.\n\t */\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t/*\n\t * If there are locks left on the wait/convert queue then send blocking\n\t * ASTs to granted locks based on the largest requested mode (high)\n\t * found above.\n\t */\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_convert_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase 0:\n\t\tgrant_pending_locks(r, NULL);\n\t\t/* grant_pending_locks also sends basts */\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "do_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3110-3163",
    "snippet": "static int do_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\tint deadlk = 0;\n\n\t/* changing an existing lock may allow others to be granted */\n\n\tif (can_be_granted(r, lkb, 1, 0, &deadlk)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\t/* can_be_granted() detected that this lock would block in a conversion\n\t   deadlock, so we leave it on the granted queue and return EDEADLK in\n\t   the ast for the convert. */\n\n\tif (deadlk) {\n\t\t/* it's left on the granted queue */\n\t\trevert_lock(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\terror = -EDEADLK;\n\t\tgoto out;\n\t}\n\n\t/* is_demoted() means the can_be_granted() above set the grmode\n\t   to NL, and left us on the granted queue.  This auto-demotion\n\t   (due to CONVDEADLK) might mean other locks, and/or this lock, are\n\t   now grantable.  We have to try to grant other converting locks\n\t   before we try again to grant this one. */\n\n\tif (is_demoted(lkb)) {\n\t\tgrant_pending_convert(r, DLM_LOCK_IV, NULL, NULL);\n\t\tif (_can_be_granted(r, lkb, 1, 0)) {\n\t\t\tgrant_lock(r, lkb);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t\tgoto out;\n\t\t}\n\t\t/* else fall through and move to convert queue */\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "-EAGAIN"
          ],
          "line": 3160
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timeout",
          "args": [
            "lkb"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "add_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1815-1837",
          "snippet": "static void add_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\n\t    !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\tlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\n\t\tgoto add_it;\n\t}\n\tif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\n\t\tgoto add_it;\n\treturn;\n\n add_it:\n\tDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\n\tmutex_lock(&ls->ls_timeout_mutex);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\n\t    !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\tlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\n\t\tgoto add_it;\n\t}\n\tif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\n\t\tgoto add_it;\n\treturn;\n\n add_it:\n\tDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\n\tmutex_lock(&ls->ls_timeout_mutex);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_lkb",
          "args": [
            "r",
            "lkb",
            "DLM_LKSTS_CONVERT"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "add_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1314-1346",
          "snippet": "static void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_lkb",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3153
        },
        "resolved": true,
        "details": {
          "function_name": "del_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1348-1353",
          "snippet": "static void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_be_queued",
          "args": [
            "lkb"
          ],
          "line": 3151
        },
        "resolved": true,
        "details": {
          "function_name": "can_be_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "220-223",
          "snippet": "static inline int can_be_queued(struct dlm_lkb *lkb)\n{\n\treturn !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int can_be_queued(struct dlm_lkb *lkb)\n{\n\treturn !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "grant_lock_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2146-2153",
          "snippet": "static void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_can_be_granted",
          "args": [
            "r",
            "lkb",
            "1",
            "0"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "_can_be_granted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2298-2442",
          "snippet": "static int _can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t   int recover)\n{\n\tint8_t conv = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\t/*\n\t * 6-10: Version 5.4 introduced an option to address the phenomenon of\n\t * a new request for a NL mode lock being blocked.\n\t *\n\t * 6-11: If the optional EXPEDITE flag is used with the new NL mode\n\t * request, then it would be granted.  In essence, the use of this flag\n\t * tells the Lock Manager to expedite theis request by not considering\n\t * what may be in the CONVERTING or WAITING queues...  As of this\n\t * writing, the EXPEDITE flag can be used only with new requests for NL\n\t * mode locks.  This flag is not valid for conversion requests.\n\t *\n\t * A shortcut.  Earlier checks return an error if EXPEDITE is used in a\n\t * conversion or used with a non-NL requested mode.  We also know an\n\t * EXPEDITE request is always granted immediately, so now must always\n\t * be 1.  The full condition to grant an expedite request: (now &&\n\t * !conv && lkb->rqmode == DLM_LOCK_NL && (flags & EXPEDITE)) can\n\t * therefore be shortened to just checking the flag.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_EXPEDITE)\n\t\treturn 1;\n\n\t/*\n\t * A shortcut. Without this, !queue_conflict(grantqueue, lkb) would be\n\t * added to the remaining conditions.\n\t */\n\n\tif (queue_conflict(&r->res_grantqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * 6-3: By default, a conversion request is immediately granted if the\n\t * requested mode is compatible with the modes of all other granted\n\t * locks\n\t */\n\n\tif (queue_conflict(&r->res_convertqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * The RECOVER_GRANT flag means dlm_recover_grant() is granting\n\t * locks for a recovered rsb, on which lkb's have been rebuilt.\n\t * The lkb's may have been rebuilt on the queues in a different\n\t * order than they were in on the previous master.  So, granting\n\t * queued conversions in order after recovery doesn't make sense\n\t * since the order hasn't been preserved anyway.  The new order\n\t * could also have created a new \"in place\" conversion deadlock.\n\t * (e.g. old, failed master held granted EX, with PR->EX, NL->EX.\n\t * After recovery, there would be no granted locks, and possibly\n\t * NL->EX, PR->EX, an in-place conversion deadlock.)  So, after\n\t * recovery, grant conversions without considering order.\n\t */\n\n\tif (conv && recover)\n\t\treturn 1;\n\n\t/*\n\t * 6-5: But the default algorithm for deciding whether to grant or\n\t * queue conversion requests does not by itself guarantee that such\n\t * requests are serviced on a \"first come first serve\" basis.  This, in\n\t * turn, can lead to a phenomenon known as \"indefinate postponement\".\n\t *\n\t * 6-7: This issue is dealt with by using the optional QUECVT flag with\n\t * the system service employed to request a lock conversion.  This flag\n\t * forces certain conversion requests to be queued, even if they are\n\t * compatible with the granted modes of other locks on the same\n\t * resource.  Thus, the use of this flag results in conversion requests\n\t * being ordered on a \"first come first servce\" basis.\n\t *\n\t * DCT: This condition is all about new conversions being able to occur\n\t * \"in place\" while the lock remains on the granted queue (assuming\n\t * nothing else conflicts.)  IOW if QUECVT isn't set, a conversion\n\t * doesn't _have_ to go onto the convert queue where it's processed in\n\t * order.  The \"now\" variable is necessary to distinguish converts\n\t * being received and processed for the first time now, because once a\n\t * convert is moved to the conversion queue the condition below applies\n\t * requiring fifo granting.\n\t */\n\n\tif (now && conv && !(lkb->lkb_exflags & DLM_LKF_QUECVT))\n\t\treturn 1;\n\n\t/*\n\t * Even if the convert is compat with all granted locks,\n\t * QUECVT forces it behind other locks on the convert queue.\n\t */\n\n\tif (now && conv && (lkb->lkb_exflags & DLM_LKF_QUECVT)) {\n\t\tif (list_empty(&r->res_convertqueue))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * The NOORDER flag is set to avoid the standard vms rules on grant\n\t * order.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_NOORDER)\n\t\treturn 1;\n\n\t/*\n\t * 6-3: Once in that queue [CONVERTING], a conversion request cannot be\n\t * granted until all other conversion requests ahead of it are granted\n\t * and/or canceled.\n\t */\n\n\tif (!now && conv && first_in_list(lkb, &r->res_convertqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: By default, a new request is immediately granted only if all\n\t * three of the following conditions are satisfied when the request is\n\t * issued:\n\t * - The queue of ungranted conversion requests for the resource is\n\t *   empty.\n\t * - The queue of ungranted new requests for the resource is empty.\n\t * - The mode of the new request is compatible with the most\n\t *   restrictive mode of all granted locks on the resource.\n\t */\n\n\tif (now && !conv && list_empty(&r->res_convertqueue) &&\n\t    list_empty(&r->res_waitqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: Once a lock request is in the queue of ungranted new requests,\n\t * it cannot be granted until the queue of ungranted conversion\n\t * requests is empty, all ungranted new requests ahead of it are\n\t * granted and/or canceled, and it is compatible with the granted mode\n\t * of the most restrictive lock granted on the resource.\n\t */\n\n\tif (!now && !conv && list_empty(&r->res_convertqueue) &&\n\t    first_in_list(lkb, &r->res_waitqueue))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t   int recover)\n{\n\tint8_t conv = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\t/*\n\t * 6-10: Version 5.4 introduced an option to address the phenomenon of\n\t * a new request for a NL mode lock being blocked.\n\t *\n\t * 6-11: If the optional EXPEDITE flag is used with the new NL mode\n\t * request, then it would be granted.  In essence, the use of this flag\n\t * tells the Lock Manager to expedite theis request by not considering\n\t * what may be in the CONVERTING or WAITING queues...  As of this\n\t * writing, the EXPEDITE flag can be used only with new requests for NL\n\t * mode locks.  This flag is not valid for conversion requests.\n\t *\n\t * A shortcut.  Earlier checks return an error if EXPEDITE is used in a\n\t * conversion or used with a non-NL requested mode.  We also know an\n\t * EXPEDITE request is always granted immediately, so now must always\n\t * be 1.  The full condition to grant an expedite request: (now &&\n\t * !conv && lkb->rqmode == DLM_LOCK_NL && (flags & EXPEDITE)) can\n\t * therefore be shortened to just checking the flag.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_EXPEDITE)\n\t\treturn 1;\n\n\t/*\n\t * A shortcut. Without this, !queue_conflict(grantqueue, lkb) would be\n\t * added to the remaining conditions.\n\t */\n\n\tif (queue_conflict(&r->res_grantqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * 6-3: By default, a conversion request is immediately granted if the\n\t * requested mode is compatible with the modes of all other granted\n\t * locks\n\t */\n\n\tif (queue_conflict(&r->res_convertqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * The RECOVER_GRANT flag means dlm_recover_grant() is granting\n\t * locks for a recovered rsb, on which lkb's have been rebuilt.\n\t * The lkb's may have been rebuilt on the queues in a different\n\t * order than they were in on the previous master.  So, granting\n\t * queued conversions in order after recovery doesn't make sense\n\t * since the order hasn't been preserved anyway.  The new order\n\t * could also have created a new \"in place\" conversion deadlock.\n\t * (e.g. old, failed master held granted EX, with PR->EX, NL->EX.\n\t * After recovery, there would be no granted locks, and possibly\n\t * NL->EX, PR->EX, an in-place conversion deadlock.)  So, after\n\t * recovery, grant conversions without considering order.\n\t */\n\n\tif (conv && recover)\n\t\treturn 1;\n\n\t/*\n\t * 6-5: But the default algorithm for deciding whether to grant or\n\t * queue conversion requests does not by itself guarantee that such\n\t * requests are serviced on a \"first come first serve\" basis.  This, in\n\t * turn, can lead to a phenomenon known as \"indefinate postponement\".\n\t *\n\t * 6-7: This issue is dealt with by using the optional QUECVT flag with\n\t * the system service employed to request a lock conversion.  This flag\n\t * forces certain conversion requests to be queued, even if they are\n\t * compatible with the granted modes of other locks on the same\n\t * resource.  Thus, the use of this flag results in conversion requests\n\t * being ordered on a \"first come first servce\" basis.\n\t *\n\t * DCT: This condition is all about new conversions being able to occur\n\t * \"in place\" while the lock remains on the granted queue (assuming\n\t * nothing else conflicts.)  IOW if QUECVT isn't set, a conversion\n\t * doesn't _have_ to go onto the convert queue where it's processed in\n\t * order.  The \"now\" variable is necessary to distinguish converts\n\t * being received and processed for the first time now, because once a\n\t * convert is moved to the conversion queue the condition below applies\n\t * requiring fifo granting.\n\t */\n\n\tif (now && conv && !(lkb->lkb_exflags & DLM_LKF_QUECVT))\n\t\treturn 1;\n\n\t/*\n\t * Even if the convert is compat with all granted locks,\n\t * QUECVT forces it behind other locks on the convert queue.\n\t */\n\n\tif (now && conv && (lkb->lkb_exflags & DLM_LKF_QUECVT)) {\n\t\tif (list_empty(&r->res_convertqueue))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * The NOORDER flag is set to avoid the standard vms rules on grant\n\t * order.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_NOORDER)\n\t\treturn 1;\n\n\t/*\n\t * 6-3: Once in that queue [CONVERTING], a conversion request cannot be\n\t * granted until all other conversion requests ahead of it are granted\n\t * and/or canceled.\n\t */\n\n\tif (!now && conv && first_in_list(lkb, &r->res_convertqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: By default, a new request is immediately granted only if all\n\t * three of the following conditions are satisfied when the request is\n\t * issued:\n\t * - The queue of ungranted conversion requests for the resource is\n\t *   empty.\n\t * - The queue of ungranted new requests for the resource is empty.\n\t * - The mode of the new request is compatible with the most\n\t *   restrictive mode of all granted locks on the resource.\n\t */\n\n\tif (now && !conv && list_empty(&r->res_convertqueue) &&\n\t    list_empty(&r->res_waitqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: Once a lock request is in the queue of ungranted new requests,\n\t * it cannot be granted until the queue of ungranted conversion\n\t * requests is empty, all ungranted new requests ahead of it are\n\t * granted and/or canceled, and it is compatible with the granted mode\n\t * of the most restrictive lock granted on the resource.\n\t */\n\n\tif (!now && !conv && list_empty(&r->res_convertqueue) &&\n\t    first_in_list(lkb, &r->res_waitqueue))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_pending_convert",
          "args": [
            "r",
            "DLM_LOCK_IV",
            "NULL",
            "NULL"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "grant_pending_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2515-2569",
          "snippet": "static int grant_pending_convert(struct dlm_rsb *r, int high, int *cw,\n\t\t\t\t unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint recover = rsb_flag(r, RSB_RECOVER_GRANT);\n\tint hi, demoted, quit, grant_restart, demote_restart;\n\tint deadlk;\n\n\tquit = 0;\n restart:\n\tgrant_restart = 0;\n\tdemote_restart = 0;\n\thi = DLM_LOCK_IV;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_convertqueue, lkb_statequeue) {\n\t\tdemoted = is_demoted(lkb);\n\t\tdeadlk = 0;\n\n\t\tif (can_be_granted(r, lkb, 0, recover, &deadlk)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tgrant_restart = 1;\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!demoted && is_demoted(lkb)) {\n\t\t\tlog_print(\"WARN: pending demoted %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdemote_restart = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (deadlk) {\n\t\t\tlog_print(\"WARN: pending deadlock %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tcontinue;\n\t\t}\n\n\t\thi = max_t(int, lkb->lkb_rqmode, hi);\n\n\t\tif (cw && lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t*cw = 1;\n\t}\n\n\tif (grant_restart)\n\t\tgoto restart;\n\tif (demote_restart && !quit) {\n\t\tquit = 1;\n\t\tgoto restart;\n\t}\n\n\treturn max_t(int, high, hi);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int grant_pending_convert(struct dlm_rsb *r, int high, int *cw,\n\t\t\t\t unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint recover = rsb_flag(r, RSB_RECOVER_GRANT);\n\tint hi, demoted, quit, grant_restart, demote_restart;\n\tint deadlk;\n\n\tquit = 0;\n restart:\n\tgrant_restart = 0;\n\tdemote_restart = 0;\n\thi = DLM_LOCK_IV;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_convertqueue, lkb_statequeue) {\n\t\tdemoted = is_demoted(lkb);\n\t\tdeadlk = 0;\n\n\t\tif (can_be_granted(r, lkb, 0, recover, &deadlk)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tgrant_restart = 1;\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!demoted && is_demoted(lkb)) {\n\t\t\tlog_print(\"WARN: pending demoted %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdemote_restart = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (deadlk) {\n\t\t\tlog_print(\"WARN: pending deadlock %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tcontinue;\n\t\t}\n\n\t\thi = max_t(int, lkb->lkb_rqmode, hi);\n\n\t\tif (cw && lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t*cw = 1;\n\t}\n\n\tif (grant_restart)\n\t\tgoto restart;\n\tif (demote_restart && !quit) {\n\t\tquit = 1;\n\t\tgoto restart;\n\t}\n\n\treturn max_t(int, high, hi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_demoted",
          "args": [
            "lkb"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "is_demoted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "230-233",
          "snippet": "static inline int is_demoted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_DEMOTED);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_demoted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_DEMOTED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "revert_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "revert_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2110-2113",
          "snippet": "static int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_be_granted",
          "args": [
            "r",
            "lkb",
            "1",
            "0",
            "&deadlk"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "can_be_granted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2444-2503",
          "snippet": "static int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t/*\n\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve\n\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm\n\t * cancels one of the locks.\n\t */\n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\n\t\t} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t\tif (err)\n\t\t\t\t*err = -EDEADLK;\n\t\t\telse {\n\t\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t\t  lkb->lkb_id, now);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The ALTPR and ALTCW flags are non-standard and tell the dlm to try\n\t * to grant a request in a mode other than the normal rqmode.  It's a\n\t * simple way to provide a big optimization to applications that can\n\t * use them.\n\t */\n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t/*\n\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve\n\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm\n\t * cancels one of the locks.\n\t */\n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\n\t\t} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t\tif (err)\n\t\t\t\t*err = -EDEADLK;\n\t\t\telse {\n\t\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t\t  lkb->lkb_id, now);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The ALTPR and ALTCW flags are non-standard and tell the dlm to try\n\t * to grant a request in a mode other than the normal rqmode.  It's a\n\t * simple way to provide a big optimization to applications that can\n\t * use them.\n\t */\n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\tint deadlk = 0;\n\n\t/* changing an existing lock may allow others to be granted */\n\n\tif (can_be_granted(r, lkb, 1, 0, &deadlk)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\t/* can_be_granted() detected that this lock would block in a conversion\n\t   deadlock, so we leave it on the granted queue and return EDEADLK in\n\t   the ast for the convert. */\n\n\tif (deadlk) {\n\t\t/* it's left on the granted queue */\n\t\trevert_lock(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\terror = -EDEADLK;\n\t\tgoto out;\n\t}\n\n\t/* is_demoted() means the can_be_granted() above set the grmode\n\t   to NL, and left us on the granted queue.  This auto-demotion\n\t   (due to CONVDEADLK) might mean other locks, and/or this lock, are\n\t   now grantable.  We have to try to grant other converting locks\n\t   before we try again to grant this one. */\n\n\tif (is_demoted(lkb)) {\n\t\tgrant_pending_convert(r, DLM_LOCK_IV, NULL, NULL);\n\t\tif (_can_be_granted(r, lkb, 1, 0)) {\n\t\t\tgrant_lock(r, lkb);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t\tgoto out;\n\t\t}\n\t\t/* else fall through and move to convert queue */\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "do_request_effects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3096-3108",
    "snippet": "static void do_request_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_blocking_asts",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "send_blocking_asts_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2681-2685",
          "snippet": "static void send_blocking_asts_all(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tsend_bast_queue(r, &r->res_grantqueue, lkb);\n\tsend_bast_queue(r, &r->res_convertqueue, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_blocking_asts_all(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tsend_bast_queue(r, &r->res_grantqueue, lkb);\n\tsend_bast_queue(r, &r->res_convertqueue, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_blocking_asts",
          "args": [
            "lkb"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "force_blocking_asts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "225-228",
          "snippet": "static inline int force_blocking_asts(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_exflags & DLM_LKF_NOQUEUEBAST);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int force_blocking_asts(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_exflags & DLM_LKF_NOQUEUEBAST);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void do_request_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "do_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "3073-3094",
    "snippet": "static int do_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\n\tif (can_be_granted(r, lkb, 1, 0, NULL)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "-EAGAIN"
          ],
          "line": 3091
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timeout",
          "args": [
            "lkb"
          ],
          "line": 3086
        },
        "resolved": true,
        "details": {
          "function_name": "add_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1815-1837",
          "snippet": "static void add_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\n\t    !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\tlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\n\t\tgoto add_it;\n\t}\n\tif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\n\t\tgoto add_it;\n\treturn;\n\n add_it:\n\tDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\n\tmutex_lock(&ls->ls_timeout_mutex);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\n\t    !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\tlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\n\t\tgoto add_it;\n\t}\n\tif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\n\t\tgoto add_it;\n\treturn;\n\n add_it:\n\tDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\n\tmutex_lock(&ls->ls_timeout_mutex);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_lkb",
          "args": [
            "r",
            "lkb",
            "DLM_LKSTS_WAITING"
          ],
          "line": 3085
        },
        "resolved": true,
        "details": {
          "function_name": "add_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1314-1346",
          "snippet": "static void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_be_queued",
          "args": [
            "lkb"
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "can_be_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "220-223",
          "snippet": "static inline int can_be_queued(struct dlm_lkb *lkb)\n{\n\treturn !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int can_be_queued(struct dlm_lkb *lkb)\n{\n\treturn !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "grant_lock_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2146-2153",
          "snippet": "static void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_be_granted",
          "args": [
            "r",
            "lkb",
            "1",
            "0",
            "NULL"
          ],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "can_be_granted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2444-2503",
          "snippet": "static int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t/*\n\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve\n\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm\n\t * cancels one of the locks.\n\t */\n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\n\t\t} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t\tif (err)\n\t\t\t\t*err = -EDEADLK;\n\t\t\telse {\n\t\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t\t  lkb->lkb_id, now);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The ALTPR and ALTCW flags are non-standard and tell the dlm to try\n\t * to grant a request in a mode other than the normal rqmode.  It's a\n\t * simple way to provide a big optimization to applications that can\n\t * use them.\n\t */\n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t/*\n\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve\n\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm\n\t * cancels one of the locks.\n\t */\n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\n\t\t} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t\tif (err)\n\t\t\t\t*err = -EDEADLK;\n\t\t\telse {\n\t\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t\t  lkb->lkb_id, now);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The ALTPR and ALTCW flags are non-standard and tell the dlm to try\n\t * to grant a request in a mode other than the normal rqmode.  It's a\n\t * simple way to provide a big optimization to applications that can\n\t * use them.\n\t */\n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int do_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\n\tif (can_be_granted(r, lkb, 1, 0, NULL)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\tadd_timeout(lkb);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "validate_unlock_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2936-3064",
    "snippet": "static int validate_unlock_args(struct dlm_lkb *lkb, struct dlm_args *args)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv = -EINVAL;\n\n\tif (lkb->lkb_flags & DLM_IFL_MSTCPY) {\n\t\tlog_error(ls, \"unlock on MSTCPY %x\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tgoto out;\n\t}\n\n\t/* an lkb may still exist even though the lock is EOL'ed due to a\n\t   cancel, unlock or failed noqueue request; an app can't use these\n\t   locks; return same error as if the lkid had not been found at all */\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\tlog_debug(ls, \"unlock on ENDOFLIFE %x\", lkb->lkb_id);\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* an lkb may be waiting for an rsb lookup to complete where the\n\t   lookup was initiated by another lock */\n\n\tif (!list_empty(&lkb->lkb_rsb_lookup)) {\n\t\tif (args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) {\n\t\t\tlog_debug(ls, \"unlock on rsb_lookup %x\", lkb->lkb_id);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tqueue_cast(lkb->lkb_resource, lkb,\n\t\t\t\t   args->flags & DLM_LKF_CANCEL ?\n\t\t\t\t   -DLM_ECANCEL : -DLM_EUNLOCK);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t}\n\t\t/* caller changes -EBUSY to 0 for CANCEL and FORCEUNLOCK */\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* cancel not allowed with another cancel/unlock in progress */\n\n\tif (args->flags & DLM_LKF_CANCEL) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CANCEL)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* there's nothing to cancel */\n\t\tif (lkb->lkb_status == DLM_LKSTS_GRANTED &&\n\t\t    !lkb->lkb_wait_type) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_CANCEL */\n\t\tgoto out_ok;\n\t}\n\n\t/* do we need to allow a force-unlock if there's a normal unlock\n\t   already in progress?  in what conditions could the normal unlock\n\t   fail such that we'd want to send a force-unlock to be sure? */\n\n\tif (args->flags & DLM_LKF_FORCEUNLOCK) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK)\n\t\t\tgoto out;\n\n\t\tif (is_overlap_unlock(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_UNLOCK */\n\t\tgoto out_ok;\n\t}\n\n\t/* normal unlock not allowed if there's any op in progress */\n\trv = -EBUSY;\n\tif (lkb->lkb_wait_type || lkb->lkb_wait_count)\n\t\tgoto out;\n\n out_ok:\n\t/* an overlapping op shouldn't blow away exflags from other op */\n\tlkb->lkb_exflags |= args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astparam = args->astparam;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_unlock_args %d %x %x %x %x %d %s\", rv,\n\t\t\t  lkb->lkb_id, lkb->lkb_flags, lkb->lkb_exflags,\n\t\t\t  args->flags, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"validate_unlock_args %d %x %x %x %x %d %s\"",
            "rv",
            "lkb->lkb_id",
            "lkb->lkb_flags",
            "lkb->lkb_exflags",
            "args->flags",
            "lkb->lkb_wait_type",
            "lkb->lkb_resource->res_name"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timeout",
          "args": [
            "lkb"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "del_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1839-1849",
          "snippet": "static void del_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tif (!list_empty(&lkb->lkb_time_list)) {\n\t\tlist_del_init(&lkb->lkb_time_list);\n\t\tunhold_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tif (!list_empty(&lkb->lkb_time_list)) {\n\t\tlist_del_init(&lkb->lkb_time_list);\n\t\tunhold_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_overlap_unlock",
          "args": [
            "lkb"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "274-277",
          "snippet": "static inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_overlap",
          "args": [
            "lkb"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "284-288",
          "snippet": "static inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\n\t\t\t\t  DLM_IFL_OVERLAP_CANCEL));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\n\t\t\t\t  DLM_IFL_OVERLAP_CANCEL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "lkb->lkb_resource",
            "lkb",
            "args->flags & DLM_LKF_CANCEL ?\n\t\t\t\t   -DLM_ECANCEL : -DLM_EUNLOCK"
          ],
          "line": 2964
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_rsb_lookup"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"unlock on rsb_lookup %x\"",
            "lkb->lkb_id"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lkb->lkb_rsb_lookup"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"unlock on ENDOFLIFE %x\"",
            "lkb->lkb_id"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"unlock on MSTCPY %x\"",
            "lkb->lkb_id"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int validate_unlock_args(struct dlm_lkb *lkb, struct dlm_args *args)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv = -EINVAL;\n\n\tif (lkb->lkb_flags & DLM_IFL_MSTCPY) {\n\t\tlog_error(ls, \"unlock on MSTCPY %x\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tgoto out;\n\t}\n\n\t/* an lkb may still exist even though the lock is EOL'ed due to a\n\t   cancel, unlock or failed noqueue request; an app can't use these\n\t   locks; return same error as if the lkid had not been found at all */\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\tlog_debug(ls, \"unlock on ENDOFLIFE %x\", lkb->lkb_id);\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* an lkb may be waiting for an rsb lookup to complete where the\n\t   lookup was initiated by another lock */\n\n\tif (!list_empty(&lkb->lkb_rsb_lookup)) {\n\t\tif (args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) {\n\t\t\tlog_debug(ls, \"unlock on rsb_lookup %x\", lkb->lkb_id);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tqueue_cast(lkb->lkb_resource, lkb,\n\t\t\t\t   args->flags & DLM_LKF_CANCEL ?\n\t\t\t\t   -DLM_ECANCEL : -DLM_EUNLOCK);\n\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t}\n\t\t/* caller changes -EBUSY to 0 for CANCEL and FORCEUNLOCK */\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* cancel not allowed with another cancel/unlock in progress */\n\n\tif (args->flags & DLM_LKF_CANCEL) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CANCEL)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* there's nothing to cancel */\n\t\tif (lkb->lkb_status == DLM_LKSTS_GRANTED &&\n\t\t    !lkb->lkb_wait_type) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_CANCEL */\n\t\tgoto out_ok;\n\t}\n\n\t/* do we need to allow a force-unlock if there's a normal unlock\n\t   already in progress?  in what conditions could the normal unlock\n\t   fail such that we'd want to send a force-unlock to be sure? */\n\n\tif (args->flags & DLM_LKF_FORCEUNLOCK) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK)\n\t\t\tgoto out;\n\n\t\tif (is_overlap_unlock(lkb))\n\t\t\tgoto out;\n\n\t\t/* don't let scand try to do a cancel */\n\t\tdel_timeout(lkb);\n\n\t\tif (lkb->lkb_flags & DLM_IFL_RESEND) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tgoto out;\n\t\t}\n\t\t/* add_to_waiters() will set OVERLAP_UNLOCK */\n\t\tgoto out_ok;\n\t}\n\n\t/* normal unlock not allowed if there's any op in progress */\n\trv = -EBUSY;\n\tif (lkb->lkb_wait_type || lkb->lkb_wait_count)\n\t\tgoto out;\n\n out_ok:\n\t/* an overlapping op shouldn't blow away exflags from other op */\n\tlkb->lkb_exflags |= args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astparam = args->astparam;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_unlock_args %d %x %x %x %x %d %s\", rv,\n\t\t\t  lkb->lkb_id, lkb->lkb_flags, lkb->lkb_exflags,\n\t\t\t  args->flags, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}"
  },
  {
    "function_name": "validate_lock_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2885-2927",
    "snippet": "static int validate_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t      struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\tif (args->flags & DLM_LKF_CONVERT) {\n\t\tif (lkb->lkb_flags & DLM_IFL_MSTCPY)\n\t\t\tgoto out;\n\n\t\tif (args->flags & DLM_LKF_QUECVT &&\n\t\t    !__quecvt_compat_matrix[lkb->lkb_grmode+1][args->mode+1])\n\t\t\tgoto out;\n\n\t\trv = -EBUSY;\n\t\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\t\tgoto out;\n\n\t\tif (lkb->lkb_wait_type)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astfn = args->astfn;\n\tlkb->lkb_astparam = args->astparam;\n\tlkb->lkb_bastfn = args->bastfn;\n\tlkb->lkb_rqmode = args->mode;\n\tlkb->lkb_lksb = args->lksb;\n\tlkb->lkb_lvbptr = args->lksb->sb_lvbptr;\n\tlkb->lkb_ownpid = (int) current->pid;\n\tlkb->lkb_timeout_cs = args->timeout;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_lock_args %d %x %x %x %d %d %s\",\n\t\t\t  rv, lkb->lkb_id, lkb->lkb_flags, args->flags,\n\t\t\t  lkb->lkb_status, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);",
      "static void del_timeout(struct dlm_lkb *lkb);",
      "static const int __quecvt_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* UN */\n        {0, 0, 1, 1, 1, 1, 1, 0},       /* NL */\n        {0, 0, 0, 1, 1, 1, 1, 0},       /* CR */\n        {0, 0, 0, 0, 1, 1, 1, 0},       /* CW */\n        {0, 0, 0, 1, 0, 1, 1, 0},       /* PR */\n        {0, 0, 0, 0, 0, 0, 1, 0},       /* PW */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"validate_lock_args %d %x %x %x %d %d %s\"",
            "rv",
            "lkb->lkb_id",
            "lkb->lkb_flags",
            "args->flags",
            "lkb->lkb_status",
            "lkb->lkb_wait_type",
            "lkb->lkb_resource->res_name"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_overlap",
          "args": [
            "lkb"
          ],
          "line": 2905
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "284-288",
          "snippet": "static inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\n\t\t\t\t  DLM_IFL_OVERLAP_CANCEL));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\n\t\t\t\t  DLM_IFL_OVERLAP_CANCEL));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\nstatic void del_timeout(struct dlm_lkb *lkb);\nstatic const int __quecvt_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* UN */\n        {0, 0, 1, 1, 1, 1, 1, 0},       /* NL */\n        {0, 0, 0, 1, 1, 1, 1, 0},       /* CR */\n        {0, 0, 0, 0, 1, 1, 1, 0},       /* CW */\n        {0, 0, 0, 1, 0, 1, 1, 0},       /* PR */\n        {0, 0, 0, 0, 0, 0, 1, 0},       /* PW */\n        {0, 0, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};\n\nstatic int validate_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t      struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\tif (args->flags & DLM_LKF_CONVERT) {\n\t\tif (lkb->lkb_flags & DLM_IFL_MSTCPY)\n\t\t\tgoto out;\n\n\t\tif (args->flags & DLM_LKF_QUECVT &&\n\t\t    !__quecvt_compat_matrix[lkb->lkb_grmode+1][args->mode+1])\n\t\t\tgoto out;\n\n\t\trv = -EBUSY;\n\t\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\t\tgoto out;\n\n\t\tif (lkb->lkb_wait_type)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = args->flags;\n\tlkb->lkb_sbflags = 0;\n\tlkb->lkb_astfn = args->astfn;\n\tlkb->lkb_astparam = args->astparam;\n\tlkb->lkb_bastfn = args->bastfn;\n\tlkb->lkb_rqmode = args->mode;\n\tlkb->lkb_lksb = args->lksb;\n\tlkb->lkb_lvbptr = args->lksb->sb_lvbptr;\n\tlkb->lkb_ownpid = (int) current->pid;\n\tlkb->lkb_timeout_cs = args->timeout;\n\trv = 0;\n out:\n\tif (rv)\n\t\tlog_debug(ls, \"validate_lock_args %d %x %x %x %d %d %s\",\n\t\t\t  rv, lkb->lkb_id, lkb->lkb_flags, args->flags,\n\t\t\t  lkb->lkb_status, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\treturn rv;\n}"
  },
  {
    "function_name": "set_unlock_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2871-2883",
    "snippet": "static int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}"
  },
  {
    "function_name": "set_lock_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2805-2869",
    "snippet": "static int set_lock_args(int mode, struct dlm_lksb *lksb, uint32_t flags,\n\t\t\t int namelen, unsigned long timeout_cs,\n\t\t\t void (*ast) (void *astparam),\n\t\t\t void *astparam,\n\t\t\t void (*bast) (void *astparam, int mode),\n\t\t\t struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\t/* check for invalid arg usage */\n\n\tif (mode < 0 || mode > DLM_LOCK_EX)\n\t\tgoto out;\n\n\tif (!(flags & DLM_LKF_CONVERT) && (namelen > DLM_RESNAME_MAXLEN))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_QUECVT && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_CONVERT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_QUECVT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && mode != DLM_LOCK_NL)\n\t\tgoto out;\n\n\tif (!ast || !lksb)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_VALBLK && !lksb->sb_lvbptr)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVERT && !lksb->sb_lkid)\n\t\tgoto out;\n\n\t/* these args will be copied to the lkb in validate_lock_args,\n\t   it cannot be done now because when converting locks, fields in\n\t   an active lkb cannot be modified before locking the rsb */\n\n\targs->flags = flags;\n\targs->astfn = ast;\n\targs->astparam = astparam;\n\targs->bastfn = bast;\n\targs->timeout = timeout_cs;\n\targs->mode = mode;\n\targs->lksb = lksb;\n\trv = 0;\n out:\n\treturn rv;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int set_lock_args(int mode, struct dlm_lksb *lksb, uint32_t flags,\n\t\t\t int namelen, unsigned long timeout_cs,\n\t\t\t void (*ast) (void *astparam),\n\t\t\t void *astparam,\n\t\t\t void (*bast) (void *astparam, int mode),\n\t\t\t struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\t/* check for invalid arg usage */\n\n\tif (mode < 0 || mode > DLM_LOCK_EX)\n\t\tgoto out;\n\n\tif (!(flags & DLM_LKF_CONVERT) && (namelen > DLM_RESNAME_MAXLEN))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_QUECVT && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_CONVERT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_QUECVT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && mode != DLM_LOCK_NL)\n\t\tgoto out;\n\n\tif (!ast || !lksb)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_VALBLK && !lksb->sb_lvbptr)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVERT && !lksb->sb_lkid)\n\t\tgoto out;\n\n\t/* these args will be copied to the lkb in validate_lock_args,\n\t   it cannot be done now because when converting locks, fields in\n\t   an active lkb cannot be modified before locking the rsb */\n\n\targs->flags = flags;\n\targs->astfn = ast;\n\targs->astparam = astparam;\n\targs->bastfn = bast;\n\targs->timeout = timeout_cs;\n\targs->mode = mode;\n\targs->lksb = lksb;\n\trv = 0;\n out:\n\treturn rv;\n}"
  },
  {
    "function_name": "confirm_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2768-2803",
    "snippet": "static void confirm_master(struct dlm_rsb *r, int error)\n{\n\tstruct dlm_lkb *lkb;\n\n\tif (!r->res_first_lkid)\n\t\treturn;\n\n\tswitch (error) {\n\tcase 0:\n\tcase -EINPROGRESS:\n\t\tr->res_first_lkid = 0;\n\t\tprocess_lookup_list(r);\n\t\tbreak;\n\n\tcase -EAGAIN:\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* the remote request failed and won't be retried (it was\n\t\t   a NOQUEUE, or has been canceled/unlocked); make a waiting\n\t\t   lkb the first_lkid */\n\n\t\tr->res_first_lkid = 0;\n\n\t\tif (!list_empty(&r->res_lookup)) {\n\t\t\tlkb = list_entry(r->res_lookup.next, struct dlm_lkb,\n\t\t\t\t\t lkb_rsb_lookup);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tr->res_first_lkid = lkb->lkb_id;\n\t\t\t_request_lock(r, lkb);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"confirm_master unknown error %d\", error);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "r->res_ls",
            "\"confirm_master unknown error %d\"",
            "error"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_request_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "_request_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3224-3249",
          "snippet": "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_rsb_lookup"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "r->res_lookup.next",
            "structdlm_lkb",
            "lkb_rsb_lookup"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&r->res_lookup"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_lookup_list",
          "args": [
            "r"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "process_lookup_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2755-2764",
          "snippet": "static void process_lookup_list(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, &r->res_lookup, lkb_rsb_lookup) {\n\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t_request_lock(r, lkb);\n\t\tschedule();\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void process_lookup_list(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, &r->res_lookup, lkb_rsb_lookup) {\n\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t_request_lock(r, lkb);\n\t\tschedule();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void confirm_master(struct dlm_rsb *r, int error)\n{\n\tstruct dlm_lkb *lkb;\n\n\tif (!r->res_first_lkid)\n\t\treturn;\n\n\tswitch (error) {\n\tcase 0:\n\tcase -EINPROGRESS:\n\t\tr->res_first_lkid = 0;\n\t\tprocess_lookup_list(r);\n\t\tbreak;\n\n\tcase -EAGAIN:\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t/* the remote request failed and won't be retried (it was\n\t\t   a NOQUEUE, or has been canceled/unlocked); make a waiting\n\t\t   lkb the first_lkid */\n\n\t\tr->res_first_lkid = 0;\n\n\t\tif (!list_empty(&r->res_lookup)) {\n\t\t\tlkb = list_entry(r->res_lookup.next, struct dlm_lkb,\n\t\t\t\t\t lkb_rsb_lookup);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tr->res_first_lkid = lkb->lkb_id;\n\t\t\t_request_lock(r, lkb);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"confirm_master unknown error %d\", error);\n\t}\n}"
  },
  {
    "function_name": "process_lookup_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2755-2764",
    "snippet": "static void process_lookup_list(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, &r->res_lookup, lkb_rsb_lookup) {\n\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t_request_lock(r, lkb);\n\t\tschedule();\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_request_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "_request_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3224-3249",
          "snippet": "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t/* set_master: sets lkb nodeid from r */\n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t/* receive_request() calls do_request() on remote node */\n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t/* for remote locks the request_reply is sent\n\t\t   between do_request and do_request_effects */\n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_rsb_lookup"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "safe",
            "&r->res_lookup",
            "lkb_rsb_lookup"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void process_lookup_list(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, &r->res_lookup, lkb_rsb_lookup) {\n\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t_request_lock(r, lkb);\n\t\tschedule();\n\t}\n}"
  },
  {
    "function_name": "set_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2706-2753",
    "snippet": "static int set_master(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint our_nodeid = dlm_our_nodeid();\n\n\tif (rsb_flag(r, RSB_MASTER_UNCERTAIN)) {\n\t\trsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = lkb->lkb_id;\n\t\tlkb->lkb_nodeid = r->res_nodeid;\n\t\treturn 0;\n\t}\n\n\tif (r->res_first_lkid && r->res_first_lkid != lkb->lkb_id) {\n\t\tlist_add_tail(&lkb->lkb_rsb_lookup, &r->res_lookup);\n\t\treturn 1;\n\t}\n\n\tif (r->res_master_nodeid == our_nodeid) {\n\t\tlkb->lkb_nodeid = 0;\n\t\treturn 0;\n\t}\n\n\tif (r->res_master_nodeid) {\n\t\tlkb->lkb_nodeid = r->res_master_nodeid;\n\t\treturn 0;\n\t}\n\n\tif (dlm_dir_nodeid(r) == our_nodeid) {\n\t\t/* This is a somewhat unusual case; find_rsb will usually\n\t\t   have set res_master_nodeid when dir nodeid is local, but\n\t\t   there are cases where we become the dir node after we've\n\t\t   past find_rsb and go through _request_lock again.\n\t\t   confirm_master() or process_lookup_list() needs to be\n\t\t   called after this. */\n\t\tlog_debug(r->res_ls, \"set_master %x self master %d dir %d %s\",\n\t\t\t  lkb->lkb_id, r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t  r->res_name);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tlkb->lkb_nodeid = 0;\n\t\treturn 0;\n\t}\n\n\twait_pending_remove(r);\n\n\tr->res_first_lkid = lkb->lkb_id;\n\tsend_lookup(r, lkb);\n\treturn 1;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_lookup",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "send_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3748-3774",
          "snippet": "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = dlm_dir_nodeid(r);\n\n\terror = add_to_waiters(lkb, DLM_MSG_LOOKUP, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_LOOKUP, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = dlm_dir_nodeid(r);\n\n\terror = add_to_waiters(lkb, DLM_MSG_LOOKUP, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_LOOKUP, &ms, &mh);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_pending_remove",
          "args": [
            "r"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "wait_pending_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1628-1642",
          "snippet": "static void wait_pending_remove(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n restart:\n\tspin_lock(&ls->ls_remove_spin);\n\tif (ls->ls_remove_len &&\n\t    !rsb_cmp(r, ls->ls_remove_name, ls->ls_remove_len)) {\n\t\tlog_debug(ls, \"delay lookup for remove dir %d %s\",\n\t\t  \t  r->res_dir_nodeid, r->res_name);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\t\tmsleep(1);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&ls->ls_remove_spin);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void wait_pending_remove(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n restart:\n\tspin_lock(&ls->ls_remove_spin);\n\tif (ls->ls_remove_len &&\n\t    !rsb_cmp(r, ls->ls_remove_name, ls->ls_remove_len)) {\n\t\tlog_debug(ls, \"delay lookup for remove dir %d %s\",\n\t\t  \t  r->res_dir_nodeid, r->res_name);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\t\tmsleep(1);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&ls->ls_remove_spin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "r->res_ls",
            "\"set_master %x self master %d dir %d %s\"",
            "lkb->lkb_id",
            "r->res_master_nodeid",
            "r->res_dir_nodeid",
            "r->res_name"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dir_nodeid",
          "args": [
            "r"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "47-50",
          "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lkb->lkb_rsb_lookup",
            "&r->res_lookup"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsb_clear_flag",
          "args": [
            "r",
            "RSB_MASTER_UNCERTAIN"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_clear_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "353-356",
          "snippet": "static inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_flag",
          "args": [
            "r",
            "RSB_MASTER_UNCERTAIN"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "358-361",
          "snippet": "static inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int set_master(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint our_nodeid = dlm_our_nodeid();\n\n\tif (rsb_flag(r, RSB_MASTER_UNCERTAIN)) {\n\t\trsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = lkb->lkb_id;\n\t\tlkb->lkb_nodeid = r->res_nodeid;\n\t\treturn 0;\n\t}\n\n\tif (r->res_first_lkid && r->res_first_lkid != lkb->lkb_id) {\n\t\tlist_add_tail(&lkb->lkb_rsb_lookup, &r->res_lookup);\n\t\treturn 1;\n\t}\n\n\tif (r->res_master_nodeid == our_nodeid) {\n\t\tlkb->lkb_nodeid = 0;\n\t\treturn 0;\n\t}\n\n\tif (r->res_master_nodeid) {\n\t\tlkb->lkb_nodeid = r->res_master_nodeid;\n\t\treturn 0;\n\t}\n\n\tif (dlm_dir_nodeid(r) == our_nodeid) {\n\t\t/* This is a somewhat unusual case; find_rsb will usually\n\t\t   have set res_master_nodeid when dir nodeid is local, but\n\t\t   there are cases where we become the dir node after we've\n\t\t   past find_rsb and go through _request_lock again.\n\t\t   confirm_master() or process_lookup_list() needs to be\n\t\t   called after this. */\n\t\tlog_debug(r->res_ls, \"set_master %x self master %d dir %d %s\",\n\t\t\t  lkb->lkb_id, r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t  r->res_name);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tlkb->lkb_nodeid = 0;\n\t\treturn 0;\n\t}\n\n\twait_pending_remove(r);\n\n\tr->res_first_lkid = lkb->lkb_id;\n\tsend_lookup(r, lkb);\n\treturn 1;\n}"
  },
  {
    "function_name": "send_blocking_asts_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2681-2685",
    "snippet": "static void send_blocking_asts_all(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tsend_bast_queue(r, &r->res_grantqueue, lkb);\n\tsend_bast_queue(r, &r->res_convertqueue, lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_bast_queue",
          "args": [
            "r",
            "&r->res_convertqueue",
            "lkb"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "send_bast_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2660-2674",
          "snippet": "static void send_bast_queue(struct dlm_rsb *r, struct list_head *head,\n\t\t\t    struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *gr;\n\n\tlist_for_each_entry(gr, head, lkb_statequeue) {\n\t\t/* skip self when sending basts to convertqueue */\n\t\tif (gr == lkb)\n\t\t\tcontinue;\n\t\tif (gr->lkb_bastfn && modes_require_bast(gr, lkb)) {\n\t\t\tqueue_bast(r, gr, lkb->lkb_rqmode);\n\t\t\tgr->lkb_highbast = lkb->lkb_rqmode;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_bast_queue(struct dlm_rsb *r, struct list_head *head,\n\t\t\t    struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *gr;\n\n\tlist_for_each_entry(gr, head, lkb_statequeue) {\n\t\t/* skip self when sending basts to convertqueue */\n\t\tif (gr == lkb)\n\t\t\tcontinue;\n\t\tif (gr->lkb_bastfn && modes_require_bast(gr, lkb)) {\n\t\t\tqueue_bast(r, gr, lkb->lkb_rqmode);\n\t\t\tgr->lkb_highbast = lkb->lkb_rqmode;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_blocking_asts_all(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tsend_bast_queue(r, &r->res_grantqueue, lkb);\n\tsend_bast_queue(r, &r->res_convertqueue, lkb);\n}"
  },
  {
    "function_name": "send_blocking_asts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2676-2679",
    "snippet": "static void send_blocking_asts(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tsend_bast_queue(r, &r->res_grantqueue, lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_bast_queue",
          "args": [
            "r",
            "&r->res_grantqueue",
            "lkb"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "send_bast_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2660-2674",
          "snippet": "static void send_bast_queue(struct dlm_rsb *r, struct list_head *head,\n\t\t\t    struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *gr;\n\n\tlist_for_each_entry(gr, head, lkb_statequeue) {\n\t\t/* skip self when sending basts to convertqueue */\n\t\tif (gr == lkb)\n\t\t\tcontinue;\n\t\tif (gr->lkb_bastfn && modes_require_bast(gr, lkb)) {\n\t\t\tqueue_bast(r, gr, lkb->lkb_rqmode);\n\t\t\tgr->lkb_highbast = lkb->lkb_rqmode;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_bast_queue(struct dlm_rsb *r, struct list_head *head,\n\t\t\t    struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *gr;\n\n\tlist_for_each_entry(gr, head, lkb_statequeue) {\n\t\t/* skip self when sending basts to convertqueue */\n\t\tif (gr == lkb)\n\t\t\tcontinue;\n\t\tif (gr->lkb_bastfn && modes_require_bast(gr, lkb)) {\n\t\t\tqueue_bast(r, gr, lkb->lkb_rqmode);\n\t\t\tgr->lkb_highbast = lkb->lkb_rqmode;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_blocking_asts(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tsend_bast_queue(r, &r->res_grantqueue, lkb);\n}"
  },
  {
    "function_name": "send_bast_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2660-2674",
    "snippet": "static void send_bast_queue(struct dlm_rsb *r, struct list_head *head,\n\t\t\t    struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *gr;\n\n\tlist_for_each_entry(gr, head, lkb_statequeue) {\n\t\t/* skip self when sending basts to convertqueue */\n\t\tif (gr == lkb)\n\t\t\tcontinue;\n\t\tif (gr->lkb_bastfn && modes_require_bast(gr, lkb)) {\n\t\t\tqueue_bast(r, gr, lkb->lkb_rqmode);\n\t\t\tgr->lkb_highbast = lkb->lkb_rqmode;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_bast",
          "args": [
            "r",
            "gr",
            "lkb->lkb_rqmode"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "queue_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "320-327",
          "snippet": "static void queue_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rqmode)\n{\n\tif (is_master_copy(lkb)) {\n\t\tsend_bast(r, lkb, rqmode);\n\t} else {\n\t\tdlm_add_cb(lkb, DLM_CB_BAST, rqmode, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rqmode)\n{\n\tif (is_master_copy(lkb)) {\n\t\tsend_bast(r, lkb, rqmode);\n\t} else {\n\t\tdlm_add_cb(lkb, DLM_CB_BAST, rqmode, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "modes_require_bast",
          "args": [
            "gr",
            "lkb"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "modes_require_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2646-2658",
          "snippet": "static int modes_require_bast(struct dlm_lkb *gr, struct dlm_lkb *rq)\n{\n\tif ((gr->lkb_grmode == DLM_LOCK_PR && rq->lkb_rqmode == DLM_LOCK_CW) ||\n\t    (gr->lkb_grmode == DLM_LOCK_CW && rq->lkb_rqmode == DLM_LOCK_PR)) {\n\t\tif (gr->lkb_highbast < DLM_LOCK_EX)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (gr->lkb_highbast < rq->lkb_rqmode && !modes_compat(gr, rq))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int modes_require_bast(struct dlm_lkb *gr, struct dlm_lkb *rq)\n{\n\tif ((gr->lkb_grmode == DLM_LOCK_PR && rq->lkb_rqmode == DLM_LOCK_CW) ||\n\t    (gr->lkb_grmode == DLM_LOCK_CW && rq->lkb_rqmode == DLM_LOCK_PR)) {\n\t\tif (gr->lkb_highbast < DLM_LOCK_EX)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (gr->lkb_highbast < rq->lkb_rqmode && !modes_compat(gr, rq))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "gr",
            "head",
            "lkb_statequeue"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void send_bast_queue(struct dlm_rsb *r, struct list_head *head,\n\t\t\t    struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *gr;\n\n\tlist_for_each_entry(gr, head, lkb_statequeue) {\n\t\t/* skip self when sending basts to convertqueue */\n\t\tif (gr == lkb)\n\t\t\tcontinue;\n\t\tif (gr->lkb_bastfn && modes_require_bast(gr, lkb)) {\n\t\t\tqueue_bast(r, gr, lkb->lkb_rqmode);\n\t\t\tgr->lkb_highbast = lkb->lkb_rqmode;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "modes_require_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2646-2658",
    "snippet": "static int modes_require_bast(struct dlm_lkb *gr, struct dlm_lkb *rq)\n{\n\tif ((gr->lkb_grmode == DLM_LOCK_PR && rq->lkb_rqmode == DLM_LOCK_CW) ||\n\t    (gr->lkb_grmode == DLM_LOCK_CW && rq->lkb_rqmode == DLM_LOCK_PR)) {\n\t\tif (gr->lkb_highbast < DLM_LOCK_EX)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (gr->lkb_highbast < rq->lkb_rqmode && !modes_compat(gr, rq))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modes_compat",
          "args": [
            "gr",
            "rq"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_modes_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "139-142",
          "snippet": "int dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};\n\nint dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int modes_require_bast(struct dlm_lkb *gr, struct dlm_lkb *rq)\n{\n\tif ((gr->lkb_grmode == DLM_LOCK_PR && rq->lkb_rqmode == DLM_LOCK_CW) ||\n\t    (gr->lkb_grmode == DLM_LOCK_CW && rq->lkb_rqmode == DLM_LOCK_PR)) {\n\t\tif (gr->lkb_highbast < DLM_LOCK_EX)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (gr->lkb_highbast < rq->lkb_rqmode && !modes_compat(gr, rq))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "grant_pending_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2610-2644",
    "snippet": "static void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t/*\n\t * If there are locks left on the wait/convert queue then send blocking\n\t * ASTs to granted locks based on the largest requested mode (high)\n\t * found above.\n\t */\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_bast",
          "args": [
            "r",
            "lkb",
            "high"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "queue_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "320-327",
          "snippet": "static void queue_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rqmode)\n{\n\tif (is_master_copy(lkb)) {\n\t\tsend_bast(r, lkb, rqmode);\n\t} else {\n\t\tdlm_add_cb(lkb, DLM_CB_BAST, rqmode, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rqmode)\n{\n\tif (is_master_copy(lkb)) {\n\t\tsend_bast(r, lkb, rqmode);\n\t} else {\n\t\tdlm_add_cb(lkb, DLM_CB_BAST, rqmode, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_requires_bast",
          "args": [
            "lkb",
            "high",
            "cw"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "lock_requires_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2596-2608",
          "snippet": "static int lock_requires_bast(struct dlm_lkb *gr, int high, int cw)\n{\n\tif (gr->lkb_grmode == DLM_LOCK_PR && cw) {\n\t\tif (gr->lkb_highbast < DLM_LOCK_EX)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (gr->lkb_highbast < high &&\n\t    !__dlm_compat_matrix[gr->lkb_grmode+1][high+1])\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};\n\nstatic int lock_requires_bast(struct dlm_lkb *gr, int high, int cw)\n{\n\tif (gr->lkb_grmode == DLM_LOCK_PR && cw) {\n\t\tif (gr->lkb_highbast < DLM_LOCK_EX)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (gr->lkb_highbast < high &&\n\t    !__dlm_compat_matrix[gr->lkb_grmode+1][high+1])\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "s",
            "&r->res_grantqueue",
            "lkb_statequeue"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grant_pending_wait",
          "args": [
            "r",
            "high",
            "&cw",
            "count"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "grant_pending_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2571-2589",
          "snippet": "static int grant_pending_wait(struct dlm_rsb *r, int high, int *cw,\n\t\t\t      unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_waitqueue, lkb_statequeue) {\n\t\tif (can_be_granted(r, lkb, 0, 0, NULL)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t} else {\n\t\t\thigh = max_t(int, lkb->lkb_rqmode, high);\n\t\t\tif (lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t\t*cw = 1;\n\t\t}\n\t}\n\n\treturn high;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int grant_pending_wait(struct dlm_rsb *r, int high, int *cw,\n\t\t\t      unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_waitqueue, lkb_statequeue) {\n\t\tif (can_be_granted(r, lkb, 0, 0, NULL)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t} else {\n\t\t\thigh = max_t(int, lkb->lkb_rqmode, high);\n\t\t\tif (lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t\t*cw = 1;\n\t\t}\n\t}\n\n\treturn high;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_pending_convert",
          "args": [
            "r",
            "high",
            "&cw",
            "count"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "grant_pending_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2515-2569",
          "snippet": "static int grant_pending_convert(struct dlm_rsb *r, int high, int *cw,\n\t\t\t\t unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint recover = rsb_flag(r, RSB_RECOVER_GRANT);\n\tint hi, demoted, quit, grant_restart, demote_restart;\n\tint deadlk;\n\n\tquit = 0;\n restart:\n\tgrant_restart = 0;\n\tdemote_restart = 0;\n\thi = DLM_LOCK_IV;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_convertqueue, lkb_statequeue) {\n\t\tdemoted = is_demoted(lkb);\n\t\tdeadlk = 0;\n\n\t\tif (can_be_granted(r, lkb, 0, recover, &deadlk)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tgrant_restart = 1;\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!demoted && is_demoted(lkb)) {\n\t\t\tlog_print(\"WARN: pending demoted %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdemote_restart = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (deadlk) {\n\t\t\tlog_print(\"WARN: pending deadlock %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tcontinue;\n\t\t}\n\n\t\thi = max_t(int, lkb->lkb_rqmode, hi);\n\n\t\tif (cw && lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t*cw = 1;\n\t}\n\n\tif (grant_restart)\n\t\tgoto restart;\n\tif (demote_restart && !quit) {\n\t\tquit = 1;\n\t\tgoto restart;\n\t}\n\n\treturn max_t(int, high, hi);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int grant_pending_convert(struct dlm_rsb *r, int high, int *cw,\n\t\t\t\t unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint recover = rsb_flag(r, RSB_RECOVER_GRANT);\n\tint hi, demoted, quit, grant_restart, demote_restart;\n\tint deadlk;\n\n\tquit = 0;\n restart:\n\tgrant_restart = 0;\n\tdemote_restart = 0;\n\thi = DLM_LOCK_IV;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_convertqueue, lkb_statequeue) {\n\t\tdemoted = is_demoted(lkb);\n\t\tdeadlk = 0;\n\n\t\tif (can_be_granted(r, lkb, 0, recover, &deadlk)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tgrant_restart = 1;\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!demoted && is_demoted(lkb)) {\n\t\t\tlog_print(\"WARN: pending demoted %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdemote_restart = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (deadlk) {\n\t\t\tlog_print(\"WARN: pending deadlock %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tcontinue;\n\t\t}\n\n\t\thi = max_t(int, lkb->lkb_rqmode, hi);\n\n\t\tif (cw && lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t*cw = 1;\n\t}\n\n\tif (grant_restart)\n\t\tgoto restart;\n\tif (demote_restart && !quit) {\n\t\tquit = 1;\n\t\tgoto restart;\n\t}\n\n\treturn max_t(int, high, hi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"grant_pending_locks r nodeid %d\"",
            "r->res_nodeid"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master",
          "args": [
            "r"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t/*\n\t * If there are locks left on the wait/convert queue then send blocking\n\t * ASTs to granted locks based on the largest requested mode (high)\n\t * found above.\n\t */\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "lock_requires_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2596-2608",
    "snippet": "static int lock_requires_bast(struct dlm_lkb *gr, int high, int cw)\n{\n\tif (gr->lkb_grmode == DLM_LOCK_PR && cw) {\n\t\tif (gr->lkb_highbast < DLM_LOCK_EX)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (gr->lkb_highbast < high &&\n\t    !__dlm_compat_matrix[gr->lkb_grmode+1][high+1])\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};\n\nstatic int lock_requires_bast(struct dlm_lkb *gr, int high, int cw)\n{\n\tif (gr->lkb_grmode == DLM_LOCK_PR && cw) {\n\t\tif (gr->lkb_highbast < DLM_LOCK_EX)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (gr->lkb_highbast < high &&\n\t    !__dlm_compat_matrix[gr->lkb_grmode+1][high+1])\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "grant_pending_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2571-2589",
    "snippet": "static int grant_pending_wait(struct dlm_rsb *r, int high, int *cw,\n\t\t\t      unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_waitqueue, lkb_statequeue) {\n\t\tif (can_be_granted(r, lkb, 0, 0, NULL)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t} else {\n\t\t\thigh = max_t(int, lkb->lkb_rqmode, high);\n\t\t\tif (lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t\t*cw = 1;\n\t\t}\n\t}\n\n\treturn high;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "int",
            "lkb->lkb_rqmode",
            "high"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grant_lock_pending",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "grant_lock_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2146-2153",
          "snippet": "static void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_be_granted",
          "args": [
            "r",
            "lkb",
            "0",
            "0",
            "NULL"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "can_be_granted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2444-2503",
          "snippet": "static int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t/*\n\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve\n\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm\n\t * cancels one of the locks.\n\t */\n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\n\t\t} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t\tif (err)\n\t\t\t\t*err = -EDEADLK;\n\t\t\telse {\n\t\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t\t  lkb->lkb_id, now);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The ALTPR and ALTCW flags are non-standard and tell the dlm to try\n\t * to grant a request in a mode other than the normal rqmode.  It's a\n\t * simple way to provide a big optimization to applications that can\n\t * use them.\n\t */\n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t/*\n\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve\n\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm\n\t * cancels one of the locks.\n\t */\n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\n\t\t} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t\tif (err)\n\t\t\t\t*err = -EDEADLK;\n\t\t\telse {\n\t\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t\t  lkb->lkb_id, now);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The ALTPR and ALTCW flags are non-standard and tell the dlm to try\n\t * to grant a request in a mode other than the normal rqmode.  It's a\n\t * simple way to provide a big optimization to applications that can\n\t * use them.\n\t */\n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "s",
            "&r->res_waitqueue",
            "lkb_statequeue"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int grant_pending_wait(struct dlm_rsb *r, int high, int *cw,\n\t\t\t      unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_waitqueue, lkb_statequeue) {\n\t\tif (can_be_granted(r, lkb, 0, 0, NULL)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t} else {\n\t\t\thigh = max_t(int, lkb->lkb_rqmode, high);\n\t\t\tif (lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t\t*cw = 1;\n\t\t}\n\t}\n\n\treturn high;\n}"
  },
  {
    "function_name": "grant_pending_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2515-2569",
    "snippet": "static int grant_pending_convert(struct dlm_rsb *r, int high, int *cw,\n\t\t\t\t unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint recover = rsb_flag(r, RSB_RECOVER_GRANT);\n\tint hi, demoted, quit, grant_restart, demote_restart;\n\tint deadlk;\n\n\tquit = 0;\n restart:\n\tgrant_restart = 0;\n\tdemote_restart = 0;\n\thi = DLM_LOCK_IV;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_convertqueue, lkb_statequeue) {\n\t\tdemoted = is_demoted(lkb);\n\t\tdeadlk = 0;\n\n\t\tif (can_be_granted(r, lkb, 0, recover, &deadlk)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tgrant_restart = 1;\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!demoted && is_demoted(lkb)) {\n\t\t\tlog_print(\"WARN: pending demoted %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdemote_restart = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (deadlk) {\n\t\t\tlog_print(\"WARN: pending deadlock %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tcontinue;\n\t\t}\n\n\t\thi = max_t(int, lkb->lkb_rqmode, hi);\n\n\t\tif (cw && lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t*cw = 1;\n\t}\n\n\tif (grant_restart)\n\t\tgoto restart;\n\tif (demote_restart && !quit) {\n\t\tquit = 1;\n\t\tgoto restart;\n\t}\n\n\treturn max_t(int, high, hi);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "int",
            "high",
            "hi"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "int",
            "lkb->lkb_rqmode",
            "hi"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"WARN: pending deadlock %x node %d %s\"",
            "lkb->lkb_id",
            "lkb->lkb_nodeid",
            "r->res_name"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"WARN: pending demoted %x node %d %s\"",
            "lkb->lkb_id",
            "lkb->lkb_nodeid",
            "r->res_name"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_demoted",
          "args": [
            "lkb"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "is_demoted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "230-233",
          "snippet": "static inline int is_demoted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_DEMOTED);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_demoted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_DEMOTED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_lock_pending",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "grant_lock_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2146-2153",
          "snippet": "static void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_be_granted",
          "args": [
            "r",
            "lkb",
            "0",
            "recover",
            "&deadlk"
          ],
          "line": 2533
        },
        "resolved": true,
        "details": {
          "function_name": "can_be_granted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2444-2503",
          "snippet": "static int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t/*\n\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve\n\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm\n\t * cancels one of the locks.\n\t */\n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\n\t\t} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t\tif (err)\n\t\t\t\t*err = -EDEADLK;\n\t\t\telse {\n\t\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t\t  lkb->lkb_id, now);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The ALTPR and ALTCW flags are non-standard and tell the dlm to try\n\t * to grant a request in a mode other than the normal rqmode.  It's a\n\t * simple way to provide a big optimization to applications that can\n\t * use them.\n\t */\n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t/*\n\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve\n\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm\n\t * cancels one of the locks.\n\t */\n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\n\t\t} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t\tif (err)\n\t\t\t\t*err = -EDEADLK;\n\t\t\telse {\n\t\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t\t  lkb->lkb_id, now);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The ALTPR and ALTCW flags are non-standard and tell the dlm to try\n\t * to grant a request in a mode other than the normal rqmode.  It's a\n\t * simple way to provide a big optimization to applications that can\n\t * use them.\n\t */\n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "s",
            "&r->res_convertqueue",
            "lkb_statequeue"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsb_flag",
          "args": [
            "r",
            "RSB_RECOVER_GRANT"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "358-361",
          "snippet": "static inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int grant_pending_convert(struct dlm_rsb *r, int high, int *cw,\n\t\t\t\t unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint recover = rsb_flag(r, RSB_RECOVER_GRANT);\n\tint hi, demoted, quit, grant_restart, demote_restart;\n\tint deadlk;\n\n\tquit = 0;\n restart:\n\tgrant_restart = 0;\n\tdemote_restart = 0;\n\thi = DLM_LOCK_IV;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_convertqueue, lkb_statequeue) {\n\t\tdemoted = is_demoted(lkb);\n\t\tdeadlk = 0;\n\n\t\tif (can_be_granted(r, lkb, 0, recover, &deadlk)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tgrant_restart = 1;\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!demoted && is_demoted(lkb)) {\n\t\t\tlog_print(\"WARN: pending demoted %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdemote_restart = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (deadlk) {\n\t\t\tlog_print(\"WARN: pending deadlock %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tcontinue;\n\t\t}\n\n\t\thi = max_t(int, lkb->lkb_rqmode, hi);\n\n\t\tif (cw && lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t*cw = 1;\n\t}\n\n\tif (grant_restart)\n\t\tgoto restart;\n\tif (demote_restart && !quit) {\n\t\tquit = 1;\n\t\tgoto restart;\n\t}\n\n\treturn max_t(int, high, hi);\n}"
  },
  {
    "function_name": "can_be_granted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2444-2503",
    "snippet": "static int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t/*\n\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve\n\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm\n\t * cancels one of the locks.\n\t */\n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\n\t\t} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t\tif (err)\n\t\t\t\t*err = -EDEADLK;\n\t\t\telse {\n\t\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t\t  lkb->lkb_id, now);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The ALTPR and ALTCW flags are non-standard and tell the dlm to try\n\t * to grant a request in a mode other than the normal rqmode.  It's a\n\t * simple way to provide a big optimization to applications that can\n\t * use them.\n\t */\n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_can_be_granted",
          "args": [
            "r",
            "lkb",
            "now",
            "0"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "_can_be_granted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2298-2442",
          "snippet": "static int _can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t   int recover)\n{\n\tint8_t conv = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\t/*\n\t * 6-10: Version 5.4 introduced an option to address the phenomenon of\n\t * a new request for a NL mode lock being blocked.\n\t *\n\t * 6-11: If the optional EXPEDITE flag is used with the new NL mode\n\t * request, then it would be granted.  In essence, the use of this flag\n\t * tells the Lock Manager to expedite theis request by not considering\n\t * what may be in the CONVERTING or WAITING queues...  As of this\n\t * writing, the EXPEDITE flag can be used only with new requests for NL\n\t * mode locks.  This flag is not valid for conversion requests.\n\t *\n\t * A shortcut.  Earlier checks return an error if EXPEDITE is used in a\n\t * conversion or used with a non-NL requested mode.  We also know an\n\t * EXPEDITE request is always granted immediately, so now must always\n\t * be 1.  The full condition to grant an expedite request: (now &&\n\t * !conv && lkb->rqmode == DLM_LOCK_NL && (flags & EXPEDITE)) can\n\t * therefore be shortened to just checking the flag.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_EXPEDITE)\n\t\treturn 1;\n\n\t/*\n\t * A shortcut. Without this, !queue_conflict(grantqueue, lkb) would be\n\t * added to the remaining conditions.\n\t */\n\n\tif (queue_conflict(&r->res_grantqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * 6-3: By default, a conversion request is immediately granted if the\n\t * requested mode is compatible with the modes of all other granted\n\t * locks\n\t */\n\n\tif (queue_conflict(&r->res_convertqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * The RECOVER_GRANT flag means dlm_recover_grant() is granting\n\t * locks for a recovered rsb, on which lkb's have been rebuilt.\n\t * The lkb's may have been rebuilt on the queues in a different\n\t * order than they were in on the previous master.  So, granting\n\t * queued conversions in order after recovery doesn't make sense\n\t * since the order hasn't been preserved anyway.  The new order\n\t * could also have created a new \"in place\" conversion deadlock.\n\t * (e.g. old, failed master held granted EX, with PR->EX, NL->EX.\n\t * After recovery, there would be no granted locks, and possibly\n\t * NL->EX, PR->EX, an in-place conversion deadlock.)  So, after\n\t * recovery, grant conversions without considering order.\n\t */\n\n\tif (conv && recover)\n\t\treturn 1;\n\n\t/*\n\t * 6-5: But the default algorithm for deciding whether to grant or\n\t * queue conversion requests does not by itself guarantee that such\n\t * requests are serviced on a \"first come first serve\" basis.  This, in\n\t * turn, can lead to a phenomenon known as \"indefinate postponement\".\n\t *\n\t * 6-7: This issue is dealt with by using the optional QUECVT flag with\n\t * the system service employed to request a lock conversion.  This flag\n\t * forces certain conversion requests to be queued, even if they are\n\t * compatible with the granted modes of other locks on the same\n\t * resource.  Thus, the use of this flag results in conversion requests\n\t * being ordered on a \"first come first servce\" basis.\n\t *\n\t * DCT: This condition is all about new conversions being able to occur\n\t * \"in place\" while the lock remains on the granted queue (assuming\n\t * nothing else conflicts.)  IOW if QUECVT isn't set, a conversion\n\t * doesn't _have_ to go onto the convert queue where it's processed in\n\t * order.  The \"now\" variable is necessary to distinguish converts\n\t * being received and processed for the first time now, because once a\n\t * convert is moved to the conversion queue the condition below applies\n\t * requiring fifo granting.\n\t */\n\n\tif (now && conv && !(lkb->lkb_exflags & DLM_LKF_QUECVT))\n\t\treturn 1;\n\n\t/*\n\t * Even if the convert is compat with all granted locks,\n\t * QUECVT forces it behind other locks on the convert queue.\n\t */\n\n\tif (now && conv && (lkb->lkb_exflags & DLM_LKF_QUECVT)) {\n\t\tif (list_empty(&r->res_convertqueue))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * The NOORDER flag is set to avoid the standard vms rules on grant\n\t * order.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_NOORDER)\n\t\treturn 1;\n\n\t/*\n\t * 6-3: Once in that queue [CONVERTING], a conversion request cannot be\n\t * granted until all other conversion requests ahead of it are granted\n\t * and/or canceled.\n\t */\n\n\tif (!now && conv && first_in_list(lkb, &r->res_convertqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: By default, a new request is immediately granted only if all\n\t * three of the following conditions are satisfied when the request is\n\t * issued:\n\t * - The queue of ungranted conversion requests for the resource is\n\t *   empty.\n\t * - The queue of ungranted new requests for the resource is empty.\n\t * - The mode of the new request is compatible with the most\n\t *   restrictive mode of all granted locks on the resource.\n\t */\n\n\tif (now && !conv && list_empty(&r->res_convertqueue) &&\n\t    list_empty(&r->res_waitqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: Once a lock request is in the queue of ungranted new requests,\n\t * it cannot be granted until the queue of ungranted conversion\n\t * requests is empty, all ungranted new requests ahead of it are\n\t * granted and/or canceled, and it is compatible with the granted mode\n\t * of the most restrictive lock granted on the resource.\n\t */\n\n\tif (!now && !conv && list_empty(&r->res_convertqueue) &&\n\t    first_in_list(lkb, &r->res_waitqueue))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t   int recover)\n{\n\tint8_t conv = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\t/*\n\t * 6-10: Version 5.4 introduced an option to address the phenomenon of\n\t * a new request for a NL mode lock being blocked.\n\t *\n\t * 6-11: If the optional EXPEDITE flag is used with the new NL mode\n\t * request, then it would be granted.  In essence, the use of this flag\n\t * tells the Lock Manager to expedite theis request by not considering\n\t * what may be in the CONVERTING or WAITING queues...  As of this\n\t * writing, the EXPEDITE flag can be used only with new requests for NL\n\t * mode locks.  This flag is not valid for conversion requests.\n\t *\n\t * A shortcut.  Earlier checks return an error if EXPEDITE is used in a\n\t * conversion or used with a non-NL requested mode.  We also know an\n\t * EXPEDITE request is always granted immediately, so now must always\n\t * be 1.  The full condition to grant an expedite request: (now &&\n\t * !conv && lkb->rqmode == DLM_LOCK_NL && (flags & EXPEDITE)) can\n\t * therefore be shortened to just checking the flag.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_EXPEDITE)\n\t\treturn 1;\n\n\t/*\n\t * A shortcut. Without this, !queue_conflict(grantqueue, lkb) would be\n\t * added to the remaining conditions.\n\t */\n\n\tif (queue_conflict(&r->res_grantqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * 6-3: By default, a conversion request is immediately granted if the\n\t * requested mode is compatible with the modes of all other granted\n\t * locks\n\t */\n\n\tif (queue_conflict(&r->res_convertqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * The RECOVER_GRANT flag means dlm_recover_grant() is granting\n\t * locks for a recovered rsb, on which lkb's have been rebuilt.\n\t * The lkb's may have been rebuilt on the queues in a different\n\t * order than they were in on the previous master.  So, granting\n\t * queued conversions in order after recovery doesn't make sense\n\t * since the order hasn't been preserved anyway.  The new order\n\t * could also have created a new \"in place\" conversion deadlock.\n\t * (e.g. old, failed master held granted EX, with PR->EX, NL->EX.\n\t * After recovery, there would be no granted locks, and possibly\n\t * NL->EX, PR->EX, an in-place conversion deadlock.)  So, after\n\t * recovery, grant conversions without considering order.\n\t */\n\n\tif (conv && recover)\n\t\treturn 1;\n\n\t/*\n\t * 6-5: But the default algorithm for deciding whether to grant or\n\t * queue conversion requests does not by itself guarantee that such\n\t * requests are serviced on a \"first come first serve\" basis.  This, in\n\t * turn, can lead to a phenomenon known as \"indefinate postponement\".\n\t *\n\t * 6-7: This issue is dealt with by using the optional QUECVT flag with\n\t * the system service employed to request a lock conversion.  This flag\n\t * forces certain conversion requests to be queued, even if they are\n\t * compatible with the granted modes of other locks on the same\n\t * resource.  Thus, the use of this flag results in conversion requests\n\t * being ordered on a \"first come first servce\" basis.\n\t *\n\t * DCT: This condition is all about new conversions being able to occur\n\t * \"in place\" while the lock remains on the granted queue (assuming\n\t * nothing else conflicts.)  IOW if QUECVT isn't set, a conversion\n\t * doesn't _have_ to go onto the convert queue where it's processed in\n\t * order.  The \"now\" variable is necessary to distinguish converts\n\t * being received and processed for the first time now, because once a\n\t * convert is moved to the conversion queue the condition below applies\n\t * requiring fifo granting.\n\t */\n\n\tif (now && conv && !(lkb->lkb_exflags & DLM_LKF_QUECVT))\n\t\treturn 1;\n\n\t/*\n\t * Even if the convert is compat with all granted locks,\n\t * QUECVT forces it behind other locks on the convert queue.\n\t */\n\n\tif (now && conv && (lkb->lkb_exflags & DLM_LKF_QUECVT)) {\n\t\tif (list_empty(&r->res_convertqueue))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * The NOORDER flag is set to avoid the standard vms rules on grant\n\t * order.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_NOORDER)\n\t\treturn 1;\n\n\t/*\n\t * 6-3: Once in that queue [CONVERTING], a conversion request cannot be\n\t * granted until all other conversion requests ahead of it are granted\n\t * and/or canceled.\n\t */\n\n\tif (!now && conv && first_in_list(lkb, &r->res_convertqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: By default, a new request is immediately granted only if all\n\t * three of the following conditions are satisfied when the request is\n\t * issued:\n\t * - The queue of ungranted conversion requests for the resource is\n\t *   empty.\n\t * - The queue of ungranted new requests for the resource is empty.\n\t * - The mode of the new request is compatible with the most\n\t *   restrictive mode of all granted locks on the resource.\n\t */\n\n\tif (now && !conv && list_empty(&r->res_convertqueue) &&\n\t    list_empty(&r->res_waitqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: Once a lock request is in the queue of ungranted new requests,\n\t * it cannot be granted until the queue of ungranted conversion\n\t * requests is empty, all ungranted new requests ahead of it are\n\t * granted and/or canceled, and it is compatible with the granted mode\n\t * of the most restrictive lock granted on the resource.\n\t */\n\n\tif (!now && !conv && list_empty(&r->res_convertqueue) &&\n\t    first_in_list(lkb, &r->res_waitqueue))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"can_be_granted deadlock %x now %d\"",
            "lkb->lkb_id",
            "now"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conversion_deadlock_detect",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "conversion_deadlock_detect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2259-2280",
          "snippet": "static int conversion_deadlock_detect(struct dlm_rsb *r, struct dlm_lkb *lkb2)\n{\n\tstruct dlm_lkb *lkb1;\n\tint lkb_is_ahead = 0;\n\n\tlist_for_each_entry(lkb1, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (lkb1 == lkb2) {\n\t\t\tlkb_is_ahead = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!lkb_is_ahead) {\n\t\t\tif (!modes_compat(lkb2, lkb1))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (!modes_compat(lkb2, lkb1) &&\n\t\t\t    !modes_compat(lkb1, lkb2))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int conversion_deadlock_detect(struct dlm_rsb *r, struct dlm_lkb *lkb2)\n{\n\tstruct dlm_lkb *lkb1;\n\tint lkb_is_ahead = 0;\n\n\tlist_for_each_entry(lkb1, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (lkb1 == lkb2) {\n\t\t\tlkb_is_ahead = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!lkb_is_ahead) {\n\t\t\tif (!modes_compat(lkb2, lkb1))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (!modes_compat(lkb2, lkb1) &&\n\t\t\t    !modes_compat(lkb1, lkb2))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_be_queued",
          "args": [
            "lkb"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "can_be_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "220-223",
          "snippet": "static inline int can_be_queued(struct dlm_lkb *lkb)\n{\n\treturn !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int can_be_queued(struct dlm_lkb *lkb)\n{\n\treturn !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t/*\n\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve\n\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm\n\t * cancels one of the locks.\n\t */\n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\n\t\t} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t\tif (err)\n\t\t\t\t*err = -EDEADLK;\n\t\t\telse {\n\t\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t\t  lkb->lkb_id, now);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The ALTPR and ALTCW flags are non-standard and tell the dlm to try\n\t * to grant a request in a mode other than the normal rqmode.  It's a\n\t * simple way to provide a big optimization to applications that can\n\t * use them.\n\t */\n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}"
  },
  {
    "function_name": "_can_be_granted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2298-2442",
    "snippet": "static int _can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t   int recover)\n{\n\tint8_t conv = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\t/*\n\t * 6-10: Version 5.4 introduced an option to address the phenomenon of\n\t * a new request for a NL mode lock being blocked.\n\t *\n\t * 6-11: If the optional EXPEDITE flag is used with the new NL mode\n\t * request, then it would be granted.  In essence, the use of this flag\n\t * tells the Lock Manager to expedite theis request by not considering\n\t * what may be in the CONVERTING or WAITING queues...  As of this\n\t * writing, the EXPEDITE flag can be used only with new requests for NL\n\t * mode locks.  This flag is not valid for conversion requests.\n\t *\n\t * A shortcut.  Earlier checks return an error if EXPEDITE is used in a\n\t * conversion or used with a non-NL requested mode.  We also know an\n\t * EXPEDITE request is always granted immediately, so now must always\n\t * be 1.  The full condition to grant an expedite request: (now &&\n\t * !conv && lkb->rqmode == DLM_LOCK_NL && (flags & EXPEDITE)) can\n\t * therefore be shortened to just checking the flag.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_EXPEDITE)\n\t\treturn 1;\n\n\t/*\n\t * A shortcut. Without this, !queue_conflict(grantqueue, lkb) would be\n\t * added to the remaining conditions.\n\t */\n\n\tif (queue_conflict(&r->res_grantqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * 6-3: By default, a conversion request is immediately granted if the\n\t * requested mode is compatible with the modes of all other granted\n\t * locks\n\t */\n\n\tif (queue_conflict(&r->res_convertqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * The RECOVER_GRANT flag means dlm_recover_grant() is granting\n\t * locks for a recovered rsb, on which lkb's have been rebuilt.\n\t * The lkb's may have been rebuilt on the queues in a different\n\t * order than they were in on the previous master.  So, granting\n\t * queued conversions in order after recovery doesn't make sense\n\t * since the order hasn't been preserved anyway.  The new order\n\t * could also have created a new \"in place\" conversion deadlock.\n\t * (e.g. old, failed master held granted EX, with PR->EX, NL->EX.\n\t * After recovery, there would be no granted locks, and possibly\n\t * NL->EX, PR->EX, an in-place conversion deadlock.)  So, after\n\t * recovery, grant conversions without considering order.\n\t */\n\n\tif (conv && recover)\n\t\treturn 1;\n\n\t/*\n\t * 6-5: But the default algorithm for deciding whether to grant or\n\t * queue conversion requests does not by itself guarantee that such\n\t * requests are serviced on a \"first come first serve\" basis.  This, in\n\t * turn, can lead to a phenomenon known as \"indefinate postponement\".\n\t *\n\t * 6-7: This issue is dealt with by using the optional QUECVT flag with\n\t * the system service employed to request a lock conversion.  This flag\n\t * forces certain conversion requests to be queued, even if they are\n\t * compatible with the granted modes of other locks on the same\n\t * resource.  Thus, the use of this flag results in conversion requests\n\t * being ordered on a \"first come first servce\" basis.\n\t *\n\t * DCT: This condition is all about new conversions being able to occur\n\t * \"in place\" while the lock remains on the granted queue (assuming\n\t * nothing else conflicts.)  IOW if QUECVT isn't set, a conversion\n\t * doesn't _have_ to go onto the convert queue where it's processed in\n\t * order.  The \"now\" variable is necessary to distinguish converts\n\t * being received and processed for the first time now, because once a\n\t * convert is moved to the conversion queue the condition below applies\n\t * requiring fifo granting.\n\t */\n\n\tif (now && conv && !(lkb->lkb_exflags & DLM_LKF_QUECVT))\n\t\treturn 1;\n\n\t/*\n\t * Even if the convert is compat with all granted locks,\n\t * QUECVT forces it behind other locks on the convert queue.\n\t */\n\n\tif (now && conv && (lkb->lkb_exflags & DLM_LKF_QUECVT)) {\n\t\tif (list_empty(&r->res_convertqueue))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * The NOORDER flag is set to avoid the standard vms rules on grant\n\t * order.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_NOORDER)\n\t\treturn 1;\n\n\t/*\n\t * 6-3: Once in that queue [CONVERTING], a conversion request cannot be\n\t * granted until all other conversion requests ahead of it are granted\n\t * and/or canceled.\n\t */\n\n\tif (!now && conv && first_in_list(lkb, &r->res_convertqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: By default, a new request is immediately granted only if all\n\t * three of the following conditions are satisfied when the request is\n\t * issued:\n\t * - The queue of ungranted conversion requests for the resource is\n\t *   empty.\n\t * - The queue of ungranted new requests for the resource is empty.\n\t * - The mode of the new request is compatible with the most\n\t *   restrictive mode of all granted locks on the resource.\n\t */\n\n\tif (now && !conv && list_empty(&r->res_convertqueue) &&\n\t    list_empty(&r->res_waitqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: Once a lock request is in the queue of ungranted new requests,\n\t * it cannot be granted until the queue of ungranted conversion\n\t * requests is empty, all ungranted new requests ahead of it are\n\t * granted and/or canceled, and it is compatible with the granted mode\n\t * of the most restrictive lock granted on the resource.\n\t */\n\n\tif (!now && !conv && list_empty(&r->res_convertqueue) &&\n\t    first_in_list(lkb, &r->res_waitqueue))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "first_in_list",
          "args": [
            "lkb",
            "&r->res_waitqueue"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "first_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2193-2201",
          "snippet": "static inline int first_in_list(struct dlm_lkb *lkb, struct list_head *head)\n{\n\tstruct dlm_lkb *first = list_entry(head->next, struct dlm_lkb,\n\t\t\t\t\t   lkb_statequeue);\n\tif (lkb->lkb_id == first->lkb_id)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int first_in_list(struct dlm_lkb *lkb, struct list_head *head)\n{\n\tstruct dlm_lkb *first = list_entry(head->next, struct dlm_lkb,\n\t\t\t\t\t   lkb_statequeue);\n\tif (lkb->lkb_id == first->lkb_id)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&r->res_convertqueue"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_conflict",
          "args": [
            "&r->res_convertqueue",
            "lkb"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "queue_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2205-2216",
          "snippet": "static int queue_conflict(struct list_head *head, struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *this;\n\n\tlist_for_each_entry(this, head, lkb_statequeue) {\n\t\tif (this == lkb)\n\t\t\tcontinue;\n\t\tif (!modes_compat(this, lkb))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int queue_conflict(struct list_head *head, struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *this;\n\n\tlist_for_each_entry(this, head, lkb_statequeue) {\n\t\tif (this == lkb)\n\t\t\tcontinue;\n\t\tif (!modes_compat(this, lkb))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t   int recover)\n{\n\tint8_t conv = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\t/*\n\t * 6-10: Version 5.4 introduced an option to address the phenomenon of\n\t * a new request for a NL mode lock being blocked.\n\t *\n\t * 6-11: If the optional EXPEDITE flag is used with the new NL mode\n\t * request, then it would be granted.  In essence, the use of this flag\n\t * tells the Lock Manager to expedite theis request by not considering\n\t * what may be in the CONVERTING or WAITING queues...  As of this\n\t * writing, the EXPEDITE flag can be used only with new requests for NL\n\t * mode locks.  This flag is not valid for conversion requests.\n\t *\n\t * A shortcut.  Earlier checks return an error if EXPEDITE is used in a\n\t * conversion or used with a non-NL requested mode.  We also know an\n\t * EXPEDITE request is always granted immediately, so now must always\n\t * be 1.  The full condition to grant an expedite request: (now &&\n\t * !conv && lkb->rqmode == DLM_LOCK_NL && (flags & EXPEDITE)) can\n\t * therefore be shortened to just checking the flag.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_EXPEDITE)\n\t\treturn 1;\n\n\t/*\n\t * A shortcut. Without this, !queue_conflict(grantqueue, lkb) would be\n\t * added to the remaining conditions.\n\t */\n\n\tif (queue_conflict(&r->res_grantqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * 6-3: By default, a conversion request is immediately granted if the\n\t * requested mode is compatible with the modes of all other granted\n\t * locks\n\t */\n\n\tif (queue_conflict(&r->res_convertqueue, lkb))\n\t\treturn 0;\n\n\t/*\n\t * The RECOVER_GRANT flag means dlm_recover_grant() is granting\n\t * locks for a recovered rsb, on which lkb's have been rebuilt.\n\t * The lkb's may have been rebuilt on the queues in a different\n\t * order than they were in on the previous master.  So, granting\n\t * queued conversions in order after recovery doesn't make sense\n\t * since the order hasn't been preserved anyway.  The new order\n\t * could also have created a new \"in place\" conversion deadlock.\n\t * (e.g. old, failed master held granted EX, with PR->EX, NL->EX.\n\t * After recovery, there would be no granted locks, and possibly\n\t * NL->EX, PR->EX, an in-place conversion deadlock.)  So, after\n\t * recovery, grant conversions without considering order.\n\t */\n\n\tif (conv && recover)\n\t\treturn 1;\n\n\t/*\n\t * 6-5: But the default algorithm for deciding whether to grant or\n\t * queue conversion requests does not by itself guarantee that such\n\t * requests are serviced on a \"first come first serve\" basis.  This, in\n\t * turn, can lead to a phenomenon known as \"indefinate postponement\".\n\t *\n\t * 6-7: This issue is dealt with by using the optional QUECVT flag with\n\t * the system service employed to request a lock conversion.  This flag\n\t * forces certain conversion requests to be queued, even if they are\n\t * compatible with the granted modes of other locks on the same\n\t * resource.  Thus, the use of this flag results in conversion requests\n\t * being ordered on a \"first come first servce\" basis.\n\t *\n\t * DCT: This condition is all about new conversions being able to occur\n\t * \"in place\" while the lock remains on the granted queue (assuming\n\t * nothing else conflicts.)  IOW if QUECVT isn't set, a conversion\n\t * doesn't _have_ to go onto the convert queue where it's processed in\n\t * order.  The \"now\" variable is necessary to distinguish converts\n\t * being received and processed for the first time now, because once a\n\t * convert is moved to the conversion queue the condition below applies\n\t * requiring fifo granting.\n\t */\n\n\tif (now && conv && !(lkb->lkb_exflags & DLM_LKF_QUECVT))\n\t\treturn 1;\n\n\t/*\n\t * Even if the convert is compat with all granted locks,\n\t * QUECVT forces it behind other locks on the convert queue.\n\t */\n\n\tif (now && conv && (lkb->lkb_exflags & DLM_LKF_QUECVT)) {\n\t\tif (list_empty(&r->res_convertqueue))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * The NOORDER flag is set to avoid the standard vms rules on grant\n\t * order.\n\t */\n\n\tif (lkb->lkb_exflags & DLM_LKF_NOORDER)\n\t\treturn 1;\n\n\t/*\n\t * 6-3: Once in that queue [CONVERTING], a conversion request cannot be\n\t * granted until all other conversion requests ahead of it are granted\n\t * and/or canceled.\n\t */\n\n\tif (!now && conv && first_in_list(lkb, &r->res_convertqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: By default, a new request is immediately granted only if all\n\t * three of the following conditions are satisfied when the request is\n\t * issued:\n\t * - The queue of ungranted conversion requests for the resource is\n\t *   empty.\n\t * - The queue of ungranted new requests for the resource is empty.\n\t * - The mode of the new request is compatible with the most\n\t *   restrictive mode of all granted locks on the resource.\n\t */\n\n\tif (now && !conv && list_empty(&r->res_convertqueue) &&\n\t    list_empty(&r->res_waitqueue))\n\t\treturn 1;\n\n\t/*\n\t * 6-4: Once a lock request is in the queue of ungranted new requests,\n\t * it cannot be granted until the queue of ungranted conversion\n\t * requests is empty, all ungranted new requests ahead of it are\n\t * granted and/or canceled, and it is compatible with the granted mode\n\t * of the most restrictive lock granted on the resource.\n\t */\n\n\tif (!now && !conv && list_empty(&r->res_convertqueue) &&\n\t    first_in_list(lkb, &r->res_waitqueue))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "conversion_deadlock_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2259-2280",
    "snippet": "static int conversion_deadlock_detect(struct dlm_rsb *r, struct dlm_lkb *lkb2)\n{\n\tstruct dlm_lkb *lkb1;\n\tint lkb_is_ahead = 0;\n\n\tlist_for_each_entry(lkb1, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (lkb1 == lkb2) {\n\t\t\tlkb_is_ahead = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!lkb_is_ahead) {\n\t\t\tif (!modes_compat(lkb2, lkb1))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (!modes_compat(lkb2, lkb1) &&\n\t\t\t    !modes_compat(lkb1, lkb2))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "modes_compat",
          "args": [
            "lkb1",
            "lkb2"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_modes_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "139-142",
          "snippet": "int dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};\n\nint dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb1",
            "&r->res_convertqueue",
            "lkb_statequeue"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int conversion_deadlock_detect(struct dlm_rsb *r, struct dlm_lkb *lkb2)\n{\n\tstruct dlm_lkb *lkb1;\n\tint lkb_is_ahead = 0;\n\n\tlist_for_each_entry(lkb1, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (lkb1 == lkb2) {\n\t\t\tlkb_is_ahead = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!lkb_is_ahead) {\n\t\t\tif (!modes_compat(lkb2, lkb1))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (!modes_compat(lkb2, lkb1) &&\n\t\t\t    !modes_compat(lkb1, lkb2))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "queue_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2205-2216",
    "snippet": "static int queue_conflict(struct list_head *head, struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *this;\n\n\tlist_for_each_entry(this, head, lkb_statequeue) {\n\t\tif (this == lkb)\n\t\t\tcontinue;\n\t\tif (!modes_compat(this, lkb))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "modes_compat",
          "args": [
            "this",
            "lkb"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_modes_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "139-142",
          "snippet": "int dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};\n\nint dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "this",
            "head",
            "lkb_statequeue"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int queue_conflict(struct list_head *head, struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *this;\n\n\tlist_for_each_entry(this, head, lkb_statequeue) {\n\t\tif (this == lkb)\n\t\t\tcontinue;\n\t\tif (!modes_compat(this, lkb))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "first_in_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2193-2201",
    "snippet": "static inline int first_in_list(struct dlm_lkb *lkb, struct list_head *head)\n{\n\tstruct dlm_lkb *first = list_entry(head->next, struct dlm_lkb,\n\t\t\t\t\t   lkb_statequeue);\n\tif (lkb->lkb_id == first->lkb_id)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->next",
            "structdlm_lkb",
            "lkb_statequeue"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int first_in_list(struct dlm_lkb *lkb, struct list_head *head)\n{\n\tstruct dlm_lkb *first = list_entry(head->next, struct dlm_lkb,\n\t\t\t\t\t   lkb_statequeue);\n\tif (lkb->lkb_id == first->lkb_id)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "munge_altmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2174-2191",
    "snippet": "static void munge_altmode(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_type != DLM_MSG_REQUEST_REPLY &&\n\t    ms->m_type != DLM_MSG_GRANT) {\n\t\tlog_print(\"munge_altmode %x invalid reply type %d\",\n\t\t\t  lkb->lkb_id, ms->m_type);\n\t\treturn;\n\t}\n\n\tif (lkb->lkb_exflags & DLM_LKF_ALTPR)\n\t\tlkb->lkb_rqmode = DLM_LOCK_PR;\n\telse if (lkb->lkb_exflags & DLM_LKF_ALTCW)\n\t\tlkb->lkb_rqmode = DLM_LOCK_CW;\n\telse {\n\t\tlog_print(\"munge_altmode invalid exflags %x\", lkb->lkb_exflags);\n\t\tdlm_print_lkb(lkb);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"munge_altmode invalid exflags %x\"",
            "lkb->lkb_exflags"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"munge_altmode %x invalid reply type %d\"",
            "lkb->lkb_id",
            "ms->m_type"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void munge_altmode(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tif (ms->m_type != DLM_MSG_REQUEST_REPLY &&\n\t    ms->m_type != DLM_MSG_GRANT) {\n\t\tlog_print(\"munge_altmode %x invalid reply type %d\",\n\t\t\t  lkb->lkb_id, ms->m_type);\n\t\treturn;\n\t}\n\n\tif (lkb->lkb_exflags & DLM_LKF_ALTPR)\n\t\tlkb->lkb_rqmode = DLM_LOCK_PR;\n\telse if (lkb->lkb_exflags & DLM_LKF_ALTCW)\n\t\tlkb->lkb_rqmode = DLM_LOCK_CW;\n\telse {\n\t\tlog_print(\"munge_altmode invalid exflags %x\", lkb->lkb_exflags);\n\t\tdlm_print_lkb(lkb);\n\t}\n}"
  },
  {
    "function_name": "munge_demoted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2163-2172",
    "snippet": "static void munge_demoted(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_rqmode == DLM_LOCK_IV || lkb->lkb_grmode == DLM_LOCK_IV) {\n\t\tlog_print(\"munge_demoted %x invalid modes gr %d rq %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_grmode, lkb->lkb_rqmode);\n\t\treturn;\n\t}\n\n\tlkb->lkb_grmode = DLM_LOCK_NL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"munge_demoted %x invalid modes gr %d rq %d\"",
            "lkb->lkb_id",
            "lkb->lkb_grmode",
            "lkb->lkb_rqmode"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void munge_demoted(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_rqmode == DLM_LOCK_IV || lkb->lkb_grmode == DLM_LOCK_IV) {\n\t\tlog_print(\"munge_demoted %x invalid modes gr %d rq %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_grmode, lkb->lkb_rqmode);\n\t\treturn;\n\t}\n\n\tlkb->lkb_grmode = DLM_LOCK_NL;\n}"
  },
  {
    "function_name": "grant_lock_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2146-2153",
    "snippet": "static void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "0"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_grant",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "send_grant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3706-3725",
          "snippet": "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, DLM_MSG_GRANT, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = 0;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, DLM_MSG_GRANT, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = 0;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master_copy",
          "args": [
            "lkb"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grant_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "grant_lock_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2146-2153",
          "snippet": "static void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}"
  },
  {
    "function_name": "grant_lock_pc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2135-2140",
    "snippet": "static void grant_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  struct dlm_message *ms)\n{\n\tset_lvb_lock_pc(r, lkb, ms);\n\t_grant_lock(r, lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_grant_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "_grant_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2115-2127",
          "snippet": "static void _grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode != lkb->lkb_rqmode) {\n\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\tif (lkb->lkb_status)\n\t\t\tmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t\telse\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t}\n\n\tlkb->lkb_rqmode = DLM_LOCK_IV;\n\tlkb->lkb_highbast = 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode != lkb->lkb_rqmode) {\n\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\tif (lkb->lkb_status)\n\t\t\tmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t\telse\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t}\n\n\tlkb->lkb_rqmode = DLM_LOCK_IV;\n\tlkb->lkb_highbast = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_lvb_lock_pc",
          "args": [
            "r",
            "lkb",
            "ms"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "set_lvb_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2028-2047",
          "snippet": "static void set_lvb_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t    struct dlm_message *ms)\n{\n\tint b;\n\n\tif (!lkb->lkb_lvbptr)\n\t\treturn;\n\n\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\treturn;\n\n\tb = dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\n\tif (b == 1) {\n\t\tint len = receive_extralen(ms);\n\t\tif (len > r->res_ls->ls_lvblen)\n\t\t\tlen = r->res_ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t\tlkb->lkb_lvbseq = ms->m_lvbseq;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);",
            "const int dlm_lvb_operations[8][8] = {\n        /* UN   NL  CR  CW  PR  PW  EX  PD*/\n        {  -1,  1,  1,  1,  1,  1,  1, -1 }, /* UN */\n        {  -1,  1,  1,  1,  1,  1,  1,  0 }, /* NL */\n        {  -1, -1,  1,  1,  1,  1,  1,  0 }, /* CR */\n        {  -1, -1, -1,  1,  1,  1,  1,  0 }, /* CW */\n        {  -1, -1, -1, -1,  1,  1,  1,  0 }, /* PR */\n        {  -1,  0,  0,  0,  0,  0,  1,  0 }, /* PW */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }, /* EX */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }  /* PD */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\nconst int dlm_lvb_operations[8][8] = {\n        /* UN   NL  CR  CW  PR  PW  EX  PD*/\n        {  -1,  1,  1,  1,  1,  1,  1, -1 }, /* UN */\n        {  -1,  1,  1,  1,  1,  1,  1,  0 }, /* NL */\n        {  -1, -1,  1,  1,  1,  1,  1,  0 }, /* CR */\n        {  -1, -1, -1,  1,  1,  1,  1,  0 }, /* CW */\n        {  -1, -1, -1, -1,  1,  1,  1,  0 }, /* PR */\n        {  -1,  0,  0,  0,  0,  0,  1,  0 }, /* PW */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }, /* EX */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }  /* PD */\n};\n\nstatic void set_lvb_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t    struct dlm_message *ms)\n{\n\tint b;\n\n\tif (!lkb->lkb_lvbptr)\n\t\treturn;\n\n\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\treturn;\n\n\tb = dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\n\tif (b == 1) {\n\t\tint len = receive_extralen(ms);\n\t\tif (len > r->res_ls->ls_lvblen)\n\t\t\tlen = r->res_ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t\tlkb->lkb_lvbseq = ms->m_lvbseq;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  struct dlm_message *ms)\n{\n\tset_lvb_lock_pc(r, lkb, ms);\n\t_grant_lock(r, lkb);\n}"
  },
  {
    "function_name": "grant_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2129-2133",
    "snippet": "static void grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tset_lvb_lock(r, lkb);\n\t_grant_lock(r, lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_grant_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "_grant_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2115-2127",
          "snippet": "static void _grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode != lkb->lkb_rqmode) {\n\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\tif (lkb->lkb_status)\n\t\t\tmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t\telse\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t}\n\n\tlkb->lkb_rqmode = DLM_LOCK_IV;\n\tlkb->lkb_highbast = 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode != lkb->lkb_rqmode) {\n\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\tif (lkb->lkb_status)\n\t\t\tmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t\telse\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t}\n\n\tlkb->lkb_rqmode = DLM_LOCK_IV;\n\tlkb->lkb_highbast = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_lvb_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "set_lvb_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1948-1997",
          "snippet": "static void set_lvb_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint b, len = r->res_ls->ls_lvblen;\n\n\t/* b=1 lvb returned to caller\n\t   b=0 lvb written to rsb or invalidated\n\t   b=-1 do nothing */\n\n\tb =  dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\n\n\tif (b == 1) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn;\n\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\treturn;\n\n\t\tif (!r->res_lvbptr)\n\t\t\treturn;\n\n\t\tmemcpy(lkb->lkb_lvbptr, r->res_lvbptr, len);\n\t\tlkb->lkb_lvbseq = r->res_lvbseq;\n\n\t} else if (b == 0) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\n\t\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn;\n\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\treturn;\n\n\t\tif (!r->res_lvbptr)\n\t\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\n\t\tif (!r->res_lvbptr)\n\t\t\treturn;\n\n\t\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, len);\n\t\tr->res_lvbseq++;\n\t\tlkb->lkb_lvbseq = r->res_lvbseq;\n\t\trsb_clear_flag(r, RSB_VALNOTVALID);\n\t}\n\n\tif (rsb_flag(r, RSB_VALNOTVALID))\n\t\tlkb->lkb_sbflags |= DLM_SBF_VALNOTVALID;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);",
            "const int dlm_lvb_operations[8][8] = {\n        /* UN   NL  CR  CW  PR  PW  EX  PD*/\n        {  -1,  1,  1,  1,  1,  1,  1, -1 }, /* UN */\n        {  -1,  1,  1,  1,  1,  1,  1,  0 }, /* NL */\n        {  -1, -1,  1,  1,  1,  1,  1,  0 }, /* CR */\n        {  -1, -1, -1,  1,  1,  1,  1,  0 }, /* CW */\n        {  -1, -1, -1, -1,  1,  1,  1,  0 }, /* PR */\n        {  -1,  0,  0,  0,  0,  0,  1,  0 }, /* PW */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }, /* EX */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }  /* PD */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\nconst int dlm_lvb_operations[8][8] = {\n        /* UN   NL  CR  CW  PR  PW  EX  PD*/\n        {  -1,  1,  1,  1,  1,  1,  1, -1 }, /* UN */\n        {  -1,  1,  1,  1,  1,  1,  1,  0 }, /* NL */\n        {  -1, -1,  1,  1,  1,  1,  1,  0 }, /* CR */\n        {  -1, -1, -1,  1,  1,  1,  1,  0 }, /* CW */\n        {  -1, -1, -1, -1,  1,  1,  1,  0 }, /* PR */\n        {  -1,  0,  0,  0,  0,  0,  1,  0 }, /* PW */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }, /* EX */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }  /* PD */\n};\n\nstatic void set_lvb_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint b, len = r->res_ls->ls_lvblen;\n\n\t/* b=1 lvb returned to caller\n\t   b=0 lvb written to rsb or invalidated\n\t   b=-1 do nothing */\n\n\tb =  dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\n\n\tif (b == 1) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn;\n\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\treturn;\n\n\t\tif (!r->res_lvbptr)\n\t\t\treturn;\n\n\t\tmemcpy(lkb->lkb_lvbptr, r->res_lvbptr, len);\n\t\tlkb->lkb_lvbseq = r->res_lvbseq;\n\n\t} else if (b == 0) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\n\t\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn;\n\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\treturn;\n\n\t\tif (!r->res_lvbptr)\n\t\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\n\t\tif (!r->res_lvbptr)\n\t\t\treturn;\n\n\t\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, len);\n\t\tr->res_lvbseq++;\n\t\tlkb->lkb_lvbseq = r->res_lvbseq;\n\t\trsb_clear_flag(r, RSB_VALNOTVALID);\n\t}\n\n\tif (rsb_flag(r, RSB_VALNOTVALID))\n\t\tlkb->lkb_sbflags |= DLM_SBF_VALNOTVALID;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tset_lvb_lock(r, lkb);\n\t_grant_lock(r, lkb);\n}"
  },
  {
    "function_name": "_grant_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2115-2127",
    "snippet": "static void _grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode != lkb->lkb_rqmode) {\n\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\tif (lkb->lkb_status)\n\t\t\tmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t\telse\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t}\n\n\tlkb->lkb_rqmode = DLM_LOCK_IV;\n\tlkb->lkb_highbast = 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_lkb",
          "args": [
            "r",
            "lkb",
            "DLM_LKSTS_GRANTED"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "add_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1314-1346",
          "snippet": "static void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_lkb",
          "args": [
            "r",
            "lkb",
            "DLM_LKSTS_GRANTED"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "move_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1355-1361",
          "snippet": "static void move_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int sts)\n{\n\thold_lkb(lkb);\n\tdel_lkb(r, lkb);\n\tadd_lkb(r, lkb, sts);\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void move_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int sts)\n{\n\thold_lkb(lkb);\n\tdel_lkb(r, lkb);\n\tadd_lkb(r, lkb, sts);\n\tunhold_lkb(lkb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode != lkb->lkb_rqmode) {\n\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\tif (lkb->lkb_status)\n\t\t\tmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t\telse\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t}\n\n\tlkb->lkb_rqmode = DLM_LOCK_IV;\n\tlkb->lkb_highbast = 0;\n}"
  },
  {
    "function_name": "revert_lock_pc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2110-2113",
    "snippet": "static int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "revert_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "revert_lock_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2110-2113",
          "snippet": "static int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}"
  },
  {
    "function_name": "revert_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2083-2108",
    "snippet": "static int revert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint rv = 0;\n\n\tlkb->lkb_rqmode = DLM_LOCK_IV;\n\n\tswitch (lkb->lkb_status) {\n\tcase DLM_LKSTS_GRANTED:\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t\trv = 1;\n\t\tbreak;\n\tcase DLM_LKSTS_WAITING:\n\t\tdel_lkb(r, lkb);\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\t/* this unhold undoes the original ref from create_lkb()\n\t\t   so this leads to the lkb being freed */\n\t\tunhold_lkb(lkb);\n\t\trv = -1;\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"invalid status for revert %d\", lkb->lkb_status);\n\t}\n\treturn rv;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"invalid status for revert %d\"",
            "lkb->lkb_status"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_lkb",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "del_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1348-1353",
          "snippet": "static void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_lkb",
          "args": [
            "r",
            "lkb",
            "DLM_LKSTS_GRANTED"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "move_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1355-1361",
          "snippet": "static void move_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int sts)\n{\n\thold_lkb(lkb);\n\tdel_lkb(r, lkb);\n\tadd_lkb(r, lkb, sts);\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void move_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int sts)\n{\n\thold_lkb(lkb);\n\tdel_lkb(r, lkb);\n\tadd_lkb(r, lkb, sts);\n\tunhold_lkb(lkb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int revert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint rv = 0;\n\n\tlkb->lkb_rqmode = DLM_LOCK_IV;\n\n\tswitch (lkb->lkb_status) {\n\tcase DLM_LKSTS_GRANTED:\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t\trv = 1;\n\t\tbreak;\n\tcase DLM_LKSTS_WAITING:\n\t\tdel_lkb(r, lkb);\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\t/* this unhold undoes the original ref from create_lkb()\n\t\t   so this leads to the lkb being freed */\n\t\tunhold_lkb(lkb);\n\t\trv = -1;\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"invalid status for revert %d\", lkb->lkb_status);\n\t}\n\treturn rv;\n}"
  },
  {
    "function_name": "remove_lock_pc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2074-2077",
    "snippet": "static void remove_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\t_remove_lock(r, lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_remove_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "_remove_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2059-2066",
          "snippet": "static void _remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tdel_lkb(r, lkb);\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t/* this unhold undoes the original ref from create_lkb()\n\t   so this leads to the lkb being freed */\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tdel_lkb(r, lkb);\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t/* this unhold undoes the original ref from create_lkb()\n\t   so this leads to the lkb being freed */\n\tunhold_lkb(lkb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void remove_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\t_remove_lock(r, lkb);\n}"
  },
  {
    "function_name": "remove_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2068-2072",
    "snippet": "static void remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tset_lvb_unlock(r, lkb);\n\t_remove_lock(r, lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_remove_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "_remove_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "2059-2066",
          "snippet": "static void _remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tdel_lkb(r, lkb);\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t/* this unhold undoes the original ref from create_lkb()\n\t   so this leads to the lkb being freed */\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tdel_lkb(r, lkb);\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t/* this unhold undoes the original ref from create_lkb()\n\t   so this leads to the lkb being freed */\n\tunhold_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_lvb_unlock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "set_lvb_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1999-2024",
          "snippet": "static void set_lvb_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode < DLM_LOCK_PW)\n\t\treturn;\n\n\tif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\treturn;\n\t}\n\n\tif (!lkb->lkb_lvbptr)\n\t\treturn;\n\n\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\treturn;\n\n\tif (!r->res_lvbptr)\n\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\n\tif (!r->res_lvbptr)\n\t\treturn;\n\n\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\tr->res_lvbseq++;\n\trsb_clear_flag(r, RSB_VALNOTVALID);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void set_lvb_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode < DLM_LOCK_PW)\n\t\treturn;\n\n\tif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\treturn;\n\t}\n\n\tif (!lkb->lkb_lvbptr)\n\t\treturn;\n\n\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\treturn;\n\n\tif (!r->res_lvbptr)\n\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\n\tif (!r->res_lvbptr)\n\t\treturn;\n\n\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\tr->res_lvbseq++;\n\trsb_clear_flag(r, RSB_VALNOTVALID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tset_lvb_unlock(r, lkb);\n\t_remove_lock(r, lkb);\n}"
  },
  {
    "function_name": "_remove_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2059-2066",
    "snippet": "static void _remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tdel_lkb(r, lkb);\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t/* this unhold undoes the original ref from create_lkb()\n\t   so this leads to the lkb being freed */\n\tunhold_lkb(lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_lkb",
          "args": [
            "r",
            "lkb"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "del_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1348-1353",
          "snippet": "static void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void _remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tdel_lkb(r, lkb);\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t/* this unhold undoes the original ref from create_lkb()\n\t   so this leads to the lkb being freed */\n\tunhold_lkb(lkb);\n}"
  },
  {
    "function_name": "set_lvb_lock_pc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "2028-2047",
    "snippet": "static void set_lvb_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t    struct dlm_message *ms)\n{\n\tint b;\n\n\tif (!lkb->lkb_lvbptr)\n\t\treturn;\n\n\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\treturn;\n\n\tb = dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\n\tif (b == 1) {\n\t\tint len = receive_extralen(ms);\n\t\tif (len > r->res_ls->ls_lvblen)\n\t\t\tlen = r->res_ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t\tlkb->lkb_lvbseq = ms->m_lvbseq;\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);",
      "const int dlm_lvb_operations[8][8] = {\n        /* UN   NL  CR  CW  PR  PW  EX  PD*/\n        {  -1,  1,  1,  1,  1,  1,  1, -1 }, /* UN */\n        {  -1,  1,  1,  1,  1,  1,  1,  0 }, /* NL */\n        {  -1, -1,  1,  1,  1,  1,  1,  0 }, /* CR */\n        {  -1, -1, -1,  1,  1,  1,  1,  0 }, /* CW */\n        {  -1, -1, -1, -1,  1,  1,  1,  0 }, /* PR */\n        {  -1,  0,  0,  0,  0,  0,  1,  0 }, /* PW */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }, /* EX */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }  /* PD */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lkb->lkb_lvbptr",
            "ms->m_extra",
            "len"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_extralen",
          "args": [
            "ms"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "receive_extralen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3881-3884",
          "snippet": "static int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int receive_extralen(struct dlm_message *ms)\n{\n\treturn (ms->m_header.h_length - sizeof(struct dlm_message));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\nconst int dlm_lvb_operations[8][8] = {\n        /* UN   NL  CR  CW  PR  PW  EX  PD*/\n        {  -1,  1,  1,  1,  1,  1,  1, -1 }, /* UN */\n        {  -1,  1,  1,  1,  1,  1,  1,  0 }, /* NL */\n        {  -1, -1,  1,  1,  1,  1,  1,  0 }, /* CR */\n        {  -1, -1, -1,  1,  1,  1,  1,  0 }, /* CW */\n        {  -1, -1, -1, -1,  1,  1,  1,  0 }, /* PR */\n        {  -1,  0,  0,  0,  0,  0,  1,  0 }, /* PW */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }, /* EX */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }  /* PD */\n};\n\nstatic void set_lvb_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t    struct dlm_message *ms)\n{\n\tint b;\n\n\tif (!lkb->lkb_lvbptr)\n\t\treturn;\n\n\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\treturn;\n\n\tb = dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\n\tif (b == 1) {\n\t\tint len = receive_extralen(ms);\n\t\tif (len > r->res_ls->ls_lvblen)\n\t\t\tlen = r->res_ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t\tlkb->lkb_lvbseq = ms->m_lvbseq;\n\t}\n}"
  },
  {
    "function_name": "set_lvb_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1999-2024",
    "snippet": "static void set_lvb_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode < DLM_LOCK_PW)\n\t\treturn;\n\n\tif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\treturn;\n\t}\n\n\tif (!lkb->lkb_lvbptr)\n\t\treturn;\n\n\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\treturn;\n\n\tif (!r->res_lvbptr)\n\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\n\tif (!r->res_lvbptr)\n\t\treturn;\n\n\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\tr->res_lvbseq++;\n\trsb_clear_flag(r, RSB_VALNOTVALID);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsb_clear_flag",
          "args": [
            "r",
            "RSB_VALNOTVALID"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_clear_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "353-356",
          "snippet": "static inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r->res_lvbptr",
            "lkb->lkb_lvbptr",
            "r->res_ls->ls_lvblen"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_allocate_lvb",
          "args": [
            "r->res_ls"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_allocate_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "47-53",
          "snippet": "char *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nchar *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "r",
            "RSB_VALNOTVALID"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void set_lvb_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode < DLM_LOCK_PW)\n\t\treturn;\n\n\tif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\treturn;\n\t}\n\n\tif (!lkb->lkb_lvbptr)\n\t\treturn;\n\n\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\treturn;\n\n\tif (!r->res_lvbptr)\n\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\n\tif (!r->res_lvbptr)\n\t\treturn;\n\n\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\tr->res_lvbseq++;\n\trsb_clear_flag(r, RSB_VALNOTVALID);\n}"
  },
  {
    "function_name": "set_lvb_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1948-1997",
    "snippet": "static void set_lvb_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint b, len = r->res_ls->ls_lvblen;\n\n\t/* b=1 lvb returned to caller\n\t   b=0 lvb written to rsb or invalidated\n\t   b=-1 do nothing */\n\n\tb =  dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\n\n\tif (b == 1) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn;\n\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\treturn;\n\n\t\tif (!r->res_lvbptr)\n\t\t\treturn;\n\n\t\tmemcpy(lkb->lkb_lvbptr, r->res_lvbptr, len);\n\t\tlkb->lkb_lvbseq = r->res_lvbseq;\n\n\t} else if (b == 0) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\n\t\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn;\n\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\treturn;\n\n\t\tif (!r->res_lvbptr)\n\t\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\n\t\tif (!r->res_lvbptr)\n\t\t\treturn;\n\n\t\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, len);\n\t\tr->res_lvbseq++;\n\t\tlkb->lkb_lvbseq = r->res_lvbseq;\n\t\trsb_clear_flag(r, RSB_VALNOTVALID);\n\t}\n\n\tif (rsb_flag(r, RSB_VALNOTVALID))\n\t\tlkb->lkb_sbflags |= DLM_SBF_VALNOTVALID;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);",
      "const int dlm_lvb_operations[8][8] = {\n        /* UN   NL  CR  CW  PR  PW  EX  PD*/\n        {  -1,  1,  1,  1,  1,  1,  1, -1 }, /* UN */\n        {  -1,  1,  1,  1,  1,  1,  1,  0 }, /* NL */\n        {  -1, -1,  1,  1,  1,  1,  1,  0 }, /* CR */\n        {  -1, -1, -1,  1,  1,  1,  1,  0 }, /* CW */\n        {  -1, -1, -1, -1,  1,  1,  1,  0 }, /* PR */\n        {  -1,  0,  0,  0,  0,  0,  1,  0 }, /* PW */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }, /* EX */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }  /* PD */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsb_flag",
          "args": [
            "r",
            "RSB_VALNOTVALID"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "358-361",
          "snippet": "static inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_clear_flag",
          "args": [
            "r",
            "RSB_VALNOTVALID"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_clear_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "353-356",
          "snippet": "static inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r->res_lvbptr",
            "lkb->lkb_lvbptr",
            "len"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_allocate_lvb",
          "args": [
            "r->res_ls"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_allocate_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "47-53",
          "snippet": "char *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nchar *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "r",
            "RSB_VALNOTVALID"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lkb->lkb_lvbptr",
            "r->res_lvbptr",
            "len"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\nconst int dlm_lvb_operations[8][8] = {\n        /* UN   NL  CR  CW  PR  PW  EX  PD*/\n        {  -1,  1,  1,  1,  1,  1,  1, -1 }, /* UN */\n        {  -1,  1,  1,  1,  1,  1,  1,  0 }, /* NL */\n        {  -1, -1,  1,  1,  1,  1,  1,  0 }, /* CR */\n        {  -1, -1, -1,  1,  1,  1,  1,  0 }, /* CW */\n        {  -1, -1, -1, -1,  1,  1,  1,  0 }, /* PR */\n        {  -1,  0,  0,  0,  0,  0,  1,  0 }, /* PW */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }, /* EX */\n        {  -1,  0,  0,  0,  0,  0,  0,  0 }  /* PD */\n};\n\nstatic void set_lvb_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint b, len = r->res_ls->ls_lvblen;\n\n\t/* b=1 lvb returned to caller\n\t   b=0 lvb written to rsb or invalidated\n\t   b=-1 do nothing */\n\n\tb =  dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\n\n\tif (b == 1) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn;\n\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\treturn;\n\n\t\tif (!r->res_lvbptr)\n\t\t\treturn;\n\n\t\tmemcpy(lkb->lkb_lvbptr, r->res_lvbptr, len);\n\t\tlkb->lkb_lvbseq = r->res_lvbseq;\n\n\t} else if (b == 0) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\n\t\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn;\n\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\treturn;\n\n\t\tif (!r->res_lvbptr)\n\t\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\n\t\tif (!r->res_lvbptr)\n\t\t\treturn;\n\n\t\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, len);\n\t\tr->res_lvbseq++;\n\t\tlkb->lkb_lvbseq = r->res_lvbseq;\n\t\trsb_clear_flag(r, RSB_VALNOTVALID);\n\t}\n\n\tif (rsb_flag(r, RSB_VALNOTVALID))\n\t\tlkb->lkb_sbflags |= DLM_SBF_VALNOTVALID;\n}"
  },
  {
    "function_name": "dlm_adjust_timeouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1924-1944",
    "snippet": "void dlm_adjust_timeouts(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tu64 adj_us = jiffies_to_usecs(jiffies - ls->ls_recover_begin);\n\n\tls->ls_recover_begin = 0;\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_timeout, lkb_time_list)\n\t\tlkb->lkb_timestamp = ktime_add_us(lkb->lkb_timestamp, adj_us);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n\n\tif (!dlm_config.ci_waitwarn_us)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (ktime_to_us(lkb->lkb_wait_time))\n\t\t\tlkb->lkb_wait_time = ktime_get();\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "lkb->lkb_wait_time"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&ls->ls_waiters",
            "lkb_wait_reply"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_timeout_mutex"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_us",
          "args": [
            "lkb->lkb_timestamp",
            "adj_us"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&ls->ls_timeout",
            "lkb_time_list"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_timeout_mutex"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_usecs",
          "args": [
            "jiffies - ls->ls_recover_begin"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_adjust_timeouts(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tu64 adj_us = jiffies_to_usecs(jiffies - ls->ls_recover_begin);\n\n\tls->ls_recover_begin = 0;\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_timeout, lkb_time_list)\n\t\tlkb->lkb_timestamp = ktime_add_us(lkb->lkb_timestamp, adj_us);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n\n\tif (!dlm_config.ci_waitwarn_us)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (ktime_to_us(lkb->lkb_wait_time))\n\t\t\tlkb->lkb_wait_time = ktime_get();\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n}"
  },
  {
    "function_name": "dlm_scan_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1857-1919",
    "snippet": "void dlm_scan_timeout(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tint do_cancel, do_warn;\n\ts64 wait_us;\n\n\tfor (;;) {\n\t\tif (dlm_locking_stopped(ls))\n\t\t\tbreak;\n\n\t\tdo_cancel = 0;\n\t\tdo_warn = 0;\n\t\tmutex_lock(&ls->ls_timeout_mutex);\n\t\tlist_for_each_entry(lkb, &ls->ls_timeout, lkb_time_list) {\n\n\t\t\twait_us = ktime_to_us(ktime_sub(ktime_get(),\n\t\t\t\t\t      \t\tlkb->lkb_timestamp));\n\n\t\t\tif ((lkb->lkb_exflags & DLM_LKF_TIMEOUT) &&\n\t\t\t    wait_us >= (lkb->lkb_timeout_cs * 10000))\n\t\t\t\tdo_cancel = 1;\n\n\t\t\tif ((lkb->lkb_flags & DLM_IFL_WATCH_TIMEWARN) &&\n\t\t\t    wait_us >= dlm_config.ci_timewarn_cs * 10000)\n\t\t\t\tdo_warn = 1;\n\n\t\t\tif (!do_cancel && !do_warn)\n\t\t\t\tcontinue;\n\t\t\thold_lkb(lkb);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ls->ls_timeout_mutex);\n\n\t\tif (!do_cancel && !do_warn)\n\t\t\tbreak;\n\n\t\tr = lkb->lkb_resource;\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\n\t\tif (do_warn) {\n\t\t\t/* clear flag so we only warn once */\n\t\t\tlkb->lkb_flags &= ~DLM_IFL_WATCH_TIMEWARN;\n\t\t\tif (!(lkb->lkb_exflags & DLM_LKF_TIMEOUT))\n\t\t\t\tdel_timeout(lkb);\n\t\t\tdlm_timeout_warn(lkb);\n\t\t}\n\n\t\tif (do_cancel) {\n\t\t\tlog_debug(ls, \"timeout cancel %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tlkb->lkb_flags &= ~DLM_IFL_WATCH_TIMEWARN;\n\t\t\tlkb->lkb_flags |= DLM_IFL_TIMEOUT_CANCEL;\n\t\t\tdel_timeout(lkb);\n\t\t\t_cancel_lock(r, lkb);\n\t\t}\n\n\t\tunlock_rsb(r);\n\t\tunhold_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhold_rsb",
          "args": [
            "r"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_cancel_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "_cancel_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3291-3306",
          "snippet": "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_cancel() calls do_cancel() on remote node */\n\t\terror = send_cancel(r, lkb);\n\t} else {\n\t\terror = do_cancel(r, lkb);\n\t\t/* for remote locks the cancel_reply is sent\n\t\t   between do_cancel and do_cancel_effects */\n\t\tdo_cancel_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t/* receive_cancel() calls do_cancel() on remote node */\n\t\terror = send_cancel(r, lkb);\n\t} else {\n\t\terror = do_cancel(r, lkb);\n\t\t/* for remote locks the cancel_reply is sent\n\t\t   between do_cancel and do_cancel_effects */\n\t\tdo_cancel_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timeout",
          "args": [
            "lkb"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "del_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1839-1849",
          "snippet": "static void del_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tif (!list_empty(&lkb->lkb_time_list)) {\n\t\tlist_del_init(&lkb->lkb_time_list);\n\t\tunhold_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tif (!list_empty(&lkb->lkb_time_list)) {\n\t\tlist_del_init(&lkb->lkb_time_list);\n\t\tunhold_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"timeout cancel %x node %d %s\"",
            "lkb->lkb_id",
            "lkb->lkb_nodeid",
            "r->res_name"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_timeout_warn",
          "args": [
            "lkb"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_timeout_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/netlink.c",
          "lines": "112-135",
          "snippet": "void dlm_timeout_warn(struct dlm_lkb *lkb)\n{\n\tstruct sk_buff *uninitialized_var(send_skb);\n\tstruct dlm_lock_data *data;\n\tsize_t size;\n\tint rv;\n\n\tsize = nla_total_size(sizeof(struct dlm_lock_data)) +\n\t       nla_total_size(0); /* why this? */\n\n\trv = prepare_data(DLM_CMD_TIMEOUT, &send_skb, size);\n\tif (rv < 0)\n\t\treturn;\n\n\tdata = mk_data(send_skb);\n\tif (!data) {\n\t\tnlmsg_free(send_skb);\n\t\treturn;\n\t}\n\n\tfill_data(data, lkb);\n\n\tsend_data(send_skb);\n}",
          "includes": [
            "#include \"dlm_internal.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/dlm_netlink.h>",
            "#include <linux/dlm.h>",
            "#include <net/genetlink.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dlm_internal.h\"\n#include <linux/gfp.h>\n#include <linux/dlm_netlink.h>\n#include <linux/dlm.h>\n#include <net/genetlink.h>\n\nvoid dlm_timeout_warn(struct dlm_lkb *lkb)\n{\n\tstruct sk_buff *uninitialized_var(send_skb);\n\tstruct dlm_lock_data *data;\n\tsize_t size;\n\tint rv;\n\n\tsize = nla_total_size(sizeof(struct dlm_lock_data)) +\n\t       nla_total_size(0); /* why this? */\n\n\trv = prepare_data(DLM_CMD_TIMEOUT, &send_skb, size);\n\tif (rv < 0)\n\t\treturn;\n\n\tdata = mk_data(send_skb);\n\tif (!data) {\n\t\tnlmsg_free(send_skb);\n\t\treturn;\n\t}\n\n\tfill_data(data, lkb);\n\n\tsend_data(send_skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_timeout_mutex"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hold_lkb",
          "args": [
            "lkb"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "ktime_sub(ktime_get(),\n\t\t\t\t\t      \t\tlkb->lkb_timestamp)"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "lkb->lkb_timestamp"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&ls->ls_timeout",
            "lkb_time_list"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_timeout_mutex"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_locking_stopped",
          "args": [
            "ls"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_locking_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "695-698",
          "snippet": "static inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RUNNING\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RUNNING\t\t4\n\nstatic inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_scan_timeout(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tint do_cancel, do_warn;\n\ts64 wait_us;\n\n\tfor (;;) {\n\t\tif (dlm_locking_stopped(ls))\n\t\t\tbreak;\n\n\t\tdo_cancel = 0;\n\t\tdo_warn = 0;\n\t\tmutex_lock(&ls->ls_timeout_mutex);\n\t\tlist_for_each_entry(lkb, &ls->ls_timeout, lkb_time_list) {\n\n\t\t\twait_us = ktime_to_us(ktime_sub(ktime_get(),\n\t\t\t\t\t      \t\tlkb->lkb_timestamp));\n\n\t\t\tif ((lkb->lkb_exflags & DLM_LKF_TIMEOUT) &&\n\t\t\t    wait_us >= (lkb->lkb_timeout_cs * 10000))\n\t\t\t\tdo_cancel = 1;\n\n\t\t\tif ((lkb->lkb_flags & DLM_IFL_WATCH_TIMEWARN) &&\n\t\t\t    wait_us >= dlm_config.ci_timewarn_cs * 10000)\n\t\t\t\tdo_warn = 1;\n\n\t\t\tif (!do_cancel && !do_warn)\n\t\t\t\tcontinue;\n\t\t\thold_lkb(lkb);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ls->ls_timeout_mutex);\n\n\t\tif (!do_cancel && !do_warn)\n\t\t\tbreak;\n\n\t\tr = lkb->lkb_resource;\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\n\t\tif (do_warn) {\n\t\t\t/* clear flag so we only warn once */\n\t\t\tlkb->lkb_flags &= ~DLM_IFL_WATCH_TIMEWARN;\n\t\t\tif (!(lkb->lkb_exflags & DLM_LKF_TIMEOUT))\n\t\t\t\tdel_timeout(lkb);\n\t\t\tdlm_timeout_warn(lkb);\n\t\t}\n\n\t\tif (do_cancel) {\n\t\t\tlog_debug(ls, \"timeout cancel %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tlkb->lkb_flags &= ~DLM_IFL_WATCH_TIMEWARN;\n\t\t\tlkb->lkb_flags |= DLM_IFL_TIMEOUT_CANCEL;\n\t\t\tdel_timeout(lkb);\n\t\t\t_cancel_lock(r, lkb);\n\t\t}\n\n\t\tunlock_rsb(r);\n\t\tunhold_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t}\n}"
  },
  {
    "function_name": "del_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1839-1849",
    "snippet": "static void del_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tif (!list_empty(&lkb->lkb_time_list)) {\n\t\tlist_del_init(&lkb->lkb_time_list);\n\t\tunhold_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_timeout_mutex"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_time_list"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lkb->lkb_time_list"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_timeout_mutex"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tif (!list_empty(&lkb->lkb_time_list)) {\n\t\tlist_del_init(&lkb->lkb_time_list);\n\t\tunhold_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}"
  },
  {
    "function_name": "add_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1815-1837",
    "snippet": "static void add_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\n\t    !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\tlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\n\t\tgoto add_it;\n\t}\n\tif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\n\t\tgoto add_it;\n\treturn;\n\n add_it:\n\tDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\n\tmutex_lock(&ls->ls_timeout_mutex);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_timeout_mutex"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lkb->lkb_time_list",
            "&ls->ls_timeout"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hold_lkb",
          "args": [
            "lkb"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_timeout_mutex"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "list_empty(&lkb->lkb_time_list)",
            "dlm_print_lkb(lkb);"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lkb->lkb_time_list"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "LSFL_TIMEWARN",
            "&ls->ls_flags"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master_copy",
          "args": [
            "lkb"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\n\t    !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\tlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\n\t\tgoto add_it;\n\t}\n\tif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\n\t\tgoto add_it;\n\treturn;\n\n add_it:\n\tDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\n\tmutex_lock(&ls->ls_timeout_mutex);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}"
  },
  {
    "function_name": "dlm_scan_rsbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1803-1813",
    "snippet": "void dlm_scan_rsbs(struct dlm_ls *ls)\n{\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tshrink_bucket(ls, i);\n\t\tif (dlm_locking_stopped(ls))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_locking_stopped",
          "args": [
            "ls"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_locking_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "695-698",
          "snippet": "static inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RUNNING\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RUNNING\t\t4\n\nstatic inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_bucket",
          "args": [
            "ls",
            "i"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1651-1801",
          "snippet": "static void shrink_bucket(struct dlm_ls *ls, int b)\n{\n\tstruct rb_node *n, *next;\n\tstruct dlm_rsb *r;\n\tchar *name;\n\tint our_nodeid = dlm_our_nodeid();\n\tint remote_count = 0;\n\tint need_shrink = 0;\n\tint i, len, rv;\n\n\tmemset(&ls->ls_remove_lens, 0, sizeof(int) * DLM_REMOVE_NAMES_MAX);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\tif (!(ls->ls_rsbtbl[b].flags & DLM_RTF_SHRINK)) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tfor (n = rb_first(&ls->ls_rsbtbl[b].toss); n; n = next) {\n\t\tnext = rb_next(n);\n\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\n\t\t/* If we're the directory record for this rsb, and\n\t\t   we're not the master of it, then we need to wait\n\t\t   for the master node to send us a dir remove for\n\t\t   before removing the dir record. */\n\n\t\tif (!dlm_no_directory(ls) &&\n\t\t    (r->res_master_nodeid != our_nodeid) &&\n\t\t    (dlm_dir_nodeid(r) == our_nodeid)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tneed_shrink = 1;\n\n\t\tif (!time_after_eq(jiffies, r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!dlm_no_directory(ls) &&\n\t\t    (r->res_master_nodeid == our_nodeid) &&\n\t\t    (dlm_dir_nodeid(r) != our_nodeid)) {\n\n\t\t\t/* We're the master of this rsb but we're not\n\t\t\t   the directory record, so we need to tell the\n\t\t\t   dir node to remove the dir record. */\n\n\t\t\tls->ls_remove_lens[remote_count] = r->res_length;\n\t\t\tmemcpy(ls->ls_remove_names[remote_count], r->res_name,\n\t\t\t       DLM_RESNAME_MAXLEN);\n\t\t\tremote_count++;\n\n\t\t\tif (remote_count >= DLM_REMOVE_NAMES_MAX)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!kref_put(&r->res_ref, kill_rsb)) {\n\t\t\tlog_error(ls, \"tossed rsb in use %s\", r->res_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tdlm_free_rsb(r);\n\t}\n\n\tif (need_shrink)\n\t\tls->ls_rsbtbl[b].flags |= DLM_RTF_SHRINK;\n\telse\n\t\tls->ls_rsbtbl[b].flags &= ~DLM_RTF_SHRINK;\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\t/*\n\t * While searching for rsb's to free, we found some that require\n\t * remote removal.  We leave them in place and find them again here\n\t * so there is a very small gap between removing them from the toss\n\t * list and sending the removal.  Keeping this gap small is\n\t * important to keep us (the master node) from being out of sync\n\t * with the remote dir node for very long.\n\t *\n\t * From the time the rsb is removed from toss until just after\n\t * send_remove, the rsb name is saved in ls_remove_name.  A new\n\t * lookup checks this to ensure that a new lookup message for the\n\t * same resource name is not sent just before the remove message.\n\t */\n\n\tfor (i = 0; i < remote_count; i++) {\n\t\tname = ls->ls_remove_names[i];\n\t\tlen = ls->ls_remove_lens[i];\n\n\t\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\t\tif (rv) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name not toss %s\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r->res_master_nodeid != our_nodeid) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name master %d dir %d our %d %s\",\n\t\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t\t  our_nodeid, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r->res_dir_nodeid == our_nodeid) {\n\t\t\t/* should never happen */\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_error(ls, \"remove_name dir %d master %d our %d %s\",\n\t\t\t\t  r->res_dir_nodeid, r->res_master_nodeid,\n\t\t\t\t  our_nodeid, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!time_after_eq(jiffies, r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ)) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name toss_time %lu now %lu %s\",\n\t\t\t\t  r->res_toss_time, jiffies, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!kref_put(&r->res_ref, kill_rsb)) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_error(ls, \"remove_name in use %s\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\n\t\t/* block lookup of same name until we've sent remove */\n\t\tspin_lock(&ls->ls_remove_spin);\n\t\tls->ls_remove_len = len;\n\t\tmemcpy(ls->ls_remove_name, name, DLM_RESNAME_MAXLEN);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\t\tsend_remove(r);\n\n\t\t/* allow lookup of name again */\n\t\tspin_lock(&ls->ls_remove_spin);\n\t\tls->ls_remove_len = 0;\n\t\tmemset(ls->ls_remove_name, 0, DLM_RESNAME_MAXLEN);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\n\t\tdlm_free_rsb(r);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void shrink_bucket(struct dlm_ls *ls, int b)\n{\n\tstruct rb_node *n, *next;\n\tstruct dlm_rsb *r;\n\tchar *name;\n\tint our_nodeid = dlm_our_nodeid();\n\tint remote_count = 0;\n\tint need_shrink = 0;\n\tint i, len, rv;\n\n\tmemset(&ls->ls_remove_lens, 0, sizeof(int) * DLM_REMOVE_NAMES_MAX);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\tif (!(ls->ls_rsbtbl[b].flags & DLM_RTF_SHRINK)) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tfor (n = rb_first(&ls->ls_rsbtbl[b].toss); n; n = next) {\n\t\tnext = rb_next(n);\n\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\n\t\t/* If we're the directory record for this rsb, and\n\t\t   we're not the master of it, then we need to wait\n\t\t   for the master node to send us a dir remove for\n\t\t   before removing the dir record. */\n\n\t\tif (!dlm_no_directory(ls) &&\n\t\t    (r->res_master_nodeid != our_nodeid) &&\n\t\t    (dlm_dir_nodeid(r) == our_nodeid)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tneed_shrink = 1;\n\n\t\tif (!time_after_eq(jiffies, r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!dlm_no_directory(ls) &&\n\t\t    (r->res_master_nodeid == our_nodeid) &&\n\t\t    (dlm_dir_nodeid(r) != our_nodeid)) {\n\n\t\t\t/* We're the master of this rsb but we're not\n\t\t\t   the directory record, so we need to tell the\n\t\t\t   dir node to remove the dir record. */\n\n\t\t\tls->ls_remove_lens[remote_count] = r->res_length;\n\t\t\tmemcpy(ls->ls_remove_names[remote_count], r->res_name,\n\t\t\t       DLM_RESNAME_MAXLEN);\n\t\t\tremote_count++;\n\n\t\t\tif (remote_count >= DLM_REMOVE_NAMES_MAX)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!kref_put(&r->res_ref, kill_rsb)) {\n\t\t\tlog_error(ls, \"tossed rsb in use %s\", r->res_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tdlm_free_rsb(r);\n\t}\n\n\tif (need_shrink)\n\t\tls->ls_rsbtbl[b].flags |= DLM_RTF_SHRINK;\n\telse\n\t\tls->ls_rsbtbl[b].flags &= ~DLM_RTF_SHRINK;\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\t/*\n\t * While searching for rsb's to free, we found some that require\n\t * remote removal.  We leave them in place and find them again here\n\t * so there is a very small gap between removing them from the toss\n\t * list and sending the removal.  Keeping this gap small is\n\t * important to keep us (the master node) from being out of sync\n\t * with the remote dir node for very long.\n\t *\n\t * From the time the rsb is removed from toss until just after\n\t * send_remove, the rsb name is saved in ls_remove_name.  A new\n\t * lookup checks this to ensure that a new lookup message for the\n\t * same resource name is not sent just before the remove message.\n\t */\n\n\tfor (i = 0; i < remote_count; i++) {\n\t\tname = ls->ls_remove_names[i];\n\t\tlen = ls->ls_remove_lens[i];\n\n\t\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\t\tif (rv) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name not toss %s\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r->res_master_nodeid != our_nodeid) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name master %d dir %d our %d %s\",\n\t\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t\t  our_nodeid, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r->res_dir_nodeid == our_nodeid) {\n\t\t\t/* should never happen */\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_error(ls, \"remove_name dir %d master %d our %d %s\",\n\t\t\t\t  r->res_dir_nodeid, r->res_master_nodeid,\n\t\t\t\t  our_nodeid, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!time_after_eq(jiffies, r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ)) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name toss_time %lu now %lu %s\",\n\t\t\t\t  r->res_toss_time, jiffies, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!kref_put(&r->res_ref, kill_rsb)) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_error(ls, \"remove_name in use %s\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\n\t\t/* block lookup of same name until we've sent remove */\n\t\tspin_lock(&ls->ls_remove_spin);\n\t\tls->ls_remove_len = len;\n\t\tmemcpy(ls->ls_remove_name, name, DLM_RESNAME_MAXLEN);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\t\tsend_remove(r);\n\n\t\t/* allow lookup of name again */\n\t\tspin_lock(&ls->ls_remove_spin);\n\t\tls->ls_remove_len = 0;\n\t\tmemset(ls->ls_remove_name, 0, DLM_RESNAME_MAXLEN);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\n\t\tdlm_free_rsb(r);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_scan_rsbs(struct dlm_ls *ls)\n{\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tshrink_bucket(ls, i);\n\t\tif (dlm_locking_stopped(ls))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "shrink_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1651-1801",
    "snippet": "static void shrink_bucket(struct dlm_ls *ls, int b)\n{\n\tstruct rb_node *n, *next;\n\tstruct dlm_rsb *r;\n\tchar *name;\n\tint our_nodeid = dlm_our_nodeid();\n\tint remote_count = 0;\n\tint need_shrink = 0;\n\tint i, len, rv;\n\n\tmemset(&ls->ls_remove_lens, 0, sizeof(int) * DLM_REMOVE_NAMES_MAX);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\tif (!(ls->ls_rsbtbl[b].flags & DLM_RTF_SHRINK)) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tfor (n = rb_first(&ls->ls_rsbtbl[b].toss); n; n = next) {\n\t\tnext = rb_next(n);\n\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\n\t\t/* If we're the directory record for this rsb, and\n\t\t   we're not the master of it, then we need to wait\n\t\t   for the master node to send us a dir remove for\n\t\t   before removing the dir record. */\n\n\t\tif (!dlm_no_directory(ls) &&\n\t\t    (r->res_master_nodeid != our_nodeid) &&\n\t\t    (dlm_dir_nodeid(r) == our_nodeid)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tneed_shrink = 1;\n\n\t\tif (!time_after_eq(jiffies, r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!dlm_no_directory(ls) &&\n\t\t    (r->res_master_nodeid == our_nodeid) &&\n\t\t    (dlm_dir_nodeid(r) != our_nodeid)) {\n\n\t\t\t/* We're the master of this rsb but we're not\n\t\t\t   the directory record, so we need to tell the\n\t\t\t   dir node to remove the dir record. */\n\n\t\t\tls->ls_remove_lens[remote_count] = r->res_length;\n\t\t\tmemcpy(ls->ls_remove_names[remote_count], r->res_name,\n\t\t\t       DLM_RESNAME_MAXLEN);\n\t\t\tremote_count++;\n\n\t\t\tif (remote_count >= DLM_REMOVE_NAMES_MAX)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!kref_put(&r->res_ref, kill_rsb)) {\n\t\t\tlog_error(ls, \"tossed rsb in use %s\", r->res_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tdlm_free_rsb(r);\n\t}\n\n\tif (need_shrink)\n\t\tls->ls_rsbtbl[b].flags |= DLM_RTF_SHRINK;\n\telse\n\t\tls->ls_rsbtbl[b].flags &= ~DLM_RTF_SHRINK;\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\t/*\n\t * While searching for rsb's to free, we found some that require\n\t * remote removal.  We leave them in place and find them again here\n\t * so there is a very small gap between removing them from the toss\n\t * list and sending the removal.  Keeping this gap small is\n\t * important to keep us (the master node) from being out of sync\n\t * with the remote dir node for very long.\n\t *\n\t * From the time the rsb is removed from toss until just after\n\t * send_remove, the rsb name is saved in ls_remove_name.  A new\n\t * lookup checks this to ensure that a new lookup message for the\n\t * same resource name is not sent just before the remove message.\n\t */\n\n\tfor (i = 0; i < remote_count; i++) {\n\t\tname = ls->ls_remove_names[i];\n\t\tlen = ls->ls_remove_lens[i];\n\n\t\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\t\tif (rv) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name not toss %s\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r->res_master_nodeid != our_nodeid) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name master %d dir %d our %d %s\",\n\t\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t\t  our_nodeid, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r->res_dir_nodeid == our_nodeid) {\n\t\t\t/* should never happen */\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_error(ls, \"remove_name dir %d master %d our %d %s\",\n\t\t\t\t  r->res_dir_nodeid, r->res_master_nodeid,\n\t\t\t\t  our_nodeid, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!time_after_eq(jiffies, r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ)) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name toss_time %lu now %lu %s\",\n\t\t\t\t  r->res_toss_time, jiffies, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!kref_put(&r->res_ref, kill_rsb)) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_error(ls, \"remove_name in use %s\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\n\t\t/* block lookup of same name until we've sent remove */\n\t\tspin_lock(&ls->ls_remove_spin);\n\t\tls->ls_remove_len = len;\n\t\tmemcpy(ls->ls_remove_name, name, DLM_RESNAME_MAXLEN);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\t\tsend_remove(r);\n\n\t\t/* allow lookup of name again */\n\t\tspin_lock(&ls->ls_remove_spin);\n\t\tls->ls_remove_len = 0;\n\t\tmemset(ls->ls_remove_name, 0, DLM_RESNAME_MAXLEN);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\n\t\tdlm_free_rsb(r);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_free_rsb",
          "args": [
            "r"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "68-73",
          "snippet": "void dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rsb_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kmem_cache *rsb_cache;\n\nvoid dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_remove_spin"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ls->ls_remove_name",
            "0",
            "DLM_RESNAME_MAXLEN"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_remove_spin"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_remove",
          "args": [
            "r"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "send_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3776-3794",
          "snippet": "static int send_remove(struct dlm_rsb *r)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = dlm_dir_nodeid(r);\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_REMOVE, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\tms->m_hash = r->res_hash;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nstatic int send_remove(struct dlm_rsb *r)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = dlm_dir_nodeid(r);\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_REMOVE, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\tms->m_hash = r->res_hash;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ls->ls_remove_name",
            "name",
            "DLM_RESNAME_MAXLEN"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&r->res_hashnode",
            "&ls->ls_rsbtbl[b].toss"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"remove_name in use %s\"",
            "name"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&r->res_ref",
            "kill_rsb"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"remove_name toss_time %lu now %lu %s\"",
            "r->res_toss_time",
            "jiffies",
            "name"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"remove_name dir %d master %d our %d %s\"",
            "r->res_dir_nodeid",
            "r->res_master_nodeid",
            "our_nodeid",
            "name"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"remove_name master %d dir %d our %d %s\"",
            "r->res_master_nodeid",
            "r->res_dir_nodeid",
            "our_nodeid",
            "name"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"remove_name not toss %s\"",
            "name"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_search_rsb_tree",
          "args": [
            "&ls->ls_rsbtbl[b].toss",
            "name",
            "len",
            "&r"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_search_rsb_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "447-470",
          "snippet": "int dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&r->res_hashnode",
            "&ls->ls_rsbtbl[b].toss"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"tossed rsb in use %s\"",
            "r->res_name"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&r->res_ref",
            "kill_rsb"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ls->ls_remove_names[remote_count]",
            "r->res_name",
            "DLM_RESNAME_MAXLEN"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dir_nodeid",
          "args": [
            "r"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "47-50",
          "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_no_directory",
          "args": [
            "ls"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "705-708",
          "snippet": "static inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_NODIR\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_NODIR\t\t10\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ls->ls_rsbtbl[b].toss"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ls->ls_remove_lens",
            "0",
            "sizeof(int) * DLM_REMOVE_NAMES_MAX"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void shrink_bucket(struct dlm_ls *ls, int b)\n{\n\tstruct rb_node *n, *next;\n\tstruct dlm_rsb *r;\n\tchar *name;\n\tint our_nodeid = dlm_our_nodeid();\n\tint remote_count = 0;\n\tint need_shrink = 0;\n\tint i, len, rv;\n\n\tmemset(&ls->ls_remove_lens, 0, sizeof(int) * DLM_REMOVE_NAMES_MAX);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\tif (!(ls->ls_rsbtbl[b].flags & DLM_RTF_SHRINK)) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tfor (n = rb_first(&ls->ls_rsbtbl[b].toss); n; n = next) {\n\t\tnext = rb_next(n);\n\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\n\t\t/* If we're the directory record for this rsb, and\n\t\t   we're not the master of it, then we need to wait\n\t\t   for the master node to send us a dir remove for\n\t\t   before removing the dir record. */\n\n\t\tif (!dlm_no_directory(ls) &&\n\t\t    (r->res_master_nodeid != our_nodeid) &&\n\t\t    (dlm_dir_nodeid(r) == our_nodeid)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tneed_shrink = 1;\n\n\t\tif (!time_after_eq(jiffies, r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!dlm_no_directory(ls) &&\n\t\t    (r->res_master_nodeid == our_nodeid) &&\n\t\t    (dlm_dir_nodeid(r) != our_nodeid)) {\n\n\t\t\t/* We're the master of this rsb but we're not\n\t\t\t   the directory record, so we need to tell the\n\t\t\t   dir node to remove the dir record. */\n\n\t\t\tls->ls_remove_lens[remote_count] = r->res_length;\n\t\t\tmemcpy(ls->ls_remove_names[remote_count], r->res_name,\n\t\t\t       DLM_RESNAME_MAXLEN);\n\t\t\tremote_count++;\n\n\t\t\tif (remote_count >= DLM_REMOVE_NAMES_MAX)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!kref_put(&r->res_ref, kill_rsb)) {\n\t\t\tlog_error(ls, \"tossed rsb in use %s\", r->res_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tdlm_free_rsb(r);\n\t}\n\n\tif (need_shrink)\n\t\tls->ls_rsbtbl[b].flags |= DLM_RTF_SHRINK;\n\telse\n\t\tls->ls_rsbtbl[b].flags &= ~DLM_RTF_SHRINK;\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\t/*\n\t * While searching for rsb's to free, we found some that require\n\t * remote removal.  We leave them in place and find them again here\n\t * so there is a very small gap between removing them from the toss\n\t * list and sending the removal.  Keeping this gap small is\n\t * important to keep us (the master node) from being out of sync\n\t * with the remote dir node for very long.\n\t *\n\t * From the time the rsb is removed from toss until just after\n\t * send_remove, the rsb name is saved in ls_remove_name.  A new\n\t * lookup checks this to ensure that a new lookup message for the\n\t * same resource name is not sent just before the remove message.\n\t */\n\n\tfor (i = 0; i < remote_count; i++) {\n\t\tname = ls->ls_remove_names[i];\n\t\tlen = ls->ls_remove_lens[i];\n\n\t\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\t\tif (rv) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name not toss %s\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r->res_master_nodeid != our_nodeid) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name master %d dir %d our %d %s\",\n\t\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t\t  our_nodeid, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r->res_dir_nodeid == our_nodeid) {\n\t\t\t/* should never happen */\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_error(ls, \"remove_name dir %d master %d our %d %s\",\n\t\t\t\t  r->res_dir_nodeid, r->res_master_nodeid,\n\t\t\t\t  our_nodeid, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!time_after_eq(jiffies, r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ)) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name toss_time %lu now %lu %s\",\n\t\t\t\t  r->res_toss_time, jiffies, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!kref_put(&r->res_ref, kill_rsb)) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_error(ls, \"remove_name in use %s\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\n\t\t/* block lookup of same name until we've sent remove */\n\t\tspin_lock(&ls->ls_remove_spin);\n\t\tls->ls_remove_len = len;\n\t\tmemcpy(ls->ls_remove_name, name, DLM_RESNAME_MAXLEN);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\t\tsend_remove(r);\n\n\t\t/* allow lookup of name again */\n\t\tspin_lock(&ls->ls_remove_spin);\n\t\tls->ls_remove_len = 0;\n\t\tmemset(ls->ls_remove_name, 0, DLM_RESNAME_MAXLEN);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\n\t\tdlm_free_rsb(r);\n\t}\n}"
  },
  {
    "function_name": "wait_pending_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1628-1642",
    "snippet": "static void wait_pending_remove(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n restart:\n\tspin_lock(&ls->ls_remove_spin);\n\tif (ls->ls_remove_len &&\n\t    !rsb_cmp(r, ls->ls_remove_name, ls->ls_remove_len)) {\n\t\tlog_debug(ls, \"delay lookup for remove dir %d %s\",\n\t\t  \t  r->res_dir_nodeid, r->res_name);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\t\tmsleep(1);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&ls->ls_remove_spin);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_remove_spin"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"delay lookup for remove dir %d %s\"",
            "r->res_dir_nodeid",
            "r->res_name"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsb_cmp",
          "args": [
            "r",
            "ls->ls_remove_name",
            "ls->ls_remove_len"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "438-445",
          "snippet": "static int rsb_cmp(struct dlm_rsb *r, const char *name, int nlen)\n{\n\tchar maxname[DLM_RESNAME_MAXLEN];\n\n\tmemset(maxname, 0, DLM_RESNAME_MAXLEN);\n\tmemcpy(maxname, name, nlen);\n\treturn memcmp(r->res_name, maxname, DLM_RESNAME_MAXLEN);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int rsb_cmp(struct dlm_rsb *r, const char *name, int nlen)\n{\n\tchar maxname[DLM_RESNAME_MAXLEN];\n\n\tmemset(maxname, 0, DLM_RESNAME_MAXLEN);\n\tmemcpy(maxname, name, nlen);\n\treturn memcmp(r->res_name, maxname, DLM_RESNAME_MAXLEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_remove_spin"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void wait_pending_remove(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n restart:\n\tspin_lock(&ls->ls_remove_spin);\n\tif (ls->ls_remove_len &&\n\t    !rsb_cmp(r, ls->ls_remove_name, ls->ls_remove_len)) {\n\t\tlog_debug(ls, \"delay lookup for remove dir %d %s\",\n\t\t  \t  r->res_dir_nodeid, r->res_name);\n\t\tspin_unlock(&ls->ls_remove_spin);\n\t\tmsleep(1);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&ls->ls_remove_spin);\n}"
  },
  {
    "function_name": "remove_from_waiters_ms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1610-1621",
    "snippet": "static int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_remove_from_waiters",
          "args": [
            "lkb",
            "ms->m_type",
            "ms"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "_remove_from_waiters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1511-1594",
          "snippet": "static int _remove_from_waiters(struct dlm_lkb *lkb, int mstype,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint overlap_done = 0;\n\n\tif (is_overlap_unlock(lkb) && (mstype == DLM_MSG_UNLOCK_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x unlock_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\tif (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\t/* Cancel state was preemptively cleared by a successful convert,\n\t   see next comment, nothing to do. */\n\n\tif ((mstype == DLM_MSG_CANCEL_REPLY) &&\n\t    (lkb->lkb_wait_type != DLM_MSG_CANCEL)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply wait_type %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type);\n\t\treturn -1;\n\t}\n\n\t/* Remove for the convert reply, and premptively remove for the\n\t   cancel reply.  A convert has been granted while there's still\n\t   an outstanding cancel on it (the cancel is moot and the result\n\t   in the cancel reply should be 0).  We preempt the cancel reply\n\t   because the app gets the convert result and then can follow up\n\t   with another op, like convert.  This subsequent op would see the\n\t   lingering state of the cancel and fail with -EBUSY. */\n\n\tif ((mstype == DLM_MSG_CONVERT_REPLY) &&\n\t    (lkb->lkb_wait_type == DLM_MSG_CONVERT) &&\n\t    is_overlap_cancel(lkb) && ms && !ms->m_result) {\n\t\tlog_debug(ls, \"remwait %x convert_reply zap overlap_cancel\",\n\t\t\t  lkb->lkb_id);\n\t\tlkb->lkb_wait_type = 0;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_wait_count--;\n\t\tgoto out_del;\n\t}\n\n\t/* N.B. type of reply may not always correspond to type of original\n\t   msg due to lookup->request optimization, verify others? */\n\n\tif (lkb->lkb_wait_type) {\n\t\tlkb->lkb_wait_type = 0;\n\t\tgoto out_del;\n\t}\n\n\tlog_error(ls, \"remwait error %x remote %d %x msg %d flags %x no wait\",\n\t\t  lkb->lkb_id, ms ? ms->m_header.h_nodeid : 0, lkb->lkb_remid,\n\t\t  mstype, lkb->lkb_flags);\n\treturn -1;\n\n out_del:\n\t/* the force-unlock/cancel has completed and we haven't recvd a reply\n\t   to the op that was in progress prior to the unlock/cancel; we\n\t   give up on any reply to the earlier op.  FIXME: not sure when/how\n\t   this would happen */\n\n\tif (overlap_done && lkb->lkb_wait_type) {\n\t\tlog_error(ls, \"remwait error %x reply %d wait_type %d overlap\",\n\t\t\t  lkb->lkb_id, mstype, lkb->lkb_wait_type);\n\t\tlkb->lkb_wait_count--;\n\t\tlkb->lkb_wait_type = 0;\n\t}\n\n\tDLM_ASSERT(lkb->lkb_wait_count, dlm_print_lkb(lkb););\n\n\tlkb->lkb_flags &= ~DLM_IFL_RESEND;\n\tlkb->lkb_wait_count--;\n\tif (!lkb->lkb_wait_count)\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\tunhold_lkb(lkb);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _remove_from_waiters(struct dlm_lkb *lkb, int mstype,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint overlap_done = 0;\n\n\tif (is_overlap_unlock(lkb) && (mstype == DLM_MSG_UNLOCK_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x unlock_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\tif (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\t/* Cancel state was preemptively cleared by a successful convert,\n\t   see next comment, nothing to do. */\n\n\tif ((mstype == DLM_MSG_CANCEL_REPLY) &&\n\t    (lkb->lkb_wait_type != DLM_MSG_CANCEL)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply wait_type %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type);\n\t\treturn -1;\n\t}\n\n\t/* Remove for the convert reply, and premptively remove for the\n\t   cancel reply.  A convert has been granted while there's still\n\t   an outstanding cancel on it (the cancel is moot and the result\n\t   in the cancel reply should be 0).  We preempt the cancel reply\n\t   because the app gets the convert result and then can follow up\n\t   with another op, like convert.  This subsequent op would see the\n\t   lingering state of the cancel and fail with -EBUSY. */\n\n\tif ((mstype == DLM_MSG_CONVERT_REPLY) &&\n\t    (lkb->lkb_wait_type == DLM_MSG_CONVERT) &&\n\t    is_overlap_cancel(lkb) && ms && !ms->m_result) {\n\t\tlog_debug(ls, \"remwait %x convert_reply zap overlap_cancel\",\n\t\t\t  lkb->lkb_id);\n\t\tlkb->lkb_wait_type = 0;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_wait_count--;\n\t\tgoto out_del;\n\t}\n\n\t/* N.B. type of reply may not always correspond to type of original\n\t   msg due to lookup->request optimization, verify others? */\n\n\tif (lkb->lkb_wait_type) {\n\t\tlkb->lkb_wait_type = 0;\n\t\tgoto out_del;\n\t}\n\n\tlog_error(ls, \"remwait error %x remote %d %x msg %d flags %x no wait\",\n\t\t  lkb->lkb_id, ms ? ms->m_header.h_nodeid : 0, lkb->lkb_remid,\n\t\t  mstype, lkb->lkb_flags);\n\treturn -1;\n\n out_del:\n\t/* the force-unlock/cancel has completed and we haven't recvd a reply\n\t   to the op that was in progress prior to the unlock/cancel; we\n\t   give up on any reply to the earlier op.  FIXME: not sure when/how\n\t   this would happen */\n\n\tif (overlap_done && lkb->lkb_wait_type) {\n\t\tlog_error(ls, \"remwait error %x reply %d wait_type %d overlap\",\n\t\t\t  lkb->lkb_id, mstype, lkb->lkb_wait_type);\n\t\tlkb->lkb_wait_count--;\n\t\tlkb->lkb_wait_type = 0;\n\t}\n\n\tDLM_ASSERT(lkb->lkb_wait_count, dlm_print_lkb(lkb););\n\n\tlkb->lkb_flags &= ~DLM_IFL_RESEND;\n\tlkb->lkb_wait_count--;\n\tif (!lkb->lkb_wait_count)\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\tunhold_lkb(lkb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, ms->m_type, ms);\n\tif (ms->m_flags != DLM_IFL_STUB_MS)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "remove_from_waiters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1596-1605",
    "snippet": "static int remove_from_waiters(struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, mstype, NULL);\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_remove_from_waiters",
          "args": [
            "lkb",
            "mstype",
            "NULL"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "_remove_from_waiters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1511-1594",
          "snippet": "static int _remove_from_waiters(struct dlm_lkb *lkb, int mstype,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint overlap_done = 0;\n\n\tif (is_overlap_unlock(lkb) && (mstype == DLM_MSG_UNLOCK_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x unlock_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\tif (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\t/* Cancel state was preemptively cleared by a successful convert,\n\t   see next comment, nothing to do. */\n\n\tif ((mstype == DLM_MSG_CANCEL_REPLY) &&\n\t    (lkb->lkb_wait_type != DLM_MSG_CANCEL)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply wait_type %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type);\n\t\treturn -1;\n\t}\n\n\t/* Remove for the convert reply, and premptively remove for the\n\t   cancel reply.  A convert has been granted while there's still\n\t   an outstanding cancel on it (the cancel is moot and the result\n\t   in the cancel reply should be 0).  We preempt the cancel reply\n\t   because the app gets the convert result and then can follow up\n\t   with another op, like convert.  This subsequent op would see the\n\t   lingering state of the cancel and fail with -EBUSY. */\n\n\tif ((mstype == DLM_MSG_CONVERT_REPLY) &&\n\t    (lkb->lkb_wait_type == DLM_MSG_CONVERT) &&\n\t    is_overlap_cancel(lkb) && ms && !ms->m_result) {\n\t\tlog_debug(ls, \"remwait %x convert_reply zap overlap_cancel\",\n\t\t\t  lkb->lkb_id);\n\t\tlkb->lkb_wait_type = 0;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_wait_count--;\n\t\tgoto out_del;\n\t}\n\n\t/* N.B. type of reply may not always correspond to type of original\n\t   msg due to lookup->request optimization, verify others? */\n\n\tif (lkb->lkb_wait_type) {\n\t\tlkb->lkb_wait_type = 0;\n\t\tgoto out_del;\n\t}\n\n\tlog_error(ls, \"remwait error %x remote %d %x msg %d flags %x no wait\",\n\t\t  lkb->lkb_id, ms ? ms->m_header.h_nodeid : 0, lkb->lkb_remid,\n\t\t  mstype, lkb->lkb_flags);\n\treturn -1;\n\n out_del:\n\t/* the force-unlock/cancel has completed and we haven't recvd a reply\n\t   to the op that was in progress prior to the unlock/cancel; we\n\t   give up on any reply to the earlier op.  FIXME: not sure when/how\n\t   this would happen */\n\n\tif (overlap_done && lkb->lkb_wait_type) {\n\t\tlog_error(ls, \"remwait error %x reply %d wait_type %d overlap\",\n\t\t\t  lkb->lkb_id, mstype, lkb->lkb_wait_type);\n\t\tlkb->lkb_wait_count--;\n\t\tlkb->lkb_wait_type = 0;\n\t}\n\n\tDLM_ASSERT(lkb->lkb_wait_count, dlm_print_lkb(lkb););\n\n\tlkb->lkb_flags &= ~DLM_IFL_RESEND;\n\tlkb->lkb_wait_count--;\n\tif (!lkb->lkb_wait_count)\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\tunhold_lkb(lkb);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _remove_from_waiters(struct dlm_lkb *lkb, int mstype,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint overlap_done = 0;\n\n\tif (is_overlap_unlock(lkb) && (mstype == DLM_MSG_UNLOCK_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x unlock_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\tif (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\t/* Cancel state was preemptively cleared by a successful convert,\n\t   see next comment, nothing to do. */\n\n\tif ((mstype == DLM_MSG_CANCEL_REPLY) &&\n\t    (lkb->lkb_wait_type != DLM_MSG_CANCEL)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply wait_type %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type);\n\t\treturn -1;\n\t}\n\n\t/* Remove for the convert reply, and premptively remove for the\n\t   cancel reply.  A convert has been granted while there's still\n\t   an outstanding cancel on it (the cancel is moot and the result\n\t   in the cancel reply should be 0).  We preempt the cancel reply\n\t   because the app gets the convert result and then can follow up\n\t   with another op, like convert.  This subsequent op would see the\n\t   lingering state of the cancel and fail with -EBUSY. */\n\n\tif ((mstype == DLM_MSG_CONVERT_REPLY) &&\n\t    (lkb->lkb_wait_type == DLM_MSG_CONVERT) &&\n\t    is_overlap_cancel(lkb) && ms && !ms->m_result) {\n\t\tlog_debug(ls, \"remwait %x convert_reply zap overlap_cancel\",\n\t\t\t  lkb->lkb_id);\n\t\tlkb->lkb_wait_type = 0;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_wait_count--;\n\t\tgoto out_del;\n\t}\n\n\t/* N.B. type of reply may not always correspond to type of original\n\t   msg due to lookup->request optimization, verify others? */\n\n\tif (lkb->lkb_wait_type) {\n\t\tlkb->lkb_wait_type = 0;\n\t\tgoto out_del;\n\t}\n\n\tlog_error(ls, \"remwait error %x remote %d %x msg %d flags %x no wait\",\n\t\t  lkb->lkb_id, ms ? ms->m_header.h_nodeid : 0, lkb->lkb_remid,\n\t\t  mstype, lkb->lkb_flags);\n\treturn -1;\n\n out_del:\n\t/* the force-unlock/cancel has completed and we haven't recvd a reply\n\t   to the op that was in progress prior to the unlock/cancel; we\n\t   give up on any reply to the earlier op.  FIXME: not sure when/how\n\t   this would happen */\n\n\tif (overlap_done && lkb->lkb_wait_type) {\n\t\tlog_error(ls, \"remwait error %x reply %d wait_type %d overlap\",\n\t\t\t  lkb->lkb_id, mstype, lkb->lkb_wait_type);\n\t\tlkb->lkb_wait_count--;\n\t\tlkb->lkb_wait_type = 0;\n\t}\n\n\tDLM_ASSERT(lkb->lkb_wait_count, dlm_print_lkb(lkb););\n\n\tlkb->lkb_flags &= ~DLM_IFL_RESEND;\n\tlkb->lkb_wait_count--;\n\tif (!lkb->lkb_wait_count)\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\tunhold_lkb(lkb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int remove_from_waiters(struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, mstype, NULL);\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "_remove_from_waiters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1511-1594",
    "snippet": "static int _remove_from_waiters(struct dlm_lkb *lkb, int mstype,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint overlap_done = 0;\n\n\tif (is_overlap_unlock(lkb) && (mstype == DLM_MSG_UNLOCK_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x unlock_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\tif (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\t/* Cancel state was preemptively cleared by a successful convert,\n\t   see next comment, nothing to do. */\n\n\tif ((mstype == DLM_MSG_CANCEL_REPLY) &&\n\t    (lkb->lkb_wait_type != DLM_MSG_CANCEL)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply wait_type %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type);\n\t\treturn -1;\n\t}\n\n\t/* Remove for the convert reply, and premptively remove for the\n\t   cancel reply.  A convert has been granted while there's still\n\t   an outstanding cancel on it (the cancel is moot and the result\n\t   in the cancel reply should be 0).  We preempt the cancel reply\n\t   because the app gets the convert result and then can follow up\n\t   with another op, like convert.  This subsequent op would see the\n\t   lingering state of the cancel and fail with -EBUSY. */\n\n\tif ((mstype == DLM_MSG_CONVERT_REPLY) &&\n\t    (lkb->lkb_wait_type == DLM_MSG_CONVERT) &&\n\t    is_overlap_cancel(lkb) && ms && !ms->m_result) {\n\t\tlog_debug(ls, \"remwait %x convert_reply zap overlap_cancel\",\n\t\t\t  lkb->lkb_id);\n\t\tlkb->lkb_wait_type = 0;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_wait_count--;\n\t\tgoto out_del;\n\t}\n\n\t/* N.B. type of reply may not always correspond to type of original\n\t   msg due to lookup->request optimization, verify others? */\n\n\tif (lkb->lkb_wait_type) {\n\t\tlkb->lkb_wait_type = 0;\n\t\tgoto out_del;\n\t}\n\n\tlog_error(ls, \"remwait error %x remote %d %x msg %d flags %x no wait\",\n\t\t  lkb->lkb_id, ms ? ms->m_header.h_nodeid : 0, lkb->lkb_remid,\n\t\t  mstype, lkb->lkb_flags);\n\treturn -1;\n\n out_del:\n\t/* the force-unlock/cancel has completed and we haven't recvd a reply\n\t   to the op that was in progress prior to the unlock/cancel; we\n\t   give up on any reply to the earlier op.  FIXME: not sure when/how\n\t   this would happen */\n\n\tif (overlap_done && lkb->lkb_wait_type) {\n\t\tlog_error(ls, \"remwait error %x reply %d wait_type %d overlap\",\n\t\t\t  lkb->lkb_id, mstype, lkb->lkb_wait_type);\n\t\tlkb->lkb_wait_count--;\n\t\tlkb->lkb_wait_type = 0;\n\t}\n\n\tDLM_ASSERT(lkb->lkb_wait_count, dlm_print_lkb(lkb););\n\n\tlkb->lkb_flags &= ~DLM_IFL_RESEND;\n\tlkb->lkb_wait_count--;\n\tif (!lkb->lkb_wait_count)\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\tunhold_lkb(lkb);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
      "static int receive_extralen(struct dlm_message *ms);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_wait_reply"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "lkb->lkb_wait_count",
            "dlm_print_lkb(lkb);"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"remwait error %x reply %d wait_type %d overlap\"",
            "lkb->lkb_id",
            "mstype",
            "lkb->lkb_wait_type"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"remwait error %x remote %d %x msg %d flags %x no wait\"",
            "lkb->lkb_id",
            "ms ? ms->m_header.h_nodeid : 0",
            "lkb->lkb_remid",
            "mstype",
            "lkb->lkb_flags"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"remwait %x convert_reply zap overlap_cancel\"",
            "lkb->lkb_id"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_overlap_cancel",
          "args": [
            "lkb"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "279-282",
          "snippet": "static inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"remwait %x cancel_reply wait_type %d\"",
            "lkb->lkb_id",
            "lkb->lkb_wait_type"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"remwait %x cancel_reply overlap\"",
            "lkb->lkb_id"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"remwait %x unlock_reply overlap\"",
            "lkb->lkb_id"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_overlap_unlock",
          "args": [
            "lkb"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "274-277",
          "snippet": "static inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int _remove_from_waiters(struct dlm_lkb *lkb, int mstype,\n\t\t\t\tstruct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint overlap_done = 0;\n\n\tif (is_overlap_unlock(lkb) && (mstype == DLM_MSG_UNLOCK_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x unlock_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\tif (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL_REPLY)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply overlap\", lkb->lkb_id);\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\t/* Cancel state was preemptively cleared by a successful convert,\n\t   see next comment, nothing to do. */\n\n\tif ((mstype == DLM_MSG_CANCEL_REPLY) &&\n\t    (lkb->lkb_wait_type != DLM_MSG_CANCEL)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply wait_type %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type);\n\t\treturn -1;\n\t}\n\n\t/* Remove for the convert reply, and premptively remove for the\n\t   cancel reply.  A convert has been granted while there's still\n\t   an outstanding cancel on it (the cancel is moot and the result\n\t   in the cancel reply should be 0).  We preempt the cancel reply\n\t   because the app gets the convert result and then can follow up\n\t   with another op, like convert.  This subsequent op would see the\n\t   lingering state of the cancel and fail with -EBUSY. */\n\n\tif ((mstype == DLM_MSG_CONVERT_REPLY) &&\n\t    (lkb->lkb_wait_type == DLM_MSG_CONVERT) &&\n\t    is_overlap_cancel(lkb) && ms && !ms->m_result) {\n\t\tlog_debug(ls, \"remwait %x convert_reply zap overlap_cancel\",\n\t\t\t  lkb->lkb_id);\n\t\tlkb->lkb_wait_type = 0;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_wait_count--;\n\t\tgoto out_del;\n\t}\n\n\t/* N.B. type of reply may not always correspond to type of original\n\t   msg due to lookup->request optimization, verify others? */\n\n\tif (lkb->lkb_wait_type) {\n\t\tlkb->lkb_wait_type = 0;\n\t\tgoto out_del;\n\t}\n\n\tlog_error(ls, \"remwait error %x remote %d %x msg %d flags %x no wait\",\n\t\t  lkb->lkb_id, ms ? ms->m_header.h_nodeid : 0, lkb->lkb_remid,\n\t\t  mstype, lkb->lkb_flags);\n\treturn -1;\n\n out_del:\n\t/* the force-unlock/cancel has completed and we haven't recvd a reply\n\t   to the op that was in progress prior to the unlock/cancel; we\n\t   give up on any reply to the earlier op.  FIXME: not sure when/how\n\t   this would happen */\n\n\tif (overlap_done && lkb->lkb_wait_type) {\n\t\tlog_error(ls, \"remwait error %x reply %d wait_type %d overlap\",\n\t\t\t  lkb->lkb_id, mstype, lkb->lkb_wait_type);\n\t\tlkb->lkb_wait_count--;\n\t\tlkb->lkb_wait_type = 0;\n\t}\n\n\tDLM_ASSERT(lkb->lkb_wait_count, dlm_print_lkb(lkb););\n\n\tlkb->lkb_flags &= ~DLM_IFL_RESEND;\n\tlkb->lkb_wait_count--;\n\tif (!lkb->lkb_wait_count)\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\tunhold_lkb(lkb);\n\treturn 0;\n}"
  },
  {
    "function_name": "add_to_waiters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1453-1504",
    "snippet": "static int add_to_waiters(struct dlm_lkb *lkb, int mstype, int to_nodeid)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tif (is_overlap_unlock(lkb) ||\n\t    (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL))) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lkb->lkb_wait_type || is_overlap_cancel(lkb)) {\n\t\tswitch (mstype) {\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\tbreak;\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tlkb->lkb_wait_count++;\n\t\thold_lkb(lkb);\n\n\t\tlog_debug(ls, \"addwait %x cur %d overlap %d count %d f %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type, mstype,\n\t\t\t  lkb->lkb_wait_count, lkb->lkb_flags);\n\t\tgoto out;\n\t}\n\n\tDLM_ASSERT(!lkb->lkb_wait_count,\n\t\t   dlm_print_lkb(lkb);\n\t\t   printk(\"wait_count %d\\n\", lkb->lkb_wait_count););\n\n\tlkb->lkb_wait_count++;\n\tlkb->lkb_wait_type = mstype;\n\tlkb->lkb_wait_time = ktime_get();\n\tlkb->lkb_wait_nodeid = to_nodeid; /* for debugging */\n\thold_lkb(lkb);\n\tlist_add(&lkb->lkb_wait_reply, &ls->ls_waiters);\n out:\n\tif (error)\n\t\tlog_error(ls, \"addwait error %x %d flags %x %d %d %s\",\n\t\t\t  lkb->lkb_id, error, lkb->lkb_flags, mstype,\n\t\t\t  lkb->lkb_wait_type, lkb->lkb_resource->res_name);\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"addwait error %x %d flags %x %d %d %s\"",
            "lkb->lkb_id",
            "error",
            "lkb->lkb_flags",
            "mstype",
            "lkb->lkb_wait_type",
            "lkb->lkb_resource->res_name"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lkb->lkb_wait_reply",
            "&ls->ls_waiters"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_lkb",
          "args": [
            "lkb"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"wait_count %d\\n\"",
            "lkb->lkb_wait_count"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "!lkb->lkb_wait_count",
            "dlm_print_lkb(lkb)"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"addwait %x cur %d overlap %d count %d f %x\"",
            "lkb->lkb_id",
            "lkb->lkb_wait_type",
            "mstype",
            "lkb->lkb_wait_count",
            "lkb->lkb_flags"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_overlap_cancel",
          "args": [
            "lkb"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "279-282",
          "snippet": "static inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_overlap_unlock",
          "args": [
            "lkb"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "274-277",
          "snippet": "static inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int add_to_waiters(struct dlm_lkb *lkb, int mstype, int to_nodeid)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tif (is_overlap_unlock(lkb) ||\n\t    (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL))) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lkb->lkb_wait_type || is_overlap_cancel(lkb)) {\n\t\tswitch (mstype) {\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\n\t\t\tbreak;\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tlkb->lkb_wait_count++;\n\t\thold_lkb(lkb);\n\n\t\tlog_debug(ls, \"addwait %x cur %d overlap %d count %d f %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type, mstype,\n\t\t\t  lkb->lkb_wait_count, lkb->lkb_flags);\n\t\tgoto out;\n\t}\n\n\tDLM_ASSERT(!lkb->lkb_wait_count,\n\t\t   dlm_print_lkb(lkb);\n\t\t   printk(\"wait_count %d\\n\", lkb->lkb_wait_count););\n\n\tlkb->lkb_wait_count++;\n\tlkb->lkb_wait_type = mstype;\n\tlkb->lkb_wait_time = ktime_get();\n\tlkb->lkb_wait_nodeid = to_nodeid; /* for debugging */\n\thold_lkb(lkb);\n\tlist_add(&lkb->lkb_wait_reply, &ls->ls_waiters);\n out:\n\tif (error)\n\t\tlog_error(ls, \"addwait error %x %d flags %x %d %d %s\",\n\t\t\t  lkb->lkb_id, error, lkb->lkb_flags, mstype,\n\t\t\t  lkb->lkb_wait_type, lkb->lkb_resource->res_name);\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_scan_waiters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1395-1448",
    "snippet": "void dlm_scan_waiters(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tktime_t zero = ktime_set(0, 0);\n\ts64 us;\n\ts64 debug_maxus = 0;\n\tu32 debug_scanned = 0;\n\tu32 debug_expired = 0;\n\tint num_nodes = 0;\n\tint *warned = NULL;\n\n\tif (!dlm_config.ci_waitwarn_us)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (ktime_equal(lkb->lkb_wait_time, zero))\n\t\t\tcontinue;\n\n\t\tdebug_scanned++;\n\n\t\tus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_wait_time));\n\n\t\tif (us < dlm_config.ci_waitwarn_us)\n\t\t\tcontinue;\n\n\t\tlkb->lkb_wait_time = zero;\n\n\t\tdebug_expired++;\n\t\tif (us > debug_maxus)\n\t\t\tdebug_maxus = us;\n\n\t\tif (!num_nodes) {\n\t\t\tnum_nodes = ls->ls_num_nodes;\n\t\t\twarned = kzalloc(num_nodes * sizeof(int), GFP_KERNEL);\n\t\t}\n\t\tif (!warned)\n\t\t\tcontinue;\n\t\tif (nodeid_warned(lkb->lkb_wait_nodeid, num_nodes, warned))\n\t\t\tcontinue;\n\n\t\tlog_error(ls, \"waitwarn %x %lld %d us check connection to \"\n\t\t\t  \"node %d\", lkb->lkb_id, (long long)us,\n\t\t\t  dlm_config.ci_waitwarn_us, lkb->lkb_wait_nodeid);\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\tkfree(warned);\n\n\tif (debug_expired)\n\t\tlog_debug(ls, \"scan_waiters %u warn %u over %d us max %lld us\",\n\t\t\t  debug_scanned, debug_expired,\n\t\t\t  dlm_config.ci_waitwarn_us, (long long)debug_maxus);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"scan_waiters %u warn %u over %d us max %lld us\"",
            "debug_scanned",
            "debug_expired",
            "dlm_config.ci_waitwarn_us",
            "(long long)debug_maxus"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "warned"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"waitwarn %x %lld %d us check connection to \"\n\t\t\t  \"node %d\"",
            "lkb->lkb_id",
            "(long long)us",
            "dlm_config.ci_waitwarn_us",
            "lkb->lkb_wait_nodeid"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeid_warned",
          "args": [
            "lkb->lkb_wait_nodeid",
            "num_nodes",
            "warned"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "nodeid_warned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1380-1393",
          "snippet": "static int nodeid_warned(int nodeid, int num_nodes, int *warned)\n{\n\tint i;\n\n\tfor (i = 0; i < num_nodes; i++) {\n\t\tif (!warned[i]) {\n\t\t\twarned[i] = nodeid;\n\t\t\treturn 0;\n\t\t}\n\t\tif (warned[i] == nodeid)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int nodeid_warned(int nodeid, int num_nodes, int *warned)\n{\n\tint i;\n\n\tfor (i = 0; i < num_nodes; i++) {\n\t\tif (!warned[i]) {\n\t\t\twarned[i] = nodeid;\n\t\t\treturn 0;\n\t\t}\n\t\tif (warned[i] == nodeid)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "num_nodes * sizeof(int)",
            "GFP_KERNEL"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "ktime_sub(ktime_get(), lkb->lkb_wait_time)"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "lkb->lkb_wait_time"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_equal",
          "args": [
            "lkb->lkb_wait_time",
            "zero"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&ls->ls_waiters",
            "lkb_wait_reply"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "0",
            "0"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_scan_waiters(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tktime_t zero = ktime_set(0, 0);\n\ts64 us;\n\ts64 debug_maxus = 0;\n\tu32 debug_scanned = 0;\n\tu32 debug_expired = 0;\n\tint num_nodes = 0;\n\tint *warned = NULL;\n\n\tif (!dlm_config.ci_waitwarn_us)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (ktime_equal(lkb->lkb_wait_time, zero))\n\t\t\tcontinue;\n\n\t\tdebug_scanned++;\n\n\t\tus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_wait_time));\n\n\t\tif (us < dlm_config.ci_waitwarn_us)\n\t\t\tcontinue;\n\n\t\tlkb->lkb_wait_time = zero;\n\n\t\tdebug_expired++;\n\t\tif (us > debug_maxus)\n\t\t\tdebug_maxus = us;\n\n\t\tif (!num_nodes) {\n\t\t\tnum_nodes = ls->ls_num_nodes;\n\t\t\twarned = kzalloc(num_nodes * sizeof(int), GFP_KERNEL);\n\t\t}\n\t\tif (!warned)\n\t\t\tcontinue;\n\t\tif (nodeid_warned(lkb->lkb_wait_nodeid, num_nodes, warned))\n\t\t\tcontinue;\n\n\t\tlog_error(ls, \"waitwarn %x %lld %d us check connection to \"\n\t\t\t  \"node %d\", lkb->lkb_id, (long long)us,\n\t\t\t  dlm_config.ci_waitwarn_us, lkb->lkb_wait_nodeid);\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\tkfree(warned);\n\n\tif (debug_expired)\n\t\tlog_debug(ls, \"scan_waiters %u warn %u over %d us max %lld us\",\n\t\t\t  debug_scanned, debug_expired,\n\t\t\t  dlm_config.ci_waitwarn_us, (long long)debug_maxus);\n}"
  },
  {
    "function_name": "nodeid_warned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1380-1393",
    "snippet": "static int nodeid_warned(int nodeid, int num_nodes, int *warned)\n{\n\tint i;\n\n\tfor (i = 0; i < num_nodes; i++) {\n\t\tif (!warned[i]) {\n\t\t\twarned[i] = nodeid;\n\t\t\treturn 0;\n\t\t}\n\t\tif (warned[i] == nodeid)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int nodeid_warned(int nodeid, int num_nodes, int *warned)\n{\n\tint i;\n\n\tfor (i = 0; i < num_nodes; i++) {\n\t\tif (!warned[i]) {\n\t\t\twarned[i] = nodeid;\n\t\t\treturn 0;\n\t\t}\n\t\tif (warned[i] == nodeid)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "msg_reply_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1363-1378",
    "snippet": "static int msg_reply_type(int mstype)\n{\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\t\treturn DLM_MSG_REQUEST_REPLY;\n\tcase DLM_MSG_CONVERT:\n\t\treturn DLM_MSG_CONVERT_REPLY;\n\tcase DLM_MSG_UNLOCK:\n\t\treturn DLM_MSG_UNLOCK_REPLY;\n\tcase DLM_MSG_CANCEL:\n\t\treturn DLM_MSG_CANCEL_REPLY;\n\tcase DLM_MSG_LOOKUP:\n\t\treturn DLM_MSG_LOOKUP_REPLY;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int msg_reply_type(int mstype)\n{\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\t\treturn DLM_MSG_REQUEST_REPLY;\n\tcase DLM_MSG_CONVERT:\n\t\treturn DLM_MSG_CONVERT_REPLY;\n\tcase DLM_MSG_UNLOCK:\n\t\treturn DLM_MSG_UNLOCK_REPLY;\n\tcase DLM_MSG_CANCEL:\n\t\treturn DLM_MSG_CANCEL_REPLY;\n\tcase DLM_MSG_LOOKUP:\n\t\treturn DLM_MSG_LOOKUP_REPLY;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "move_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1355-1361",
    "snippet": "static void move_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int sts)\n{\n\thold_lkb(lkb);\n\tdel_lkb(r, lkb);\n\tadd_lkb(r, lkb, sts);\n\tunhold_lkb(lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_lkb",
          "args": [
            "r",
            "lkb",
            "sts"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "add_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1314-1346",
          "snippet": "static void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_lkb",
          "args": [
            "r",
            "lkb"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "del_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1348-1353",
          "snippet": "static void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void move_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int sts)\n{\n\thold_lkb(lkb);\n\tdel_lkb(r, lkb);\n\tadd_lkb(r, lkb, sts);\n\tunhold_lkb(lkb);\n}"
  },
  {
    "function_name": "del_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1348-1353",
    "snippet": "static void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhold_lkb",
          "args": [
            "lkb"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1293-1298",
          "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&lkb->lkb_statequeue"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}"
  },
  {
    "function_name": "add_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1314-1346",
    "snippet": "static void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"sts=%d\\n\"",
            "status"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "0",
            "dlm_print_lkb(lkb)"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lkb->lkb_statequeue",
            "&r->res_convertqueue"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lkb->lkb_statequeue",
            "&r->res_convertqueue"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lkb_add_ordered",
          "args": [
            "&lkb->lkb_statequeue",
            "&r->res_grantqueue",
            "lkb->lkb_grmode"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "lkb_add_ordered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1300-1310",
          "snippet": "static void lkb_add_ordered(struct list_head *new, struct list_head *head,\n\t\t\t    int mode)\n{\n\tstruct dlm_lkb *lkb = NULL;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue)\n\t\tif (lkb->lkb_rqmode < mode)\n\t\t\tbreak;\n\n\t__list_add(new, lkb->lkb_statequeue.prev, &lkb->lkb_statequeue);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void lkb_add_ordered(struct list_head *new, struct list_head *head,\n\t\t\t    int mode)\n{\n\tstruct dlm_lkb *lkb = NULL;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue)\n\t\tif (lkb->lkb_rqmode < mode)\n\t\t\tbreak;\n\n\t__list_add(new, lkb->lkb_statequeue.prev, &lkb->lkb_statequeue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lkb->lkb_statequeue",
            "&r->res_waitqueue"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "!lkb->lkb_status",
            "dlm_print_lkb(lkb);"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&lkb->lkb_ref"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t/* convention says granted locks kept in order of grmode */\n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}"
  },
  {
    "function_name": "lkb_add_ordered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1300-1310",
    "snippet": "static void lkb_add_ordered(struct list_head *new, struct list_head *head,\n\t\t\t    int mode)\n{\n\tstruct dlm_lkb *lkb = NULL;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue)\n\t\tif (lkb->lkb_rqmode < mode)\n\t\t\tbreak;\n\n\t__list_add(new, lkb->lkb_statequeue.prev, &lkb->lkb_statequeue);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__list_add",
          "args": [
            "new",
            "lkb->lkb_statequeue.prev",
            "&lkb->lkb_statequeue"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "head",
            "lkb_statequeue"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void lkb_add_ordered(struct list_head *new, struct list_head *head,\n\t\t\t    int mode)\n{\n\tstruct dlm_lkb *lkb = NULL;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue)\n\t\tif (lkb->lkb_rqmode < mode)\n\t\t\tbreak;\n\n\t__list_add(new, lkb->lkb_statequeue.prev, &lkb->lkb_statequeue);\n}"
  },
  {
    "function_name": "unhold_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1293-1298",
    "snippet": "static inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "!rv",
            "dlm_print_lkb(lkb);"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&lkb->lkb_ref",
            "kill_lkb"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tint rv;\n\trv = kref_put(&lkb->lkb_ref, kill_lkb);\n\tDLM_ASSERT(!rv, dlm_print_lkb(lkb););\n}"
  },
  {
    "function_name": "hold_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1283-1286",
    "snippet": "static inline void hold_lkb(struct dlm_lkb *lkb)\n{\n\tkref_get(&lkb->lkb_ref);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&lkb->lkb_ref"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void hold_lkb(struct dlm_lkb *lkb)\n{\n\tkref_get(&lkb->lkb_ref);\n}"
  },
  {
    "function_name": "dlm_put_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1269-1278",
    "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_lkb",
          "args": [
            "ls",
            "lkb"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "__put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1247-1267",
          "snippet": "static int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "lkb->lkb_resource->res_ls",
            "dlm_print_lkb(lkb);"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "lkb->lkb_resource",
            "dlm_print_lkb(lkb);"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
  },
  {
    "function_name": "__put_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1247-1267",
    "snippet": "static int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lkbidr_spin"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_free_lkb",
          "args": [
            "lkb"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "83-95",
          "snippet": "void dlm_free_lkb(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tstruct dlm_user_args *ua;\n\t\tua = lkb->lkb_ua;\n\t\tif (ua) {\n\t\t\tif (ua->lksb.sb_lvbptr)\n\t\t\t\tkfree(ua->lksb.sb_lvbptr);\n\t\t\tkfree(ua);\n\t\t}\n\t}\n\tkmem_cache_free(lkb_cache, lkb);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lkb_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kmem_cache *lkb_cache;\n\nvoid dlm_free_lkb(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tstruct dlm_user_args *ua;\n\t\tua = lkb->lkb_ua;\n\t\tif (ua) {\n\t\t\tif (ua->lksb.sb_lvbptr)\n\t\t\t\tkfree(ua->lksb.sb_lvbptr);\n\t\t\tkfree(ua);\n\t\t}\n\t}\n\tkmem_cache_free(lkb_cache, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_free_lvb",
          "args": [
            "lkb->lkb_lvbptr"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "55-58",
          "snippet": "void dlm_free_lvb(char *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_free_lvb(char *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master_copy",
          "args": [
            "lkb"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_lkb",
          "args": [
            "lkb"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "detach_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1176-1182",
          "snippet": "static void detach_lkb(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_resource) {\n\t\tput_rsb(lkb->lkb_resource);\n\t\tlkb->lkb_resource = NULL;\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void detach_lkb(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_resource) {\n\t\tput_rsb(lkb->lkb_resource);\n\t\tlkb->lkb_resource = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&ls->ls_lkbidr",
            "lkid"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&lkb->lkb_ref",
            "kill_lkb"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lkbidr_spin"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (kref_put(&lkb->lkb_ref, kill_lkb)) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t/* for local/process lkbs, lvbptr points to caller's lksb */\n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t\treturn 1;\n\t} else {\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "kill_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1234-1242",
    "snippet": "static void kill_lkb(struct kref *kref)\n{\n\tstruct dlm_lkb *lkb = container_of(kref, struct dlm_lkb, lkb_ref);\n\n\t/* All work is done after the return from kref_put() so we\n\t   can release the write_lock before the detach_lkb */\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);",
      "static void toss_rsb(struct kref *kref);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "!lkb->lkb_status",
            "dlm_print_lkb(lkb);"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structdlm_lkb",
            "lkb_ref"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\nstatic void toss_rsb(struct kref *kref);\n\nstatic void kill_lkb(struct kref *kref)\n{\n\tstruct dlm_lkb *lkb = container_of(kref, struct dlm_lkb, lkb_ref);\n\n\t/* All work is done after the return from kref_put() so we\n\t   can release the write_lock before the detach_lkb */\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n}"
  },
  {
    "function_name": "find_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1220-1232",
    "snippet": "static int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lkbidr_spin"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&lkb->lkb_ref"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&ls->ls_lkbidr",
            "lkid"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "recover_idr_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "343-351",
          "snippet": "static struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lkbidr_spin"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}"
  },
  {
    "function_name": "create_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1184-1218",
    "snippet": "static int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_time_list);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tmutex_init(&lkb->lkb_cb_mutex);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, 1, 0, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"create_lkb idr error %d\"",
            "rv"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lkbidr_spin"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&ls->ls_lkbidr",
            "lkb",
            "1",
            "0",
            "GFP_NOWAIT"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lkbidr_spin"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&lkb->lkb_cb_work",
            "dlm_callback_work"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&lkb->lkb_cb_mutex"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lkb->lkb_cb_list"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lkb->lkb_time_list"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lkb->lkb_rsb_lookup"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lkb->lkb_ownqueue"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&lkb->lkb_ref"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_allocate_lkb",
          "args": [
            "ls"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_allocate_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "75-81",
          "snippet": "struct dlm_lkb *dlm_allocate_lkb(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlkb = kmem_cache_zalloc(lkb_cache, GFP_NOFS);\n\treturn lkb;\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lkb_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kmem_cache *lkb_cache;\n\nstruct dlm_lkb *dlm_allocate_lkb(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlkb = kmem_cache_zalloc(lkb_cache, GFP_NOFS);\n\treturn lkb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_time_list);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tmutex_init(&lkb->lkb_cb_mutex);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, 1, 0, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}"
  },
  {
    "function_name": "detach_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1176-1182",
    "snippet": "static void detach_lkb(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_resource) {\n\t\tput_rsb(lkb->lkb_resource);\n\t\tlkb->lkb_resource = NULL;\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "lkb->lkb_resource"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void detach_lkb(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_resource) {\n\t\tput_rsb(lkb->lkb_resource);\n\t\tlkb->lkb_resource = NULL;\n\t}\n}"
  },
  {
    "function_name": "attach_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1170-1174",
    "snippet": "static void attach_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\thold_rsb(r);\n\tlkb->lkb_resource = r;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void attach_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\thold_rsb(r);\n\tlkb->lkb_resource = r;\n}"
  },
  {
    "function_name": "kill_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1152-1165",
    "snippet": "static void kill_rsb(struct kref *kref)\n{\n\tstruct dlm_rsb *r = container_of(kref, struct dlm_rsb, res_ref);\n\n\t/* All work is done after the return from kref_put() so we\n\t   can release the write_lock before the remove and free. */\n\n\tDLM_ASSERT(list_empty(&r->res_lookup), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_grantqueue), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_convertqueue), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_waitqueue), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_root_list), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_recover_list), dlm_dump_rsb(r););\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);",
      "static void toss_rsb(struct kref *kref);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "list_empty(&r->res_recover_list)",
            "dlm_dump_rsb(r);"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&r->res_recover_list"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "list_empty(&r->res_root_list)",
            "dlm_dump_rsb(r);"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "list_empty(&r->res_waitqueue)",
            "dlm_dump_rsb(r);"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "list_empty(&r->res_convertqueue)",
            "dlm_dump_rsb(r);"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "list_empty(&r->res_grantqueue)",
            "dlm_dump_rsb(r);"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "list_empty(&r->res_lookup)",
            "dlm_dump_rsb(r);"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structdlm_rsb",
            "res_ref"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\nstatic void toss_rsb(struct kref *kref);\n\nstatic void kill_rsb(struct kref *kref)\n{\n\tstruct dlm_rsb *r = container_of(kref, struct dlm_rsb, res_ref);\n\n\t/* All work is done after the return from kref_put() so we\n\t   can release the write_lock before the remove and free. */\n\n\tDLM_ASSERT(list_empty(&r->res_lookup), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_grantqueue), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_convertqueue), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_waitqueue), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_root_list), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_recover_list), dlm_dump_rsb(r););\n}"
  },
  {
    "function_name": "unhold_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1145-1150",
    "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "!rv",
            "dlm_dump_rsb(r);"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&r->res_ref",
            "toss_rsb"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
  },
  {
    "function_name": "toss_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1126-1141",
    "snippet": "static void toss_rsb(struct kref *kref)\n{\n\tstruct dlm_rsb *r = container_of(kref, struct dlm_rsb, res_ref);\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tDLM_ASSERT(list_empty(&r->res_root_list), dlm_print_rsb(r););\n\tkref_init(&r->res_ref);\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[r->res_bucket].keep);\n\trsb_insert(r, &ls->ls_rsbtbl[r->res_bucket].toss);\n\tr->res_toss_time = jiffies;\n\tls->ls_rsbtbl[r->res_bucket].flags |= DLM_RTF_SHRINK;\n\tif (r->res_lvbptr) {\n\t\tdlm_free_lvb(r->res_lvbptr);\n\t\tr->res_lvbptr = NULL;\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);",
      "static void toss_rsb(struct kref *kref);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_free_lvb",
          "args": [
            "r->res_lvbptr"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "55-58",
          "snippet": "void dlm_free_lvb(char *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_free_lvb(char *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_insert",
          "args": [
            "r",
            "&ls->ls_rsbtbl[r->res_bucket].toss"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "472-499",
          "snippet": "static int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&r->res_hashnode",
            "&ls->ls_rsbtbl[r->res_bucket].keep"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&r->res_ref"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "list_empty(&r->res_root_list)",
            "dlm_print_rsb(r);"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_rsb",
          "args": [
            "r"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "172-179",
          "snippet": "static void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&r->res_root_list"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structdlm_rsb",
            "res_ref"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\nstatic void toss_rsb(struct kref *kref);\n\nstatic void toss_rsb(struct kref *kref)\n{\n\tstruct dlm_rsb *r = container_of(kref, struct dlm_rsb, res_ref);\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tDLM_ASSERT(list_empty(&r->res_root_list), dlm_print_rsb(r););\n\tkref_init(&r->res_ref);\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[r->res_bucket].keep);\n\trsb_insert(r, &ls->ls_rsbtbl[r->res_bucket].toss);\n\tr->res_toss_time = jiffies;\n\tls->ls_rsbtbl[r->res_bucket].flags |= DLM_RTF_SHRINK;\n\tif (r->res_lvbptr) {\n\t\tdlm_free_lvb(r->res_lvbptr);\n\t\tr->res_lvbptr = NULL;\n\t}\n}"
  },
  {
    "function_name": "dlm_dump_rsb_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1103-1124",
    "snippet": "void dlm_dump_rsb_name(struct dlm_ls *ls, char *name, int len)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint error;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error)\n\t\tgoto out_dump;\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto out;\n out_dump:\n\tdlm_dump_rsb(r);\n out:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[b].lock"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_search_rsb_tree",
          "args": [
            "&ls->ls_rsbtbl[b].toss",
            "name",
            "len",
            "&r"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_search_rsb_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "447-470",
          "snippet": "int dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[b].lock"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "name",
            "len",
            "0"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_dump_rsb_name(struct dlm_ls *ls, char *name, int len)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint error;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error)\n\t\tgoto out_dump;\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto out;\n out_dump:\n\tdlm_dump_rsb(r);\n out:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n}"
  },
  {
    "function_name": "dlm_dump_rsb_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "1086-1101",
    "snippet": "static void dlm_dump_rsb_hash(struct dlm_ls *ls, uint32_t hash)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\tif (r->res_hash == hash)\n\t\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[i].lock"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ls->ls_rsbtbl[i].keep"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[i].lock"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_dump_rsb_hash(struct dlm_ls *ls, uint32_t hash)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\tif (r->res_hash == hash)\n\t\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n}"
  },
  {
    "function_name": "dlm_master_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "912-1084",
    "snippet": "int dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, char *name, int len,\n\t\t      unsigned int flags, int *r_nodeid, int *result)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint from_master = (flags & DLM_LU_RECOVER_DIR);\n\tint fix_master = (flags & DLM_LU_RECOVER_MASTER);\n\tint our_nodeid = dlm_our_nodeid();\n\tint dir_nodeid, error, toss_list = 0;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tif (from_nodeid == our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from our_nodeid %d flags %x\",\n\t\t\t  our_nodeid, flags);\n\t\treturn -EINVAL;\n\t}\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\tif (dir_nodeid != our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from %d dir %d our %d h %x %d\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, hash,\n\t\t\t  ls->ls_num_nodes);\n\t\t*r_nodeid = -1;\n\t\treturn -EINVAL;\n\t}\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\treturn error;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error) {\n\t\t/* because the rsb is active, we need to lock_rsb before\n\t\t   checking/changing re_master_nodeid */\n\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlock_rsb(r);\n\t\tgoto found;\n\t}\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto not_found;\n\n\t/* because the rsb is inactive (on toss list), it's not refcounted\n\t   and lock_rsb is not used, but is protected by the rsbtbl lock */\n\n\ttoss_list = 1;\n found:\n\tif (r->res_dir_nodeid != our_nodeid) {\n\t\t/* should not happen, but may as well fix it and carry on */\n\t\tlog_error(ls, \"dlm_master_lookup res_dir %d our %d %s\",\n\t\t\t  r->res_dir_nodeid, our_nodeid, r->res_name);\n\t\tr->res_dir_nodeid = our_nodeid;\n\t}\n\n\tif (fix_master && dlm_is_removed(ls, r->res_master_nodeid)) {\n\t\t/* Recovery uses this function to set a new master when\n\t\t   the previous master failed.  Setting NEW_MASTER will\n\t\t   force dlm_recover_masters to call recover_master on this\n\t\t   rsb even though the res_nodeid is no longer removed. */\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\n\t\tif (toss_list) {\n\t\t\t/* I don't think we should ever find it on toss list. */\n\t\t\tlog_error(ls, \"dlm_master_lookup fix_master on toss\");\n\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t}\n\n\tif (from_master && (r->res_master_nodeid != from_nodeid)) {\n\t\t/* this will happen if from_nodeid became master during\n\t\t   a previous recovery cycle, and we aborted the previous\n\t\t   cycle before recovering this master value */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from_master %d \"\n\t\t\t  \"master_nodeid %d res_nodeid %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_nodeid,\n\t\t\t  r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_master_nodeid == our_nodeid) {\n\t\t\tlog_error(ls, \"from_master %d our_master\", from_nodeid);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tdlm_send_rcom_lookup_dump(r, from_nodeid);\n\t\t\tgoto out_found;\n\t\t}\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\t}\n\n\tif (!r->res_master_nodeid) {\n\t\t/* this will happen if recovery happens while we're looking\n\t\t   up the master for this rsb */\n\n\t\tlog_debug(ls, \"dlm_master_lookup master 0 to %d first %x %s\",\n\t\t\t  from_nodeid, r->res_first_lkid, r->res_name);\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t}\n\n\tif (!from_master && !fix_master &&\n\t    (r->res_master_nodeid == from_nodeid)) {\n\t\t/* this can happen when the master sends remove, the dir node\n\t\t   finds the rsb on the keep list and ignores the remove,\n\t\t   and the former master sends a lookup */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from master %d flags %x \"\n\t\t\t  \"first %x %s\", from_nodeid, flags,\n\t\t\t  r->res_first_lkid, r->res_name);\n\t}\n\n out_found:\n\t*r_nodeid = r->res_master_nodeid;\n\tif (result)\n\t\t*result = DLM_LU_MATCH;\n\n\tif (toss_list) {\n\t\tr->res_toss_time = jiffies;\n\t\t/* the rsb was inactive (on toss list) */\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t} else {\n\t\t/* the rsb was active */\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t}\n\treturn 0;\n\n not_found:\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = our_nodeid;\n\tr->res_master_nodeid = from_nodeid;\n\tr->res_nodeid = from_nodeid;\n\tkref_init(&r->res_ref);\n\tr->res_toss_time = jiffies;\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].toss);\n\tif (error) {\n\t\t/* should never happen */\n\t\tdlm_free_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\n\tif (result)\n\t\t*result = DLM_LU_ADD;\n\t*r_nodeid = from_nodeid;\n\terror = 0;\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[b].lock"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_free_rsb",
          "args": [
            "r"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "68-73",
          "snippet": "void dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rsb_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kmem_cache *rsb_cache;\n\nvoid dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_insert",
          "args": [
            "r",
            "&ls->ls_rsbtbl[b].toss"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "472-499",
          "snippet": "static int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&r->res_ref"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rsb_struct",
          "args": [
            "ls",
            "name",
            "len",
            "&r"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "get_rsb_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "400-436",
          "snippet": "static int get_rsb_struct(struct dlm_ls *ls, char *name, int len,\n\t\t\t  struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r;\n\tint count;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (list_empty(&ls->ls_new_rsb)) {\n\t\tcount = ls->ls_new_rsb_count;\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\tlog_debug(ls, \"find_rsb retry %d %d %s\",\n\t\t\t  count, dlm_config.ci_new_rsb_count, name);\n\t\treturn -EAGAIN;\n\t}\n\n\tr = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb, res_hashchain);\n\tlist_del(&r->res_hashchain);\n\t/* Convert the empty list_head to a NULL rb_node for tree usage: */\n\tmemset(&r->res_hashnode, 0, sizeof(struct rb_node));\n\tls->ls_new_rsb_count--;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr->res_ls = ls;\n\tr->res_length = len;\n\tmemcpy(r->res_name, name, len);\n\tmutex_init(&r->res_mutex);\n\n\tINIT_LIST_HEAD(&r->res_lookup);\n\tINIT_LIST_HEAD(&r->res_grantqueue);\n\tINIT_LIST_HEAD(&r->res_convertqueue);\n\tINIT_LIST_HEAD(&r->res_waitqueue);\n\tINIT_LIST_HEAD(&r->res_root_list);\n\tINIT_LIST_HEAD(&r->res_recover_list);\n\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int get_rsb_struct(struct dlm_ls *ls, char *name, int len,\n\t\t\t  struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r;\n\tint count;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (list_empty(&ls->ls_new_rsb)) {\n\t\tcount = ls->ls_new_rsb_count;\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\tlog_debug(ls, \"find_rsb retry %d %d %s\",\n\t\t\t  count, dlm_config.ci_new_rsb_count, name);\n\t\treturn -EAGAIN;\n\t}\n\n\tr = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb, res_hashchain);\n\tlist_del(&r->res_hashchain);\n\t/* Convert the empty list_head to a NULL rb_node for tree usage: */\n\tmemset(&r->res_hashnode, 0, sizeof(struct rb_node));\n\tls->ls_new_rsb_count--;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr->res_ls = ls;\n\tr->res_length = len;\n\tmemcpy(r->res_name, name, len);\n\tmutex_init(&r->res_mutex);\n\n\tINIT_LIST_HEAD(&r->res_lookup);\n\tINIT_LIST_HEAD(&r->res_grantqueue);\n\tINIT_LIST_HEAD(&r->res_convertqueue);\n\tINIT_LIST_HEAD(&r->res_waitqueue);\n\tINIT_LIST_HEAD(&r->res_root_list);\n\tINIT_LIST_HEAD(&r->res_recover_list);\n\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_limit",
          "args": [
            "ls",
            "\"dlm_master_lookup from master %d flags %x \"\n\t\t\t  \"first %x %s\"",
            "from_nodeid",
            "flags",
            "r->res_first_lkid",
            "r->res_name"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"dlm_master_lookup master 0 to %d first %x %s\"",
            "from_nodeid",
            "r->res_first_lkid",
            "r->res_name"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_rcom_lookup_dump",
          "args": [
            "r",
            "from_nodeid"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_rcom_lookup_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "335-352",
          "snippet": "int dlm_send_rcom_lookup_dump(struct dlm_rsb *r, int to_nodeid)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_ls *ls = r->res_ls;\n\tint error;\n\n\terror = create_rcom(ls, to_nodeid, DLM_RCOM_LOOKUP, r->res_length,\n\t\t\t    &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, r->res_name, r->res_length);\n\trc->rc_id = 0xFFFFFFFF;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_send_rcom_lookup_dump(struct dlm_rsb *r, int to_nodeid)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_ls *ls = r->res_ls;\n\tint error;\n\n\terror = create_rcom(ls, to_nodeid, DLM_RCOM_LOOKUP, r->res_length,\n\t\t\t    &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, r->res_name, r->res_length);\n\trc->rc_id = 0xFFFFFFFF;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"from_master %d our_master\"",
            "from_nodeid"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_limit",
          "args": [
            "ls",
            "\"dlm_master_lookup from_master %d \"\n\t\t\t  \"master_nodeid %d res_nodeid %d first %x %s\"",
            "from_nodeid",
            "r->res_master_nodeid",
            "r->res_nodeid",
            "r->res_first_lkid",
            "r->res_name"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_master_lookup fix_master on toss\""
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_removed",
          "args": [
            "ls",
            "r->res_master_nodeid"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "358-363",
          "snippet": "int dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_master_lookup res_dir %d our %d %s\"",
            "r->res_dir_nodeid",
            "our_nodeid",
            "r->res_name"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_search_rsb_tree",
          "args": [
            "&ls->ls_rsbtbl[b].toss",
            "name",
            "len",
            "&r"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_search_rsb_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "447-470",
          "snippet": "int dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[b].lock"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pre_rsb_struct",
          "args": [
            "ls"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "pre_rsb_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "364-394",
          "snippet": "static int pre_rsb_struct(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r1, *r2;\n\tint count = 0;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (ls->ls_new_rsb_count > dlm_config.ci_new_rsb_count / 2) {\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr1 = dlm_allocate_rsb(ls);\n\tr2 = dlm_allocate_rsb(ls);\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (r1) {\n\t\tlist_add(&r1->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tif (r2) {\n\t\tlist_add(&r2->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tcount = ls->ls_new_rsb_count;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tif (!count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int pre_rsb_struct(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r1, *r2;\n\tint count = 0;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (ls->ls_new_rsb_count > dlm_config.ci_new_rsb_count / 2) {\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr1 = dlm_allocate_rsb(ls);\n\tr2 = dlm_allocate_rsb(ls);\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (r1) {\n\t\tlist_add(&r1->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tif (r2) {\n\t\tlist_add(&r2->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tcount = ls->ls_new_rsb_count;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tif (!count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_master_lookup from %d dir %d our %d h %x %d\"",
            "from_nodeid",
            "dir_nodeid",
            "our_nodeid",
            "hash",
            "ls->ls_num_nodes"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_hash2nodeid",
          "args": [
            "ls",
            "hash"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hash2nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "35-45",
          "snippet": "int dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "name",
            "len",
            "0"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_master_lookup from our_nodeid %d flags %x\"",
            "our_nodeid",
            "flags"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, char *name, int len,\n\t\t      unsigned int flags, int *r_nodeid, int *result)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint from_master = (flags & DLM_LU_RECOVER_DIR);\n\tint fix_master = (flags & DLM_LU_RECOVER_MASTER);\n\tint our_nodeid = dlm_our_nodeid();\n\tint dir_nodeid, error, toss_list = 0;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tif (from_nodeid == our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from our_nodeid %d flags %x\",\n\t\t\t  our_nodeid, flags);\n\t\treturn -EINVAL;\n\t}\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\tif (dir_nodeid != our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from %d dir %d our %d h %x %d\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, hash,\n\t\t\t  ls->ls_num_nodes);\n\t\t*r_nodeid = -1;\n\t\treturn -EINVAL;\n\t}\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\treturn error;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error) {\n\t\t/* because the rsb is active, we need to lock_rsb before\n\t\t   checking/changing re_master_nodeid */\n\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlock_rsb(r);\n\t\tgoto found;\n\t}\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto not_found;\n\n\t/* because the rsb is inactive (on toss list), it's not refcounted\n\t   and lock_rsb is not used, but is protected by the rsbtbl lock */\n\n\ttoss_list = 1;\n found:\n\tif (r->res_dir_nodeid != our_nodeid) {\n\t\t/* should not happen, but may as well fix it and carry on */\n\t\tlog_error(ls, \"dlm_master_lookup res_dir %d our %d %s\",\n\t\t\t  r->res_dir_nodeid, our_nodeid, r->res_name);\n\t\tr->res_dir_nodeid = our_nodeid;\n\t}\n\n\tif (fix_master && dlm_is_removed(ls, r->res_master_nodeid)) {\n\t\t/* Recovery uses this function to set a new master when\n\t\t   the previous master failed.  Setting NEW_MASTER will\n\t\t   force dlm_recover_masters to call recover_master on this\n\t\t   rsb even though the res_nodeid is no longer removed. */\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\n\t\tif (toss_list) {\n\t\t\t/* I don't think we should ever find it on toss list. */\n\t\t\tlog_error(ls, \"dlm_master_lookup fix_master on toss\");\n\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t}\n\n\tif (from_master && (r->res_master_nodeid != from_nodeid)) {\n\t\t/* this will happen if from_nodeid became master during\n\t\t   a previous recovery cycle, and we aborted the previous\n\t\t   cycle before recovering this master value */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from_master %d \"\n\t\t\t  \"master_nodeid %d res_nodeid %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_nodeid,\n\t\t\t  r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_master_nodeid == our_nodeid) {\n\t\t\tlog_error(ls, \"from_master %d our_master\", from_nodeid);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tdlm_send_rcom_lookup_dump(r, from_nodeid);\n\t\t\tgoto out_found;\n\t\t}\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\t}\n\n\tif (!r->res_master_nodeid) {\n\t\t/* this will happen if recovery happens while we're looking\n\t\t   up the master for this rsb */\n\n\t\tlog_debug(ls, \"dlm_master_lookup master 0 to %d first %x %s\",\n\t\t\t  from_nodeid, r->res_first_lkid, r->res_name);\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t}\n\n\tif (!from_master && !fix_master &&\n\t    (r->res_master_nodeid == from_nodeid)) {\n\t\t/* this can happen when the master sends remove, the dir node\n\t\t   finds the rsb on the keep list and ignores the remove,\n\t\t   and the former master sends a lookup */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from master %d flags %x \"\n\t\t\t  \"first %x %s\", from_nodeid, flags,\n\t\t\t  r->res_first_lkid, r->res_name);\n\t}\n\n out_found:\n\t*r_nodeid = r->res_master_nodeid;\n\tif (result)\n\t\t*result = DLM_LU_MATCH;\n\n\tif (toss_list) {\n\t\tr->res_toss_time = jiffies;\n\t\t/* the rsb was inactive (on toss list) */\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t} else {\n\t\t/* the rsb was active */\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t}\n\treturn 0;\n\n not_found:\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = our_nodeid;\n\tr->res_master_nodeid = from_nodeid;\n\tr->res_nodeid = from_nodeid;\n\tkref_init(&r->res_ref);\n\tr->res_toss_time = jiffies;\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].toss);\n\tif (error) {\n\t\t/* should never happen */\n\t\tdlm_free_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\n\tif (result)\n\t\t*result = DLM_LU_ADD;\n\t*r_nodeid = from_nodeid;\n\terror = 0;\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\treturn error;\n}"
  },
  {
    "function_name": "validate_master_nodeid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "843-881",
    "snippet": "static int validate_master_nodeid(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t\t  int from_nodeid)\n{\n\tif (dlm_no_directory(ls)) {\n\t\tlog_error(ls, \"find_rsb keep from_nodeid %d master %d dir %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\treturn -ENOTBLK;\n\t}\n\n\tif (from_nodeid != r->res_dir_nodeid) {\n\t\t/* our rsb is not master, and another node (not the dir node)\n\t   \t   has sent us a request.  this is much more common when our\n\t   \t   master_nodeid is zero, so limit debug to non-zero.  */\n\n\t\tif (r->res_master_nodeid) {\n\t\t\tlog_debug(ls, \"validate master from_other %d master %d \"\n\t\t\t\t  \"dir %d first %x %s\", from_nodeid,\n\t\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t\t  r->res_first_lkid, r->res_name);\n\t\t}\n\t\treturn -ENOTBLK;\n\t} else {\n\t\t/* our rsb is not master, but the dir nodeid has sent us a\n\t   \t   request; this could happen with master 0 / res_nodeid -1 */\n\n\t\tif (r->res_master_nodeid) {\n\t\t\tlog_error(ls, \"validate master from_dir %d master %d \"\n\t\t\t\t  \"first %x %s\",\n\t\t\t\t  from_nodeid, r->res_master_nodeid,\n\t\t\t\t  r->res_first_lkid, r->res_name);\n\t\t}\n\n\t\tr->res_master_nodeid = dlm_our_nodeid();\n\t\tr->res_nodeid = 0;\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"validate master from_dir %d master %d \"\n\t\t\t\t  \"first %x %s\"",
            "from_nodeid",
            "r->res_master_nodeid",
            "r->res_first_lkid",
            "r->res_name"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"validate master from_other %d master %d \"\n\t\t\t\t  \"dir %d first %x %s\"",
            "from_nodeid",
            "r->res_master_nodeid",
            "r->res_dir_nodeid",
            "r->res_first_lkid",
            "r->res_name"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_rsb",
          "args": [
            "r"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "172-179",
          "snippet": "static void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"find_rsb keep from_nodeid %d master %d dir %d\"",
            "from_nodeid",
            "r->res_master_nodeid",
            "r->res_dir_nodeid"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_no_directory",
          "args": [
            "ls"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "705-708",
          "snippet": "static inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_NODIR\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_NODIR\t\t10\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int validate_master_nodeid(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t\t  int from_nodeid)\n{\n\tif (dlm_no_directory(ls)) {\n\t\tlog_error(ls, \"find_rsb keep from_nodeid %d master %d dir %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\treturn -ENOTBLK;\n\t}\n\n\tif (from_nodeid != r->res_dir_nodeid) {\n\t\t/* our rsb is not master, and another node (not the dir node)\n\t   \t   has sent us a request.  this is much more common when our\n\t   \t   master_nodeid is zero, so limit debug to non-zero.  */\n\n\t\tif (r->res_master_nodeid) {\n\t\t\tlog_debug(ls, \"validate master from_other %d master %d \"\n\t\t\t\t  \"dir %d first %x %s\", from_nodeid,\n\t\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t\t  r->res_first_lkid, r->res_name);\n\t\t}\n\t\treturn -ENOTBLK;\n\t} else {\n\t\t/* our rsb is not master, but the dir nodeid has sent us a\n\t   \t   request; this could happen with master 0 / res_nodeid -1 */\n\n\t\tif (r->res_master_nodeid) {\n\t\t\tlog_error(ls, \"validate master from_dir %d master %d \"\n\t\t\t\t  \"first %x %s\",\n\t\t\t\t  from_nodeid, r->res_master_nodeid,\n\t\t\t\t  r->res_first_lkid, r->res_name);\n\t\t}\n\n\t\tr->res_master_nodeid = dlm_our_nodeid();\n\t\tr->res_nodeid = 0;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "find_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "818-838",
    "snippet": "static int find_rsb(struct dlm_ls *ls, char *name, int len, int from_nodeid,\n\t\t    unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tuint32_t hash, b;\n\tint dir_nodeid;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tif (dlm_no_directory(ls))\n\t\treturn find_rsb_nodir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n\telse\n\t\treturn find_rsb_dir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_rsb_dir",
          "args": [
            "ls",
            "name",
            "len",
            "hash",
            "b",
            "dir_nodeid",
            "from_nodeid",
            "flags",
            "r_ret"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "find_rsb_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "545-718",
          "snippet": "static int find_rsb_dir(struct dlm_ls *ls, char *name, int len,\n\t\t\tuint32_t hash, uint32_t b,\n\t\t\tint dir_nodeid, int from_nodeid,\n\t\t\tunsigned int flags, struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r = NULL;\n\tint our_nodeid = dlm_our_nodeid();\n\tint from_local = 0;\n\tint from_other = 0;\n\tint from_dir = 0;\n\tint create = 0;\n\tint error;\n\n\tif (flags & R_RECEIVE_REQUEST) {\n\t\tif (from_nodeid == dir_nodeid)\n\t\t\tfrom_dir = 1;\n\t\telse\n\t\t\tfrom_other = 1;\n\t} else if (flags & R_REQUEST) {\n\t\tfrom_local = 1;\n\t}\n\n\t/*\n\t * flags & R_RECEIVE_RECOVER is from dlm_recover_master_copy, so\n\t * from_nodeid has sent us a lock in dlm_recover_locks, believing\n\t * we're the new master.  Our local recovery may not have set\n\t * res_master_nodeid to our_nodeid yet, so allow either.  Don't\n\t * create the rsb; dlm_recover_process_copy() will handle EBADR\n\t * by resending.\n\t *\n\t * If someone sends us a request, we are the dir node, and we do\n\t * not find the rsb anywhere, then recreate it.  This happens if\n\t * someone sends us a request after we have removed/freed an rsb\n\t * from our toss list.  (They sent a request instead of lookup\n\t * because they are using an rsb from their toss list.)\n\t */\n\n\tif (from_local || from_dir ||\n\t    (from_other && (dir_nodeid == our_nodeid))) {\n\t\tcreate = 1;\n\t}\n\n retry:\n\tif (create) {\n\t\terror = pre_rsb_struct(ls);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (error)\n\t\tgoto do_toss;\n\t\n\t/*\n\t * rsb is active, so we can't check master_nodeid without lock_rsb.\n\t */\n\n\tkref_get(&r->res_ref);\n\terror = 0;\n\tgoto out_unlock;\n\n\n do_toss:\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto do_new;\n\n\t/*\n\t * rsb found inactive (master_nodeid may be out of date unless\n\t * we are the dir_nodeid or were the master)  No other thread\n\t * is using this rsb because it's on the toss list, so we can\n\t * look at or update res_master_nodeid without lock_rsb.\n\t */\n\n\tif ((r->res_master_nodeid != our_nodeid) && from_other) {\n\t\t/* our rsb was not master, and another node (not the dir node)\n\t\t   has sent us a request */\n\t\tlog_debug(ls, \"find_rsb toss from_other %d master %d dir %d %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, dir_nodeid,\n\t\t\t  r->res_name);\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif ((r->res_master_nodeid != our_nodeid) && from_dir) {\n\t\t/* don't think this should ever happen */\n\t\tlog_error(ls, \"find_rsb toss from_dir %d master %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\tdlm_print_rsb(r);\n\t\t/* fix it and go on */\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\trsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = 0;\n\t}\n\n\tif (from_local && (r->res_master_nodeid != our_nodeid)) {\n\t\t/* Because we have held no locks on this rsb,\n\t\t   res_master_nodeid could have become stale. */\n\t\trsb_set_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = 0;\n\t}\n\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n\tgoto out_unlock;\n\n\n do_new:\n\t/*\n\t * rsb not found\n\t */\n\n\tif (error == -EBADR && !create)\n\t\tgoto out_unlock;\n\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = dir_nodeid;\n\tkref_init(&r->res_ref);\n\n\tif (from_dir) {\n\t\t/* want to see how often this happens */\n\t\tlog_debug(ls, \"find_rsb new from_dir %d recreate %s\",\n\t\t\t  from_nodeid, r->res_name);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tgoto out_add;\n\t}\n\n\tif (from_other && (dir_nodeid != our_nodeid)) {\n\t\t/* should never happen */\n\t\tlog_error(ls, \"find_rsb new from_other %d dir %d our %d %s\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, r->res_name);\n\t\tdlm_free_rsb(r);\n\t\tr = NULL;\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif (from_other) {\n\t\tlog_debug(ls, \"find_rsb new from_other %d dir %d %s\",\n\t\t\t  from_nodeid, dir_nodeid, r->res_name);\n\t}\n\n\tif (dir_nodeid == our_nodeid) {\n\t\t/* When we are the dir nodeid, we can set the master\n\t\t   node immediately */\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t} else {\n\t\t/* set_master will send_lookup to dir_nodeid */\n\t\tr->res_master_nodeid = 0;\n\t\tr->res_nodeid = -1;\n\t}\n\n out_add:\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n out:\n\t*r_ret = r;\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int find_rsb_dir(struct dlm_ls *ls, char *name, int len,\n\t\t\tuint32_t hash, uint32_t b,\n\t\t\tint dir_nodeid, int from_nodeid,\n\t\t\tunsigned int flags, struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r = NULL;\n\tint our_nodeid = dlm_our_nodeid();\n\tint from_local = 0;\n\tint from_other = 0;\n\tint from_dir = 0;\n\tint create = 0;\n\tint error;\n\n\tif (flags & R_RECEIVE_REQUEST) {\n\t\tif (from_nodeid == dir_nodeid)\n\t\t\tfrom_dir = 1;\n\t\telse\n\t\t\tfrom_other = 1;\n\t} else if (flags & R_REQUEST) {\n\t\tfrom_local = 1;\n\t}\n\n\t/*\n\t * flags & R_RECEIVE_RECOVER is from dlm_recover_master_copy, so\n\t * from_nodeid has sent us a lock in dlm_recover_locks, believing\n\t * we're the new master.  Our local recovery may not have set\n\t * res_master_nodeid to our_nodeid yet, so allow either.  Don't\n\t * create the rsb; dlm_recover_process_copy() will handle EBADR\n\t * by resending.\n\t *\n\t * If someone sends us a request, we are the dir node, and we do\n\t * not find the rsb anywhere, then recreate it.  This happens if\n\t * someone sends us a request after we have removed/freed an rsb\n\t * from our toss list.  (They sent a request instead of lookup\n\t * because they are using an rsb from their toss list.)\n\t */\n\n\tif (from_local || from_dir ||\n\t    (from_other && (dir_nodeid == our_nodeid))) {\n\t\tcreate = 1;\n\t}\n\n retry:\n\tif (create) {\n\t\terror = pre_rsb_struct(ls);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (error)\n\t\tgoto do_toss;\n\t\n\t/*\n\t * rsb is active, so we can't check master_nodeid without lock_rsb.\n\t */\n\n\tkref_get(&r->res_ref);\n\terror = 0;\n\tgoto out_unlock;\n\n\n do_toss:\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto do_new;\n\n\t/*\n\t * rsb found inactive (master_nodeid may be out of date unless\n\t * we are the dir_nodeid or were the master)  No other thread\n\t * is using this rsb because it's on the toss list, so we can\n\t * look at or update res_master_nodeid without lock_rsb.\n\t */\n\n\tif ((r->res_master_nodeid != our_nodeid) && from_other) {\n\t\t/* our rsb was not master, and another node (not the dir node)\n\t\t   has sent us a request */\n\t\tlog_debug(ls, \"find_rsb toss from_other %d master %d dir %d %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, dir_nodeid,\n\t\t\t  r->res_name);\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif ((r->res_master_nodeid != our_nodeid) && from_dir) {\n\t\t/* don't think this should ever happen */\n\t\tlog_error(ls, \"find_rsb toss from_dir %d master %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\tdlm_print_rsb(r);\n\t\t/* fix it and go on */\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\trsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = 0;\n\t}\n\n\tif (from_local && (r->res_master_nodeid != our_nodeid)) {\n\t\t/* Because we have held no locks on this rsb,\n\t\t   res_master_nodeid could have become stale. */\n\t\trsb_set_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = 0;\n\t}\n\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n\tgoto out_unlock;\n\n\n do_new:\n\t/*\n\t * rsb not found\n\t */\n\n\tif (error == -EBADR && !create)\n\t\tgoto out_unlock;\n\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = dir_nodeid;\n\tkref_init(&r->res_ref);\n\n\tif (from_dir) {\n\t\t/* want to see how often this happens */\n\t\tlog_debug(ls, \"find_rsb new from_dir %d recreate %s\",\n\t\t\t  from_nodeid, r->res_name);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tgoto out_add;\n\t}\n\n\tif (from_other && (dir_nodeid != our_nodeid)) {\n\t\t/* should never happen */\n\t\tlog_error(ls, \"find_rsb new from_other %d dir %d our %d %s\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, r->res_name);\n\t\tdlm_free_rsb(r);\n\t\tr = NULL;\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif (from_other) {\n\t\tlog_debug(ls, \"find_rsb new from_other %d dir %d %s\",\n\t\t\t  from_nodeid, dir_nodeid, r->res_name);\n\t}\n\n\tif (dir_nodeid == our_nodeid) {\n\t\t/* When we are the dir nodeid, we can set the master\n\t\t   node immediately */\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t} else {\n\t\t/* set_master will send_lookup to dir_nodeid */\n\t\tr->res_master_nodeid = 0;\n\t\tr->res_nodeid = -1;\n\t}\n\n out_add:\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n out:\n\t*r_ret = r;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_rsb_nodir",
          "args": [
            "ls",
            "name",
            "len",
            "hash",
            "b",
            "dir_nodeid",
            "from_nodeid",
            "flags",
            "r_ret"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "find_rsb_nodir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "724-816",
          "snippet": "static int find_rsb_nodir(struct dlm_ls *ls, char *name, int len,\n\t\t\t  uint32_t hash, uint32_t b,\n\t\t\t  int dir_nodeid, int from_nodeid,\n\t\t\t  unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r = NULL;\n\tint our_nodeid = dlm_our_nodeid();\n\tint recover = (flags & R_RECEIVE_RECOVER);\n\tint error;\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\tgoto out;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (error)\n\t\tgoto do_toss;\n\n\t/*\n\t * rsb is active, so we can't check master_nodeid without lock_rsb.\n\t */\n\n\tkref_get(&r->res_ref);\n\tgoto out_unlock;\n\n\n do_toss:\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto do_new;\n\n\t/*\n\t * rsb found inactive. No other thread is using this rsb because\n\t * it's on the toss list, so we can look at or update\n\t * res_master_nodeid without lock_rsb.\n\t */\n\n\tif (!recover && (r->res_master_nodeid != our_nodeid) && from_nodeid) {\n\t\t/* our rsb is not master, and another node has sent us a\n\t\t   request; this should never happen */\n\t\tlog_error(ls, \"find_rsb toss from_nodeid %d master %d dir %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid, dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!recover && (r->res_master_nodeid != our_nodeid) &&\n\t    (dir_nodeid == our_nodeid)) {\n\t\t/* our rsb is not master, and we are dir; may as well fix it;\n\t\t   this should never happen */\n\t\tlog_error(ls, \"find_rsb toss our %d master %d dir %d\",\n\t\t\t  our_nodeid, r->res_master_nodeid, dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t}\n\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n\tgoto out_unlock;\n\n\n do_new:\n\t/*\n\t * rsb not found\n\t */\n\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = dir_nodeid;\n\tr->res_master_nodeid = dir_nodeid;\n\tr->res_nodeid = (dir_nodeid == our_nodeid) ? 0 : dir_nodeid;\n\tkref_init(&r->res_ref);\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n out:\n\t*r_ret = r;\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int find_rsb_nodir(struct dlm_ls *ls, char *name, int len,\n\t\t\t  uint32_t hash, uint32_t b,\n\t\t\t  int dir_nodeid, int from_nodeid,\n\t\t\t  unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r = NULL;\n\tint our_nodeid = dlm_our_nodeid();\n\tint recover = (flags & R_RECEIVE_RECOVER);\n\tint error;\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\tgoto out;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (error)\n\t\tgoto do_toss;\n\n\t/*\n\t * rsb is active, so we can't check master_nodeid without lock_rsb.\n\t */\n\n\tkref_get(&r->res_ref);\n\tgoto out_unlock;\n\n\n do_toss:\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto do_new;\n\n\t/*\n\t * rsb found inactive. No other thread is using this rsb because\n\t * it's on the toss list, so we can look at or update\n\t * res_master_nodeid without lock_rsb.\n\t */\n\n\tif (!recover && (r->res_master_nodeid != our_nodeid) && from_nodeid) {\n\t\t/* our rsb is not master, and another node has sent us a\n\t\t   request; this should never happen */\n\t\tlog_error(ls, \"find_rsb toss from_nodeid %d master %d dir %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid, dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!recover && (r->res_master_nodeid != our_nodeid) &&\n\t    (dir_nodeid == our_nodeid)) {\n\t\t/* our rsb is not master, and we are dir; may as well fix it;\n\t\t   this should never happen */\n\t\tlog_error(ls, \"find_rsb toss our %d master %d dir %d\",\n\t\t\t  our_nodeid, r->res_master_nodeid, dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t}\n\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n\tgoto out_unlock;\n\n\n do_new:\n\t/*\n\t * rsb not found\n\t */\n\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = dir_nodeid;\n\tr->res_master_nodeid = dir_nodeid;\n\tr->res_nodeid = (dir_nodeid == our_nodeid) ? 0 : dir_nodeid;\n\tkref_init(&r->res_ref);\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n out:\n\t*r_ret = r;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_no_directory",
          "args": [
            "ls"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "705-708",
          "snippet": "static inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_NODIR\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_NODIR\t\t10\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_hash2nodeid",
          "args": [
            "ls",
            "hash"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hash2nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "35-45",
          "snippet": "int dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "name",
            "len",
            "0"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int find_rsb(struct dlm_ls *ls, char *name, int len, int from_nodeid,\n\t\t    unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tuint32_t hash, b;\n\tint dir_nodeid;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tif (dlm_no_directory(ls))\n\t\treturn find_rsb_nodir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n\telse\n\t\treturn find_rsb_dir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n}"
  },
  {
    "function_name": "find_rsb_nodir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "724-816",
    "snippet": "static int find_rsb_nodir(struct dlm_ls *ls, char *name, int len,\n\t\t\t  uint32_t hash, uint32_t b,\n\t\t\t  int dir_nodeid, int from_nodeid,\n\t\t\t  unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r = NULL;\n\tint our_nodeid = dlm_our_nodeid();\n\tint recover = (flags & R_RECEIVE_RECOVER);\n\tint error;\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\tgoto out;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (error)\n\t\tgoto do_toss;\n\n\t/*\n\t * rsb is active, so we can't check master_nodeid without lock_rsb.\n\t */\n\n\tkref_get(&r->res_ref);\n\tgoto out_unlock;\n\n\n do_toss:\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto do_new;\n\n\t/*\n\t * rsb found inactive. No other thread is using this rsb because\n\t * it's on the toss list, so we can look at or update\n\t * res_master_nodeid without lock_rsb.\n\t */\n\n\tif (!recover && (r->res_master_nodeid != our_nodeid) && from_nodeid) {\n\t\t/* our rsb is not master, and another node has sent us a\n\t\t   request; this should never happen */\n\t\tlog_error(ls, \"find_rsb toss from_nodeid %d master %d dir %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid, dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!recover && (r->res_master_nodeid != our_nodeid) &&\n\t    (dir_nodeid == our_nodeid)) {\n\t\t/* our rsb is not master, and we are dir; may as well fix it;\n\t\t   this should never happen */\n\t\tlog_error(ls, \"find_rsb toss our %d master %d dir %d\",\n\t\t\t  our_nodeid, r->res_master_nodeid, dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t}\n\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n\tgoto out_unlock;\n\n\n do_new:\n\t/*\n\t * rsb not found\n\t */\n\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = dir_nodeid;\n\tr->res_master_nodeid = dir_nodeid;\n\tr->res_nodeid = (dir_nodeid == our_nodeid) ? 0 : dir_nodeid;\n\tkref_init(&r->res_ref);\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n out:\n\t*r_ret = r;\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[b].lock"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_insert",
          "args": [
            "r",
            "&ls->ls_rsbtbl[b].keep"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "472-499",
          "snippet": "static int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&r->res_ref"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rsb_struct",
          "args": [
            "ls",
            "name",
            "len",
            "&r"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "get_rsb_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "400-436",
          "snippet": "static int get_rsb_struct(struct dlm_ls *ls, char *name, int len,\n\t\t\t  struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r;\n\tint count;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (list_empty(&ls->ls_new_rsb)) {\n\t\tcount = ls->ls_new_rsb_count;\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\tlog_debug(ls, \"find_rsb retry %d %d %s\",\n\t\t\t  count, dlm_config.ci_new_rsb_count, name);\n\t\treturn -EAGAIN;\n\t}\n\n\tr = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb, res_hashchain);\n\tlist_del(&r->res_hashchain);\n\t/* Convert the empty list_head to a NULL rb_node for tree usage: */\n\tmemset(&r->res_hashnode, 0, sizeof(struct rb_node));\n\tls->ls_new_rsb_count--;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr->res_ls = ls;\n\tr->res_length = len;\n\tmemcpy(r->res_name, name, len);\n\tmutex_init(&r->res_mutex);\n\n\tINIT_LIST_HEAD(&r->res_lookup);\n\tINIT_LIST_HEAD(&r->res_grantqueue);\n\tINIT_LIST_HEAD(&r->res_convertqueue);\n\tINIT_LIST_HEAD(&r->res_waitqueue);\n\tINIT_LIST_HEAD(&r->res_root_list);\n\tINIT_LIST_HEAD(&r->res_recover_list);\n\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int get_rsb_struct(struct dlm_ls *ls, char *name, int len,\n\t\t\t  struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r;\n\tint count;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (list_empty(&ls->ls_new_rsb)) {\n\t\tcount = ls->ls_new_rsb_count;\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\tlog_debug(ls, \"find_rsb retry %d %d %s\",\n\t\t\t  count, dlm_config.ci_new_rsb_count, name);\n\t\treturn -EAGAIN;\n\t}\n\n\tr = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb, res_hashchain);\n\tlist_del(&r->res_hashchain);\n\t/* Convert the empty list_head to a NULL rb_node for tree usage: */\n\tmemset(&r->res_hashnode, 0, sizeof(struct rb_node));\n\tls->ls_new_rsb_count--;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr->res_ls = ls;\n\tr->res_length = len;\n\tmemcpy(r->res_name, name, len);\n\tmutex_init(&r->res_mutex);\n\n\tINIT_LIST_HEAD(&r->res_lookup);\n\tINIT_LIST_HEAD(&r->res_grantqueue);\n\tINIT_LIST_HEAD(&r->res_convertqueue);\n\tINIT_LIST_HEAD(&r->res_waitqueue);\n\tINIT_LIST_HEAD(&r->res_root_list);\n\tINIT_LIST_HEAD(&r->res_recover_list);\n\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&r->res_hashnode",
            "&ls->ls_rsbtbl[b].toss"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_rsb",
          "args": [
            "r"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "172-179",
          "snippet": "static void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"find_rsb toss our %d master %d dir %d\"",
            "our_nodeid",
            "r->res_master_nodeid",
            "dir_nodeid"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"find_rsb toss from_nodeid %d master %d dir %d\"",
            "from_nodeid",
            "r->res_master_nodeid",
            "dir_nodeid"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_search_rsb_tree",
          "args": [
            "&ls->ls_rsbtbl[b].toss",
            "name",
            "len",
            "&r"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_search_rsb_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "447-470",
          "snippet": "int dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&r->res_ref"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[b].lock"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pre_rsb_struct",
          "args": [
            "ls"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "pre_rsb_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "364-394",
          "snippet": "static int pre_rsb_struct(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r1, *r2;\n\tint count = 0;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (ls->ls_new_rsb_count > dlm_config.ci_new_rsb_count / 2) {\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr1 = dlm_allocate_rsb(ls);\n\tr2 = dlm_allocate_rsb(ls);\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (r1) {\n\t\tlist_add(&r1->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tif (r2) {\n\t\tlist_add(&r2->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tcount = ls->ls_new_rsb_count;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tif (!count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int pre_rsb_struct(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r1, *r2;\n\tint count = 0;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (ls->ls_new_rsb_count > dlm_config.ci_new_rsb_count / 2) {\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr1 = dlm_allocate_rsb(ls);\n\tr2 = dlm_allocate_rsb(ls);\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (r1) {\n\t\tlist_add(&r1->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tif (r2) {\n\t\tlist_add(&r2->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tcount = ls->ls_new_rsb_count;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tif (!count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int find_rsb_nodir(struct dlm_ls *ls, char *name, int len,\n\t\t\t  uint32_t hash, uint32_t b,\n\t\t\t  int dir_nodeid, int from_nodeid,\n\t\t\t  unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r = NULL;\n\tint our_nodeid = dlm_our_nodeid();\n\tint recover = (flags & R_RECEIVE_RECOVER);\n\tint error;\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\tgoto out;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (error)\n\t\tgoto do_toss;\n\n\t/*\n\t * rsb is active, so we can't check master_nodeid without lock_rsb.\n\t */\n\n\tkref_get(&r->res_ref);\n\tgoto out_unlock;\n\n\n do_toss:\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto do_new;\n\n\t/*\n\t * rsb found inactive. No other thread is using this rsb because\n\t * it's on the toss list, so we can look at or update\n\t * res_master_nodeid without lock_rsb.\n\t */\n\n\tif (!recover && (r->res_master_nodeid != our_nodeid) && from_nodeid) {\n\t\t/* our rsb is not master, and another node has sent us a\n\t\t   request; this should never happen */\n\t\tlog_error(ls, \"find_rsb toss from_nodeid %d master %d dir %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid, dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!recover && (r->res_master_nodeid != our_nodeid) &&\n\t    (dir_nodeid == our_nodeid)) {\n\t\t/* our rsb is not master, and we are dir; may as well fix it;\n\t\t   this should never happen */\n\t\tlog_error(ls, \"find_rsb toss our %d master %d dir %d\",\n\t\t\t  our_nodeid, r->res_master_nodeid, dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t}\n\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n\tgoto out_unlock;\n\n\n do_new:\n\t/*\n\t * rsb not found\n\t */\n\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = dir_nodeid;\n\tr->res_master_nodeid = dir_nodeid;\n\tr->res_nodeid = (dir_nodeid == our_nodeid) ? 0 : dir_nodeid;\n\tkref_init(&r->res_ref);\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n out:\n\t*r_ret = r;\n\treturn error;\n}"
  },
  {
    "function_name": "find_rsb_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "545-718",
    "snippet": "static int find_rsb_dir(struct dlm_ls *ls, char *name, int len,\n\t\t\tuint32_t hash, uint32_t b,\n\t\t\tint dir_nodeid, int from_nodeid,\n\t\t\tunsigned int flags, struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r = NULL;\n\tint our_nodeid = dlm_our_nodeid();\n\tint from_local = 0;\n\tint from_other = 0;\n\tint from_dir = 0;\n\tint create = 0;\n\tint error;\n\n\tif (flags & R_RECEIVE_REQUEST) {\n\t\tif (from_nodeid == dir_nodeid)\n\t\t\tfrom_dir = 1;\n\t\telse\n\t\t\tfrom_other = 1;\n\t} else if (flags & R_REQUEST) {\n\t\tfrom_local = 1;\n\t}\n\n\t/*\n\t * flags & R_RECEIVE_RECOVER is from dlm_recover_master_copy, so\n\t * from_nodeid has sent us a lock in dlm_recover_locks, believing\n\t * we're the new master.  Our local recovery may not have set\n\t * res_master_nodeid to our_nodeid yet, so allow either.  Don't\n\t * create the rsb; dlm_recover_process_copy() will handle EBADR\n\t * by resending.\n\t *\n\t * If someone sends us a request, we are the dir node, and we do\n\t * not find the rsb anywhere, then recreate it.  This happens if\n\t * someone sends us a request after we have removed/freed an rsb\n\t * from our toss list.  (They sent a request instead of lookup\n\t * because they are using an rsb from their toss list.)\n\t */\n\n\tif (from_local || from_dir ||\n\t    (from_other && (dir_nodeid == our_nodeid))) {\n\t\tcreate = 1;\n\t}\n\n retry:\n\tif (create) {\n\t\terror = pre_rsb_struct(ls);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (error)\n\t\tgoto do_toss;\n\t\n\t/*\n\t * rsb is active, so we can't check master_nodeid without lock_rsb.\n\t */\n\n\tkref_get(&r->res_ref);\n\terror = 0;\n\tgoto out_unlock;\n\n\n do_toss:\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto do_new;\n\n\t/*\n\t * rsb found inactive (master_nodeid may be out of date unless\n\t * we are the dir_nodeid or were the master)  No other thread\n\t * is using this rsb because it's on the toss list, so we can\n\t * look at or update res_master_nodeid without lock_rsb.\n\t */\n\n\tif ((r->res_master_nodeid != our_nodeid) && from_other) {\n\t\t/* our rsb was not master, and another node (not the dir node)\n\t\t   has sent us a request */\n\t\tlog_debug(ls, \"find_rsb toss from_other %d master %d dir %d %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, dir_nodeid,\n\t\t\t  r->res_name);\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif ((r->res_master_nodeid != our_nodeid) && from_dir) {\n\t\t/* don't think this should ever happen */\n\t\tlog_error(ls, \"find_rsb toss from_dir %d master %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\tdlm_print_rsb(r);\n\t\t/* fix it and go on */\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\trsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = 0;\n\t}\n\n\tif (from_local && (r->res_master_nodeid != our_nodeid)) {\n\t\t/* Because we have held no locks on this rsb,\n\t\t   res_master_nodeid could have become stale. */\n\t\trsb_set_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = 0;\n\t}\n\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n\tgoto out_unlock;\n\n\n do_new:\n\t/*\n\t * rsb not found\n\t */\n\n\tif (error == -EBADR && !create)\n\t\tgoto out_unlock;\n\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = dir_nodeid;\n\tkref_init(&r->res_ref);\n\n\tif (from_dir) {\n\t\t/* want to see how often this happens */\n\t\tlog_debug(ls, \"find_rsb new from_dir %d recreate %s\",\n\t\t\t  from_nodeid, r->res_name);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tgoto out_add;\n\t}\n\n\tif (from_other && (dir_nodeid != our_nodeid)) {\n\t\t/* should never happen */\n\t\tlog_error(ls, \"find_rsb new from_other %d dir %d our %d %s\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, r->res_name);\n\t\tdlm_free_rsb(r);\n\t\tr = NULL;\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif (from_other) {\n\t\tlog_debug(ls, \"find_rsb new from_other %d dir %d %s\",\n\t\t\t  from_nodeid, dir_nodeid, r->res_name);\n\t}\n\n\tif (dir_nodeid == our_nodeid) {\n\t\t/* When we are the dir nodeid, we can set the master\n\t\t   node immediately */\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t} else {\n\t\t/* set_master will send_lookup to dir_nodeid */\n\t\tr->res_master_nodeid = 0;\n\t\tr->res_nodeid = -1;\n\t}\n\n out_add:\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n out:\n\t*r_ret = r;\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[b].lock"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_insert",
          "args": [
            "r",
            "&ls->ls_rsbtbl[b].keep"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "472-499",
          "snippet": "static int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"find_rsb new from_other %d dir %d %s\"",
            "from_nodeid",
            "dir_nodeid",
            "r->res_name"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_free_rsb",
          "args": [
            "r"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "68-73",
          "snippet": "void dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rsb_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kmem_cache *rsb_cache;\n\nvoid dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"find_rsb new from_other %d dir %d our %d %s\"",
            "from_nodeid",
            "dir_nodeid",
            "our_nodeid",
            "r->res_name"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"find_rsb new from_dir %d recreate %s\"",
            "from_nodeid",
            "r->res_name"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&r->res_ref"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rsb_struct",
          "args": [
            "ls",
            "name",
            "len",
            "&r"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "get_rsb_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "400-436",
          "snippet": "static int get_rsb_struct(struct dlm_ls *ls, char *name, int len,\n\t\t\t  struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r;\n\tint count;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (list_empty(&ls->ls_new_rsb)) {\n\t\tcount = ls->ls_new_rsb_count;\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\tlog_debug(ls, \"find_rsb retry %d %d %s\",\n\t\t\t  count, dlm_config.ci_new_rsb_count, name);\n\t\treturn -EAGAIN;\n\t}\n\n\tr = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb, res_hashchain);\n\tlist_del(&r->res_hashchain);\n\t/* Convert the empty list_head to a NULL rb_node for tree usage: */\n\tmemset(&r->res_hashnode, 0, sizeof(struct rb_node));\n\tls->ls_new_rsb_count--;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr->res_ls = ls;\n\tr->res_length = len;\n\tmemcpy(r->res_name, name, len);\n\tmutex_init(&r->res_mutex);\n\n\tINIT_LIST_HEAD(&r->res_lookup);\n\tINIT_LIST_HEAD(&r->res_grantqueue);\n\tINIT_LIST_HEAD(&r->res_convertqueue);\n\tINIT_LIST_HEAD(&r->res_waitqueue);\n\tINIT_LIST_HEAD(&r->res_root_list);\n\tINIT_LIST_HEAD(&r->res_recover_list);\n\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int get_rsb_struct(struct dlm_ls *ls, char *name, int len,\n\t\t\t  struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r;\n\tint count;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (list_empty(&ls->ls_new_rsb)) {\n\t\tcount = ls->ls_new_rsb_count;\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\tlog_debug(ls, \"find_rsb retry %d %d %s\",\n\t\t\t  count, dlm_config.ci_new_rsb_count, name);\n\t\treturn -EAGAIN;\n\t}\n\n\tr = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb, res_hashchain);\n\tlist_del(&r->res_hashchain);\n\t/* Convert the empty list_head to a NULL rb_node for tree usage: */\n\tmemset(&r->res_hashnode, 0, sizeof(struct rb_node));\n\tls->ls_new_rsb_count--;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr->res_ls = ls;\n\tr->res_length = len;\n\tmemcpy(r->res_name, name, len);\n\tmutex_init(&r->res_mutex);\n\n\tINIT_LIST_HEAD(&r->res_lookup);\n\tINIT_LIST_HEAD(&r->res_grantqueue);\n\tINIT_LIST_HEAD(&r->res_convertqueue);\n\tINIT_LIST_HEAD(&r->res_waitqueue);\n\tINIT_LIST_HEAD(&r->res_root_list);\n\tINIT_LIST_HEAD(&r->res_recover_list);\n\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&r->res_hashnode",
            "&ls->ls_rsbtbl[b].toss"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "r",
            "RSB_MASTER_UNCERTAIN"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_clear_flag",
          "args": [
            "r",
            "RSB_MASTER_UNCERTAIN"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_clear_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "353-356",
          "snippet": "static inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_rsb",
          "args": [
            "r"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "172-179",
          "snippet": "static void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"find_rsb toss from_dir %d master %d\"",
            "from_nodeid",
            "r->res_master_nodeid"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"find_rsb toss from_other %d master %d dir %d %s\"",
            "from_nodeid",
            "r->res_master_nodeid",
            "dir_nodeid",
            "r->res_name"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_search_rsb_tree",
          "args": [
            "&ls->ls_rsbtbl[b].toss",
            "name",
            "len",
            "&r"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_search_rsb_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "447-470",
          "snippet": "int dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&r->res_ref"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[b].lock"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pre_rsb_struct",
          "args": [
            "ls"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "pre_rsb_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "364-394",
          "snippet": "static int pre_rsb_struct(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r1, *r2;\n\tint count = 0;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (ls->ls_new_rsb_count > dlm_config.ci_new_rsb_count / 2) {\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr1 = dlm_allocate_rsb(ls);\n\tr2 = dlm_allocate_rsb(ls);\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (r1) {\n\t\tlist_add(&r1->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tif (r2) {\n\t\tlist_add(&r2->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tcount = ls->ls_new_rsb_count;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tif (!count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int pre_rsb_struct(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r1, *r2;\n\tint count = 0;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (ls->ls_new_rsb_count > dlm_config.ci_new_rsb_count / 2) {\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr1 = dlm_allocate_rsb(ls);\n\tr2 = dlm_allocate_rsb(ls);\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (r1) {\n\t\tlist_add(&r1->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tif (r2) {\n\t\tlist_add(&r2->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tcount = ls->ls_new_rsb_count;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tif (!count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int find_rsb_dir(struct dlm_ls *ls, char *name, int len,\n\t\t\tuint32_t hash, uint32_t b,\n\t\t\tint dir_nodeid, int from_nodeid,\n\t\t\tunsigned int flags, struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r = NULL;\n\tint our_nodeid = dlm_our_nodeid();\n\tint from_local = 0;\n\tint from_other = 0;\n\tint from_dir = 0;\n\tint create = 0;\n\tint error;\n\n\tif (flags & R_RECEIVE_REQUEST) {\n\t\tif (from_nodeid == dir_nodeid)\n\t\t\tfrom_dir = 1;\n\t\telse\n\t\t\tfrom_other = 1;\n\t} else if (flags & R_REQUEST) {\n\t\tfrom_local = 1;\n\t}\n\n\t/*\n\t * flags & R_RECEIVE_RECOVER is from dlm_recover_master_copy, so\n\t * from_nodeid has sent us a lock in dlm_recover_locks, believing\n\t * we're the new master.  Our local recovery may not have set\n\t * res_master_nodeid to our_nodeid yet, so allow either.  Don't\n\t * create the rsb; dlm_recover_process_copy() will handle EBADR\n\t * by resending.\n\t *\n\t * If someone sends us a request, we are the dir node, and we do\n\t * not find the rsb anywhere, then recreate it.  This happens if\n\t * someone sends us a request after we have removed/freed an rsb\n\t * from our toss list.  (They sent a request instead of lookup\n\t * because they are using an rsb from their toss list.)\n\t */\n\n\tif (from_local || from_dir ||\n\t    (from_other && (dir_nodeid == our_nodeid))) {\n\t\tcreate = 1;\n\t}\n\n retry:\n\tif (create) {\n\t\terror = pre_rsb_struct(ls);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (error)\n\t\tgoto do_toss;\n\t\n\t/*\n\t * rsb is active, so we can't check master_nodeid without lock_rsb.\n\t */\n\n\tkref_get(&r->res_ref);\n\terror = 0;\n\tgoto out_unlock;\n\n\n do_toss:\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto do_new;\n\n\t/*\n\t * rsb found inactive (master_nodeid may be out of date unless\n\t * we are the dir_nodeid or were the master)  No other thread\n\t * is using this rsb because it's on the toss list, so we can\n\t * look at or update res_master_nodeid without lock_rsb.\n\t */\n\n\tif ((r->res_master_nodeid != our_nodeid) && from_other) {\n\t\t/* our rsb was not master, and another node (not the dir node)\n\t\t   has sent us a request */\n\t\tlog_debug(ls, \"find_rsb toss from_other %d master %d dir %d %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, dir_nodeid,\n\t\t\t  r->res_name);\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif ((r->res_master_nodeid != our_nodeid) && from_dir) {\n\t\t/* don't think this should ever happen */\n\t\tlog_error(ls, \"find_rsb toss from_dir %d master %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\tdlm_print_rsb(r);\n\t\t/* fix it and go on */\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\trsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = 0;\n\t}\n\n\tif (from_local && (r->res_master_nodeid != our_nodeid)) {\n\t\t/* Because we have held no locks on this rsb,\n\t\t   res_master_nodeid could have become stale. */\n\t\trsb_set_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = 0;\n\t}\n\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n\tgoto out_unlock;\n\n\n do_new:\n\t/*\n\t * rsb not found\n\t */\n\n\tif (error == -EBADR && !create)\n\t\tgoto out_unlock;\n\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = dir_nodeid;\n\tkref_init(&r->res_ref);\n\n\tif (from_dir) {\n\t\t/* want to see how often this happens */\n\t\tlog_debug(ls, \"find_rsb new from_dir %d recreate %s\",\n\t\t\t  from_nodeid, r->res_name);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tgoto out_add;\n\t}\n\n\tif (from_other && (dir_nodeid != our_nodeid)) {\n\t\t/* should never happen */\n\t\tlog_error(ls, \"find_rsb new from_other %d dir %d our %d %s\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, r->res_name);\n\t\tdlm_free_rsb(r);\n\t\tr = NULL;\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif (from_other) {\n\t\tlog_debug(ls, \"find_rsb new from_other %d dir %d %s\",\n\t\t\t  from_nodeid, dir_nodeid, r->res_name);\n\t}\n\n\tif (dir_nodeid == our_nodeid) {\n\t\t/* When we are the dir nodeid, we can set the master\n\t\t   node immediately */\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t} else {\n\t\t/* set_master will send_lookup to dir_nodeid */\n\t\tr->res_master_nodeid = 0;\n\t\tr->res_nodeid = -1;\n\t}\n\n out_add:\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n out:\n\t*r_ret = r;\n\treturn error;\n}"
  },
  {
    "function_name": "rsb_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "472-499",
    "snippet": "static int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&rsb->res_hashnode",
            "tree"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&rsb->res_hashnode",
            "parent",
            "newn"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "cur"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"rsb_insert match\""
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsb_cmp",
          "args": [
            "cur",
            "rsb->res_name",
            "rsb->res_length"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "438-445",
          "snippet": "static int rsb_cmp(struct dlm_rsb *r, const char *name, int nlen)\n{\n\tchar maxname[DLM_RESNAME_MAXLEN];\n\n\tmemset(maxname, 0, DLM_RESNAME_MAXLEN);\n\tmemcpy(maxname, name, nlen);\n\treturn memcmp(r->res_name, maxname, DLM_RESNAME_MAXLEN);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int rsb_cmp(struct dlm_rsb *r, const char *name, int nlen)\n{\n\tchar maxname[DLM_RESNAME_MAXLEN];\n\n\tmemset(maxname, 0, DLM_RESNAME_MAXLEN);\n\tmemcpy(maxname, name, nlen);\n\treturn memcmp(r->res_name, maxname, DLM_RESNAME_MAXLEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*newn",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_search_rsb_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "447-470",
    "snippet": "int dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsb_cmp",
          "args": [
            "r",
            "name",
            "len"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "438-445",
          "snippet": "static int rsb_cmp(struct dlm_rsb *r, const char *name, int nlen)\n{\n\tchar maxname[DLM_RESNAME_MAXLEN];\n\n\tmemset(maxname, 0, DLM_RESNAME_MAXLEN);\n\tmemcpy(maxname, name, nlen);\n\treturn memcmp(r->res_name, maxname, DLM_RESNAME_MAXLEN);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int rsb_cmp(struct dlm_rsb *r, const char *name, int nlen)\n{\n\tchar maxname[DLM_RESNAME_MAXLEN];\n\n\tmemset(maxname, 0, DLM_RESNAME_MAXLEN);\n\tmemcpy(maxname, name, nlen);\n\treturn memcmp(r->res_name, maxname, DLM_RESNAME_MAXLEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}"
  },
  {
    "function_name": "rsb_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "438-445",
    "snippet": "static int rsb_cmp(struct dlm_rsb *r, const char *name, int nlen)\n{\n\tchar maxname[DLM_RESNAME_MAXLEN];\n\n\tmemset(maxname, 0, DLM_RESNAME_MAXLEN);\n\tmemcpy(maxname, name, nlen);\n\treturn memcmp(r->res_name, maxname, DLM_RESNAME_MAXLEN);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "r->res_name",
            "maxname",
            "DLM_RESNAME_MAXLEN"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "maxname",
            "name",
            "nlen"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "maxname",
            "0",
            "DLM_RESNAME_MAXLEN"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int rsb_cmp(struct dlm_rsb *r, const char *name, int nlen)\n{\n\tchar maxname[DLM_RESNAME_MAXLEN];\n\n\tmemset(maxname, 0, DLM_RESNAME_MAXLEN);\n\tmemcpy(maxname, name, nlen);\n\treturn memcmp(r->res_name, maxname, DLM_RESNAME_MAXLEN);\n}"
  },
  {
    "function_name": "get_rsb_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "400-436",
    "snippet": "static int get_rsb_struct(struct dlm_ls *ls, char *name, int len,\n\t\t\t  struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r;\n\tint count;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (list_empty(&ls->ls_new_rsb)) {\n\t\tcount = ls->ls_new_rsb_count;\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\tlog_debug(ls, \"find_rsb retry %d %d %s\",\n\t\t\t  count, dlm_config.ci_new_rsb_count, name);\n\t\treturn -EAGAIN;\n\t}\n\n\tr = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb, res_hashchain);\n\tlist_del(&r->res_hashchain);\n\t/* Convert the empty list_head to a NULL rb_node for tree usage: */\n\tmemset(&r->res_hashnode, 0, sizeof(struct rb_node));\n\tls->ls_new_rsb_count--;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr->res_ls = ls;\n\tr->res_length = len;\n\tmemcpy(r->res_name, name, len);\n\tmutex_init(&r->res_mutex);\n\n\tINIT_LIST_HEAD(&r->res_lookup);\n\tINIT_LIST_HEAD(&r->res_grantqueue);\n\tINIT_LIST_HEAD(&r->res_convertqueue);\n\tINIT_LIST_HEAD(&r->res_waitqueue);\n\tINIT_LIST_HEAD(&r->res_root_list);\n\tINIT_LIST_HEAD(&r->res_recover_list);\n\n\t*r_ret = r;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&r->res_recover_list"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&r->res_root_list"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&r->res_waitqueue"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&r->res_convertqueue"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&r->res_grantqueue"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&r->res_lookup"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&r->res_mutex"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r->res_name",
            "name",
            "len"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_new_rsb_spin"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&r->res_hashnode",
            "0",
            "sizeof(struct rb_node)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&r->res_hashchain"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ls->ls_new_rsb",
            "structdlm_rsb",
            "res_hashchain"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"find_rsb retry %d %d %s\"",
            "count",
            "dlm_config.ci_new_rsb_count",
            "name"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_new_rsb"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_new_rsb_spin"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic int get_rsb_struct(struct dlm_ls *ls, char *name, int len,\n\t\t\t  struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r;\n\tint count;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (list_empty(&ls->ls_new_rsb)) {\n\t\tcount = ls->ls_new_rsb_count;\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\tlog_debug(ls, \"find_rsb retry %d %d %s\",\n\t\t\t  count, dlm_config.ci_new_rsb_count, name);\n\t\treturn -EAGAIN;\n\t}\n\n\tr = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb, res_hashchain);\n\tlist_del(&r->res_hashchain);\n\t/* Convert the empty list_head to a NULL rb_node for tree usage: */\n\tmemset(&r->res_hashnode, 0, sizeof(struct rb_node));\n\tls->ls_new_rsb_count--;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr->res_ls = ls;\n\tr->res_length = len;\n\tmemcpy(r->res_name, name, len);\n\tmutex_init(&r->res_mutex);\n\n\tINIT_LIST_HEAD(&r->res_lookup);\n\tINIT_LIST_HEAD(&r->res_grantqueue);\n\tINIT_LIST_HEAD(&r->res_convertqueue);\n\tINIT_LIST_HEAD(&r->res_waitqueue);\n\tINIT_LIST_HEAD(&r->res_root_list);\n\tINIT_LIST_HEAD(&r->res_recover_list);\n\n\t*r_ret = r;\n\treturn 0;\n}"
  },
  {
    "function_name": "pre_rsb_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "364-394",
    "snippet": "static int pre_rsb_struct(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r1, *r2;\n\tint count = 0;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (ls->ls_new_rsb_count > dlm_config.ci_new_rsb_count / 2) {\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr1 = dlm_allocate_rsb(ls);\n\tr2 = dlm_allocate_rsb(ls);\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (r1) {\n\t\tlist_add(&r1->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tif (r2) {\n\t\tlist_add(&r2->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tcount = ls->ls_new_rsb_count;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tif (!count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_new_rsb_spin"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&r2->res_hashchain",
            "&ls->ls_new_rsb"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_new_rsb_spin"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_allocate_rsb",
          "args": [
            "ls"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_allocate_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "60-66",
          "snippet": "struct dlm_rsb *dlm_allocate_rsb(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\n\tr = kmem_cache_zalloc(rsb_cache, GFP_NOFS);\n\treturn r;\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rsb_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kmem_cache *rsb_cache;\n\nstruct dlm_rsb *dlm_allocate_rsb(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\n\tr = kmem_cache_zalloc(rsb_cache, GFP_NOFS);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int pre_rsb_struct(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r1, *r2;\n\tint count = 0;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (ls->ls_new_rsb_count > dlm_config.ci_new_rsb_count / 2) {\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr1 = dlm_allocate_rsb(ls);\n\tr2 = dlm_allocate_rsb(ls);\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (r1) {\n\t\tlist_add(&r1->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tif (r2) {\n\t\tlist_add(&r2->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tcount = ls->ls_new_rsb_count;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tif (!count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_put_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "359-362",
    "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rsb",
          "args": [
            "r"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
  },
  {
    "function_name": "put_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "349-357",
    "snippet": "static void put_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tuint32_t bucket = r->res_bucket;\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\tkref_put(&r->res_ref, toss_rsb);\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[bucket].lock"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&r->res_ref",
            "toss_rsb"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[bucket].lock"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void put_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tuint32_t bucket = r->res_bucket;\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\tkref_put(&r->res_ref, toss_rsb);\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n}"
  },
  {
    "function_name": "dlm_hold_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "341-344",
    "snippet": "void dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hold_rsb",
          "args": [
            "r"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "unhold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1145-1150",
          "snippet": "static void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}"
  },
  {
    "function_name": "hold_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "336-339",
    "snippet": "static inline void hold_rsb(struct dlm_rsb *r)\n{\n\tkref_get(&r->res_ref);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&r->res_ref"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic inline void hold_rsb(struct dlm_rsb *r)\n{\n\tkref_get(&r->res_ref);\n}"
  },
  {
    "function_name": "queue_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "320-327",
    "snippet": "static void queue_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rqmode)\n{\n\tif (is_master_copy(lkb)) {\n\t\tsend_bast(r, lkb, rqmode);\n\t} else {\n\t\tdlm_add_cb(lkb, DLM_CB_BAST, rqmode, 0, 0);\n\t}\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_add_cb",
          "args": [
            "lkb",
            "DLM_CB_BAST",
            "rqmode",
            "0",
            "0"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "175-211",
          "snippet": "void dlm_add_cb(struct dlm_lkb *lkb, uint32_t flags, int mode, int status,\n\t\tuint32_t sbflags)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t new_seq, prev_seq;\n\tint rv;\n\n\tspin_lock(&dlm_cb_seq_spin);\n\tnew_seq = ++dlm_cb_seq;\n\tspin_unlock(&dlm_cb_seq_spin);\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tdlm_user_add_ast(lkb, flags, mode, status, sbflags, new_seq);\n\t\treturn;\n\t}\n\n\tmutex_lock(&lkb->lkb_cb_mutex);\n\tprev_seq = lkb->lkb_callbacks[0].seq;\n\n\trv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, new_seq);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (!prev_seq) {\n\t\tkref_get(&lkb->lkb_ref);\n\n\t\tif (test_bit(LSFL_CB_DELAY, &ls->ls_flags)) {\n\t\t\tmutex_lock(&ls->ls_cb_mutex);\n\t\t\tlist_add(&lkb->lkb_cb_list, &ls->ls_cb_delay);\n\t\t\tmutex_unlock(&ls->ls_cb_mutex);\n\t\t} else {\n\t\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\t}\n\t}\n out:\n\tmutex_unlock(&lkb->lkb_cb_mutex);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t dlm_cb_seq;",
            "static DEFINE_SPINLOCK(dlm_cb_seq_spin);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nstatic uint64_t dlm_cb_seq;\nstatic DEFINE_SPINLOCK(dlm_cb_seq_spin);\n\nvoid dlm_add_cb(struct dlm_lkb *lkb, uint32_t flags, int mode, int status,\n\t\tuint32_t sbflags)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t new_seq, prev_seq;\n\tint rv;\n\n\tspin_lock(&dlm_cb_seq_spin);\n\tnew_seq = ++dlm_cb_seq;\n\tspin_unlock(&dlm_cb_seq_spin);\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tdlm_user_add_ast(lkb, flags, mode, status, sbflags, new_seq);\n\t\treturn;\n\t}\n\n\tmutex_lock(&lkb->lkb_cb_mutex);\n\tprev_seq = lkb->lkb_callbacks[0].seq;\n\n\trv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, new_seq);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (!prev_seq) {\n\t\tkref_get(&lkb->lkb_ref);\n\n\t\tif (test_bit(LSFL_CB_DELAY, &ls->ls_flags)) {\n\t\t\tmutex_lock(&ls->ls_cb_mutex);\n\t\t\tlist_add(&lkb->lkb_cb_list, &ls->ls_cb_delay);\n\t\t\tmutex_unlock(&ls->ls_cb_mutex);\n\t\t} else {\n\t\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\t}\n\t}\n out:\n\tmutex_unlock(&lkb->lkb_cb_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_bast",
          "args": [
            "r",
            "lkb",
            "rqmode"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "send_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3727-3746",
          "snippet": "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_BAST, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_bastmode = mode;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_BAST, &ms, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_bastmode = mode;\n\n\terror = send_message(mh, ms);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master_copy",
          "args": [
            "lkb"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rqmode)\n{\n\tif (is_master_copy(lkb)) {\n\t\tsend_bast(r, lkb, rqmode);\n\t} else {\n\t\tdlm_add_cb(lkb, DLM_CB_BAST, rqmode, 0, 0);\n\t}\n}"
  },
  {
    "function_name": "queue_cast_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "314-318",
    "snippet": "static inline void queue_cast_overlap(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tqueue_cast(r, lkb,\n\t\t   is_overlap_unlock(lkb) ? -DLM_EUNLOCK : -DLM_ECANCEL);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_cast",
          "args": [
            "r",
            "lkb",
            "is_overlap_unlock(lkb) ? -DLM_EUNLOCK : -DLM_ECANCEL"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "queue_cast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "290-312",
          "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_overlap_unlock",
          "args": [
            "lkb"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "is_overlap_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "274-277",
          "snippet": "static inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline void queue_cast_overlap(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tqueue_cast(r, lkb,\n\t\t   is_overlap_unlock(lkb) ? -DLM_EUNLOCK : -DLM_ECANCEL);\n}"
  },
  {
    "function_name": "queue_cast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "290-312",
    "snippet": "static void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_add_cb",
          "args": [
            "lkb",
            "DLM_CB_CAST",
            "lkb->lkb_grmode",
            "rv",
            "lkb->lkb_sbflags"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "175-211",
          "snippet": "void dlm_add_cb(struct dlm_lkb *lkb, uint32_t flags, int mode, int status,\n\t\tuint32_t sbflags)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t new_seq, prev_seq;\n\tint rv;\n\n\tspin_lock(&dlm_cb_seq_spin);\n\tnew_seq = ++dlm_cb_seq;\n\tspin_unlock(&dlm_cb_seq_spin);\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tdlm_user_add_ast(lkb, flags, mode, status, sbflags, new_seq);\n\t\treturn;\n\t}\n\n\tmutex_lock(&lkb->lkb_cb_mutex);\n\tprev_seq = lkb->lkb_callbacks[0].seq;\n\n\trv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, new_seq);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (!prev_seq) {\n\t\tkref_get(&lkb->lkb_ref);\n\n\t\tif (test_bit(LSFL_CB_DELAY, &ls->ls_flags)) {\n\t\t\tmutex_lock(&ls->ls_cb_mutex);\n\t\t\tlist_add(&lkb->lkb_cb_list, &ls->ls_cb_delay);\n\t\t\tmutex_unlock(&ls->ls_cb_mutex);\n\t\t} else {\n\t\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\t}\n\t}\n out:\n\tmutex_unlock(&lkb->lkb_cb_mutex);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t dlm_cb_seq;",
            "static DEFINE_SPINLOCK(dlm_cb_seq_spin);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nstatic uint64_t dlm_cb_seq;\nstatic DEFINE_SPINLOCK(dlm_cb_seq_spin);\n\nvoid dlm_add_cb(struct dlm_lkb *lkb, uint32_t flags, int mode, int status,\n\t\tuint32_t sbflags)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t new_seq, prev_seq;\n\tint rv;\n\n\tspin_lock(&dlm_cb_seq_spin);\n\tnew_seq = ++dlm_cb_seq;\n\tspin_unlock(&dlm_cb_seq_spin);\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tdlm_user_add_ast(lkb, flags, mode, status, sbflags, new_seq);\n\t\treturn;\n\t}\n\n\tmutex_lock(&lkb->lkb_cb_mutex);\n\tprev_seq = lkb->lkb_callbacks[0].seq;\n\n\trv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, new_seq);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (!prev_seq) {\n\t\tkref_get(&lkb->lkb_ref);\n\n\t\tif (test_bit(LSFL_CB_DELAY, &ls->ls_flags)) {\n\t\t\tmutex_lock(&ls->ls_cb_mutex);\n\t\t\tlist_add(&lkb->lkb_cb_list, &ls->ls_cb_delay);\n\t\t\tmutex_unlock(&ls->ls_cb_mutex);\n\t\t} else {\n\t\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\t}\n\t}\n out:\n\tmutex_unlock(&lkb->lkb_cb_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "lkb->lkb_lksb",
            "dlm_print_lkb(lkb);"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timeout",
          "args": [
            "lkb"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "del_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1839-1849",
          "snippet": "static void del_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tif (!list_empty(&lkb->lkb_time_list)) {\n\t\tlist_del_init(&lkb->lkb_time_list);\n\t\tunhold_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void del_timeout(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tif (!list_empty(&lkb->lkb_time_list)) {\n\t\tlist_del_init(&lkb->lkb_time_list);\n\t\tunhold_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_timeout_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master_copy",
          "args": [
            "lkb"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tdel_timeout(lkb);\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\t/* if the operation was a cancel, then return -DLM_ECANCEL, if a\n\t   timeout caused the cancel then return -ETIMEDOUT */\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\n\t\trv = -ETIMEDOUT;\n\t}\n\n\tif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\n\t\tlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\n\t\trv = -EDEADLK;\n\t}\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\n}"
  },
  {
    "function_name": "is_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "284-288",
    "snippet": "static inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\n\t\t\t\t  DLM_IFL_OVERLAP_CANCEL));\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\n\t\t\t\t  DLM_IFL_OVERLAP_CANCEL));\n}"
  },
  {
    "function_name": "is_overlap_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "279-282",
    "snippet": "static inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\n}"
  },
  {
    "function_name": "is_overlap_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "274-277",
    "snippet": "static inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\n}"
  },
  {
    "function_name": "down_conversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "269-272",
    "snippet": "static inline int down_conversion(struct dlm_lkb *lkb)\n{\n\treturn (!middle_conversion(lkb) && lkb->lkb_rqmode < lkb->lkb_grmode);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "middle_conversion",
          "args": [
            "lkb"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "middle_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "261-267",
          "snippet": "static inline int middle_conversion(struct dlm_lkb *lkb)\n{\n\tif ((lkb->lkb_grmode==DLM_LOCK_PR && lkb->lkb_rqmode==DLM_LOCK_CW) ||\n\t    (lkb->lkb_rqmode==DLM_LOCK_PR && lkb->lkb_grmode==DLM_LOCK_CW))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int middle_conversion(struct dlm_lkb *lkb)\n{\n\tif ((lkb->lkb_grmode==DLM_LOCK_PR && lkb->lkb_rqmode==DLM_LOCK_CW) ||\n\t    (lkb->lkb_rqmode==DLM_LOCK_PR && lkb->lkb_grmode==DLM_LOCK_CW))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int down_conversion(struct dlm_lkb *lkb)\n{\n\treturn (!middle_conversion(lkb) && lkb->lkb_rqmode < lkb->lkb_grmode);\n}"
  },
  {
    "function_name": "middle_conversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "261-267",
    "snippet": "static inline int middle_conversion(struct dlm_lkb *lkb)\n{\n\tif ((lkb->lkb_grmode==DLM_LOCK_PR && lkb->lkb_rqmode==DLM_LOCK_CW) ||\n\t    (lkb->lkb_rqmode==DLM_LOCK_PR && lkb->lkb_grmode==DLM_LOCK_CW))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int middle_conversion(struct dlm_lkb *lkb)\n{\n\tif ((lkb->lkb_grmode==DLM_LOCK_PR && lkb->lkb_rqmode==DLM_LOCK_CW) ||\n\t    (lkb->lkb_rqmode==DLM_LOCK_PR && lkb->lkb_grmode==DLM_LOCK_CW))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "is_master_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "256-259",
    "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
  },
  {
    "function_name": "is_process_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "251-254",
    "snippet": "static inline int is_process_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_nodeid && !(lkb->lkb_flags & DLM_IFL_MSTCPY));\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_process_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_nodeid && !(lkb->lkb_flags & DLM_IFL_MSTCPY));\n}"
  },
  {
    "function_name": "is_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "245-249",
    "snippet": "static inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "r->res_nodeid >= 0",
            "dlm_print_rsb(r);"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_rsb",
          "args": [
            "r"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "172-179",
          "snippet": "static void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}"
  },
  {
    "function_name": "is_granted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "240-243",
    "snippet": "static inline int is_granted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_status == DLM_LKSTS_GRANTED);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_granted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_status == DLM_LKSTS_GRANTED);\n}"
  },
  {
    "function_name": "is_altmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "235-238",
    "snippet": "static inline int is_altmode(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_ALTMODE);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_altmode(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_ALTMODE);\n}"
  },
  {
    "function_name": "is_demoted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "230-233",
    "snippet": "static inline int is_demoted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_DEMOTED);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_demoted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_sbflags & DLM_SBF_DEMOTED);\n}"
  },
  {
    "function_name": "force_blocking_asts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "225-228",
    "snippet": "static inline int force_blocking_asts(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_exflags & DLM_LKF_NOQUEUEBAST);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int force_blocking_asts(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_exflags & DLM_LKF_NOQUEUEBAST);\n}"
  },
  {
    "function_name": "can_be_queued",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "220-223",
    "snippet": "static inline int can_be_queued(struct dlm_lkb *lkb)\n{\n\treturn !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int can_be_queued(struct dlm_lkb *lkb)\n{\n\treturn !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);\n}"
  },
  {
    "function_name": "dlm_lock_recovery_try",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "215-218",
    "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&ls->ls_in_recovery"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
  },
  {
    "function_name": "dlm_unlock_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "210-213",
    "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_in_recovery"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
  },
  {
    "function_name": "dlm_lock_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "205-208",
    "snippet": "static inline void dlm_lock_recovery(struct dlm_ls *ls)\n{\n\tdown_read(&ls->ls_in_recovery);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ls->ls_in_recovery"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic inline void dlm_lock_recovery(struct dlm_ls *ls)\n{\n\tdown_read(&ls->ls_in_recovery);\n}"
  },
  {
    "function_name": "dlm_dump_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "181-201",
    "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_remove(struct dlm_rsb *r);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_waitqueue",
            "lkb_statequeue"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"rsb wait queue:\\n\""
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_convertqueue",
            "lkb_statequeue"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_grantqueue",
            "lkb_statequeue"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_lookup",
            "lkb_rsb_lookup"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&r->res_recover_list"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_rsb",
          "args": [
            "r"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "172-179",
          "snippet": "static void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
  },
  {
    "function_name": "dlm_print_rsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "172-179",
    "snippet": "static void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_remove(struct dlm_rsb *r);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\"",
            "r->res_nodeid",
            "r->res_master_nodeid",
            "r->res_dir_nodeid",
            "r->res_flags",
            "r->res_first_lkid",
            "r->res_recover_locks_count",
            "r->res_name"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nstatic void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}"
  },
  {
    "function_name": "dlm_print_lkb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "162-170",
    "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
      "static void del_timeout(struct dlm_lkb *lkb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\"",
            "lkb->lkb_nodeid",
            "lkb->lkb_id",
            "lkb->lkb_remid",
            "lkb->lkb_exflags",
            "lkb->lkb_flags",
            "lkb->lkb_status",
            "lkb->lkb_rqmode",
            "lkb->lkb_grmode",
            "lkb->lkb_wait_type",
            "lkb->lkb_wait_nodeid",
            "(unsigned long long)lkb->lkb_recover_seq"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
  },
  {
    "function_name": "dlm_modes_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
    "lines": "139-142",
    "snippet": "int dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"lock.h\"",
      "#include \"ast.h\"",
      "#include \"lockspace.h\"",
      "#include \"member.h\"",
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lowcomms.h\"",
      "#include \"memory.h\"",
      "#include <linux/dlm_device.h>",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};\n\nint dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}"
  }
]