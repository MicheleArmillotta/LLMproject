[
  {
    "function_name": "ext4_convert_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1981-2018",
    "snippet": "int ext4_convert_inline_data(struct inode *inode)\n{\n\tint error, needed_blocks;\n\thandle_t *handle;\n\tstruct ext4_iloc iloc;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\treturn 0;\n\t}\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\n\tiloc.bh = NULL;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\terror = PTR_ERR(handle);\n\t\tgoto out_free;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\terror = ext4_convert_inline_data_nolock(handle, inode, &iloc);\n\tup_write(&EXT4_I(inode)->xattr_sem);\nout:\n\text4_journal_stop(handle);\nout_free:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_convert_inline_data_nolock",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_convert_inline_data_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1159-1241",
          "snippet": "static int ext4_convert_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tint error;\n\tvoid *buf = NULL;\n\tstruct buffer_head *data_bh = NULL;\n\tstruct ext4_map_blocks map;\n\tint inline_size;\n\n\tinline_size = ext4_get_inline_size(inode);\n\tbuf = kmalloc(inline_size, GFP_NOFS);\n\tif (!buf) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = ext4_read_inline_data(inode, buf, inline_size, iloc);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * Make sure the inline directory entries pass checks before we try to\n\t * convert them, so that we avoid touching stuff that needs fsck.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = ext4_check_all_de(inode, iloc->bh,\n\t\t\t\t\tbuf + EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (error)\n\t\tgoto out;\n\n\tmap.m_lblk = 0;\n\tmap.m_len = 1;\n\tmap.m_flags = 0;\n\terror = ext4_map_blocks(handle, inode, &map, EXT4_GET_BLOCKS_CREATE);\n\tif (error < 0)\n\t\tgoto out_restore;\n\tif (!(map.m_flags & EXT4_MAP_MAPPED)) {\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\n\tdata_bh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (!data_bh) {\n\t\terror = -ENOMEM;\n\t\tgoto out_restore;\n\t}\n\n\tlock_buffer(data_bh);\n\terror = ext4_journal_get_create_access(handle, data_bh);\n\tif (error) {\n\t\tunlock_buffer(data_bh);\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\tmemset(data_bh->b_data, 0, inode->i_sb->s_blocksize);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmemcpy(data_bh->b_data, buf, inline_size);\n\t\tset_buffer_uptodate(data_bh);\n\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t   inode, data_bh);\n\t} else {\n\t\terror = ext4_finish_convert_inline_dir(handle, inode, data_bh,\n\t\t\t\t\t\t       buf, inline_size);\n\t}\n\n\tunlock_buffer(data_bh);\nout_restore:\n\tif (error)\n\t\text4_restore_inline_data(handle, inode, iloc, buf, inline_size);\n\nout:\n\tbrelse(data_bh);\n\tkfree(buf);\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nstatic int ext4_convert_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tint error;\n\tvoid *buf = NULL;\n\tstruct buffer_head *data_bh = NULL;\n\tstruct ext4_map_blocks map;\n\tint inline_size;\n\n\tinline_size = ext4_get_inline_size(inode);\n\tbuf = kmalloc(inline_size, GFP_NOFS);\n\tif (!buf) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = ext4_read_inline_data(inode, buf, inline_size, iloc);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * Make sure the inline directory entries pass checks before we try to\n\t * convert them, so that we avoid touching stuff that needs fsck.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = ext4_check_all_de(inode, iloc->bh,\n\t\t\t\t\tbuf + EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (error)\n\t\tgoto out;\n\n\tmap.m_lblk = 0;\n\tmap.m_len = 1;\n\tmap.m_flags = 0;\n\terror = ext4_map_blocks(handle, inode, &map, EXT4_GET_BLOCKS_CREATE);\n\tif (error < 0)\n\t\tgoto out_restore;\n\tif (!(map.m_flags & EXT4_MAP_MAPPED)) {\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\n\tdata_bh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (!data_bh) {\n\t\terror = -ENOMEM;\n\t\tgoto out_restore;\n\t}\n\n\tlock_buffer(data_bh);\n\terror = ext4_journal_get_create_access(handle, data_bh);\n\tif (error) {\n\t\tunlock_buffer(data_bh);\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\tmemset(data_bh->b_data, 0, inode->i_sb->s_blocksize);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmemcpy(data_bh->b_data, buf, inline_size);\n\t\tset_buffer_uptodate(data_bh);\n\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t   inode, data_bh);\n\t} else {\n\t\terror = ext4_finish_convert_inline_dir(handle, inode, data_bh,\n\t\t\t\t\t\t       buf, inline_size);\n\t}\n\n\tunlock_buffer(data_bh);\nout_restore:\n\tif (error)\n\t\text4_restore_inline_data(handle, inode, iloc, buf, inline_size);\n\nout:\n\tbrelse(data_bh);\n\tkfree(buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_WRITE_PAGE",
            "needed_blocks"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4769-4780",
          "snippet": "int ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_convert_inline_data(struct inode *inode)\n{\n\tint error, needed_blocks;\n\thandle_t *handle;\n\tstruct ext4_iloc iloc;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\treturn 0;\n\t}\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\n\tiloc.bh = NULL;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\terror = PTR_ERR(handle);\n\t\tgoto out_free;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\terror = ext4_convert_inline_data_nolock(handle, inode, &iloc);\n\tup_write(&EXT4_I(inode)->xattr_sem);\nout:\n\text4_journal_stop(handle);\nout_free:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_inline_data_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1889-1979",
    "snippet": "void ext4_inline_data_truncate(struct inode *inode, int *has_inline)\n{\n\thandle_t *handle;\n\tint inline_size, value_len, needed_blocks;\n\tsize_t i_size;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, needed_blocks);\n\tif (IS_ERR(handle))\n\t\treturn;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\t*has_inline = 0;\n\t\text4_journal_stop(handle);\n\t\treturn;\n\t}\n\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out;\n\n\tif (ext4_get_inode_loc(inode, &is.iloc))\n\t\tgoto out;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\ti_size = inode->i_size;\n\tinline_size = ext4_get_inline_size(inode);\n\tEXT4_I(inode)->i_disksize = i_size;\n\n\tif (i_size < inline_size) {\n\t\t/* Clear the content in the xattr space. */\n\t\tif (inline_size > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\t\tif (ext4_xattr_ibody_find(inode, &i, &is))\n\t\t\t\tgoto out_error;\n\n\t\t\tBUG_ON(is.s.not_found);\n\n\t\t\tvalue_len = le32_to_cpu(is.s.here->e_value_size);\n\t\t\tvalue = kmalloc(value_len, GFP_NOFS);\n\t\t\tif (!value)\n\t\t\t\tgoto out_error;\n\n\t\t\tif (ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t\t\tvalue, value_len))\n\t\t\t\tgoto out_error;\n\n\t\t\ti.value = value;\n\t\t\ti.value_len = i_size > EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t\t\ti_size - EXT4_MIN_INLINE_DATA_SIZE : 0;\n\t\t\tif (ext4_xattr_ibody_inline_set(handle, inode, &i, &is))\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* Clear the content within i_blocks. */\n\t\tif (i_size < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\t\tvoid *p = (void *) ext4_raw_inode(&is.iloc)->i_block;\n\t\t\tmemset(p + i_size, 0,\n\t\t\t       EXT4_MIN_INLINE_DATA_SIZE - i_size);\n\t\t}\n\n\t\tEXT4_I(inode)->i_inline_size = i_size <\n\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE : i_size;\n\t}\n\nout_error:\n\tup_write(&EXT4_I(inode)->i_data_sem);\nout:\n\tbrelse(is.iloc.bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tkfree(value);\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\text4_journal_stop(handle);\n\treturn;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
      "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "inode"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "is.iloc.bh"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p + i_size",
            "0",
            "EXT4_MIN_INLINE_DATA_SIZE - i_size"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&is.iloc"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_inline_set",
          "args": [
            "handle",
            "inode",
            "&i",
            "&is"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_inline_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1011-1047",
          "snippet": "int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error) {\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_has_inline_data(inode)) {\n\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,\n\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_ibody_find(inode, i, is);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error) {\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_has_inline_data(inode)) {\n\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,\n\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_ibody_find(inode, i, is);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_get",
          "args": [
            "inode",
            "i.name_index",
            "i.name",
            "value",
            "value_len"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "326-367",
          "snippet": "int\next4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(entry, end, entry);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);",
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nint\next4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(entry, end, entry);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "value_len",
            "GFP_NOFS"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "is.s.here->e_value_size"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "is.s.not_found"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_find",
          "args": [
            "inode",
            "&i",
            "&is"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "981-1009",
          "snippet": "int ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "inode"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&is.iloc"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_INODE",
            "needed_blocks"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4769-4780",
          "snippet": "int ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nvoid ext4_inline_data_truncate(struct inode *inode, int *has_inline)\n{\n\thandle_t *handle;\n\tint inline_size, value_len, needed_blocks;\n\tsize_t i_size;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, needed_blocks);\n\tif (IS_ERR(handle))\n\t\treturn;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\t*has_inline = 0;\n\t\text4_journal_stop(handle);\n\t\treturn;\n\t}\n\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out;\n\n\tif (ext4_get_inode_loc(inode, &is.iloc))\n\t\tgoto out;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\ti_size = inode->i_size;\n\tinline_size = ext4_get_inline_size(inode);\n\tEXT4_I(inode)->i_disksize = i_size;\n\n\tif (i_size < inline_size) {\n\t\t/* Clear the content in the xattr space. */\n\t\tif (inline_size > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\t\tif (ext4_xattr_ibody_find(inode, &i, &is))\n\t\t\t\tgoto out_error;\n\n\t\t\tBUG_ON(is.s.not_found);\n\n\t\t\tvalue_len = le32_to_cpu(is.s.here->e_value_size);\n\t\t\tvalue = kmalloc(value_len, GFP_NOFS);\n\t\t\tif (!value)\n\t\t\t\tgoto out_error;\n\n\t\t\tif (ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t\t\tvalue, value_len))\n\t\t\t\tgoto out_error;\n\n\t\t\ti.value = value;\n\t\t\ti.value_len = i_size > EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t\t\ti_size - EXT4_MIN_INLINE_DATA_SIZE : 0;\n\t\t\tif (ext4_xattr_ibody_inline_set(handle, inode, &i, &is))\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* Clear the content within i_blocks. */\n\t\tif (i_size < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\t\tvoid *p = (void *) ext4_raw_inode(&is.iloc)->i_block;\n\t\t\tmemset(p + i_size, 0,\n\t\t\t       EXT4_MIN_INLINE_DATA_SIZE - i_size);\n\t\t}\n\n\t\tEXT4_I(inode)->i_inline_size = i_size <\n\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE : i_size;\n\t}\n\nout_error:\n\tup_write(&EXT4_I(inode)->i_data_sem);\nout:\n\tbrelse(is.iloc.bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tkfree(value);\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\text4_journal_stop(handle);\n\treturn;\n}"
  },
  {
    "function_name": "ext4_try_to_evict_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1861-1887",
    "snippet": "int ext4_try_to_evict_inline_data(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  int needed)\n{\n\tint error;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tif (EXT4_XATTR_LEN(entry->e_name_len) +\n\t    EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)) < needed) {\n\t\terror = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\terror = ext4_convert_inline_data_nolock(handle, inode, &iloc);\nout:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_convert_inline_data_nolock",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_convert_inline_data_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1159-1241",
          "snippet": "static int ext4_convert_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tint error;\n\tvoid *buf = NULL;\n\tstruct buffer_head *data_bh = NULL;\n\tstruct ext4_map_blocks map;\n\tint inline_size;\n\n\tinline_size = ext4_get_inline_size(inode);\n\tbuf = kmalloc(inline_size, GFP_NOFS);\n\tif (!buf) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = ext4_read_inline_data(inode, buf, inline_size, iloc);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * Make sure the inline directory entries pass checks before we try to\n\t * convert them, so that we avoid touching stuff that needs fsck.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = ext4_check_all_de(inode, iloc->bh,\n\t\t\t\t\tbuf + EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (error)\n\t\tgoto out;\n\n\tmap.m_lblk = 0;\n\tmap.m_len = 1;\n\tmap.m_flags = 0;\n\terror = ext4_map_blocks(handle, inode, &map, EXT4_GET_BLOCKS_CREATE);\n\tif (error < 0)\n\t\tgoto out_restore;\n\tif (!(map.m_flags & EXT4_MAP_MAPPED)) {\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\n\tdata_bh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (!data_bh) {\n\t\terror = -ENOMEM;\n\t\tgoto out_restore;\n\t}\n\n\tlock_buffer(data_bh);\n\terror = ext4_journal_get_create_access(handle, data_bh);\n\tif (error) {\n\t\tunlock_buffer(data_bh);\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\tmemset(data_bh->b_data, 0, inode->i_sb->s_blocksize);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmemcpy(data_bh->b_data, buf, inline_size);\n\t\tset_buffer_uptodate(data_bh);\n\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t   inode, data_bh);\n\t} else {\n\t\terror = ext4_finish_convert_inline_dir(handle, inode, data_bh,\n\t\t\t\t\t\t       buf, inline_size);\n\t}\n\n\tunlock_buffer(data_bh);\nout_restore:\n\tif (error)\n\t\text4_restore_inline_data(handle, inode, iloc, buf, inline_size);\n\nout:\n\tbrelse(data_bh);\n\tkfree(buf);\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nstatic int ext4_convert_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tint error;\n\tvoid *buf = NULL;\n\tstruct buffer_head *data_bh = NULL;\n\tstruct ext4_map_blocks map;\n\tint inline_size;\n\n\tinline_size = ext4_get_inline_size(inode);\n\tbuf = kmalloc(inline_size, GFP_NOFS);\n\tif (!buf) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = ext4_read_inline_data(inode, buf, inline_size, iloc);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * Make sure the inline directory entries pass checks before we try to\n\t * convert them, so that we avoid touching stuff that needs fsck.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = ext4_check_all_de(inode, iloc->bh,\n\t\t\t\t\tbuf + EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (error)\n\t\tgoto out;\n\n\tmap.m_lblk = 0;\n\tmap.m_len = 1;\n\tmap.m_flags = 0;\n\terror = ext4_map_blocks(handle, inode, &map, EXT4_GET_BLOCKS_CREATE);\n\tif (error < 0)\n\t\tgoto out_restore;\n\tif (!(map.m_flags & EXT4_MAP_MAPPED)) {\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\n\tdata_bh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (!data_bh) {\n\t\terror = -ENOMEM;\n\t\tgoto out_restore;\n\t}\n\n\tlock_buffer(data_bh);\n\terror = ext4_journal_get_create_access(handle, data_bh);\n\tif (error) {\n\t\tunlock_buffer(data_bh);\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\tmemset(data_bh->b_data, 0, inode->i_sb->s_blocksize);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmemcpy(data_bh->b_data, buf, inline_size);\n\t\tset_buffer_uptodate(data_bh);\n\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t   inode, data_bh);\n\t} else {\n\t\terror = ext4_finish_convert_inline_dir(handle, inode, data_bh,\n\t\t\t\t\t\t       buf, inline_size);\n\t}\n\n\tunlock_buffer(data_bh);\nout_restore:\n\tif (error)\n\t\text4_restore_inline_data(handle, inode, iloc, buf, inline_size);\n\nout:\n\tbrelse(data_bh);\n\tkfree(buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "le32_to_cpu(entry->e_value_size)"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "entry->e_name_len"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_try_to_evict_inline_data(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  int needed)\n{\n\tint error;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tif (EXT4_XATTR_LEN(entry->e_name_len) +\n\t    EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)) < needed) {\n\t\terror = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\terror = ext4_convert_inline_data_nolock(handle, inode, &iloc);\nout:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_inline_data_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1812-1851",
    "snippet": "int ext4_inline_data_fiemap(struct inode *inode,\n\t\t\t    struct fiemap_extent_info *fieinfo,\n\t\t\t    int *has_inline, __u64 start, __u64 len)\n{\n\t__u64 physical = 0;\n\t__u64 inline_len;\n\t__u32 flags = FIEMAP_EXTENT_DATA_INLINE | FIEMAP_EXTENT_NOT_ALIGNED |\n\t\tFIEMAP_EXTENT_LAST;\n\tint error = 0;\n\tstruct ext4_iloc iloc;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\t*has_inline = 0;\n\t\tgoto out;\n\t}\n\tinline_len = min_t(size_t, ext4_get_inline_size(inode),\n\t\t\t   i_size_read(inode));\n\tif (start >= inline_len)\n\t\tgoto out;\n\tif (start + len < inline_len)\n\t\tinline_len = start + len;\n\tinline_len -= start;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\tgoto out;\n\n\tphysical = (__u64)iloc.bh->b_blocknr << inode->i_sb->s_blocksize_bits;\n\tphysical += (char *)ext4_raw_inode(&iloc) - iloc.bh->b_data;\n\tphysical += offsetof(struct ext4_inode, i_block);\n\n\tif (physical)\n\t\terror = fiemap_fill_next_extent(fieinfo, start, physical,\n\t\t\t\t\t\tinline_len, flags);\n\tbrelse(iloc.bh);\nout:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn (error < 0 ? error : 0);\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fiemap_fill_next_extent",
          "args": [
            "fieinfo",
            "start",
            "physical",
            "inline_len",
            "flags"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_fill_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "85-121",
          "snippet": "int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [
            "#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)",
            "#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)",
            "#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "ext4_get_inline_size(inode)",
            "i_size_read(inode)"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "inode"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_inline_data_fiemap(struct inode *inode,\n\t\t\t    struct fiemap_extent_info *fieinfo,\n\t\t\t    int *has_inline, __u64 start, __u64 len)\n{\n\t__u64 physical = 0;\n\t__u64 inline_len;\n\t__u32 flags = FIEMAP_EXTENT_DATA_INLINE | FIEMAP_EXTENT_NOT_ALIGNED |\n\t\tFIEMAP_EXTENT_LAST;\n\tint error = 0;\n\tstruct ext4_iloc iloc;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\t*has_inline = 0;\n\t\tgoto out;\n\t}\n\tinline_len = min_t(size_t, ext4_get_inline_size(inode),\n\t\t\t   i_size_read(inode));\n\tif (start >= inline_len)\n\t\tgoto out;\n\tif (start + len < inline_len)\n\t\tinline_len = start + len;\n\tinline_len -= start;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\tgoto out;\n\n\tphysical = (__u64)iloc.bh->b_blocknr << inode->i_sb->s_blocksize_bits;\n\tphysical += (char *)ext4_raw_inode(&iloc) - iloc.bh->b_data;\n\tphysical += offsetof(struct ext4_inode, i_block);\n\n\tif (physical)\n\t\terror = fiemap_fill_next_extent(fieinfo, start, physical,\n\t\t\t\t\t\tinline_len, flags);\n\tbrelse(iloc.bh);\nout:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn (error < 0 ? error : 0);\n}"
  },
  {
    "function_name": "ext4_destroy_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1801-1810",
    "snippet": "int ext4_destroy_inline_data(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tret = ext4_destroy_inline_data_nolock(handle, inode);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_destroy_inline_data_nolock",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_destroy_inline_data_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "397-456",
          "snippet": "static int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_destroy_inline_data(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tret = ext4_destroy_inline_data_nolock(handle, inode);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "empty_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1740-1799",
    "snippet": "int empty_inline_dir(struct inode *dir, int *has_inline_data)\n{\n\tint err, inline_size;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_pos;\n\tunsigned int offset;\n\tstruct ext4_dir_entry_2 *de;\n\tint ret = 1;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err) {\n\t\tEXT4_ERROR_INODE(dir, \"error %d getting inode %lu block\",\n\t\t\t\t err, dir->i_ino);\n\t\treturn 1;\n\t}\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tif (!le32_to_cpu(de->inode)) {\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"bad inline directory (dir #%lu) - no `..'\",\n\t\t\t     dir->i_ino);\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\toffset = EXT4_INLINE_DOTDOT_SIZE;\n\twhile (offset < dir->i_size) {\n\t\tde = ext4_get_inline_entry(dir, &iloc, offset,\n\t\t\t\t\t   &inline_pos, &inline_size);\n\t\tif (ext4_check_dir_entry(dir, NULL, de,\n\t\t\t\t\t iloc.bh, inline_pos,\n\t\t\t\t\t inline_size, offset)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"bad inline directory (dir #%lu) - \"\n\t\t\t\t     \"inode %u, rec_len %u, name_len %d\"\n\t\t\t\t     \"inline size %d\\n\",\n\t\t\t\t     dir->i_ino, le32_to_cpu(de->inode),\n\t\t\t\t     le16_to_cpu(de->rec_len), de->name_len,\n\t\t\t\t     inline_size);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t}\n\nout:\n\tup_read(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_INLINE_DOTDOT_SIZE\t\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(dir)->xattr_sem"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "dir"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "inline_size"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "dir->i_sb",
            "\"bad inline directory (dir #%lu) - \"\n\t\t\t\t     \"inode %u, rec_len %u, name_len %d\"\n\t\t\t\t     \"inline size %d\\n\"",
            "dir->i_ino",
            "le32_to_cpu(de->inode)",
            "le16_to_cpu(de->rec_len)",
            "de->name_len",
            "inline_size"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "dir",
            "NULL",
            "de",
            "iloc.bh",
            "inline_pos",
            "inline_size",
            "offset"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_entry",
          "args": [
            "dir",
            "&iloc",
            "offset",
            "&inline_pos",
            "&inline_size"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1714-1738",
          "snippet": "static inline struct ext4_dir_entry_2 *\next4_get_inline_entry(struct inode *inode,\n\t\t      struct ext4_iloc *iloc,\n\t\t      unsigned int offset,\n\t\t      void **inline_start,\n\t\t      int *inline_size)\n{\n\tvoid *inline_pos;\n\n\tBUG_ON(offset > ext4_get_inline_size(inode));\n\n\tif (offset < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tinline_pos = (void *)ext4_raw_inode(iloc)->i_block;\n\t\t*inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tinline_pos = ext4_get_inline_xattr_pos(inode, iloc);\n\t\toffset -= EXT4_MIN_INLINE_DATA_SIZE;\n\t\t*inline_size = ext4_get_inline_size(inode) -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tif (inline_start)\n\t\t*inline_start = inline_pos;\n\treturn (struct ext4_dir_entry_2 *)(inline_pos + offset);\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstatic inline struct ext4_dir_entry_2 *\next4_get_inline_entry(struct inode *inode,\n\t\t      struct ext4_iloc *iloc,\n\t\t      unsigned int offset,\n\t\t      void **inline_start,\n\t\t      int *inline_size)\n{\n\tvoid *inline_pos;\n\n\tBUG_ON(offset > ext4_get_inline_size(inode));\n\n\tif (offset < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tinline_pos = (void *)ext4_raw_inode(iloc)->i_block;\n\t\t*inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tinline_pos = ext4_get_inline_xattr_pos(inode, iloc);\n\t\toffset -= EXT4_MIN_INLINE_DATA_SIZE;\n\t\t*inline_size = ext4_get_inline_size(inode) -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tif (inline_start)\n\t\t*inline_start = inline_pos;\n\treturn (struct ext4_dir_entry_2 *)(inline_pos + offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "dir->i_sb",
            "\"bad inline directory (dir #%lu) - no `..'\"",
            "dir->i_ino"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "dir"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(dir)->xattr_sem"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "dir",
            "\"error %d getting inode %lu block\"",
            "err",
            "dir->i_ino"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "dir",
            "&iloc"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nint empty_inline_dir(struct inode *dir, int *has_inline_data)\n{\n\tint err, inline_size;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_pos;\n\tunsigned int offset;\n\tstruct ext4_dir_entry_2 *de;\n\tint ret = 1;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err) {\n\t\tEXT4_ERROR_INODE(dir, \"error %d getting inode %lu block\",\n\t\t\t\t err, dir->i_ino);\n\t\treturn 1;\n\t}\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tif (!le32_to_cpu(de->inode)) {\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"bad inline directory (dir #%lu) - no `..'\",\n\t\t\t     dir->i_ino);\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\toffset = EXT4_INLINE_DOTDOT_SIZE;\n\twhile (offset < dir->i_size) {\n\t\tde = ext4_get_inline_entry(dir, &iloc, offset,\n\t\t\t\t\t   &inline_pos, &inline_size);\n\t\tif (ext4_check_dir_entry(dir, NULL, de,\n\t\t\t\t\t iloc.bh, inline_pos,\n\t\t\t\t\t inline_size, offset)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"bad inline directory (dir #%lu) - \"\n\t\t\t\t     \"inode %u, rec_len %u, name_len %d\"\n\t\t\t\t     \"inline size %d\\n\",\n\t\t\t\t     dir->i_ino, le32_to_cpu(de->inode),\n\t\t\t\t     le16_to_cpu(de->rec_len), de->name_len,\n\t\t\t\t     inline_size);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t}\n\nout:\n\tup_read(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_get_inline_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1714-1738",
    "snippet": "static inline struct ext4_dir_entry_2 *\next4_get_inline_entry(struct inode *inode,\n\t\t      struct ext4_iloc *iloc,\n\t\t      unsigned int offset,\n\t\t      void **inline_start,\n\t\t      int *inline_size)\n{\n\tvoid *inline_pos;\n\n\tBUG_ON(offset > ext4_get_inline_size(inode));\n\n\tif (offset < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tinline_pos = (void *)ext4_raw_inode(iloc)->i_block;\n\t\t*inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tinline_pos = ext4_get_inline_xattr_pos(inode, iloc);\n\t\toffset -= EXT4_MIN_INLINE_DATA_SIZE;\n\t\t*inline_size = ext4_get_inline_size(inode) -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tif (inline_start)\n\t\t*inline_start = inline_pos;\n\treturn (struct ext4_dir_entry_2 *)(inline_pos + offset);\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "inode"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_xattr_pos",
          "args": [
            "inode",
            "iloc"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_xattr_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1039-1052",
          "snippet": "static void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "iloc"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset > ext4_get_inline_size(inode)"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstatic inline struct ext4_dir_entry_2 *\next4_get_inline_entry(struct inode *inode,\n\t\t      struct ext4_iloc *iloc,\n\t\t      unsigned int offset,\n\t\t      void **inline_start,\n\t\t      int *inline_size)\n{\n\tvoid *inline_pos;\n\n\tBUG_ON(offset > ext4_get_inline_size(inode));\n\n\tif (offset < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tinline_pos = (void *)ext4_raw_inode(iloc)->i_block;\n\t\t*inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tinline_pos = ext4_get_inline_xattr_pos(inode, iloc);\n\t\toffset -= EXT4_MIN_INLINE_DATA_SIZE;\n\t\t*inline_size = ext4_get_inline_size(inode) -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tif (inline_start)\n\t\t*inline_start = inline_pos;\n\treturn (struct ext4_dir_entry_2 *)(inline_pos + offset);\n}"
  },
  {
    "function_name": "ext4_delete_inline_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1655-1709",
    "snippet": "int ext4_delete_inline_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     int *has_inline_data)\n{\n\tint err, inline_size;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_start;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tif ((void *)de_del - ((void *)ext4_raw_inode(&iloc)->i_block) <\n\t\tEXT4_MIN_INLINE_DATA_SIZE) {\n\t\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\t\tinline_size = EXT4_MIN_INLINE_DATA_SIZE -\n\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\t} else {\n\t\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\t\tinline_size = ext4_get_inline_size(dir) -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del, bh,\n\t\t\t\t\tinline_start, inline_size, 0);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_mark_inode_dirty(handle, dir);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\text4_show_inline_dir(dir, iloc.bh, inline_start, inline_size);\nout:\n\tup_write(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_INLINE_DOTDOT_SIZE\t\t4",
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "dir->i_sb",
            "err"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(dir)->xattr_sem"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "dir"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_show_inline_dir",
          "args": [
            "dir",
            "iloc.bh",
            "inline_start",
            "inline_size"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_show_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "963-985",
          "snippet": "void ext4_show_inline_dir(struct inode *dir, struct buffer_head *bh,\n\t\t\t  void *inline_start, int inline_size)\n{\n\tint offset;\n\tunsigned short de_len;\n\tstruct ext4_dir_entry_2 *de = inline_start;\n\tvoid *dlimit = inline_start + inline_size;\n\n\ttrace_printk(\"inode %lu\\n\", dir->i_ino);\n\toffset = 0;\n\twhile ((void *)de < dlimit) {\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\ttrace_printk(\"de: off %u rlen %u name %*.s nlen %u ino %u\\n\",\n\t\t\t     offset, de_len, de->name_len, de->name,\n\t\t\t     de->name_len, le32_to_cpu(de->inode));\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t inline_start, inline_size, offset))\n\t\t\tBUG();\n\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_show_inline_dir(struct inode *dir, struct buffer_head *bh,\n\t\t\t  void *inline_start, int inline_size)\n{\n\tint offset;\n\tunsigned short de_len;\n\tstruct ext4_dir_entry_2 *de = inline_start;\n\tvoid *dlimit = inline_start + inline_size;\n\n\ttrace_printk(\"inode %lu\\n\", dir->i_ino);\n\toffset = 0;\n\twhile ((void *)de < dlimit) {\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\ttrace_printk(\"de: off %u rlen %u name %*.s nlen %u ino %u\\n\",\n\t\t\t     offset, de_len, de->name_len, de->name,\n\t\t\t     de->name_len, le32_to_cpu(de->inode));\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t inline_start, inline_size, offset))\n\t\t\tBUG();\n\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_generic_delete_entry",
          "args": [
            "handle",
            "dir",
            "de_del",
            "bh",
            "inline_start",
            "inline_size",
            "0"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_generic_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2088-2125",
          "snippet": "int ext4_generic_delete_entry(handle_t *handle,\n\t\t\t      struct inode *dir,\n\t\t\t      struct ext4_dir_entry_2 *de_del,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *entry_buf,\n\t\t\t      int buf_size,\n\t\t\t      int csum_size)\n{\n\tstruct ext4_dir_entry_2 *de, *pde;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext4_dir_entry_2 *)entry_buf;\n\twhile (i < buf_size - csum_size) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\text4_rec_len_from_disk(pde->rec_len,\n\t\t\t\t\t\t\t       blocksize) +\n\t\t\t\t\text4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t       blocksize),\n\t\t\t\t\tblocksize);\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext4_rec_len_from_disk(de->rec_len, blocksize);\n\t\tpde = de;\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_generic_delete_entry(handle_t *handle,\n\t\t\t      struct inode *dir,\n\t\t\t      struct ext4_dir_entry_2 *de_del,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *entry_buf,\n\t\t\t      int buf_size,\n\t\t\t      int csum_size)\n{\n\tstruct ext4_dir_entry_2 *de, *pde;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext4_dir_entry_2 *)entry_buf;\n\twhile (i < buf_size - csum_size) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, i))\n\t\t\treturn -EIO;\n\t\tif (de == de_del)  {\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\text4_rec_len_from_disk(pde->rec_len,\n\t\t\t\t\t\t\t       blocksize) +\n\t\t\t\t\text4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t       blocksize),\n\t\t\t\t\tblocksize);\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tdir->i_version++;\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext4_rec_len_from_disk(de->rec_len, blocksize);\n\t\tpde = de;\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "dir"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_xattr_pos",
          "args": [
            "dir",
            "&iloc"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_xattr_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1039-1052",
          "snippet": "static void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "dir"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(dir)->xattr_sem"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "dir",
            "&iloc"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_delete_inline_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     int *has_inline_data)\n{\n\tint err, inline_size;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_start;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tif ((void *)de_del - ((void *)ext4_raw_inode(&iloc)->i_block) <\n\t\tEXT4_MIN_INLINE_DATA_SIZE) {\n\t\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\t\tinline_size = EXT4_MIN_INLINE_DATA_SIZE -\n\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\t} else {\n\t\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\t\tinline_size = ext4_get_inline_size(dir) -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(handle, dir, de_del, bh,\n\t\t\t\t\tinline_start, inline_size, 0);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_mark_inode_dirty(handle, dir);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\text4_show_inline_dir(dir, iloc.bh, inline_start, inline_size);\nout:\n\tup_write(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_find_inline_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1607-1653",
    "snippet": "struct buffer_head *ext4_find_inline_entry(struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *has_inline_data)\n{\n\tint ret;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_start;\n\tint inline_size;\n\n\tif (ext4_get_inode_loc(dir, &iloc))\n\t\treturn NULL;\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\tinline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\n\tret = search_dir(iloc.bh, inline_start, inline_size,\n\t\t\t dir, d_name, 0, res_dir);\n\tif (ret == 1)\n\t\tgoto out_find;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ext4_get_inline_size(dir) == EXT4_MIN_INLINE_DATA_SIZE)\n\t\tgoto out;\n\n\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\tinline_size = ext4_get_inline_size(dir) - EXT4_MIN_INLINE_DATA_SIZE;\n\n\tret = search_dir(iloc.bh, inline_start, inline_size,\n\t\t\t dir, d_name, 0, res_dir);\n\tif (ret == 1)\n\t\tgoto out_find;\n\nout:\n\tbrelse(iloc.bh);\n\tiloc.bh = NULL;\nout_find:\n\tup_read(&EXT4_I(dir)->xattr_sem);\n\treturn iloc.bh;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_INLINE_DOTDOT_SIZE\t\t4",
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(dir)->xattr_sem"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "dir"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_dir",
          "args": [
            "iloc.bh",
            "inline_start",
            "inline_size",
            "dir",
            "d_name",
            "0",
            "res_dir"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "search_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1122-1160",
          "snippet": "int search_dir(struct buffer_head *bh,\n\t       char *search_buf,\n\t       int buf_size,\n\t       struct inode *dir,\n\t       const struct qstr *d_name,\n\t       unsigned int offset,\n\t       struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct ext4_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = d_name->name;\n\tint namelen = d_name->len;\n\n\tde = (struct ext4_dir_entry_2 *)search_buf;\n\tdlimit = search_buf + buf_size;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext4_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (ext4_check_dir_entry(dir, NULL, de, bh, bh->b_data,\n\t\t\t\t\t\t bh->b_size, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tconst struct qstr *d_name,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint search_dir(struct buffer_head *bh,\n\t       char *search_buf,\n\t       int buf_size,\n\t       struct inode *dir,\n\t       const struct qstr *d_name,\n\t       unsigned int offset,\n\t       struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct ext4_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\tconst char *name = d_name->name;\n\tint namelen = d_name->len;\n\n\tde = (struct ext4_dir_entry_2 *)search_buf;\n\tdlimit = search_buf + buf_size;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\n\t\tif ((char *) de + namelen <= dlimit &&\n\t\t    ext4_match (namelen, name, de)) {\n\t\t\t/* found a match - just to be sure, do a full check */\n\t\t\tif (ext4_check_dir_entry(dir, NULL, de, bh, bh->b_data,\n\t\t\t\t\t\t bh->b_size, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "dir"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_xattr_pos",
          "args": [
            "dir",
            "&iloc"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_xattr_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1039-1052",
          "snippet": "static void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "dir"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(dir)->xattr_sem"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "dir",
            "&iloc"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstruct buffer_head *ext4_find_inline_entry(struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *has_inline_data)\n{\n\tint ret;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_start;\n\tint inline_size;\n\n\tif (ext4_get_inode_loc(dir, &iloc))\n\t\treturn NULL;\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\tinline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\n\tret = search_dir(iloc.bh, inline_start, inline_size,\n\t\t\t dir, d_name, 0, res_dir);\n\tif (ret == 1)\n\t\tgoto out_find;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ext4_get_inline_size(dir) == EXT4_MIN_INLINE_DATA_SIZE)\n\t\tgoto out;\n\n\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\tinline_size = ext4_get_inline_size(dir) - EXT4_MIN_INLINE_DATA_SIZE;\n\n\tret = search_dir(iloc.bh, inline_start, inline_size,\n\t\t\t dir, d_name, 0, res_dir);\n\tif (ret == 1)\n\t\tgoto out_find;\n\nout:\n\tbrelse(iloc.bh);\n\tiloc.bh = NULL;\nout_find:\n\tup_read(&EXT4_I(dir)->xattr_sem);\n\treturn iloc.bh;\n}"
  },
  {
    "function_name": "ext4_try_create_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1574-1605",
    "snippet": "int ext4_try_create_inline_dir(handle_t *handle, struct inode *parent,\n\t\t\t       struct inode *inode)\n{\n\tint ret, inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\tstruct ext4_iloc iloc;\n\tstruct ext4_dir_entry_2 *de;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ext4_prepare_inline_data(handle, inode, inline_size);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * For inline dir, we only save the inode information for the \"..\"\n\t * and create a fake dentry to cover the left space.\n\t */\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tde->inode = cpu_to_le32(parent->i_ino);\n\tde = (struct ext4_dir_entry_2 *)((void *)de + EXT4_INLINE_DOTDOT_SIZE);\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\tinline_size);\n\tset_nlink(inode, 2);\n\tinode->i_size = EXT4_I(inode)->i_disksize = inline_size;\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_INLINE_DOTDOT_SIZE\t\t4",
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "inline_size - EXT4_INLINE_DOTDOT_SIZE",
            "inline_size"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "parent->i_ino"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_prepare_inline_data",
          "args": [
            "handle",
            "inode",
            "inline_size"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_prepare_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "372-395",
          "snippet": "static int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int len)\n{\n\tint ret, size;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\t\treturn -ENOSPC;\n\n\tsize = ext4_get_max_inline_size(inode);\n\tif (size < len)\n\t\treturn -ENOSPC;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\n\tif (ei->i_inline_off)\n\t\tret = ext4_update_inline_data(handle, inode, len);\n\telse\n\t\tret = ext4_create_inline_data(handle, inode, len);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int len)\n{\n\tint ret, size;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\t\treturn -ENOSPC;\n\n\tsize = ext4_get_max_inline_size(inode);\n\tif (size < len)\n\t\treturn -ENOSPC;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\n\tif (ei->i_inline_off)\n\t\tret = ext4_update_inline_data(handle, inode, len);\n\telse\n\t\tret = ext4_create_inline_data(handle, inode, len);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_try_create_inline_dir(handle_t *handle, struct inode *parent,\n\t\t\t       struct inode *inode)\n{\n\tint ret, inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\tstruct ext4_iloc iloc;\n\tstruct ext4_dir_entry_2 *de;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ext4_prepare_inline_data(handle, inode, inline_size);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * For inline dir, we only save the inode information for the \"..\"\n\t * and create a fake dentry to cover the left space.\n\t */\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tde->inode = cpu_to_le32(parent->i_ino);\n\tde = (struct ext4_dir_entry_2 *)((void *)de + EXT4_INLINE_DOTDOT_SIZE);\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\tinline_size);\n\tset_nlink(inode, 2);\n\tinode->i_size = EXT4_I(inode)->i_disksize = inline_size;\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_get_first_inline_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1554-1567",
    "snippet": "struct buffer_head *ext4_get_first_inline_block(struct inode *inode,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *retval)\n{\n\tstruct ext4_iloc iloc;\n\n\t*retval = ext4_get_inode_loc(inode, &iloc);\n\tif (*retval)\n\t\treturn NULL;\n\n\t*parent_de = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\n\treturn iloc.bh;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstruct buffer_head *ext4_get_first_inline_block(struct inode *inode,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *retval)\n{\n\tstruct ext4_iloc iloc;\n\n\t*retval = ext4_get_inode_loc(inode, &iloc);\n\tif (*retval)\n\t\treturn NULL;\n\n\t*parent_de = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\n\treturn iloc.bh;\n}"
  },
  {
    "function_name": "ext4_read_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1424-1552",
    "snippet": "int ext4_read_inline_dir(struct file *file,\n\t\t\t struct dir_context *ctx,\n\t\t\t int *has_inline_data)\n{\n\tunsigned int offset, parent_ino;\n\tint i;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct super_block *sb;\n\tstruct inode *inode = file_inode(file);\n\tint ret, inline_size = 0;\n\tstruct ext4_iloc iloc;\n\tvoid *dir_buf = NULL;\n\tint dotdot_offset, dotdot_size, extra_offset, extra_size;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\tdir_buf = kmalloc(inline_size, GFP_NOFS);\n\tif (!dir_buf) {\n\t\tret = -ENOMEM;\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\tret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = 0;\n\tsb = inode->i_sb;\n\tparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\n\toffset = ctx->pos;\n\n\t/*\n\t * dotdot_offset and dotdot_size is the real offset and\n\t * size for \"..\" and \".\" if the dir is block based while\n\t * the real size for them are only EXT4_INLINE_DOTDOT_SIZE.\n\t * So we will use extra_offset and extra_size to indicate them\n\t * during the inline dir iteration.\n\t */\n\tdotdot_offset = EXT4_DIR_REC_LEN(1);\n\tdotdot_size = dotdot_offset + EXT4_DIR_REC_LEN(2);\n\textra_offset = dotdot_size - EXT4_INLINE_DOTDOT_SIZE;\n\textra_size = extra_offset + inline_size;\n\n\t/*\n\t * If the version has changed since the last call to\n\t * readdir(2), then we might be pointing to an invalid\n\t * dirent right now.  Scan from the start of the inline\n\t * dir to make sure.\n\t */\n\tif (file->f_version != inode->i_version) {\n\t\tfor (i = 0; i < extra_size && i < offset;) {\n\t\t\t/*\n\t\t\t * \".\" is with offset 0 and\n\t\t\t * \"..\" is dotdot_offset.\n\t\t\t */\n\t\t\tif (!i) {\n\t\t\t\ti = dotdot_offset;\n\t\t\t\tcontinue;\n\t\t\t} else if (i == dotdot_offset) {\n\t\t\t\ti = dotdot_size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* for other entry, the real offset in\n\t\t\t * the buf has to be tuned accordingly.\n\t\t\t */\n\t\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t\t(dir_buf + i - extra_offset);\n\t\t\t/* It's too expensive to do a full\n\t\t\t * dirent test each time round this\n\t\t\t * loop, but we do have to test at\n\t\t\t * least that it is non-zero.  A\n\t\t\t * failure will be detected in the\n\t\t\t * dirent test below. */\n\t\t\tif (ext4_rec_len_from_disk(de->rec_len, extra_size)\n\t\t\t\t< EXT4_DIR_REC_LEN(1))\n\t\t\t\tbreak;\n\t\t\ti += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t    extra_size);\n\t\t}\n\t\toffset = i;\n\t\tctx->pos = offset;\n\t\tfile->f_version = inode->i_version;\n\t}\n\n\twhile (ctx->pos < extra_size) {\n\t\tif (ctx->pos == 0) {\n\t\t\tif (!dir_emit(ctx, \".\", 1, inode->i_ino, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = dotdot_offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->pos == dotdot_offset) {\n\t\t\tif (!dir_emit(ctx, \"..\", 2, parent_ino, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = dotdot_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t(dir_buf + ctx->pos - extra_offset);\n\t\tif (ext4_check_dir_entry(inode, file, de, iloc.bh, dir_buf,\n\t\t\t\t\t extra_size, ctx->pos))\n\t\t\tgoto out;\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t      le32_to_cpu(de->inode),\n\t\t\t\t      get_dtype(sb, de->file_type)))\n\t\t\t\tgoto out;\n\t\t}\n\t\tctx->pos += ext4_rec_len_from_disk(de->rec_len, extra_size);\n\t}\nout:\n\tkfree(dir_buf);\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_INLINE_DOTDOT_SIZE\t\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir_buf"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "extra_size"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "de->name",
            "de->name_len",
            "le32_to_cpu(de->inode)",
            "get_dtype(sb, de->file_type)"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dtype",
          "args": [
            "sb",
            "de->file_type"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "get_dtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2036-2043",
          "snippet": "static inline  unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT4_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn ext4_filetype_table[filetype];\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FT_MAX\t\t8",
            "#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FT_MAX\t\t8\n#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n\nstatic inline  unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT4_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn ext4_filetype_table[filetype];\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "inode",
            "file",
            "de",
            "iloc.bh",
            "dir_buf",
            "extra_size",
            "ctx->pos"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\"..\"",
            "2",
            "parent_ino",
            "DT_DIR"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\".\"",
            "1",
            "inode->i_ino",
            "DT_DIR"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "2"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_read_inline_data",
          "args": [
            "inode",
            "dir_buf",
            "inline_size",
            "&iloc"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "162-200",
          "snippet": "static int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\tlen : EXT4_MIN_INLINE_DATA_SIZE;\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstatic int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\tlen : EXT4_MIN_INLINE_DATA_SIZE;\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "inline_size",
            "GFP_NOFS"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "inode"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nint ext4_read_inline_dir(struct file *file,\n\t\t\t struct dir_context *ctx,\n\t\t\t int *has_inline_data)\n{\n\tunsigned int offset, parent_ino;\n\tint i;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct super_block *sb;\n\tstruct inode *inode = file_inode(file);\n\tint ret, inline_size = 0;\n\tstruct ext4_iloc iloc;\n\tvoid *dir_buf = NULL;\n\tint dotdot_offset, dotdot_size, extra_offset, extra_size;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\tdir_buf = kmalloc(inline_size, GFP_NOFS);\n\tif (!dir_buf) {\n\t\tret = -ENOMEM;\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\tret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = 0;\n\tsb = inode->i_sb;\n\tparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\n\toffset = ctx->pos;\n\n\t/*\n\t * dotdot_offset and dotdot_size is the real offset and\n\t * size for \"..\" and \".\" if the dir is block based while\n\t * the real size for them are only EXT4_INLINE_DOTDOT_SIZE.\n\t * So we will use extra_offset and extra_size to indicate them\n\t * during the inline dir iteration.\n\t */\n\tdotdot_offset = EXT4_DIR_REC_LEN(1);\n\tdotdot_size = dotdot_offset + EXT4_DIR_REC_LEN(2);\n\textra_offset = dotdot_size - EXT4_INLINE_DOTDOT_SIZE;\n\textra_size = extra_offset + inline_size;\n\n\t/*\n\t * If the version has changed since the last call to\n\t * readdir(2), then we might be pointing to an invalid\n\t * dirent right now.  Scan from the start of the inline\n\t * dir to make sure.\n\t */\n\tif (file->f_version != inode->i_version) {\n\t\tfor (i = 0; i < extra_size && i < offset;) {\n\t\t\t/*\n\t\t\t * \".\" is with offset 0 and\n\t\t\t * \"..\" is dotdot_offset.\n\t\t\t */\n\t\t\tif (!i) {\n\t\t\t\ti = dotdot_offset;\n\t\t\t\tcontinue;\n\t\t\t} else if (i == dotdot_offset) {\n\t\t\t\ti = dotdot_size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* for other entry, the real offset in\n\t\t\t * the buf has to be tuned accordingly.\n\t\t\t */\n\t\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t\t(dir_buf + i - extra_offset);\n\t\t\t/* It's too expensive to do a full\n\t\t\t * dirent test each time round this\n\t\t\t * loop, but we do have to test at\n\t\t\t * least that it is non-zero.  A\n\t\t\t * failure will be detected in the\n\t\t\t * dirent test below. */\n\t\t\tif (ext4_rec_len_from_disk(de->rec_len, extra_size)\n\t\t\t\t< EXT4_DIR_REC_LEN(1))\n\t\t\t\tbreak;\n\t\t\ti += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t    extra_size);\n\t\t}\n\t\toffset = i;\n\t\tctx->pos = offset;\n\t\tfile->f_version = inode->i_version;\n\t}\n\n\twhile (ctx->pos < extra_size) {\n\t\tif (ctx->pos == 0) {\n\t\t\tif (!dir_emit(ctx, \".\", 1, inode->i_ino, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = dotdot_offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->pos == dotdot_offset) {\n\t\t\tif (!dir_emit(ctx, \"..\", 2, parent_ino, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = dotdot_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t(dir_buf + ctx->pos - extra_offset);\n\t\tif (ext4_check_dir_entry(inode, file, de, iloc.bh, dir_buf,\n\t\t\t\t\t extra_size, ctx->pos))\n\t\t\tgoto out;\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t      le32_to_cpu(de->inode),\n\t\t\t\t      get_dtype(sb, de->file_type)))\n\t\t\t\tgoto out;\n\t\t}\n\t\tctx->pos += ext4_rec_len_from_disk(de->rec_len, extra_size);\n\t}\nout:\n\tkfree(dir_buf);\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "htree_inlinedir_to_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1315-1414",
    "snippet": "int htree_inlinedir_to_tree(struct file *dir_file,\n\t\t\t    struct inode *dir, ext4_lblk_t block,\n\t\t\t    struct dx_hash_info *hinfo,\n\t\t\t    __u32 start_hash, __u32 start_minor_hash,\n\t\t\t    int *has_inline_data)\n{\n\tint err = 0, count = 0;\n\tunsigned int parent_ino;\n\tint pos;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct inode *inode = file_inode(dir_file);\n\tint ret, inline_size = 0;\n\tstruct ext4_iloc iloc;\n\tvoid *dir_buf = NULL;\n\tstruct ext4_dir_entry_2 fake;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\tdir_buf = kmalloc(inline_size, GFP_NOFS);\n\tif (!dir_buf) {\n\t\tret = -ENOMEM;\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\tret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpos = 0;\n\tparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\n\twhile (pos < inline_size) {\n\t\t/*\n\t\t * As inlined dir doesn't store any information about '.' and\n\t\t * only the inode number of '..' is stored, we have to handle\n\t\t * them differently.\n\t\t */\n\t\tif (pos == 0) {\n\t\t\tfake.inode = cpu_to_le32(inode->i_ino);\n\t\t\tfake.name_len = 1;\n\t\t\tstrcpy(fake.name, \".\");\n\t\t\tfake.rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\t\tEXT4_DIR_REC_LEN(fake.name_len),\n\t\t\t\t\t\tinline_size);\n\t\t\text4_set_de_type(inode->i_sb, &fake, S_IFDIR);\n\t\t\tde = &fake;\n\t\t\tpos = EXT4_INLINE_DOTDOT_OFFSET;\n\t\t} else if (pos == EXT4_INLINE_DOTDOT_OFFSET) {\n\t\t\tfake.inode = cpu_to_le32(parent_ino);\n\t\t\tfake.name_len = 2;\n\t\t\tstrcpy(fake.name, \"..\");\n\t\t\tfake.rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\t\tEXT4_DIR_REC_LEN(fake.name_len),\n\t\t\t\t\t\tinline_size);\n\t\t\text4_set_de_type(inode->i_sb, &fake, S_IFDIR);\n\t\t\tde = &fake;\n\t\t\tpos = EXT4_INLINE_DOTDOT_SIZE;\n\t\t} else {\n\t\t\tde = (struct ext4_dir_entry_2 *)(dir_buf + pos);\n\t\t\tpos += ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\t\tif (ext4_check_dir_entry(inode, dir_file, de,\n\t\t\t\t\t iloc.bh, dir_buf,\n\t\t\t\t\t inline_size, pos)) {\n\t\t\t\tret = count;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\text4fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\terr = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de);\n\t\tif (err) {\n\t\t\tcount = err;\n\t\t\tgoto out;\n\t\t}\n\t\tcount++;\n\t}\n\tret = count;\nout:\n\tkfree(dir_buf);\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_INLINE_DOTDOT_SIZE\t\t4",
      "#define EXT4_INLINE_DOTDOT_OFFSET\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir_buf"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_htree_store_dirent",
          "args": [
            "dir_file",
            "hinfo->hash",
            "hinfo->minor_hash",
            "de"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_htree_store_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "388-441",
          "snippet": "int ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext4_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname *fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext4_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname *fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4fs_dirhash",
          "args": [
            "de->name",
            "de->name_len",
            "hinfo"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "ext4fs_dirhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/hash.c",
          "lines": "139-208",
          "snippet": "int ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/cryptohash.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/cryptohash.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\thinfo->hash = 0;\n\t\treturn -1;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "inode",
            "dir_file",
            "de",
            "iloc.bh",
            "dir_buf",
            "inline_size",
            "pos"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "inline_size"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_de_type",
          "args": [
            "inode->i_sb",
            "&fake",
            "S_IFDIR"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2695-2700",
          "snippet": "static inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define S_SHIFT 12",
            "#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define S_SHIFT 12\n#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n\nstatic inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "EXT4_DIR_REC_LEN(fake.name_len)",
            "inline_size"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "fake.name_len"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fake.name",
            "\"..\""
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "parent_ino"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "fake.name_len"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fake.name",
            "\".\""
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "((struct ext4_dir_entry_2 *)dir_buf)->inode"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_read_inline_data",
          "args": [
            "inode",
            "dir_buf",
            "inline_size",
            "&iloc"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "162-200",
          "snippet": "static int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\tlen : EXT4_MIN_INLINE_DATA_SIZE;\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstatic int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\tlen : EXT4_MIN_INLINE_DATA_SIZE;\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "inline_size",
            "GFP_NOFS"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "inode"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "dir_file"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n#define EXT4_INLINE_DOTDOT_OFFSET\t2\n\nint htree_inlinedir_to_tree(struct file *dir_file,\n\t\t\t    struct inode *dir, ext4_lblk_t block,\n\t\t\t    struct dx_hash_info *hinfo,\n\t\t\t    __u32 start_hash, __u32 start_minor_hash,\n\t\t\t    int *has_inline_data)\n{\n\tint err = 0, count = 0;\n\tunsigned int parent_ino;\n\tint pos;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct inode *inode = file_inode(dir_file);\n\tint ret, inline_size = 0;\n\tstruct ext4_iloc iloc;\n\tvoid *dir_buf = NULL;\n\tstruct ext4_dir_entry_2 fake;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\tdir_buf = kmalloc(inline_size, GFP_NOFS);\n\tif (!dir_buf) {\n\t\tret = -ENOMEM;\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\tret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpos = 0;\n\tparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\n\twhile (pos < inline_size) {\n\t\t/*\n\t\t * As inlined dir doesn't store any information about '.' and\n\t\t * only the inode number of '..' is stored, we have to handle\n\t\t * them differently.\n\t\t */\n\t\tif (pos == 0) {\n\t\t\tfake.inode = cpu_to_le32(inode->i_ino);\n\t\t\tfake.name_len = 1;\n\t\t\tstrcpy(fake.name, \".\");\n\t\t\tfake.rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\t\tEXT4_DIR_REC_LEN(fake.name_len),\n\t\t\t\t\t\tinline_size);\n\t\t\text4_set_de_type(inode->i_sb, &fake, S_IFDIR);\n\t\t\tde = &fake;\n\t\t\tpos = EXT4_INLINE_DOTDOT_OFFSET;\n\t\t} else if (pos == EXT4_INLINE_DOTDOT_OFFSET) {\n\t\t\tfake.inode = cpu_to_le32(parent_ino);\n\t\t\tfake.name_len = 2;\n\t\t\tstrcpy(fake.name, \"..\");\n\t\t\tfake.rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\t\tEXT4_DIR_REC_LEN(fake.name_len),\n\t\t\t\t\t\tinline_size);\n\t\t\text4_set_de_type(inode->i_sb, &fake, S_IFDIR);\n\t\t\tde = &fake;\n\t\t\tpos = EXT4_INLINE_DOTDOT_SIZE;\n\t\t} else {\n\t\t\tde = (struct ext4_dir_entry_2 *)(dir_buf + pos);\n\t\t\tpos += ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\t\tif (ext4_check_dir_entry(inode, dir_file, de,\n\t\t\t\t\t iloc.bh, dir_buf,\n\t\t\t\t\t inline_size, pos)) {\n\t\t\t\tret = count;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\text4fs_dirhash(de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\terr = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de);\n\t\tif (err) {\n\t\t\tcount = err;\n\t\t\tgoto out;\n\t\t}\n\t\tcount++;\n\t}\n\tret = count;\nout:\n\tkfree(dir_buf);\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_try_add_inline_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1248-1308",
    "snippet": "int ext4_try_add_inline_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tint ret, inline_size;\n\tvoid *inline_start;\n\tstruct ext4_iloc iloc;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\n\tret = ext4_get_inode_loc(dir, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_write(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir))\n\t\tgoto out;\n\n\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\t\t EXT4_INLINE_DOTDOT_SIZE;\n\tinline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\n\n\tret = ext4_add_dirent_to_inline(handle, dentry, inode, &iloc,\n\t\t\t\t\tinline_start, inline_size);\n\tif (ret != -ENOSPC)\n\t\tgoto out;\n\n\t/* check whether it can be inserted to inline xattr space. */\n\tinline_size = EXT4_I(dir)->i_inline_size -\n\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\tif (!inline_size) {\n\t\t/* Try to use the xattr space.*/\n\t\tret = ext4_update_inline_dir(handle, dir, &iloc);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out;\n\n\t\tinline_size = EXT4_I(dir)->i_inline_size -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tif (inline_size) {\n\t\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\n\t\tret = ext4_add_dirent_to_inline(handle, dentry, inode, &iloc,\n\t\t\t\t\t\tinline_start, inline_size);\n\n\t\tif (ret != -ENOSPC)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * The inline space is filled up, so create a new block for it.\n\t * As the extent tree will be created, we have to save the inline\n\t * dir first.\n\t */\n\tret = ext4_convert_inline_data_nolock(handle, dir, &iloc);\n\nout:\n\text4_mark_inode_dirty(handle, dir);\n\tup_write(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_INLINE_DOTDOT_SIZE\t\t4",
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(dir)->xattr_sem"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "dir"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_convert_inline_data_nolock",
          "args": [
            "handle",
            "dir",
            "&iloc"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_convert_inline_data_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1159-1241",
          "snippet": "static int ext4_convert_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tint error;\n\tvoid *buf = NULL;\n\tstruct buffer_head *data_bh = NULL;\n\tstruct ext4_map_blocks map;\n\tint inline_size;\n\n\tinline_size = ext4_get_inline_size(inode);\n\tbuf = kmalloc(inline_size, GFP_NOFS);\n\tif (!buf) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = ext4_read_inline_data(inode, buf, inline_size, iloc);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * Make sure the inline directory entries pass checks before we try to\n\t * convert them, so that we avoid touching stuff that needs fsck.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = ext4_check_all_de(inode, iloc->bh,\n\t\t\t\t\tbuf + EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (error)\n\t\tgoto out;\n\n\tmap.m_lblk = 0;\n\tmap.m_len = 1;\n\tmap.m_flags = 0;\n\terror = ext4_map_blocks(handle, inode, &map, EXT4_GET_BLOCKS_CREATE);\n\tif (error < 0)\n\t\tgoto out_restore;\n\tif (!(map.m_flags & EXT4_MAP_MAPPED)) {\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\n\tdata_bh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (!data_bh) {\n\t\terror = -ENOMEM;\n\t\tgoto out_restore;\n\t}\n\n\tlock_buffer(data_bh);\n\terror = ext4_journal_get_create_access(handle, data_bh);\n\tif (error) {\n\t\tunlock_buffer(data_bh);\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\tmemset(data_bh->b_data, 0, inode->i_sb->s_blocksize);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmemcpy(data_bh->b_data, buf, inline_size);\n\t\tset_buffer_uptodate(data_bh);\n\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t   inode, data_bh);\n\t} else {\n\t\terror = ext4_finish_convert_inline_dir(handle, inode, data_bh,\n\t\t\t\t\t\t       buf, inline_size);\n\t}\n\n\tunlock_buffer(data_bh);\nout_restore:\n\tif (error)\n\t\text4_restore_inline_data(handle, inode, iloc, buf, inline_size);\n\nout:\n\tbrelse(data_bh);\n\tkfree(buf);\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nstatic int ext4_convert_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tint error;\n\tvoid *buf = NULL;\n\tstruct buffer_head *data_bh = NULL;\n\tstruct ext4_map_blocks map;\n\tint inline_size;\n\n\tinline_size = ext4_get_inline_size(inode);\n\tbuf = kmalloc(inline_size, GFP_NOFS);\n\tif (!buf) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = ext4_read_inline_data(inode, buf, inline_size, iloc);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * Make sure the inline directory entries pass checks before we try to\n\t * convert them, so that we avoid touching stuff that needs fsck.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = ext4_check_all_de(inode, iloc->bh,\n\t\t\t\t\tbuf + EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (error)\n\t\tgoto out;\n\n\tmap.m_lblk = 0;\n\tmap.m_len = 1;\n\tmap.m_flags = 0;\n\terror = ext4_map_blocks(handle, inode, &map, EXT4_GET_BLOCKS_CREATE);\n\tif (error < 0)\n\t\tgoto out_restore;\n\tif (!(map.m_flags & EXT4_MAP_MAPPED)) {\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\n\tdata_bh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (!data_bh) {\n\t\terror = -ENOMEM;\n\t\tgoto out_restore;\n\t}\n\n\tlock_buffer(data_bh);\n\terror = ext4_journal_get_create_access(handle, data_bh);\n\tif (error) {\n\t\tunlock_buffer(data_bh);\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\tmemset(data_bh->b_data, 0, inode->i_sb->s_blocksize);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmemcpy(data_bh->b_data, buf, inline_size);\n\t\tset_buffer_uptodate(data_bh);\n\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t   inode, data_bh);\n\t} else {\n\t\terror = ext4_finish_convert_inline_dir(handle, inode, data_bh,\n\t\t\t\t\t\t       buf, inline_size);\n\t}\n\n\tunlock_buffer(data_bh);\nout_restore:\n\tif (error)\n\t\text4_restore_inline_data(handle, inode, iloc, buf, inline_size);\n\nout:\n\tbrelse(data_bh);\n\tkfree(buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_add_dirent_to_inline",
          "args": [
            "handle",
            "dentry",
            "inode",
            "&iloc",
            "inline_start",
            "inline_size"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_add_dirent_to_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "995-1037",
          "snippet": "static int ext4_add_dirent_to_inline(handle_t *handle,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     void *inline_start, int inline_size)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tint\t\terr;\n\tstruct ext4_dir_entry_2 *de;\n\n\terr = ext4_find_dest_de(dir, inode, iloc->bh,\n\t\t\t\tinline_start, inline_size,\n\t\t\t\tname, namelen, &de);\n\tif (err)\n\t\treturn err;\n\n\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\tif (err)\n\t\treturn err;\n\text4_insert_dentry(inode, de, inline_size, name, namelen);\n\n\text4_show_inline_dir(dir, iloc->bh, inline_start, inline_size);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_add_dirent_to_inline(handle_t *handle,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     void *inline_start, int inline_size)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tint\t\terr;\n\tstruct ext4_dir_entry_2 *de;\n\n\terr = ext4_find_dest_de(dir, inode, iloc->bh,\n\t\t\t\tinline_start, inline_size,\n\t\t\t\tname, namelen, &de);\n\tif (err)\n\t\treturn err;\n\n\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\tif (err)\n\t\treturn err;\n\text4_insert_dentry(inode, de, inline_size, name, namelen);\n\n\text4_show_inline_dir(dir, iloc->bh, inline_start, inline_size);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_xattr_pos",
          "args": [
            "dir",
            "&iloc"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_xattr_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1039-1052",
          "snippet": "static void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_inline_dir",
          "args": [
            "handle",
            "dir",
            "&iloc"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1080-1100",
          "snippet": "static int ext4_update_inline_dir(handle_t *handle, struct inode *dir,\n\t\t\t\t  struct ext4_iloc *iloc)\n{\n\tint ret;\n\tint old_size = EXT4_I(dir)->i_inline_size - EXT4_MIN_INLINE_DATA_SIZE;\n\tint new_size = get_max_inline_xattr_value_size(dir, iloc);\n\n\tif (new_size - old_size <= EXT4_DIR_REC_LEN(1))\n\t\treturn -ENOSPC;\n\n\tret = ext4_update_inline_data(handle, dir,\n\t\t\t\t      new_size + EXT4_MIN_INLINE_DATA_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\text4_update_final_de(ext4_get_inline_xattr_pos(dir, iloc), old_size,\n\t\t\t     EXT4_I(dir)->i_inline_size -\n\t\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE);\n\tdir->i_size = EXT4_I(dir)->i_disksize = EXT4_I(dir)->i_inline_size;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstatic int ext4_update_inline_dir(handle_t *handle, struct inode *dir,\n\t\t\t\t  struct ext4_iloc *iloc)\n{\n\tint ret;\n\tint old_size = EXT4_I(dir)->i_inline_size - EXT4_MIN_INLINE_DATA_SIZE;\n\tint new_size = get_max_inline_xattr_value_size(dir, iloc);\n\n\tif (new_size - old_size <= EXT4_DIR_REC_LEN(1))\n\t\treturn -ENOSPC;\n\n\tret = ext4_update_inline_data(handle, dir,\n\t\t\t\t      new_size + EXT4_MIN_INLINE_DATA_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\text4_update_final_de(ext4_get_inline_xattr_pos(dir, iloc), old_size,\n\t\t\t     EXT4_I(dir)->i_inline_size -\n\t\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE);\n\tdir->i_size = EXT4_I(dir)->i_disksize = EXT4_I(dir)->i_inline_size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "dir"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(dir)->xattr_sem"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "dir",
            "&iloc"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_try_add_inline_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tint ret, inline_size;\n\tvoid *inline_start;\n\tstruct ext4_iloc iloc;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\n\tret = ext4_get_inode_loc(dir, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_write(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir))\n\t\tgoto out;\n\n\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\t\t EXT4_INLINE_DOTDOT_SIZE;\n\tinline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\n\n\tret = ext4_add_dirent_to_inline(handle, dentry, inode, &iloc,\n\t\t\t\t\tinline_start, inline_size);\n\tif (ret != -ENOSPC)\n\t\tgoto out;\n\n\t/* check whether it can be inserted to inline xattr space. */\n\tinline_size = EXT4_I(dir)->i_inline_size -\n\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\tif (!inline_size) {\n\t\t/* Try to use the xattr space.*/\n\t\tret = ext4_update_inline_dir(handle, dir, &iloc);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out;\n\n\t\tinline_size = EXT4_I(dir)->i_inline_size -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tif (inline_size) {\n\t\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\n\t\tret = ext4_add_dirent_to_inline(handle, dentry, inode, &iloc,\n\t\t\t\t\t\tinline_start, inline_size);\n\n\t\tif (ret != -ENOSPC)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * The inline space is filled up, so create a new block for it.\n\t * As the extent tree will be created, we have to save the inline\n\t * dir first.\n\t */\n\tret = ext4_convert_inline_data_nolock(handle, dir, &iloc);\n\nout:\n\text4_mark_inode_dirty(handle, dir);\n\tup_write(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_convert_inline_data_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1159-1241",
    "snippet": "static int ext4_convert_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tint error;\n\tvoid *buf = NULL;\n\tstruct buffer_head *data_bh = NULL;\n\tstruct ext4_map_blocks map;\n\tint inline_size;\n\n\tinline_size = ext4_get_inline_size(inode);\n\tbuf = kmalloc(inline_size, GFP_NOFS);\n\tif (!buf) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = ext4_read_inline_data(inode, buf, inline_size, iloc);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * Make sure the inline directory entries pass checks before we try to\n\t * convert them, so that we avoid touching stuff that needs fsck.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = ext4_check_all_de(inode, iloc->bh,\n\t\t\t\t\tbuf + EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (error)\n\t\tgoto out;\n\n\tmap.m_lblk = 0;\n\tmap.m_len = 1;\n\tmap.m_flags = 0;\n\terror = ext4_map_blocks(handle, inode, &map, EXT4_GET_BLOCKS_CREATE);\n\tif (error < 0)\n\t\tgoto out_restore;\n\tif (!(map.m_flags & EXT4_MAP_MAPPED)) {\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\n\tdata_bh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (!data_bh) {\n\t\terror = -ENOMEM;\n\t\tgoto out_restore;\n\t}\n\n\tlock_buffer(data_bh);\n\terror = ext4_journal_get_create_access(handle, data_bh);\n\tif (error) {\n\t\tunlock_buffer(data_bh);\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\tmemset(data_bh->b_data, 0, inode->i_sb->s_blocksize);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmemcpy(data_bh->b_data, buf, inline_size);\n\t\tset_buffer_uptodate(data_bh);\n\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t   inode, data_bh);\n\t} else {\n\t\terror = ext4_finish_convert_inline_dir(handle, inode, data_bh,\n\t\t\t\t\t\t       buf, inline_size);\n\t}\n\n\tunlock_buffer(data_bh);\nout_restore:\n\tif (error)\n\t\text4_restore_inline_data(handle, inode, iloc, buf, inline_size);\n\nout:\n\tbrelse(data_bh);\n\tkfree(buf);\n\treturn error;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_INLINE_DOTDOT_SIZE\t\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "data_bh"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_restore_inline_data",
          "args": [
            "handle",
            "inode",
            "iloc",
            "buf",
            "inline_size"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_restore_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1102-1109",
          "snippet": "static void ext4_restore_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     void *buf, int inline_size)\n{\n\text4_create_inline_data(handle, inode, inline_size);\n\text4_write_inline_data(inode, iloc, buf, 0, inline_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_restore_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     void *buf, int inline_size)\n{\n\text4_create_inline_data(handle, inode, inline_size);\n\text4_write_inline_data(inode, iloc, buf, 0, inline_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "data_bh"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_finish_convert_inline_dir",
          "args": [
            "handle",
            "inode",
            "data_bh",
            "buf",
            "inline_size"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_finish_convert_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1111-1157",
          "snippet": "static int ext4_finish_convert_inline_dir(handle_t *handle,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  struct buffer_head *dir_block,\n\t\t\t\t\t  void *buf,\n\t\t\t\t\t  int inline_size)\n{\n\tint err, csum_size = 0, header_size = 0;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tvoid *target = dir_block->b_data;\n\n\t/*\n\t * First create \".\" and \"..\" and then copy the dir information\n\t * back to the block.\n\t */\n\tde = (struct ext4_dir_entry_2 *)target;\n\tde = ext4_init_dot_dotdot(inode, de,\n\t\tinode->i_sb->s_blocksize, csum_size,\n\t\tle32_to_cpu(((struct ext4_dir_entry_2 *)buf)->inode), 1);\n\theader_size = (void *)de - target;\n\n\tmemcpy((void *)de, buf + EXT4_INLINE_DOTDOT_SIZE,\n\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tinode->i_size = inode->i_sb->s_blocksize;\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tEXT4_I(inode)->i_disksize = inode->i_sb->s_blocksize;\n\text4_update_final_de(dir_block->b_data,\n\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE + header_size,\n\t\t\tinode->i_sb->s_blocksize - csum_size);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(dir_block->b_data,\n\t\t\t\t     inode->i_sb->s_blocksize);\n\t\tinitialize_dirent_tail(t, inode->i_sb->s_blocksize);\n\t}\n\tset_buffer_uptodate(dir_block);\n\terr = ext4_handle_dirty_dirent_node(handle, inode, dir_block);\n\tif (err)\n\t\tgoto out;\n\tset_buffer_verified(dir_block);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nstatic int ext4_finish_convert_inline_dir(handle_t *handle,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  struct buffer_head *dir_block,\n\t\t\t\t\t  void *buf,\n\t\t\t\t\t  int inline_size)\n{\n\tint err, csum_size = 0, header_size = 0;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tvoid *target = dir_block->b_data;\n\n\t/*\n\t * First create \".\" and \"..\" and then copy the dir information\n\t * back to the block.\n\t */\n\tde = (struct ext4_dir_entry_2 *)target;\n\tde = ext4_init_dot_dotdot(inode, de,\n\t\tinode->i_sb->s_blocksize, csum_size,\n\t\tle32_to_cpu(((struct ext4_dir_entry_2 *)buf)->inode), 1);\n\theader_size = (void *)de - target;\n\n\tmemcpy((void *)de, buf + EXT4_INLINE_DOTDOT_SIZE,\n\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tinode->i_size = inode->i_sb->s_blocksize;\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tEXT4_I(inode)->i_disksize = inode->i_sb->s_blocksize;\n\text4_update_final_de(dir_block->b_data,\n\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE + header_size,\n\t\t\tinode->i_sb->s_blocksize - csum_size);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(dir_block->b_data,\n\t\t\t\t     inode->i_sb->s_blocksize);\n\t\tinitialize_dirent_tail(t, inode->i_sb->s_blocksize);\n\t}\n\tset_buffer_uptodate(dir_block);\n\terr = ext4_handle_dirty_dirent_node(handle, inode, dir_block);\n\tif (err)\n\t\tgoto out;\n\tset_buffer_verified(dir_block);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "inode",
            "data_bh"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "data_bh"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data_bh->b_data",
            "buf",
            "inline_size"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data_bh->b_data",
            "0",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_create_access",
          "args": [
            "handle",
            "data_bh"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "map.m_pblk"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_map_blocks",
          "args": [
            "handle",
            "inode",
            "&map",
            "EXT4_GET_BLOCKS_CREATE"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "460-658",
          "snippet": "int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_destroy_inline_data_nolock",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_destroy_inline_data_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "397-456",
          "snippet": "static int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_check_all_de",
          "args": [
            "inode",
            "iloc->bh",
            "buf + EXT4_INLINE_DOTDOT_SIZE",
            "inline_size - EXT4_INLINE_DOTDOT_SIZE"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_check_all_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "572-595",
          "snippet": "int ext4_check_all_de(struct inode *dir, struct buffer_head *bh, void *buf,\n\t\t      int buf_size)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size;\n\twhile ((char *) de < top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EIO;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4_check_all_de(struct inode *dir, struct buffer_head *bh, void *buf,\n\t\t      int buf_size)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size;\n\twhile ((char *) de < top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EIO;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_inline_data",
          "args": [
            "inode",
            "buf",
            "inline_size",
            "iloc"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "162-200",
          "snippet": "static int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\tlen : EXT4_MIN_INLINE_DATA_SIZE;\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstatic int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\tlen : EXT4_MIN_INLINE_DATA_SIZE;\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "inline_size",
            "GFP_NOFS"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "inode"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nstatic int ext4_convert_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tint error;\n\tvoid *buf = NULL;\n\tstruct buffer_head *data_bh = NULL;\n\tstruct ext4_map_blocks map;\n\tint inline_size;\n\n\tinline_size = ext4_get_inline_size(inode);\n\tbuf = kmalloc(inline_size, GFP_NOFS);\n\tif (!buf) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = ext4_read_inline_data(inode, buf, inline_size, iloc);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * Make sure the inline directory entries pass checks before we try to\n\t * convert them, so that we avoid touching stuff that needs fsck.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = ext4_check_all_de(inode, iloc->bh,\n\t\t\t\t\tbuf + EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (error)\n\t\tgoto out;\n\n\tmap.m_lblk = 0;\n\tmap.m_len = 1;\n\tmap.m_flags = 0;\n\terror = ext4_map_blocks(handle, inode, &map, EXT4_GET_BLOCKS_CREATE);\n\tif (error < 0)\n\t\tgoto out_restore;\n\tif (!(map.m_flags & EXT4_MAP_MAPPED)) {\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\n\tdata_bh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (!data_bh) {\n\t\terror = -ENOMEM;\n\t\tgoto out_restore;\n\t}\n\n\tlock_buffer(data_bh);\n\terror = ext4_journal_get_create_access(handle, data_bh);\n\tif (error) {\n\t\tunlock_buffer(data_bh);\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\tmemset(data_bh->b_data, 0, inode->i_sb->s_blocksize);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmemcpy(data_bh->b_data, buf, inline_size);\n\t\tset_buffer_uptodate(data_bh);\n\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t   inode, data_bh);\n\t} else {\n\t\terror = ext4_finish_convert_inline_dir(handle, inode, data_bh,\n\t\t\t\t\t\t       buf, inline_size);\n\t}\n\n\tunlock_buffer(data_bh);\nout_restore:\n\tif (error)\n\t\text4_restore_inline_data(handle, inode, iloc, buf, inline_size);\n\nout:\n\tbrelse(data_bh);\n\tkfree(buf);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_finish_convert_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1111-1157",
    "snippet": "static int ext4_finish_convert_inline_dir(handle_t *handle,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  struct buffer_head *dir_block,\n\t\t\t\t\t  void *buf,\n\t\t\t\t\t  int inline_size)\n{\n\tint err, csum_size = 0, header_size = 0;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tvoid *target = dir_block->b_data;\n\n\t/*\n\t * First create \".\" and \"..\" and then copy the dir information\n\t * back to the block.\n\t */\n\tde = (struct ext4_dir_entry_2 *)target;\n\tde = ext4_init_dot_dotdot(inode, de,\n\t\tinode->i_sb->s_blocksize, csum_size,\n\t\tle32_to_cpu(((struct ext4_dir_entry_2 *)buf)->inode), 1);\n\theader_size = (void *)de - target;\n\n\tmemcpy((void *)de, buf + EXT4_INLINE_DOTDOT_SIZE,\n\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tinode->i_size = inode->i_sb->s_blocksize;\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tEXT4_I(inode)->i_disksize = inode->i_sb->s_blocksize;\n\text4_update_final_de(dir_block->b_data,\n\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE + header_size,\n\t\t\tinode->i_sb->s_blocksize - csum_size);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(dir_block->b_data,\n\t\t\t\t     inode->i_sb->s_blocksize);\n\t\tinitialize_dirent_tail(t, inode->i_sb->s_blocksize);\n\t}\n\tset_buffer_uptodate(dir_block);\n\terr = ext4_handle_dirty_dirent_node(handle, inode, dir_block);\n\tif (err)\n\t\tgoto out;\n\tset_buffer_verified(dir_block);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_INLINE_DOTDOT_SIZE\t\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_verified",
          "args": [
            "dir_block"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_dirent_node",
          "args": [
            "handle",
            "inode",
            "dir_block"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_dirent_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "374-380",
          "snippet": "int ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_handle_dirty_dirent_node(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct buffer_head *bh)\n{\n\text4_dirent_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "dir_block"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_dirent_tail",
          "args": [
            "t",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_dirent_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "276-283",
          "snippet": "void initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\n\nvoid initialize_dirent_tail(struct ext4_dir_entry_tail *t,\n\t\t\t    unsigned int blocksize)\n{\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIRENT_TAIL",
          "args": [
            "dir_block->b_data",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_update_final_de",
          "args": [
            "dir_block->b_data",
            "inline_size - EXT4_INLINE_DOTDOT_SIZE + header_size",
            "inode->i_sb->s_blocksize - csum_size"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_final_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1055-1078",
          "snippet": "static void ext4_update_final_de(void *de_buf, int old_size, int new_size)\n{\n\tstruct ext4_dir_entry_2 *de, *prev_de;\n\tvoid *limit;\n\tint de_len;\n\n\tde = (struct ext4_dir_entry_2 *)de_buf;\n\tif (old_size) {\n\t\tlimit = de_buf + old_size;\n\t\tdo {\n\t\t\tprev_de = de;\n\t\t\tde_len = ext4_rec_len_from_disk(de->rec_len, old_size);\n\t\t\tde_buf += de_len;\n\t\t\tde = (struct ext4_dir_entry_2 *)de_buf;\n\t\t} while (de_buf < limit);\n\n\t\tprev_de->rec_len = ext4_rec_len_to_disk(de_len + new_size -\n\t\t\t\t\t\t\told_size, new_size);\n\t} else {\n\t\t/* this is just created, so create an empty entry. */\n\t\tde->inode = 0;\n\t\tde->rec_len = ext4_rec_len_to_disk(new_size, new_size);\n\t}\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_update_final_de(void *de_buf, int old_size, int new_size)\n{\n\tstruct ext4_dir_entry_2 *de, *prev_de;\n\tvoid *limit;\n\tint de_len;\n\n\tde = (struct ext4_dir_entry_2 *)de_buf;\n\tif (old_size) {\n\t\tlimit = de_buf + old_size;\n\t\tdo {\n\t\t\tprev_de = de;\n\t\t\tde_len = ext4_rec_len_from_disk(de->rec_len, old_size);\n\t\t\tde_buf += de_len;\n\t\t\tde = (struct ext4_dir_entry_2 *)de_buf;\n\t\t} while (de_buf < limit);\n\n\t\tprev_de->rec_len = ext4_rec_len_to_disk(de_len + new_size -\n\t\t\t\t\t\t\told_size, new_size);\n\t} else {\n\t\t/* this is just created, so create an empty entry. */\n\t\tde->inode = 0;\n\t\tde->rec_len = ext4_rec_len_to_disk(new_size, new_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)de",
            "buf + EXT4_INLINE_DOTDOT_SIZE",
            "inline_size - EXT4_INLINE_DOTDOT_SIZE"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_init_dot_dotdot",
          "args": [
            "inode",
            "de",
            "inode->i_sb->s_blocksize",
            "csum_size",
            "le32_to_cpu(((struct ext4_dir_entry_2 *)buf)->inode)",
            "1"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_dot_dotdot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2328-2354",
          "snippet": "struct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t  struct ext4_dir_entry_2 *de,\n\t\t\t  int blocksize, int csum_size,\n\t\t\t  unsigned int parent_ino, int dotdot_real_len)\n{\n\tde->inode = cpu_to_le32(inode->i_ino);\n\tde->name_len = 1;\n\tde->rec_len = ext4_rec_len_to_disk(EXT4_DIR_REC_LEN(de->name_len),\n\t\t\t\t\t   blocksize);\n\tstrcpy(de->name, \".\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\tde = ext4_next_entry(de, blocksize);\n\tde->inode = cpu_to_le32(parent_ino);\n\tde->name_len = 2;\n\tif (!dotdot_real_len)\n\t\tde->rec_len = ext4_rec_len_to_disk(blocksize -\n\t\t\t\t\t(csum_size + EXT4_DIR_REC_LEN(1)),\n\t\t\t\t\tblocksize);\n\telse\n\t\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tEXT4_DIR_REC_LEN(de->name_len), blocksize);\n\tstrcpy(de->name, \"..\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\treturn ext4_next_entry(de, blocksize);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);",
            "static struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nstruct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t  struct ext4_dir_entry_2 *de,\n\t\t\t  int blocksize, int csum_size,\n\t\t\t  unsigned int parent_ino, int dotdot_real_len)\n{\n\tde->inode = cpu_to_le32(inode->i_ino);\n\tde->name_len = 1;\n\tde->rec_len = ext4_rec_len_to_disk(EXT4_DIR_REC_LEN(de->name_len),\n\t\t\t\t\t   blocksize);\n\tstrcpy(de->name, \".\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\tde = ext4_next_entry(de, blocksize);\n\tde->inode = cpu_to_le32(parent_ino);\n\tde->name_len = 2;\n\tif (!dotdot_real_len)\n\t\tde->rec_len = ext4_rec_len_to_disk(blocksize -\n\t\t\t\t\t(csum_size + EXT4_DIR_REC_LEN(1)),\n\t\t\t\t\tblocksize);\n\telse\n\t\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tEXT4_DIR_REC_LEN(de->name_len), blocksize);\n\tstrcpy(de->name, \"..\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\treturn ext4_next_entry(de, blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "((struct ext4_dir_entry_2 *)buf)->inode"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nstatic int ext4_finish_convert_inline_dir(handle_t *handle,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  struct buffer_head *dir_block,\n\t\t\t\t\t  void *buf,\n\t\t\t\t\t  int inline_size)\n{\n\tint err, csum_size = 0, header_size = 0;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct ext4_dir_entry_tail *t;\n\tvoid *target = dir_block->b_data;\n\n\t/*\n\t * First create \".\" and \"..\" and then copy the dir information\n\t * back to the block.\n\t */\n\tde = (struct ext4_dir_entry_2 *)target;\n\tde = ext4_init_dot_dotdot(inode, de,\n\t\tinode->i_sb->s_blocksize, csum_size,\n\t\tle32_to_cpu(((struct ext4_dir_entry_2 *)buf)->inode), 1);\n\theader_size = (void *)de - target;\n\n\tmemcpy((void *)de, buf + EXT4_INLINE_DOTDOT_SIZE,\n\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tinode->i_size = inode->i_sb->s_blocksize;\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tEXT4_I(inode)->i_disksize = inode->i_sb->s_blocksize;\n\text4_update_final_de(dir_block->b_data,\n\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE + header_size,\n\t\t\tinode->i_sb->s_blocksize - csum_size);\n\n\tif (csum_size) {\n\t\tt = EXT4_DIRENT_TAIL(dir_block->b_data,\n\t\t\t\t     inode->i_sb->s_blocksize);\n\t\tinitialize_dirent_tail(t, inode->i_sb->s_blocksize);\n\t}\n\tset_buffer_uptodate(dir_block);\n\terr = ext4_handle_dirty_dirent_node(handle, inode, dir_block);\n\tif (err)\n\t\tgoto out;\n\tset_buffer_verified(dir_block);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_restore_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1102-1109",
    "snippet": "static void ext4_restore_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     void *buf, int inline_size)\n{\n\text4_create_inline_data(handle, inode, inline_size);\n\text4_write_inline_data(inode, iloc, buf, 0, inline_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_write_inline_data",
          "args": [
            "inode",
            "iloc",
            "buf",
            "0",
            "inline_size"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_write_inline_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "715-750",
          "snippet": "int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_create_inline_data",
          "args": [
            "handle",
            "inode",
            "inline_size"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_create_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "244-306",
          "snippet": "static int ext4_create_inline_data(handle_t *handle,\n\t\t\t\t   struct inode *inode, unsigned len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\tif (len > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tvalue = EXT4_ZERO_XATTR_VALUE;\n\t\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tvalue = \"\";\n\t\tlen = 0;\n\t}\n\n\t/* Insert the the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(!is.s.not_found);\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\text4_clear_inode_state(inode,\n\t\t\t\t\t       EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = len + EXT4_MIN_INLINE_DATA_SIZE;\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\text4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int ext4_create_inline_data(handle_t *handle,\n\t\t\t\t   struct inode *inode, unsigned len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\tif (len > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tvalue = EXT4_ZERO_XATTR_VALUE;\n\t\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tvalue = \"\";\n\t\tlen = 0;\n\t}\n\n\t/* Insert the the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(!is.s.not_found);\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\text4_clear_inode_state(inode,\n\t\t\t\t\t       EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = len + EXT4_MIN_INLINE_DATA_SIZE;\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\text4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_restore_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     void *buf, int inline_size)\n{\n\text4_create_inline_data(handle, inode, inline_size);\n\text4_write_inline_data(inode, iloc, buf, 0, inline_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n}"
  },
  {
    "function_name": "ext4_update_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1080-1100",
    "snippet": "static int ext4_update_inline_dir(handle_t *handle, struct inode *dir,\n\t\t\t\t  struct ext4_iloc *iloc)\n{\n\tint ret;\n\tint old_size = EXT4_I(dir)->i_inline_size - EXT4_MIN_INLINE_DATA_SIZE;\n\tint new_size = get_max_inline_xattr_value_size(dir, iloc);\n\n\tif (new_size - old_size <= EXT4_DIR_REC_LEN(1))\n\t\treturn -ENOSPC;\n\n\tret = ext4_update_inline_data(handle, dir,\n\t\t\t\t      new_size + EXT4_MIN_INLINE_DATA_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\text4_update_final_de(ext4_get_inline_xattr_pos(dir, iloc), old_size,\n\t\t\t     EXT4_I(dir)->i_inline_size -\n\t\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE);\n\tdir->i_size = EXT4_I(dir)->i_disksize = EXT4_I(dir)->i_inline_size;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "dir"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_final_de",
          "args": [
            "ext4_get_inline_xattr_pos(dir, iloc)",
            "old_size",
            "EXT4_I(dir)->i_inline_size -\n\t\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_final_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1055-1078",
          "snippet": "static void ext4_update_final_de(void *de_buf, int old_size, int new_size)\n{\n\tstruct ext4_dir_entry_2 *de, *prev_de;\n\tvoid *limit;\n\tint de_len;\n\n\tde = (struct ext4_dir_entry_2 *)de_buf;\n\tif (old_size) {\n\t\tlimit = de_buf + old_size;\n\t\tdo {\n\t\t\tprev_de = de;\n\t\t\tde_len = ext4_rec_len_from_disk(de->rec_len, old_size);\n\t\t\tde_buf += de_len;\n\t\t\tde = (struct ext4_dir_entry_2 *)de_buf;\n\t\t} while (de_buf < limit);\n\n\t\tprev_de->rec_len = ext4_rec_len_to_disk(de_len + new_size -\n\t\t\t\t\t\t\told_size, new_size);\n\t} else {\n\t\t/* this is just created, so create an empty entry. */\n\t\tde->inode = 0;\n\t\tde->rec_len = ext4_rec_len_to_disk(new_size, new_size);\n\t}\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_update_final_de(void *de_buf, int old_size, int new_size)\n{\n\tstruct ext4_dir_entry_2 *de, *prev_de;\n\tvoid *limit;\n\tint de_len;\n\n\tde = (struct ext4_dir_entry_2 *)de_buf;\n\tif (old_size) {\n\t\tlimit = de_buf + old_size;\n\t\tdo {\n\t\t\tprev_de = de;\n\t\t\tde_len = ext4_rec_len_from_disk(de->rec_len, old_size);\n\t\t\tde_buf += de_len;\n\t\t\tde = (struct ext4_dir_entry_2 *)de_buf;\n\t\t} while (de_buf < limit);\n\n\t\tprev_de->rec_len = ext4_rec_len_to_disk(de_len + new_size -\n\t\t\t\t\t\t\told_size, new_size);\n\t} else {\n\t\t/* this is just created, so create an empty entry. */\n\t\tde->inode = 0;\n\t\tde->rec_len = ext4_rec_len_to_disk(new_size, new_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_xattr_pos",
          "args": [
            "dir",
            "iloc"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_xattr_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1039-1052",
          "snippet": "static void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_inline_data",
          "args": [
            "handle",
            "dir",
            "new_size + EXT4_MIN_INLINE_DATA_SIZE"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "308-370",
          "snippet": "static int ext4_update_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t   unsigned int len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\t/* If the old space is ok, write the data directly. */\n\tif (len <= EXT4_I(inode)->i_inline_size)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(is.s.not_found);\n\n\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\tvalue = kzalloc(len, GFP_NOFS);\n\tif (!value)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t     value, len);\n\tif (error == -ENODATA)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\t/* Update the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tkfree(value);\n\tbrelse(is.iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int ext4_update_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t   unsigned int len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\t/* If the old space is ok, write the data directly. */\n\tif (len <= EXT4_I(inode)->i_inline_size)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(is.s.not_found);\n\n\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\tvalue = kzalloc(len, GFP_NOFS);\n\tif (!value)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t     value, len);\n\tif (error == -ENODATA)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\t/* Update the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tkfree(value);\n\tbrelse(is.iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_max_inline_xattr_value_size",
          "args": [
            "dir",
            "iloc"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "get_max_inline_xattr_value_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "33-88",
          "snippet": "static int get_max_inline_xattr_value_size(struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tint free, min_offs;\n\n\tmin_offs = EXT4_SB(inode->i_sb)->s_inode_size -\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE -\n\t\t\tEXT4_I(inode)->i_extra_isize -\n\t\t\tsizeof(struct ext4_xattr_ibody_header);\n\n\t/*\n\t * We need to subtract another sizeof(__u32) since an in-inode xattr\n\t * needs an empty 4 bytes to indicate the gap between the xattr entry\n\t * and the name/value pair.\n\t */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn EXT4_XATTR_SIZE(min_offs -\n\t\t\tEXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) -\n\t\t\tEXT4_XATTR_ROUND - sizeof(__u32));\n\n\traw_inode = ext4_raw_inode(iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\n\t/* Compute min_offs. */\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_block && entry->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(entry->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs -\n\t\t((void *)entry - (void *)IFIRST(header)) - sizeof(__u32);\n\n\tif (EXT4_I(inode)->i_inline_off) {\n\t\tentry = (struct ext4_xattr_entry *)\n\t\t\t((void *)raw_inode + EXT4_I(inode)->i_inline_off);\n\n\t\tfree += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size));\n\t\tgoto out;\n\t}\n\n\tfree -= EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA));\n\n\tif (free > EXT4_XATTR_ROUND)\n\t\tfree = EXT4_XATTR_SIZE(free - EXT4_XATTR_ROUND);\n\telse\n\t\tfree = 0;\n\nout:\n\treturn free;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int get_max_inline_xattr_value_size(struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tint free, min_offs;\n\n\tmin_offs = EXT4_SB(inode->i_sb)->s_inode_size -\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE -\n\t\t\tEXT4_I(inode)->i_extra_isize -\n\t\t\tsizeof(struct ext4_xattr_ibody_header);\n\n\t/*\n\t * We need to subtract another sizeof(__u32) since an in-inode xattr\n\t * needs an empty 4 bytes to indicate the gap between the xattr entry\n\t * and the name/value pair.\n\t */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn EXT4_XATTR_SIZE(min_offs -\n\t\t\tEXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) -\n\t\t\tEXT4_XATTR_ROUND - sizeof(__u32));\n\n\traw_inode = ext4_raw_inode(iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\n\t/* Compute min_offs. */\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_block && entry->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(entry->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs -\n\t\t((void *)entry - (void *)IFIRST(header)) - sizeof(__u32);\n\n\tif (EXT4_I(inode)->i_inline_off) {\n\t\tentry = (struct ext4_xattr_entry *)\n\t\t\t((void *)raw_inode + EXT4_I(inode)->i_inline_off);\n\n\t\tfree += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size));\n\t\tgoto out;\n\t}\n\n\tfree -= EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA));\n\n\tif (free > EXT4_XATTR_ROUND)\n\t\tfree = EXT4_XATTR_SIZE(free - EXT4_XATTR_ROUND);\n\telse\n\t\tfree = 0;\n\nout:\n\treturn free;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstatic int ext4_update_inline_dir(handle_t *handle, struct inode *dir,\n\t\t\t\t  struct ext4_iloc *iloc)\n{\n\tint ret;\n\tint old_size = EXT4_I(dir)->i_inline_size - EXT4_MIN_INLINE_DATA_SIZE;\n\tint new_size = get_max_inline_xattr_value_size(dir, iloc);\n\n\tif (new_size - old_size <= EXT4_DIR_REC_LEN(1))\n\t\treturn -ENOSPC;\n\n\tret = ext4_update_inline_data(handle, dir,\n\t\t\t\t      new_size + EXT4_MIN_INLINE_DATA_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\text4_update_final_de(ext4_get_inline_xattr_pos(dir, iloc), old_size,\n\t\t\t     EXT4_I(dir)->i_inline_size -\n\t\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE);\n\tdir->i_size = EXT4_I(dir)->i_disksize = EXT4_I(dir)->i_inline_size;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_update_final_de",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1055-1078",
    "snippet": "static void ext4_update_final_de(void *de_buf, int old_size, int new_size)\n{\n\tstruct ext4_dir_entry_2 *de, *prev_de;\n\tvoid *limit;\n\tint de_len;\n\n\tde = (struct ext4_dir_entry_2 *)de_buf;\n\tif (old_size) {\n\t\tlimit = de_buf + old_size;\n\t\tdo {\n\t\t\tprev_de = de;\n\t\t\tde_len = ext4_rec_len_from_disk(de->rec_len, old_size);\n\t\t\tde_buf += de_len;\n\t\t\tde = (struct ext4_dir_entry_2 *)de_buf;\n\t\t} while (de_buf < limit);\n\n\t\tprev_de->rec_len = ext4_rec_len_to_disk(de_len + new_size -\n\t\t\t\t\t\t\told_size, new_size);\n\t} else {\n\t\t/* this is just created, so create an empty entry. */\n\t\tde->inode = 0;\n\t\tde->rec_len = ext4_rec_len_to_disk(new_size, new_size);\n\t}\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_rec_len_to_disk",
          "args": [
            "new_size",
            "new_size"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1717-1734",
          "snippet": "static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "old_size"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_update_final_de(void *de_buf, int old_size, int new_size)\n{\n\tstruct ext4_dir_entry_2 *de, *prev_de;\n\tvoid *limit;\n\tint de_len;\n\n\tde = (struct ext4_dir_entry_2 *)de_buf;\n\tif (old_size) {\n\t\tlimit = de_buf + old_size;\n\t\tdo {\n\t\t\tprev_de = de;\n\t\t\tde_len = ext4_rec_len_from_disk(de->rec_len, old_size);\n\t\t\tde_buf += de_len;\n\t\t\tde = (struct ext4_dir_entry_2 *)de_buf;\n\t\t} while (de_buf < limit);\n\n\t\tprev_de->rec_len = ext4_rec_len_to_disk(de_len + new_size -\n\t\t\t\t\t\t\told_size, new_size);\n\t} else {\n\t\t/* this is just created, so create an empty entry. */\n\t\tde->inode = 0;\n\t\tde->rec_len = ext4_rec_len_to_disk(new_size, new_size);\n\t}\n}"
  },
  {
    "function_name": "ext4_get_inline_xattr_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "1039-1052",
    "snippet": "static void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "iloc"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "ext4_raw_inode(iloc)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!EXT4_I(inode)->i_inline_off"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}"
  },
  {
    "function_name": "ext4_add_dirent_to_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "995-1037",
    "snippet": "static int ext4_add_dirent_to_inline(handle_t *handle,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     void *inline_start, int inline_size)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tint\t\terr;\n\tstruct ext4_dir_entry_2 *de;\n\n\terr = ext4_find_dest_de(dir, inode, iloc->bh,\n\t\t\t\tinline_start, inline_size,\n\t\t\t\tname, namelen, &de);\n\tif (err)\n\t\treturn err;\n\n\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\tif (err)\n\t\treturn err;\n\text4_insert_dentry(inode, de, inline_size, name, namelen);\n\n\text4_show_inline_dir(dir, iloc->bh, inline_start, inline_size);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "dir"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_dx_flag",
          "args": [
            "dir"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_dx_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2026-2031",
          "snippet": "static inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n\nstatic inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "dir"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_show_inline_dir",
          "args": [
            "dir",
            "iloc->bh",
            "inline_start",
            "inline_size"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_show_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "963-985",
          "snippet": "void ext4_show_inline_dir(struct inode *dir, struct buffer_head *bh,\n\t\t\t  void *inline_start, int inline_size)\n{\n\tint offset;\n\tunsigned short de_len;\n\tstruct ext4_dir_entry_2 *de = inline_start;\n\tvoid *dlimit = inline_start + inline_size;\n\n\ttrace_printk(\"inode %lu\\n\", dir->i_ino);\n\toffset = 0;\n\twhile ((void *)de < dlimit) {\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\ttrace_printk(\"de: off %u rlen %u name %*.s nlen %u ino %u\\n\",\n\t\t\t     offset, de_len, de->name_len, de->name,\n\t\t\t     de->name_len, le32_to_cpu(de->inode));\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t inline_start, inline_size, offset))\n\t\t\tBUG();\n\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_show_inline_dir(struct inode *dir, struct buffer_head *bh,\n\t\t\t  void *inline_start, int inline_size)\n{\n\tint offset;\n\tunsigned short de_len;\n\tstruct ext4_dir_entry_2 *de = inline_start;\n\tvoid *dlimit = inline_start + inline_size;\n\n\ttrace_printk(\"inode %lu\\n\", dir->i_ino);\n\toffset = 0;\n\twhile ((void *)de < dlimit) {\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\ttrace_printk(\"de: off %u rlen %u name %*.s nlen %u ino %u\\n\",\n\t\t\t     offset, de_len, de->name_len, de->name,\n\t\t\t     de->name_len, le32_to_cpu(de->inode));\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t inline_start, inline_size, offset))\n\t\t\tBUG();\n\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_insert_dentry",
          "args": [
            "inode",
            "de",
            "inline_size",
            "name",
            "namelen"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_insert_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1644-1666",
          "snippet": "void ext4_insert_dentry(struct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tconst char *name, int namelen)\n{\n\n\tint nlen, rlen;\n\n\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\tif (de->inode) {\n\t\tstruct ext4_dir_entry_2 *de1 =\n\t\t\t\t(struct ext4_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext4_rec_len_to_disk(rlen - nlen, buf_size);\n\t\tde->rec_len = ext4_rec_len_to_disk(nlen, buf_size);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT4_FT_UNKNOWN;\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text4_set_de_type(inode->i_sb, de, inode->i_mode);\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nvoid ext4_insert_dentry(struct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tconst char *name, int namelen)\n{\n\n\tint nlen, rlen;\n\n\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\tif (de->inode) {\n\t\tstruct ext4_dir_entry_2 *de1 =\n\t\t\t\t(struct ext4_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext4_rec_len_to_disk(rlen - nlen, buf_size);\n\t\tde->rec_len = ext4_rec_len_to_disk(nlen, buf_size);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT4_FT_UNKNOWN;\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text4_set_de_type(inode->i_sb, de, inode->i_mode);\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "iloc->bh"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "iloc->bh",
            "\"get_write_access\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_dest_de",
          "args": [
            "dir",
            "inode",
            "iloc->bh",
            "inline_start",
            "inline_size",
            "name",
            "namelen",
            "&de"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_dest_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "1610-1642",
          "snippet": "int ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t      struct buffer_head *bh,\n\t\t      void *buf, int buf_size,\n\t\t      const char *name, int namelen,\n\t\t      struct ext4_dir_entry_2 **dest_de)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tunsigned short reclen = EXT4_DIR_REC_LEN(namelen);\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size - reclen;\n\twhile ((char *) de <= top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EIO;\n\t\tif (ext4_match(namelen, name, de))\n\t\t\treturn -EEXIST;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tif ((de->inode ? rlen - nlen : rlen) >= reclen)\n\t\t\tbreak;\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -ENOSPC;\n\n\t*dest_de = de;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_node_limit(struct inode *dir);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t      struct buffer_head *bh,\n\t\t      void *buf, int buf_size,\n\t\t      const char *name, int namelen,\n\t\t      struct ext4_dir_entry_2 **dest_de)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tunsigned short reclen = EXT4_DIR_REC_LEN(namelen);\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size - reclen;\n\twhile ((char *) de <= top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EIO;\n\t\tif (ext4_match(namelen, name, de))\n\t\t\treturn -EEXIST;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tif ((de->inode ? rlen - nlen : rlen) >= reclen)\n\t\t\tbreak;\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -ENOSPC;\n\n\t*dest_de = de;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_add_dirent_to_inline(handle_t *handle,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     void *inline_start, int inline_size)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tint\t\terr;\n\tstruct ext4_dir_entry_2 *de;\n\n\terr = ext4_find_dest_de(dir, inode, iloc->bh,\n\t\t\t\tinline_start, inline_size,\n\t\t\t\tname, namelen, &de);\n\tif (err)\n\t\treturn err;\n\n\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\tif (err)\n\t\treturn err;\n\text4_insert_dentry(inode, de, inline_size, name, namelen);\n\n\text4_show_inline_dir(dir, iloc->bh, inline_start, inline_size);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = ext4_current_time(dir);\n\text4_update_dx_flag(dir);\n\tdir->i_version++;\n\text4_mark_inode_dirty(handle, dir);\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_show_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "963-985",
    "snippet": "void ext4_show_inline_dir(struct inode *dir, struct buffer_head *bh,\n\t\t\t  void *inline_start, int inline_size)\n{\n\tint offset;\n\tunsigned short de_len;\n\tstruct ext4_dir_entry_2 *de = inline_start;\n\tvoid *dlimit = inline_start + inline_size;\n\n\ttrace_printk(\"inode %lu\\n\", dir->i_ino);\n\toffset = 0;\n\twhile ((void *)de < dlimit) {\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\ttrace_printk(\"de: off %u rlen %u name %*.s nlen %u ino %u\\n\",\n\t\t\t     offset, de_len, de->name_len, de->name,\n\t\t\t     de->name_len, le32_to_cpu(de->inode));\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t inline_start, inline_size, offset))\n\t\t\tBUG();\n\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "dir",
            "NULL",
            "de",
            "bh",
            "inline_start",
            "inline_size",
            "offset"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_printk",
          "args": [
            "\"de: off %u rlen %u name %*.s nlen %u ino %u\\n\"",
            "offset",
            "de_len",
            "de->name_len",
            "de->name",
            "de->name_len",
            "le32_to_cpu(de->inode)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "inline_size"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_printk",
          "args": [
            "\"inode %lu\\n\"",
            "dir->i_ino"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_show_inline_dir(struct inode *dir, struct buffer_head *bh,\n\t\t\t  void *inline_start, int inline_size)\n{\n\tint offset;\n\tunsigned short de_len;\n\tstruct ext4_dir_entry_2 *de = inline_start;\n\tvoid *dlimit = inline_start + inline_size;\n\n\ttrace_printk(\"inode %lu\\n\", dir->i_ino);\n\toffset = 0;\n\twhile ((void *)de < dlimit) {\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\ttrace_printk(\"de: off %u rlen %u name %*.s nlen %u ino %u\\n\",\n\t\t\t     offset, de_len, de->name_len, de->name,\n\t\t\t     de->name_len, le32_to_cpu(de->inode));\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t inline_start, inline_size, offset))\n\t\t\tBUG();\n\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n}"
  },
  {
    "function_name": "ext4_da_write_inline_data_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "928-960",
    "snippet": "int ext4_da_write_inline_data_end(struct inode *inode, loff_t pos,\n\t\t\t\t  unsigned len, unsigned copied,\n\t\t\t\t  struct page *page)\n{\n\tint i_size_changed = 0;\n\n\tcopied = ext4_write_inline_data_end(inode, pos, len, copied, page);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos+copied"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_write_inline_data_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied",
            "page"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_write_inline_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "715-750",
          "snippet": "int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_da_write_inline_data_end(struct inode *inode, loff_t pos,\n\t\t\t\t  unsigned len, unsigned copied,\n\t\t\t\t  struct page *page)\n{\n\tint i_size_changed = 0;\n\n\tcopied = ext4_write_inline_data_end(inode, pos, len, copied, page);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
  },
  {
    "function_name": "ext4_da_write_inline_data_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "843-926",
    "snippet": "int ext4_da_write_inline_data_begin(struct address_space *mapping,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    loff_t pos, unsigned len,\n\t\t\t\t    unsigned flags,\n\t\t\t\t    struct page **pagep,\n\t\t\t\t    void **fsdata)\n{\n\tint ret, inline_size;\n\thandle_t *handle;\n\tstruct page *page;\n\tstruct ext4_iloc iloc;\n\tint retries;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_max_inline_size(inode);\n\n\tret = -ENOSPC;\n\tif (inline_size >= pos + len) {\n\t\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out_journal;\n\t}\n\n\t/*\n\t * We cannot recurse into the filesystem as the transaction\n\t * is already started.\n\t */\n\tflags |= AOP_FLAG_NOFS;\n\n\tif (ret == -ENOSPC) {\n\t\tret = ext4_da_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t    flags,\n\t\t\t\t\t\t\t    fsdata);\n\t\text4_journal_stop(handle);\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tgoto out;\n\t}\n\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_journal;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out_release_page;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out_release_page;\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\t*pagep = page;\n\tbrelse(iloc.bh);\n\treturn 1;\nout_release_page:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tunlock_page(page);\n\tpage_cache_release(page);\nout_journal:\n\text4_journal_stop(handle);\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_inline_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_inline_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "458-490",
          "snippet": "static int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "0",
            "flags"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_da_convert_inline_data_to_extent",
          "args": [
            "mapping",
            "inode",
            "flags",
            "fsdata"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_convert_inline_data_to_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "785-833",
          "snippet": "static int ext4_da_convert_inline_data_to_extent(struct address_space *mapping,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t unsigned flags,\n\t\t\t\t\t\t void **fsdata)\n{\n\tint ret = 0, inline_size;\n\tstruct page *page;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __block_write_begin(page, 0, inline_size,\n\t\t\t\t  ext4_da_get_block_prep);\n\tif (ret) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\text4_truncate_failed_write(inode);\n\t\treturn ret;\n\t}\n\n\tSetPageDirty(page);\n\tSetPageUptodate(page);\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t*fsdata = (void *)CONVERT_INLINE_DATA;\n\nout:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_da_convert_inline_data_to_extent(struct address_space *mapping,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t unsigned flags,\n\t\t\t\t\t\t void **fsdata)\n{\n\tint ret = 0, inline_size;\n\tstruct page *page;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __block_write_begin(page, 0, inline_size,\n\t\t\t\t  ext4_da_get_block_prep);\n\tif (ret) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\text4_truncate_failed_write(inode);\n\t\treturn ret;\n\t}\n\n\tSetPageDirty(page);\n\tSetPageUptodate(page);\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t*fsdata = (void *)CONVERT_INLINE_DATA;\n\nout:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_prepare_inline_data",
          "args": [
            "handle",
            "inode",
            "pos + len"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_prepare_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "372-395",
          "snippet": "static int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int len)\n{\n\tint ret, size;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\t\treturn -ENOSPC;\n\n\tsize = ext4_get_max_inline_size(inode);\n\tif (size < len)\n\t\treturn -ENOSPC;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\n\tif (ei->i_inline_off)\n\t\tret = ext4_update_inline_data(handle, inode, len);\n\telse\n\t\tret = ext4_create_inline_data(handle, inode, len);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int len)\n{\n\tint ret, size;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\t\treturn -ENOSPC;\n\n\tsize = ext4_get_max_inline_size(inode);\n\tif (size < len)\n\t\treturn -ENOSPC;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\n\tif (ei->i_inline_off)\n\t\tret = ext4_update_inline_data(handle, inode, len);\n\telse\n\t\tret = ext4_create_inline_data(handle, inode, len);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_max_inline_size",
          "args": [
            "inode"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_max_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "95-121",
          "snippet": "int ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode(inode, __func__, __LINE__, 0,\n\t\t\t\t \"can't get inode location %lu\",\n\t\t\t\t inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode(inode, __func__, __LINE__, 0,\n\t\t\t\t \"can't get inode location %lu\",\n\t\t\t\t inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_INODE",
            "1"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_da_write_inline_data_begin(struct address_space *mapping,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    loff_t pos, unsigned len,\n\t\t\t\t    unsigned flags,\n\t\t\t\t    struct page **pagep,\n\t\t\t\t    void **fsdata)\n{\n\tint ret, inline_size;\n\thandle_t *handle;\n\tstruct page *page;\n\tstruct ext4_iloc iloc;\n\tint retries;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_max_inline_size(inode);\n\n\tret = -ENOSPC;\n\tif (inline_size >= pos + len) {\n\t\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out_journal;\n\t}\n\n\t/*\n\t * We cannot recurse into the filesystem as the transaction\n\t * is already started.\n\t */\n\tflags |= AOP_FLAG_NOFS;\n\n\tif (ret == -ENOSPC) {\n\t\tret = ext4_da_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t    flags,\n\t\t\t\t\t\t\t    fsdata);\n\t\text4_journal_stop(handle);\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tgoto out;\n\t}\n\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_journal;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out_release_page;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out_release_page;\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\t*pagep = page;\n\tbrelse(iloc.bh);\n\treturn 1;\nout_release_page:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tunlock_page(page);\n\tpage_cache_release(page);\nout_journal:\n\text4_journal_stop(handle);\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_da_convert_inline_data_to_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "785-833",
    "snippet": "static int ext4_da_convert_inline_data_to_extent(struct address_space *mapping,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t unsigned flags,\n\t\t\t\t\t\t void **fsdata)\n{\n\tint ret = 0, inline_size;\n\tstruct page *page;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __block_write_begin(page, 0, inline_size,\n\t\t\t\t  ext4_da_get_block_prep);\n\tif (ret) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\text4_truncate_failed_write(inode);\n\t\treturn ret;\n\t}\n\n\tSetPageDirty(page);\n\tSetPageUptodate(page);\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t*fsdata = (void *)CONVERT_INLINE_DATA;\n\nout:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "page"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "11-15",
          "snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "0",
            "inline_size",
            "ext4_da_get_block_prep"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_read_inline_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_inline_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "458-490",
          "snippet": "static int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "inode"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "0",
            "flags"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_da_convert_inline_data_to_extent(struct address_space *mapping,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t unsigned flags,\n\t\t\t\t\t\t void **fsdata)\n{\n\tint ret = 0, inline_size;\n\tstruct page *page;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __block_write_begin(page, 0, inline_size,\n\t\t\t\t  ext4_da_get_block_prep);\n\tif (ret) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\text4_truncate_failed_write(inode);\n\t\treturn ret;\n\t}\n\n\tSetPageDirty(page);\n\tSetPageUptodate(page);\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t*fsdata = (void *)CONVERT_INLINE_DATA;\n\nout:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_journalled_write_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "752-774",
    "snippet": "struct buffer_head *\next4_journalled_write_inline_data(struct inode *inode,\n\t\t\t\t  unsigned len,\n\t\t\t\t  struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\treturn NULL;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, 0, len);\n\tkunmap_atomic(kaddr);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn iloc.bh;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_write_inline_data",
          "args": [
            "inode",
            "&iloc",
            "kaddr",
            "0",
            "len"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_write_inline_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "715-750",
          "snippet": "int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "ret"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstruct buffer_head *\next4_journalled_write_inline_data(struct inode *inode,\n\t\t\t\t  unsigned len,\n\t\t\t\t  struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\treturn NULL;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, 0, len);\n\tkunmap_atomic(kaddr);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn iloc.bh;\n}"
  },
  {
    "function_name": "ext4_write_inline_data_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "715-750",
    "snippet": "int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageDirty",
          "args": [
            "page"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_write_inline_data",
          "args": [
            "inode",
            "&iloc",
            "kaddr",
            "pos",
            "len"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_write_inline_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "715-750",
          "snippet": "int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ext4_has_inline_data(inode)"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "ret"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied < len"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}"
  },
  {
    "function_name": "ext4_try_to_write_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "638-713",
    "snippet": "int ext4_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  loff_t pos, unsigned len,\n\t\t\t\t  unsigned flags,\n\t\t\t\t  struct page **pagep)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct page *page;\n\tstruct ext4_iloc iloc;\n\n\tif (pos + len > ext4_get_max_inline_size(inode))\n\t\tgoto convert;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * The possible write could happen in the inode,\n\t * so try to reserve the space in inode first.\n\t */\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto out;\n\t}\n\n\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\tif (ret && ret != -ENOSPC)\n\t\tgoto out;\n\n\t/* We don't have space in inline inode, so convert it to extent. */\n\tif (ret == -ENOSPC) {\n\t\text4_journal_stop(handle);\n\t\tbrelse(iloc.bh);\n\t\tgoto convert;\n\t}\n\n\tflags |= AOP_FLAG_NOFS;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*pagep = page;\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tgoto out_up_read;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out_up_read;\n\t}\n\n\tret = 1;\n\thandle = NULL;\nout_up_read:\n\tup_read(&EXT4_I(inode)->xattr_sem);\nout:\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tbrelse(iloc.bh);\n\treturn ret;\nconvert:\n\treturn ext4_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t  inode, flags);\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_convert_inline_data_to_extent",
          "args": [
            "mapping",
            "inode",
            "flags"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_convert_inline_data_to_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "519-630",
          "snippet": "static int ext4_convert_inline_data_to_extent(struct address_space *mapping,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      unsigned flags)\n{\n\tint ret, needed_blocks;\n\thandle_t *handle = NULL;\n\tint retries = 0, sem_held = 0;\n\tstruct page *page = NULL;\n\tunsigned from, to;\n\tstruct ext4_iloc iloc;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\t/*\n\t\t * clear the flag so that no new write\n\t\t * will trap here again.\n\t\t */\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\treturn 0;\n\t}\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto out;\n\t}\n\n\t/* We cannot recurse into the filesystem as the transaction is already\n\t * started */\n\tflags |= AOP_FLAG_NOFS;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tsem_held = 1;\n\t/* If some one has already done this for us, just exit. */\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfrom = 0;\n\tto = ext4_get_inline_size(inode);\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (ret)\n\t\tgoto out;\n\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = __block_write_begin(page, from, to, ext4_get_block_write);\n\telse\n\t\tret = __block_write_begin(page, from, to, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t     from, to, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\text4_orphan_add(handle, inode);\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\t\tsem_held = 0;\n\t\text4_journal_stop(handle);\n\t\thandle = NULL;\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might\n\t\t * still be on the orphan list; we need to\n\t\t * make sure the inode is removed from the\n\t\t * orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (page)\n\t\tblock_commit_write(page, from, to);\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (sem_held)\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_convert_inline_data_to_extent(struct address_space *mapping,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      unsigned flags)\n{\n\tint ret, needed_blocks;\n\thandle_t *handle = NULL;\n\tint retries = 0, sem_held = 0;\n\tstruct page *page = NULL;\n\tunsigned from, to;\n\tstruct ext4_iloc iloc;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\t/*\n\t\t * clear the flag so that no new write\n\t\t * will trap here again.\n\t\t */\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\treturn 0;\n\t}\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto out;\n\t}\n\n\t/* We cannot recurse into the filesystem as the transaction is already\n\t * started */\n\tflags |= AOP_FLAG_NOFS;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tsem_held = 1;\n\t/* If some one has already done this for us, just exit. */\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfrom = 0;\n\tto = ext4_get_inline_size(inode);\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (ret)\n\t\tgoto out;\n\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = __block_write_begin(page, from, to, ext4_get_block_write);\n\telse\n\t\tret = __block_write_begin(page, from, to, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t     from, to, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\text4_orphan_add(handle, inode);\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\t\tsem_held = 0;\n\t\text4_journal_stop(handle);\n\t\thandle = NULL;\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might\n\t\t * still be on the orphan list; we need to\n\t\t * make sure the inode is removed from the\n\t\t * orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (page)\n\t\tblock_commit_write(page, from, to);\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (sem_held)\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_read_inline_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_inline_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "458-490",
          "snippet": "static int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "0",
            "flags"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_prepare_inline_data",
          "args": [
            "handle",
            "inode",
            "pos + len"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_prepare_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "372-395",
          "snippet": "static int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int len)\n{\n\tint ret, size;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\t\treturn -ENOSPC;\n\n\tsize = ext4_get_max_inline_size(inode);\n\tif (size < len)\n\t\treturn -ENOSPC;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\n\tif (ei->i_inline_off)\n\t\tret = ext4_update_inline_data(handle, inode, len);\n\telse\n\t\tret = ext4_create_inline_data(handle, inode, len);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int len)\n{\n\tint ret, size;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\t\treturn -ENOSPC;\n\n\tsize = ext4_get_max_inline_size(inode);\n\tif (size < len)\n\t\treturn -ENOSPC;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\n\tif (ei->i_inline_off)\n\t\tret = ext4_update_inline_data(handle, inode, len);\n\telse\n\t\tret = ext4_create_inline_data(handle, inode, len);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_INODE",
            "1"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_max_inline_size",
          "args": [
            "inode"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_max_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "95-121",
          "snippet": "int ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode(inode, __func__, __LINE__, 0,\n\t\t\t\t \"can't get inode location %lu\",\n\t\t\t\t inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode(inode, __func__, __LINE__, 0,\n\t\t\t\t \"can't get inode location %lu\",\n\t\t\t\t inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  loff_t pos, unsigned len,\n\t\t\t\t  unsigned flags,\n\t\t\t\t  struct page **pagep)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct page *page;\n\tstruct ext4_iloc iloc;\n\n\tif (pos + len > ext4_get_max_inline_size(inode))\n\t\tgoto convert;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * The possible write could happen in the inode,\n\t * so try to reserve the space in inode first.\n\t */\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto out;\n\t}\n\n\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\tif (ret && ret != -ENOSPC)\n\t\tgoto out;\n\n\t/* We don't have space in inline inode, so convert it to extent. */\n\tif (ret == -ENOSPC) {\n\t\text4_journal_stop(handle);\n\t\tbrelse(iloc.bh);\n\t\tgoto convert;\n\t}\n\n\tflags |= AOP_FLAG_NOFS;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*pagep = page;\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tgoto out_up_read;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out_up_read;\n\t}\n\n\tret = 1;\n\thandle = NULL;\nout_up_read:\n\tup_read(&EXT4_I(inode)->xattr_sem);\nout:\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tbrelse(iloc.bh);\n\treturn ret;\nconvert:\n\treturn ext4_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t  inode, flags);\n}"
  },
  {
    "function_name": "ext4_convert_inline_data_to_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "519-630",
    "snippet": "static int ext4_convert_inline_data_to_extent(struct address_space *mapping,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      unsigned flags)\n{\n\tint ret, needed_blocks;\n\thandle_t *handle = NULL;\n\tint retries = 0, sem_held = 0;\n\tstruct page *page = NULL;\n\tunsigned from, to;\n\tstruct ext4_iloc iloc;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\t/*\n\t\t * clear the flag so that no new write\n\t\t * will trap here again.\n\t\t */\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\treturn 0;\n\t}\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto out;\n\t}\n\n\t/* We cannot recurse into the filesystem as the transaction is already\n\t * started */\n\tflags |= AOP_FLAG_NOFS;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tsem_held = 1;\n\t/* If some one has already done this for us, just exit. */\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfrom = 0;\n\tto = ext4_get_inline_size(inode);\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (ret)\n\t\tgoto out;\n\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = __block_write_begin(page, from, to, ext4_get_block_write);\n\telse\n\t\tret = __block_write_begin(page, from, to, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t     from, to, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\text4_orphan_add(handle, inode);\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\t\tsem_held = 0;\n\t\text4_journal_stop(handle);\n\t\thandle = NULL;\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might\n\t\t * still be on the orphan list; we need to\n\t\t * make sure the inode is removed from the\n\t\t * orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (page)\n\t\tblock_commit_write(page, from, to);\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (sem_held)\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_commit_write",
          "args": [
            "page",
            "from",
            "to"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "block_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2376-2381",
          "snippet": "int block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "NULL",
            "inode"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "11-15",
          "snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "from",
            "to",
            "NULL",
            "do_journal_get_write_access"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "809-838",
          "snippet": "int ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "from",
            "to",
            "ext4_get_block"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_dioread_nolock",
          "args": [
            "inode"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_dioread_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "437-448",
          "snippet": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_destroy_inline_data_nolock",
          "args": [
            "handle",
            "inode"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_destroy_inline_data_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "397-456",
          "snippet": "static int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_read_inline_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_inline_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "458-490",
          "snippet": "static int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "inode"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "0",
            "flags"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_WRITE_PAGE",
            "needed_blocks"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4769-4780",
          "snippet": "int ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_convert_inline_data_to_extent(struct address_space *mapping,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      unsigned flags)\n{\n\tint ret, needed_blocks;\n\thandle_t *handle = NULL;\n\tint retries = 0, sem_held = 0;\n\tstruct page *page = NULL;\n\tunsigned from, to;\n\tstruct ext4_iloc iloc;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\t/*\n\t\t * clear the flag so that no new write\n\t\t * will trap here again.\n\t\t */\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\treturn 0;\n\t}\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto out;\n\t}\n\n\t/* We cannot recurse into the filesystem as the transaction is already\n\t * started */\n\tflags |= AOP_FLAG_NOFS;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tsem_held = 1;\n\t/* If some one has already done this for us, just exit. */\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfrom = 0;\n\tto = ext4_get_inline_size(inode);\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (ret)\n\t\tgoto out;\n\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = __block_write_begin(page, from, to, ext4_get_block_write);\n\telse\n\t\tret = __block_write_begin(page, from, to, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t     from, to, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\text4_orphan_add(handle, inode);\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\t\tsem_held = 0;\n\t\text4_journal_stop(handle);\n\t\thandle = NULL;\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might\n\t\t * still be on the orphan list; we need to\n\t\t * make sure the inode is removed from the\n\t\t * orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (page)\n\t\tblock_commit_write(page, from, to);\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (sem_held)\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_readpage_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "492-517",
    "snippet": "int ext4_readpage_inline(struct inode *inode, struct page *page)\n{\n\tint ret = 0;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Current inline data can only exist in the 1st page,\n\t * So for all the other pages, just set them uptodate.\n\t */\n\tif (!page->index)\n\t\tret = ext4_read_inline_page(inode, page);\n\telse if (!PageUptodate(page)) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tunlock_page(page);\n\treturn ret >= 0 ? 0 : ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_inline_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_inline_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "458-490",
          "snippet": "static int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_readpage_inline(struct inode *inode, struct page *page)\n{\n\tint ret = 0;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Current inline data can only exist in the 1st page,\n\t * So for all the other pages, just set them uptodate.\n\t */\n\tif (!page->index)\n\t\tret = ext4_read_inline_page(inode, page);\n\telse if (!PageUptodate(page)) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tunlock_page(page);\n\treturn ret >= 0 ? 0 : ret;\n}"
  },
  {
    "function_name": "ext4_read_inline_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "458-490",
    "snippet": "static int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_read_inline_data",
          "args": [
            "inode",
            "kaddr",
            "len",
            "&iloc"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "162-200",
          "snippet": "static int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\tlen : EXT4_MIN_INLINE_DATA_SIZE;\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstatic int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\tlen : EXT4_MIN_INLINE_DATA_SIZE;\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "ext4_get_inline_size(inode)",
            "i_size_read(inode)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inline_size",
          "args": [
            "inode"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "25-31",
          "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"inode %lu doesn't have inline data.\"",
            "inode->i_ino"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->index"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ext4_has_inline_data(inode)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_read_inline_page(struct inode *inode, struct page *page)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(page->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tkaddr = kmap_atomic(page);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_destroy_inline_data_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "397-456",
    "snippet": "static int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
      "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "is.iloc.bh"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&is.iloc"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4800-4815",
          "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "is.iloc.bh"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_INLINE_DATA"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_tree_init",
          "args": [
            "handle",
            "inode"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "844-855",
          "snippet": "int ext4_ext_tree_init(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_extent_header *eh;\n\n\teh = ext_inode_hdr(inode);\n\teh->eh_depth = 0;\n\teh->eh_entries = 0;\n\teh->eh_magic = EXT4_EXT_MAGIC;\n\teh->eh_max = cpu_to_le16(ext4_ext_space_root(inode, 0));\n\text4_mark_inode_dirty(handle, inode);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_ext_tree_init(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_extent_header *eh;\n\n\teh = ext_inode_hdr(inode);\n\teh->eh_depth = 0;\n\teh->eh_entries = 0;\n\teh->eh_magic = EXT4_EXT_MAGIC;\n\teh->eh_max = cpu_to_le16(ext4_ext_space_root(inode, 0));\n\text4_mark_inode_dirty(handle, inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT4_FEATURE_INCOMPAT_EXTENTS"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)ext4_raw_inode(&is.iloc)->i_block",
            "0",
            "EXT4_MIN_INLINE_DATA_SIZE"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&is.iloc"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_inline_set",
          "args": [
            "handle",
            "inode",
            "&i",
            "&is"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_inline_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1011-1047",
          "snippet": "int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error) {\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_has_inline_data(inode)) {\n\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,\n\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_ibody_find(inode, i, is);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error) {\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_has_inline_data(inode)) {\n\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,\n\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_ibody_find(inode, i, is);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "is.iloc.bh"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "is.iloc.bh",
            "\"get_write_access\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_find",
          "args": [
            "inode",
            "&i",
            "&is"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "981-1009",
          "snippet": "int ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&is.iloc"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_prepare_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "372-395",
    "snippet": "static int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int len)\n{\n\tint ret, size;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\t\treturn -ENOSPC;\n\n\tsize = ext4_get_max_inline_size(inode);\n\tif (size < len)\n\t\treturn -ENOSPC;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\n\tif (ei->i_inline_off)\n\t\tret = ext4_update_inline_data(handle, inode, len);\n\telse\n\t\tret = ext4_create_inline_data(handle, inode, len);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_create_inline_data",
          "args": [
            "handle",
            "inode",
            "len"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_create_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "244-306",
          "snippet": "static int ext4_create_inline_data(handle_t *handle,\n\t\t\t\t   struct inode *inode, unsigned len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\tif (len > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tvalue = EXT4_ZERO_XATTR_VALUE;\n\t\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tvalue = \"\";\n\t\tlen = 0;\n\t}\n\n\t/* Insert the the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(!is.s.not_found);\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\text4_clear_inode_state(inode,\n\t\t\t\t\t       EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = len + EXT4_MIN_INLINE_DATA_SIZE;\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\text4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int ext4_create_inline_data(handle_t *handle,\n\t\t\t\t   struct inode *inode, unsigned len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\tif (len > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tvalue = EXT4_ZERO_XATTR_VALUE;\n\t\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tvalue = \"\";\n\t\tlen = 0;\n\t}\n\n\t/* Insert the the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(!is.s.not_found);\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\text4_clear_inode_state(inode,\n\t\t\t\t\t       EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = len + EXT4_MIN_INLINE_DATA_SIZE;\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\text4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_inline_data",
          "args": [
            "handle",
            "inode",
            "len"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "308-370",
          "snippet": "static int ext4_update_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t   unsigned int len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\t/* If the old space is ok, write the data directly. */\n\tif (len <= EXT4_I(inode)->i_inline_size)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(is.s.not_found);\n\n\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\tvalue = kzalloc(len, GFP_NOFS);\n\tif (!value)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t     value, len);\n\tif (error == -ENODATA)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\t/* Update the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tkfree(value);\n\tbrelse(is.iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int ext4_update_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t   unsigned int len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\t/* If the old space is ok, write the data directly. */\n\tif (len <= EXT4_I(inode)->i_inline_size)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(is.s.not_found);\n\n\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\tvalue = kzalloc(len, GFP_NOFS);\n\tif (!value)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t     value, len);\n\tif (error == -ENODATA)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\t/* Update the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tkfree(value);\n\tbrelse(is.iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_max_inline_size",
          "args": [
            "inode"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_max_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "95-121",
          "snippet": "int ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode(inode, __func__, __LINE__, 0,\n\t\t\t\t \"can't get inode location %lu\",\n\t\t\t\t inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode(inode, __func__, __LINE__, 0,\n\t\t\t\t \"can't get inode location %lu\",\n\t\t\t\t inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int len)\n{\n\tint ret, size;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\t\treturn -ENOSPC;\n\n\tsize = ext4_get_max_inline_size(inode);\n\tif (size < len)\n\t\treturn -ENOSPC;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\n\tif (ei->i_inline_off)\n\t\tret = ext4_update_inline_data(handle, inode, len);\n\telse\n\t\tret = ext4_create_inline_data(handle, inode, len);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_update_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "308-370",
    "snippet": "static int ext4_update_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t   unsigned int len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\t/* If the old space is ok, write the data directly. */\n\tif (len <= EXT4_I(inode)->i_inline_size)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(is.s.not_found);\n\n\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\tvalue = kzalloc(len, GFP_NOFS);\n\tif (!value)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t     value, len);\n\tif (error == -ENODATA)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\t/* Update the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tkfree(value);\n\tbrelse(is.iloc.bh);\n\treturn error;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
      "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "is.iloc.bh"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&is.iloc"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4800-4815",
          "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "is.iloc.bh"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "is.s.here->e_value_size"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&is.iloc"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_inline_set",
          "args": [
            "handle",
            "inode",
            "&i",
            "&is"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_inline_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1011-1047",
          "snippet": "int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error) {\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_has_inline_data(inode)) {\n\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,\n\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_ibody_find(inode, i, is);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error) {\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_has_inline_data(inode)) {\n\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,\n\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_ibody_find(inode, i, is);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "is.iloc.bh"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "is.iloc.bh",
            "\"get_write_access\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_get",
          "args": [
            "inode",
            "i.name_index",
            "i.name",
            "value",
            "len"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "326-367",
          "snippet": "int\next4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(entry, end, entry);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);",
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nint\next4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(entry, end, entry);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "GFP_NOFS"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "is.s.not_found"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_find",
          "args": [
            "inode",
            "&i",
            "&is"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "981-1009",
          "snippet": "int ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&is.iloc"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int ext4_update_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t   unsigned int len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\t/* If the old space is ok, write the data directly. */\n\tif (len <= EXT4_I(inode)->i_inline_size)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(is.s.not_found);\n\n\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\tvalue = kzalloc(len, GFP_NOFS);\n\tif (!value)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t     value, len);\n\tif (error == -ENODATA)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\t/* Update the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tkfree(value);\n\tbrelse(is.iloc.bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_create_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "244-306",
    "snippet": "static int ext4_create_inline_data(handle_t *handle,\n\t\t\t\t   struct inode *inode, unsigned len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\tif (len > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tvalue = EXT4_ZERO_XATTR_VALUE;\n\t\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tvalue = \"\";\n\t\tlen = 0;\n\t}\n\n\t/* Insert the the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(!is.s.not_found);\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\text4_clear_inode_state(inode,\n\t\t\t\t\t       EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = len + EXT4_MIN_INLINE_DATA_SIZE;\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\text4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
      "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "is.iloc.bh"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&is.iloc"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4800-4815",
          "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "is.iloc.bh"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_INLINE_DATA"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&is.iloc"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)ext4_raw_inode(&is.iloc)->i_block",
            "0",
            "EXT4_MIN_INLINE_DATA_SIZE"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_inline_set",
          "args": [
            "handle",
            "inode",
            "&i",
            "&is"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_inline_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1011-1047",
          "snippet": "int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error) {\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_has_inline_data(inode)) {\n\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,\n\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_ibody_find(inode, i, is);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error) {\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_has_inline_data(inode)) {\n\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,\n\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_ibody_find(inode, i, is);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!is.s.not_found"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_find",
          "args": [
            "inode",
            "&i",
            "&is"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "981-1009",
          "snippet": "int ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "is.iloc.bh"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "is.iloc.bh",
            "\"get_write_access\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&is.iloc"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int ext4_create_inline_data(handle_t *handle,\n\t\t\t\t   struct inode *inode, unsigned len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\n\tif (len > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tvalue = EXT4_ZERO_XATTR_VALUE;\n\t\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tvalue = \"\";\n\t\tlen = 0;\n\t}\n\n\t/* Insert the the xttr entry. */\n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(!is.s.not_found);\n\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\text4_clear_inode_state(inode,\n\t\t\t\t\t       EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = len + EXT4_MIN_INLINE_DATA_SIZE;\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\text4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_write_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "208-242",
    "snippet": "static void ext4_write_inline_data(struct inode *inode, struct ext4_iloc *iloc,\n\t\t\t\t   void *buffer, loff_t pos, unsigned int len)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint cp_len = 0;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\tBUG_ON(pos + len > EXT4_I(inode)->i_inline_size);\n\n\traw_inode = ext4_raw_inode(iloc);\n\tbuffer += pos;\n\n\tif (pos < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tcp_len = pos + len > EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t EXT4_MIN_INLINE_DATA_SIZE - pos : len;\n\t\tmemcpy((void *)raw_inode->i_block + pos, buffer, cp_len);\n\n\t\tlen -= cp_len;\n\t\tbuffer += cp_len;\n\t\tpos += cp_len;\n\t}\n\n\tif (!len)\n\t\treturn;\n\n\tpos -= EXT4_MIN_INLINE_DATA_SIZE;\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\tmemcpy((void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs) + pos,\n\t       buffer, len);\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs) + pos",
            "buffer",
            "len"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)raw_inode->i_block + pos",
            "buffer",
            "cp_len"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "iloc"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pos + len > EXT4_I(inode)->i_inline_size"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!EXT4_I(inode)->i_inline_off"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstatic void ext4_write_inline_data(struct inode *inode, struct ext4_iloc *iloc,\n\t\t\t\t   void *buffer, loff_t pos, unsigned int len)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint cp_len = 0;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\tBUG_ON(pos + len > EXT4_I(inode)->i_inline_size);\n\n\traw_inode = ext4_raw_inode(iloc);\n\tbuffer += pos;\n\n\tif (pos < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tcp_len = pos + len > EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t EXT4_MIN_INLINE_DATA_SIZE - pos : len;\n\t\tmemcpy((void *)raw_inode->i_block + pos, buffer, cp_len);\n\n\t\tlen -= cp_len;\n\t\tbuffer += cp_len;\n\t\tpos += cp_len;\n\t}\n\n\tif (!len)\n\t\treturn;\n\n\tpos -= EXT4_MIN_INLINE_DATA_SIZE;\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\tmemcpy((void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs) + pos,\n\t       buffer, len);\n}"
  },
  {
    "function_name": "ext4_read_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "162-200",
    "snippet": "static int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\tlen : EXT4_MIN_INLINE_DATA_SIZE;\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "(void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs)",
            "len"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "len",
            "(unsigned int)le32_to_cpu(entry->e_value_size)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "(void *)(raw_inode->i_block)",
            "cp_len"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "iloc"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len > EXT4_I(inode)->i_inline_size"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nstatic int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\tlen : EXT4_MIN_INLINE_DATA_SIZE;\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}"
  },
  {
    "function_name": "ext4_find_inline_data_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "128-160",
    "snippet": "int ext4_find_inline_data_nolock(struct inode *inode)\n{\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tif (!is.s.not_found) {\n\t\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t\t(void *)ext4_raw_inode(&is.iloc));\n\t\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t}\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
      "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "is.iloc.bh"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "is.s.here->e_value_size"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(void *)is.s.here -\n\t\t\t\t\t(void *)ext4_raw_inode(&is.iloc)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&is.iloc"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_find",
          "args": [
            "inode",
            "&i",
            "&is"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "981-1009",
          "snippet": "int ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&is.iloc"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nint ext4_find_inline_data_nolock(struct inode *inode)\n{\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tif (!is.s.not_found) {\n\t\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t\t(void *)ext4_raw_inode(&is.iloc));\n\t\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t}\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_get_max_inline_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "95-121",
    "snippet": "int ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode(inode, __func__, __LINE__, 0,\n\t\t\t\t \"can't get inode location %lu\",\n\t\t\t\t inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_max_inline_xattr_value_size",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "get_max_inline_xattr_value_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "33-88",
          "snippet": "static int get_max_inline_xattr_value_size(struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tint free, min_offs;\n\n\tmin_offs = EXT4_SB(inode->i_sb)->s_inode_size -\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE -\n\t\t\tEXT4_I(inode)->i_extra_isize -\n\t\t\tsizeof(struct ext4_xattr_ibody_header);\n\n\t/*\n\t * We need to subtract another sizeof(__u32) since an in-inode xattr\n\t * needs an empty 4 bytes to indicate the gap between the xattr entry\n\t * and the name/value pair.\n\t */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn EXT4_XATTR_SIZE(min_offs -\n\t\t\tEXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) -\n\t\t\tEXT4_XATTR_ROUND - sizeof(__u32));\n\n\traw_inode = ext4_raw_inode(iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\n\t/* Compute min_offs. */\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_block && entry->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(entry->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs -\n\t\t((void *)entry - (void *)IFIRST(header)) - sizeof(__u32);\n\n\tif (EXT4_I(inode)->i_inline_off) {\n\t\tentry = (struct ext4_xattr_entry *)\n\t\t\t((void *)raw_inode + EXT4_I(inode)->i_inline_off);\n\n\t\tfree += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size));\n\t\tgoto out;\n\t}\n\n\tfree -= EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA));\n\n\tif (free > EXT4_XATTR_ROUND)\n\t\tfree = EXT4_XATTR_SIZE(free - EXT4_XATTR_ROUND);\n\telse\n\t\tfree = 0;\n\nout:\n\treturn free;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int get_max_inline_xattr_value_size(struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tint free, min_offs;\n\n\tmin_offs = EXT4_SB(inode->i_sb)->s_inode_size -\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE -\n\t\t\tEXT4_I(inode)->i_extra_isize -\n\t\t\tsizeof(struct ext4_xattr_ibody_header);\n\n\t/*\n\t * We need to subtract another sizeof(__u32) since an in-inode xattr\n\t * needs an empty 4 bytes to indicate the gap between the xattr entry\n\t * and the name/value pair.\n\t */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn EXT4_XATTR_SIZE(min_offs -\n\t\t\tEXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) -\n\t\t\tEXT4_XATTR_ROUND - sizeof(__u32));\n\n\traw_inode = ext4_raw_inode(iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\n\t/* Compute min_offs. */\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_block && entry->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(entry->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs -\n\t\t((void *)entry - (void *)IFIRST(header)) - sizeof(__u32);\n\n\tif (EXT4_I(inode)->i_inline_off) {\n\t\tentry = (struct ext4_xattr_entry *)\n\t\t\t((void *)raw_inode + EXT4_I(inode)->i_inline_off);\n\n\t\tfree += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size));\n\t\tgoto out;\n\t}\n\n\tfree -= EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA));\n\n\tif (free > EXT4_XATTR_ROUND)\n\t\tfree = EXT4_XATTR_SIZE(free - EXT4_XATTR_ROUND);\n\telse\n\t\tfree = 0;\n\nout:\n\treturn free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error_inode",
          "args": [
            "inode",
            "__func__",
            "__LINE__",
            "0",
            "\"can't get inode location %lu\"",
            "inode->i_ino"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "426-454",
          "snippet": "void __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode(inode, __func__, __LINE__, 0,\n\t\t\t\t \"can't get inode location %lu\",\n\t\t\t\t inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}"
  },
  {
    "function_name": "get_max_inline_xattr_value_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "33-88",
    "snippet": "static int get_max_inline_xattr_value_size(struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tint free, min_offs;\n\n\tmin_offs = EXT4_SB(inode->i_sb)->s_inode_size -\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE -\n\t\t\tEXT4_I(inode)->i_extra_isize -\n\t\t\tsizeof(struct ext4_xattr_ibody_header);\n\n\t/*\n\t * We need to subtract another sizeof(__u32) since an in-inode xattr\n\t * needs an empty 4 bytes to indicate the gap between the xattr entry\n\t * and the name/value pair.\n\t */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn EXT4_XATTR_SIZE(min_offs -\n\t\t\tEXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) -\n\t\t\tEXT4_XATTR_ROUND - sizeof(__u32));\n\n\traw_inode = ext4_raw_inode(iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\n\t/* Compute min_offs. */\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_block && entry->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(entry->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs -\n\t\t((void *)entry - (void *)IFIRST(header)) - sizeof(__u32);\n\n\tif (EXT4_I(inode)->i_inline_off) {\n\t\tentry = (struct ext4_xattr_entry *)\n\t\t\t((void *)raw_inode + EXT4_I(inode)->i_inline_off);\n\n\t\tfree += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size));\n\t\tgoto out;\n\t}\n\n\tfree -= EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA));\n\n\tif (free > EXT4_XATTR_ROUND)\n\t\tfree = EXT4_XATTR_SIZE(free - EXT4_XATTR_ROUND);\n\telse\n\t\tfree = 0;\n\nout:\n\treturn free;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "free - EXT4_XATTR_ROUND"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "strlen(EXT4_XATTR_SYSTEM_DATA)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "EXT4_XATTR_SYSTEM_DATA"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "le32_to_cpu(entry->e_value_size)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "entry"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "iloc"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "min_offs -\n\t\t\tEXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) -\n\t\t\tEXT4_XATTR_ROUND - sizeof(__u32)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "strlen(EXT4_XATTR_SYSTEM_DATA)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nstatic int get_max_inline_xattr_value_size(struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tint free, min_offs;\n\n\tmin_offs = EXT4_SB(inode->i_sb)->s_inode_size -\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE -\n\t\t\tEXT4_I(inode)->i_extra_isize -\n\t\t\tsizeof(struct ext4_xattr_ibody_header);\n\n\t/*\n\t * We need to subtract another sizeof(__u32) since an in-inode xattr\n\t * needs an empty 4 bytes to indicate the gap between the xattr entry\n\t * and the name/value pair.\n\t */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn EXT4_XATTR_SIZE(min_offs -\n\t\t\tEXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) -\n\t\t\tEXT4_XATTR_ROUND - sizeof(__u32));\n\n\traw_inode = ext4_raw_inode(iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\n\t/* Compute min_offs. */\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_block && entry->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(entry->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs -\n\t\t((void *)entry - (void *)IFIRST(header)) - sizeof(__u32);\n\n\tif (EXT4_I(inode)->i_inline_off) {\n\t\tentry = (struct ext4_xattr_entry *)\n\t\t\t((void *)raw_inode + EXT4_I(inode)->i_inline_off);\n\n\t\tfree += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size));\n\t\tgoto out;\n\t}\n\n\tfree -= EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA));\n\n\tif (free > EXT4_XATTR_ROUND)\n\t\tfree = EXT4_XATTR_SIZE(free - EXT4_XATTR_ROUND);\n\telse\n\t\tfree = 0;\n\nout:\n\treturn free;\n}"
  },
  {
    "function_name": "ext4_get_inline_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
    "lines": "25-31",
    "snippet": "static int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fiemap.h>",
      "#include \"truncate.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}"
  }
]