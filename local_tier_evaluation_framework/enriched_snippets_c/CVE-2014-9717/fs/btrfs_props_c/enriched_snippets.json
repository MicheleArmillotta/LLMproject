[
  {
    "function_name": "prop_compression_extract",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "417-427",
    "snippet": "static const char *prop_compression_extract(struct inode *inode)\n{\n\tswitch (BTRFS_I(inode)->force_compress) {\n\tcase BTRFS_COMPRESS_ZLIB:\n\t\treturn \"zlib\";\n\tcase BTRFS_COMPRESS_LZO:\n\t\treturn \"lzo\";\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *prop_compression_extract(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nstatic const char *prop_compression_extract(struct inode *inode)\n{\n\tswitch (BTRFS_I(inode)->force_compress) {\n\tcase BTRFS_COMPRESS_ZLIB:\n\t\treturn \"zlib\";\n\tcase BTRFS_COMPRESS_LZO:\n\t\treturn \"lzo\";\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "prop_compression_apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "389-415",
    "snippet": "static int prop_compression_apply(struct inode *inode,\n\t\t\t\t  const char *value,\n\t\t\t\t  size_t len)\n{\n\tint type;\n\n\tif (len == 0) {\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NOCOMPRESS;\n\t\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tBTRFS_I(inode)->force_compress = BTRFS_COMPRESS_NONE;\n\n\t\treturn 0;\n\t}\n\n\tif (!strncmp(\"lzo\", value, len))\n\t\ttype = BTRFS_COMPRESS_LZO;\n\telse if (!strncmp(\"zlib\", value, len))\n\t\ttype = BTRFS_COMPRESS_ZLIB;\n\telse\n\t\treturn -EINVAL;\n\n\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\tBTRFS_I(inode)->flags |= BTRFS_INODE_COMPRESS;\n\tBTRFS_I(inode)->force_compress = type;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int prop_compression_validate(const char *value, size_t len);",
      "static int prop_compression_apply(struct inode *inode,\n\t\t\t\t  const char *value,\n\t\t\t\t  size_t len);",
      "static const char *prop_compression_extract(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"zlib\"",
            "value",
            "len"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"lzo\"",
            "value",
            "len"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic int prop_compression_validate(const char *value, size_t len);\nstatic int prop_compression_apply(struct inode *inode,\n\t\t\t\t  const char *value,\n\t\t\t\t  size_t len);\nstatic const char *prop_compression_extract(struct inode *inode);\n\nstatic int prop_compression_apply(struct inode *inode,\n\t\t\t\t  const char *value,\n\t\t\t\t  size_t len)\n{\n\tint type;\n\n\tif (len == 0) {\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NOCOMPRESS;\n\t\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tBTRFS_I(inode)->force_compress = BTRFS_COMPRESS_NONE;\n\n\t\treturn 0;\n\t}\n\n\tif (!strncmp(\"lzo\", value, len))\n\t\ttype = BTRFS_COMPRESS_LZO;\n\telse if (!strncmp(\"zlib\", value, len))\n\t\ttype = BTRFS_COMPRESS_ZLIB;\n\telse\n\t\treturn -EINVAL;\n\n\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\tBTRFS_I(inode)->flags |= BTRFS_INODE_COMPRESS;\n\tBTRFS_I(inode)->force_compress = type;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "prop_compression_validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "379-387",
    "snippet": "static int prop_compression_validate(const char *value, size_t len)\n{\n\tif (!strncmp(\"lzo\", value, len))\n\t\treturn 0;\n\telse if (!strncmp(\"zlib\", value, len))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int prop_compression_validate(const char *value, size_t len);",
      "static int prop_compression_apply(struct inode *inode,\n\t\t\t\t  const char *value,\n\t\t\t\t  size_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"zlib\"",
            "value",
            "len"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"lzo\"",
            "value",
            "len"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic int prop_compression_validate(const char *value, size_t len);\nstatic int prop_compression_apply(struct inode *inode,\n\t\t\t\t  const char *value,\n\t\t\t\t  size_t len);\n\nstatic int prop_compression_validate(const char *value, size_t len)\n{\n\tif (!strncmp(\"lzo\", value, len))\n\t\treturn 0;\n\telse if (!strncmp(\"zlib\", value, len))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btrfs_subvol_inherit_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "349-377",
    "snippet": "int btrfs_subvol_inherit_props(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_root *parent_root)\n{\n\tstruct btrfs_key key;\n\tstruct inode *parent_inode, *child_inode;\n\tint ret;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tparent_inode = btrfs_iget(parent_root->fs_info->sb, &key,\n\t\t\t\t  parent_root, NULL);\n\tif (IS_ERR(parent_inode))\n\t\treturn PTR_ERR(parent_inode);\n\n\tchild_inode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(child_inode)) {\n\t\tiput(parent_inode);\n\t\treturn PTR_ERR(child_inode);\n\t}\n\n\tret = inherit_props(trans, child_inode, parent_inode);\n\tiput(child_inode);\n\tiput(parent_inode);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *prop_compression_extract(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "parent_inode"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inherit_props",
          "args": [
            "trans",
            "child_inode",
            "parent_inode"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_subvol_inherit_props",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "349-377",
          "snippet": "int btrfs_subvol_inherit_props(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_root *parent_root)\n{\n\tstruct btrfs_key key;\n\tstruct inode *parent_inode, *child_inode;\n\tint ret;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tparent_inode = btrfs_iget(parent_root->fs_info->sb, &key,\n\t\t\t\t  parent_root, NULL);\n\tif (IS_ERR(parent_inode))\n\t\treturn PTR_ERR(parent_inode);\n\n\tchild_inode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(child_inode)) {\n\t\tiput(parent_inode);\n\t\treturn PTR_ERR(child_inode);\n\t}\n\n\tret = inherit_props(trans, child_inode, parent_inode);\n\tiput(child_inode);\n\tiput(parent_inode);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "child_inode"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "child_inode"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "root->fs_info->sb",
            "&key",
            "root",
            "NULL"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "parent_inode"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "parent_inode"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nint btrfs_subvol_inherit_props(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_root *parent_root)\n{\n\tstruct btrfs_key key;\n\tstruct inode *parent_inode, *child_inode;\n\tint ret;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tparent_inode = btrfs_iget(parent_root->fs_info->sb, &key,\n\t\t\t\t  parent_root, NULL);\n\tif (IS_ERR(parent_inode))\n\t\treturn PTR_ERR(parent_inode);\n\n\tchild_inode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(child_inode)) {\n\t\tiput(parent_inode);\n\t\treturn PTR_ERR(child_inode);\n\t}\n\n\tret = inherit_props(trans, child_inode, parent_inode);\n\tiput(child_inode);\n\tiput(parent_inode);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_inode_inherit_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "339-347",
    "snippet": "int btrfs_inode_inherit_props(struct btrfs_trans_handle *trans,\n\t\t\t      struct inode *inode,\n\t\t\t      struct inode *dir)\n{\n\tif (!dir)\n\t\treturn 0;\n\n\treturn inherit_props(trans, inode, dir);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *prop_compression_extract(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inherit_props",
          "args": [
            "trans",
            "inode",
            "dir"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_subvol_inherit_props",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "349-377",
          "snippet": "int btrfs_subvol_inherit_props(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_root *parent_root)\n{\n\tstruct btrfs_key key;\n\tstruct inode *parent_inode, *child_inode;\n\tint ret;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tparent_inode = btrfs_iget(parent_root->fs_info->sb, &key,\n\t\t\t\t  parent_root, NULL);\n\tif (IS_ERR(parent_inode))\n\t\treturn PTR_ERR(parent_inode);\n\n\tchild_inode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(child_inode)) {\n\t\tiput(parent_inode);\n\t\treturn PTR_ERR(child_inode);\n\t}\n\n\tret = inherit_props(trans, child_inode, parent_inode);\n\tiput(child_inode);\n\tiput(parent_inode);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *prop_compression_extract(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nint btrfs_subvol_inherit_props(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_root *parent_root)\n{\n\tstruct btrfs_key key;\n\tstruct inode *parent_inode, *child_inode;\n\tint ret;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tparent_inode = btrfs_iget(parent_root->fs_info->sb, &key,\n\t\t\t\t  parent_root, NULL);\n\tif (IS_ERR(parent_inode))\n\t\treturn PTR_ERR(parent_inode);\n\n\tchild_inode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(child_inode)) {\n\t\tiput(parent_inode);\n\t\treturn PTR_ERR(child_inode);\n\t}\n\n\tret = inherit_props(trans, child_inode, parent_inode);\n\tiput(child_inode);\n\tiput(parent_inode);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nint btrfs_inode_inherit_props(struct btrfs_trans_handle *trans,\n\t\t\t      struct inode *inode,\n\t\t\t      struct inode *dir)\n{\n\tif (!dir)\n\t\treturn 0;\n\n\treturn inherit_props(trans, inode, dir);\n}"
  },
  {
    "function_name": "inherit_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "300-337",
    "snippet": "static int inherit_props(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode,\n\t\t\t struct inode *parent)\n{\n\tconst struct prop_handler *h;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (!test_bit(BTRFS_INODE_HAS_PROPS,\n\t\t      &BTRFS_I(parent)->runtime_flags))\n\t\treturn 0;\n\n\tfor (h = &prop_handlers[0]; h->xattr_name; h++) {\n\t\tconst char *value;\n\t\tu64 num_bytes;\n\n\t\tif (!h->inheritable)\n\t\t\tcontinue;\n\n\t\tvalue = h->extract(parent);\n\t\tif (!value)\n\t\t\tcontinue;\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\t\tret = btrfs_block_rsv_add(root, trans->block_rsv,\n\t\t\t\t\t  num_bytes, BTRFS_RESERVE_NO_FLUSH);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = __btrfs_set_prop(trans, inode, h->xattr_name,\n\t\t\t\t       value, strlen(value), 0);\n\t\tbtrfs_block_rsv_release(root, trans->block_rsv, num_bytes);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *prop_compression_extract(struct inode *inode);",
      "static struct prop_handler prop_handlers[] = {\n\t{\n\t\t.xattr_name = XATTR_BTRFS_PREFIX \"compression\",\n\t\t.validate = prop_compression_validate,\n\t\t.apply = prop_compression_apply,\n\t\t.extract = prop_compression_extract,\n\t\t.inheritable = 1\n\t},\n\t{\n\t\t.xattr_name = NULL\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_block_rsv_release",
          "args": [
            "root",
            "trans->block_rsv",
            "num_bytes"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4776-4786",
          "snippet": "void btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_set_prop",
          "args": [
            "trans",
            "inode",
            "h->xattr_name",
            "value",
            "strlen(value)",
            "0"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_set_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "102-148",
          "snippet": "static int __btrfs_set_prop(struct btrfs_trans_handle *trans,\n\t\t\t    struct inode *inode,\n\t\t\t    const char *name,\n\t\t\t    const char *value,\n\t\t\t    size_t value_len,\n\t\t\t    int flags)\n{\n\tconst struct prop_handler *handler;\n\tint ret;\n\n\tif (strlen(name) <= XATTR_BTRFS_PREFIX_LEN)\n\t\treturn -EINVAL;\n\n\thandler = find_prop_handler(name, NULL);\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tif (value_len == 0) {\n\t\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t       NULL, 0, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = handler->apply(inode, NULL, 0);\n\t\tASSERT(ret == 0);\n\n\t\treturn ret;\n\t}\n\n\tret = handler->validate(value, value_len);\n\tif (ret)\n\t\treturn ret;\n\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t       value, value_len, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = handler->apply(inode, value, value_len);\n\tif (ret) {\n\t\t__btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t NULL, 0, flags);\n\t\treturn ret;\n\t}\n\n\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *prop_compression_extract(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nstatic int __btrfs_set_prop(struct btrfs_trans_handle *trans,\n\t\t\t    struct inode *inode,\n\t\t\t    const char *name,\n\t\t\t    const char *value,\n\t\t\t    size_t value_len,\n\t\t\t    int flags)\n{\n\tconst struct prop_handler *handler;\n\tint ret;\n\n\tif (strlen(name) <= XATTR_BTRFS_PREFIX_LEN)\n\t\treturn -EINVAL;\n\n\thandler = find_prop_handler(name, NULL);\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tif (value_len == 0) {\n\t\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t       NULL, 0, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = handler->apply(inode, NULL, 0);\n\t\tASSERT(ret == 0);\n\n\t\treturn ret;\n\t}\n\n\tret = handler->validate(value, value_len);\n\tif (ret)\n\t\treturn ret;\n\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t       value, value_len, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = handler->apply(inode, value, value_len);\n\tif (ret) {\n\t\t__btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t NULL, 0, flags);\n\t\treturn ret;\n\t}\n\n\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_add",
          "args": [
            "root",
            "trans->block_rsv",
            "num_bytes",
            "BTRFS_RESERVE_NO_FLUSH"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4703-4719",
          "snippet": "int btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_calc_trans_metadata_size",
          "args": [
            "root",
            "1"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_trans_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3298-3303",
          "snippet": "static inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_LEVEL 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_MAX_LEVEL 8\n\nstatic inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}"
        }
      },
      {
        "call_info": {
          "callee": "h->extract",
          "args": [
            "parent"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_INODE_HAS_PROPS",
            "&BTRFS_I(parent)->runtime_flags"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "parent"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\nstatic struct prop_handler prop_handlers[] = {\n\t{\n\t\t.xattr_name = XATTR_BTRFS_PREFIX \"compression\",\n\t\t.validate = prop_compression_validate,\n\t\t.apply = prop_compression_apply,\n\t\t.extract = prop_compression_extract,\n\t\t.inheritable = 1\n\t},\n\t{\n\t\t.xattr_name = NULL\n\t}\n};\n\nstatic int inherit_props(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode,\n\t\t\t struct inode *parent)\n{\n\tconst struct prop_handler *h;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (!test_bit(BTRFS_INODE_HAS_PROPS,\n\t\t      &BTRFS_I(parent)->runtime_flags))\n\t\treturn 0;\n\n\tfor (h = &prop_handlers[0]; h->xattr_name; h++) {\n\t\tconst char *value;\n\t\tu64 num_bytes;\n\n\t\tif (!h->inheritable)\n\t\t\tcontinue;\n\n\t\tvalue = h->extract(parent);\n\t\tif (!value)\n\t\t\tcontinue;\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\t\tret = btrfs_block_rsv_add(root, trans->block_rsv,\n\t\t\t\t\t  num_bytes, BTRFS_RESERVE_NO_FLUSH);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = __btrfs_set_prop(trans, inode, h->xattr_name,\n\t\t\t\t       value, strlen(value), 0);\n\t\tbtrfs_block_rsv_release(root, trans->block_rsv, num_bytes);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_load_inode_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "289-298",
    "snippet": "int btrfs_load_inode_props(struct inode *inode, struct btrfs_path *path)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\n\tret = iterate_object_props(root, path, ino, inode_prop_iterator, inode);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *prop_compression_extract(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_object_props",
          "args": [
            "root",
            "path",
            "ino",
            "inode_prop_iterator",
            "inode"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_object_props",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "159-268",
          "snippet": "static int iterate_object_props(struct btrfs_root *root,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\tu64 objectid,\n\t\t\t\tvoid (*iterator)(void *,\n\t\t\t\t\t\t const struct prop_handler *,\n\t\t\t\t\t\t const char *,\n\t\t\t\t\t\t size_t),\n\t\t\t\tvoid *ctx)\n{\n\tint ret;\n\tchar *name_buf = NULL;\n\tchar *value_buf = NULL;\n\tint name_buf_len = 0;\n\tint value_buf_len = 0;\n\n\twhile (1) {\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_dir_item *di;\n\t\tstruct extent_buffer *leaf;\n\t\tu32 total_len, cur, this_len;\n\t\tint slot;\n\t\tconst struct hlist_head *handlers;\n\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != objectid)\n\t\t\tbreak;\n\t\tif (key.type != BTRFS_XATTR_ITEM_KEY)\n\t\t\tbreak;\n\n\t\thandlers = find_prop_handlers_by_hash(key.offset);\n\t\tif (!handlers)\n\t\t\tgoto next_slot;\n\n\t\tdi = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);\n\t\tcur = 0;\n\t\ttotal_len = btrfs_item_size_nr(leaf, slot);\n\n\t\twhile (cur < total_len) {\n\t\t\tu32 name_len = btrfs_dir_name_len(leaf, di);\n\t\t\tu32 data_len = btrfs_dir_data_len(leaf, di);\n\t\t\tunsigned long name_ptr, data_ptr;\n\t\t\tconst struct prop_handler *handler;\n\n\t\t\tthis_len = sizeof(*di) + name_len + data_len;\n\t\t\tname_ptr = (unsigned long)(di + 1);\n\t\t\tdata_ptr = name_ptr + name_len;\n\n\t\t\tif (name_len <= XATTR_BTRFS_PREFIX_LEN ||\n\t\t\t    memcmp_extent_buffer(leaf, XATTR_BTRFS_PREFIX,\n\t\t\t\t\t\t name_ptr,\n\t\t\t\t\t\t XATTR_BTRFS_PREFIX_LEN))\n\t\t\t\tgoto next_dir_item;\n\n\t\t\tif (name_len >= name_buf_len) {\n\t\t\t\tkfree(name_buf);\n\t\t\t\tname_buf_len = name_len + 1;\n\t\t\t\tname_buf = kmalloc(name_buf_len, GFP_NOFS);\n\t\t\t\tif (!name_buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_extent_buffer(leaf, name_buf, name_ptr, name_len);\n\t\t\tname_buf[name_len] = '\\0';\n\n\t\t\thandler = find_prop_handler(name_buf, handlers);\n\t\t\tif (!handler)\n\t\t\t\tgoto next_dir_item;\n\n\t\t\tif (data_len > value_buf_len) {\n\t\t\t\tkfree(value_buf);\n\t\t\t\tvalue_buf_len = data_len;\n\t\t\t\tvalue_buf = kmalloc(data_len, GFP_NOFS);\n\t\t\t\tif (!value_buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_extent_buffer(leaf, value_buf, data_ptr, data_len);\n\n\t\t\titerator(ctx, handler, value_buf, data_len);\nnext_dir_item:\n\t\t\tcur += this_len;\n\t\t\tdi = (struct btrfs_dir_item *)((char *) di + this_len);\n\t\t}\n\nnext_slot:\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tkfree(name_buf);\n\tkfree(value_buf);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic int iterate_object_props(struct btrfs_root *root,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\tu64 objectid,\n\t\t\t\tvoid (*iterator)(void *,\n\t\t\t\t\t\t const struct prop_handler *,\n\t\t\t\t\t\t const char *,\n\t\t\t\t\t\t size_t),\n\t\t\t\tvoid *ctx)\n{\n\tint ret;\n\tchar *name_buf = NULL;\n\tchar *value_buf = NULL;\n\tint name_buf_len = 0;\n\tint value_buf_len = 0;\n\n\twhile (1) {\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_dir_item *di;\n\t\tstruct extent_buffer *leaf;\n\t\tu32 total_len, cur, this_len;\n\t\tint slot;\n\t\tconst struct hlist_head *handlers;\n\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != objectid)\n\t\t\tbreak;\n\t\tif (key.type != BTRFS_XATTR_ITEM_KEY)\n\t\t\tbreak;\n\n\t\thandlers = find_prop_handlers_by_hash(key.offset);\n\t\tif (!handlers)\n\t\t\tgoto next_slot;\n\n\t\tdi = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);\n\t\tcur = 0;\n\t\ttotal_len = btrfs_item_size_nr(leaf, slot);\n\n\t\twhile (cur < total_len) {\n\t\t\tu32 name_len = btrfs_dir_name_len(leaf, di);\n\t\t\tu32 data_len = btrfs_dir_data_len(leaf, di);\n\t\t\tunsigned long name_ptr, data_ptr;\n\t\t\tconst struct prop_handler *handler;\n\n\t\t\tthis_len = sizeof(*di) + name_len + data_len;\n\t\t\tname_ptr = (unsigned long)(di + 1);\n\t\t\tdata_ptr = name_ptr + name_len;\n\n\t\t\tif (name_len <= XATTR_BTRFS_PREFIX_LEN ||\n\t\t\t    memcmp_extent_buffer(leaf, XATTR_BTRFS_PREFIX,\n\t\t\t\t\t\t name_ptr,\n\t\t\t\t\t\t XATTR_BTRFS_PREFIX_LEN))\n\t\t\t\tgoto next_dir_item;\n\n\t\t\tif (name_len >= name_buf_len) {\n\t\t\t\tkfree(name_buf);\n\t\t\t\tname_buf_len = name_len + 1;\n\t\t\t\tname_buf = kmalloc(name_buf_len, GFP_NOFS);\n\t\t\t\tif (!name_buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_extent_buffer(leaf, name_buf, name_ptr, name_len);\n\t\t\tname_buf[name_len] = '\\0';\n\n\t\t\thandler = find_prop_handler(name_buf, handlers);\n\t\t\tif (!handler)\n\t\t\t\tgoto next_dir_item;\n\n\t\t\tif (data_len > value_buf_len) {\n\t\t\t\tkfree(value_buf);\n\t\t\t\tvalue_buf_len = data_len;\n\t\t\t\tvalue_buf = kmalloc(data_len, GFP_NOFS);\n\t\t\t\tif (!value_buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_extent_buffer(leaf, value_buf, data_ptr, data_len);\n\n\t\t\titerator(ctx, handler, value_buf, data_len);\nnext_dir_item:\n\t\t\tcur += this_len;\n\t\t\tdi = (struct btrfs_dir_item *)((char *) di + this_len);\n\t\t}\n\nnext_slot:\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tkfree(name_buf);\n\tkfree(value_buf);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nint btrfs_load_inode_props(struct inode *inode, struct btrfs_path *path)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\n\tret = iterate_object_props(root, path, ino, inode_prop_iterator, inode);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "inode_prop_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "270-287",
    "snippet": "static void inode_prop_iterator(void *ctx,\n\t\t\t\tconst struct prop_handler *handler,\n\t\t\t\tconst char *value,\n\t\t\t\tsize_t len)\n{\n\tstruct inode *inode = ctx;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tret = handler->apply(inode, value, len);\n\tif (unlikely(ret))\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"error applying prop %s to ino %llu (root %llu): %d\",\n\t\t\t   handler->xattr_name, btrfs_ino(inode),\n\t\t\t   root->root_key.objectid, ret);\n\telse\n\t\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int prop_compression_validate(const char *value, size_t len);",
      "static int prop_compression_apply(struct inode *inode,\n\t\t\t\t  const char *value,\n\t\t\t\t  size_t len);",
      "static const char *prop_compression_extract(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_INODE_HAS_PROPS",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"error applying prop %s to ino %llu (root %llu): %d\"",
            "handler->xattr_name",
            "btrfs_ino(inode)",
            "root->root_key.objectid",
            "ret"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler->apply",
          "args": [
            "inode",
            "value",
            "len"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic int prop_compression_validate(const char *value, size_t len);\nstatic int prop_compression_apply(struct inode *inode,\n\t\t\t\t  const char *value,\n\t\t\t\t  size_t len);\nstatic const char *prop_compression_extract(struct inode *inode);\n\nstatic void inode_prop_iterator(void *ctx,\n\t\t\t\tconst struct prop_handler *handler,\n\t\t\t\tconst char *value,\n\t\t\t\tsize_t len)\n{\n\tstruct inode *inode = ctx;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tret = handler->apply(inode, value, len);\n\tif (unlikely(ret))\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"error applying prop %s to ino %llu (root %llu): %d\",\n\t\t\t   handler->xattr_name, btrfs_ino(inode),\n\t\t\t   root->root_key.objectid, ret);\n\telse\n\t\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n}"
  },
  {
    "function_name": "iterate_object_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "159-268",
    "snippet": "static int iterate_object_props(struct btrfs_root *root,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\tu64 objectid,\n\t\t\t\tvoid (*iterator)(void *,\n\t\t\t\t\t\t const struct prop_handler *,\n\t\t\t\t\t\t const char *,\n\t\t\t\t\t\t size_t),\n\t\t\t\tvoid *ctx)\n{\n\tint ret;\n\tchar *name_buf = NULL;\n\tchar *value_buf = NULL;\n\tint name_buf_len = 0;\n\tint value_buf_len = 0;\n\n\twhile (1) {\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_dir_item *di;\n\t\tstruct extent_buffer *leaf;\n\t\tu32 total_len, cur, this_len;\n\t\tint slot;\n\t\tconst struct hlist_head *handlers;\n\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != objectid)\n\t\t\tbreak;\n\t\tif (key.type != BTRFS_XATTR_ITEM_KEY)\n\t\t\tbreak;\n\n\t\thandlers = find_prop_handlers_by_hash(key.offset);\n\t\tif (!handlers)\n\t\t\tgoto next_slot;\n\n\t\tdi = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);\n\t\tcur = 0;\n\t\ttotal_len = btrfs_item_size_nr(leaf, slot);\n\n\t\twhile (cur < total_len) {\n\t\t\tu32 name_len = btrfs_dir_name_len(leaf, di);\n\t\t\tu32 data_len = btrfs_dir_data_len(leaf, di);\n\t\t\tunsigned long name_ptr, data_ptr;\n\t\t\tconst struct prop_handler *handler;\n\n\t\t\tthis_len = sizeof(*di) + name_len + data_len;\n\t\t\tname_ptr = (unsigned long)(di + 1);\n\t\t\tdata_ptr = name_ptr + name_len;\n\n\t\t\tif (name_len <= XATTR_BTRFS_PREFIX_LEN ||\n\t\t\t    memcmp_extent_buffer(leaf, XATTR_BTRFS_PREFIX,\n\t\t\t\t\t\t name_ptr,\n\t\t\t\t\t\t XATTR_BTRFS_PREFIX_LEN))\n\t\t\t\tgoto next_dir_item;\n\n\t\t\tif (name_len >= name_buf_len) {\n\t\t\t\tkfree(name_buf);\n\t\t\t\tname_buf_len = name_len + 1;\n\t\t\t\tname_buf = kmalloc(name_buf_len, GFP_NOFS);\n\t\t\t\tif (!name_buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_extent_buffer(leaf, name_buf, name_ptr, name_len);\n\t\t\tname_buf[name_len] = '\\0';\n\n\t\t\thandler = find_prop_handler(name_buf, handlers);\n\t\t\tif (!handler)\n\t\t\t\tgoto next_dir_item;\n\n\t\t\tif (data_len > value_buf_len) {\n\t\t\t\tkfree(value_buf);\n\t\t\t\tvalue_buf_len = data_len;\n\t\t\t\tvalue_buf = kmalloc(data_len, GFP_NOFS);\n\t\t\t\tif (!value_buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_extent_buffer(leaf, value_buf, data_ptr, data_len);\n\n\t\t\titerator(ctx, handler, value_buf, data_len);\nnext_dir_item:\n\t\t\tcur += this_len;\n\t\t\tdi = (struct btrfs_dir_item *)((char *) di + this_len);\n\t\t}\n\nnext_slot:\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tkfree(name_buf);\n\tkfree(value_buf);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value_buf"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name_buf"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator",
          "args": [
            "ctx",
            "handler",
            "value_buf",
            "data_len"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "inode_prop_iterator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "270-287",
          "snippet": "static void inode_prop_iterator(void *ctx,\n\t\t\t\tconst struct prop_handler *handler,\n\t\t\t\tconst char *value,\n\t\t\t\tsize_t len)\n{\n\tstruct inode *inode = ctx;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tret = handler->apply(inode, value, len);\n\tif (unlikely(ret))\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"error applying prop %s to ino %llu (root %llu): %d\",\n\t\t\t   handler->xattr_name, btrfs_ino(inode),\n\t\t\t   root->root_key.objectid, ret);\n\telse\n\t\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int prop_compression_validate(const char *value, size_t len);",
            "static int prop_compression_apply(struct inode *inode,\n\t\t\t\t  const char *value,\n\t\t\t\t  size_t len);",
            "static const char *prop_compression_extract(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic int prop_compression_validate(const char *value, size_t len);\nstatic int prop_compression_apply(struct inode *inode,\n\t\t\t\t  const char *value,\n\t\t\t\t  size_t len);\nstatic const char *prop_compression_extract(struct inode *inode);\n\nstatic void inode_prop_iterator(void *ctx,\n\t\t\t\tconst struct prop_handler *handler,\n\t\t\t\tconst char *value,\n\t\t\t\tsize_t len)\n{\n\tstruct inode *inode = ctx;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tret = handler->apply(inode, value, len);\n\tif (unlikely(ret))\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"error applying prop %s to ino %llu (root %llu): %d\",\n\t\t\t   handler->xattr_name, btrfs_ino(inode),\n\t\t\t   root->root_key.objectid, ret);\n\telse\n\t\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "value_buf",
            "data_ptr",
            "data_len"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "data_len",
            "GFP_NOFS"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value_buf"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_prop_handler",
          "args": [
            "name_buf",
            "handlers"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "find_prop_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "81-100",
          "snippet": "static const struct prop_handler *\nfind_prop_handler(const char *name,\n\t\t  const struct hlist_head *handlers)\n{\n\tstruct prop_handler *h;\n\n\tif (!handlers) {\n\t\tu64 hash = btrfs_name_hash(name, strlen(name));\n\n\t\thandlers = find_prop_handlers_by_hash(hash);\n\t\tif (!handlers)\n\t\t\treturn NULL;\n\t}\n\n\thlist_for_each_entry(h, handlers, node)\n\t\tif (!strcmp(h->xattr_name, name))\n\t\t\treturn h;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const struct prop_handler *\nfind_prop_handler(const char *name,\n\t\t  const struct hlist_head *handlers)\n{\n\tstruct prop_handler *h;\n\n\tif (!handlers) {\n\t\tu64 hash = btrfs_name_hash(name, strlen(name));\n\n\t\thandlers = find_prop_handlers_by_hash(hash);\n\t\tif (!handlers)\n\t\t\treturn NULL;\n\t}\n\n\thlist_for_each_entry(h, handlers, node)\n\t\tif (!strcmp(h->xattr_name, name))\n\t\t\treturn h;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name_buf"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp_extent_buffer",
          "args": [
            "leaf",
            "XATTR_BTRFS_PREFIX",
            "name_ptr",
            "XATTR_BTRFS_PREFIX_LEN"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "memcmp_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5320-5354",
          "snippet": "int memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,\n\t\t\t  unsigned long start,\n\t\t\t  unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *ptr = (char *)ptrv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tret = memcmp(ptr, kaddr + offset, cur);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,\n\t\t\t  unsigned long start,\n\t\t\t  unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *ptr = (char *)ptrv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tret = memcmp(ptr, kaddr + offset, cur);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_data_len",
          "args": [
            "leaf",
            "di"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_name_len",
          "args": [
            "leaf",
            "di"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_dir_item"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_prop_handlers_by_hash",
          "args": [
            "key.offset"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "find_prop_handlers_by_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "70-79",
          "snippet": "static const struct hlist_head *find_prop_handlers_by_hash(const u64 hash)\n{\n\tstruct hlist_head *h;\n\n\th = &prop_handlers_ht[hash_min(hash, BTRFS_PROP_HANDLERS_HT_BITS)];\n\tif (hlist_empty(h))\n\t\treturn NULL;\n\n\treturn h;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [
            "#define BTRFS_PROP_HANDLERS_HT_BITS 8"
          ],
          "globals_used": [
            "static DEFINE_HASHTABLE(prop_handlers_ht, BTRFS_PROP_HANDLERS_HT_BITS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\n#define BTRFS_PROP_HANDLERS_HT_BITS 8\n\nstatic DEFINE_HASHTABLE(prop_handlers_ht, BTRFS_PROP_HANDLERS_HT_BITS);\n\nstatic const struct hlist_head *find_prop_handlers_by_hash(const u64 hash)\n{\n\tstruct hlist_head *h;\n\n\th = &prop_handlers_ht[hash_min(hash, BTRFS_PROP_HANDLERS_HT_BITS)];\n\tif (hlist_empty(h))\n\t\treturn NULL;\n\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic int iterate_object_props(struct btrfs_root *root,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\tu64 objectid,\n\t\t\t\tvoid (*iterator)(void *,\n\t\t\t\t\t\t const struct prop_handler *,\n\t\t\t\t\t\t const char *,\n\t\t\t\t\t\t size_t),\n\t\t\t\tvoid *ctx)\n{\n\tint ret;\n\tchar *name_buf = NULL;\n\tchar *value_buf = NULL;\n\tint name_buf_len = 0;\n\tint value_buf_len = 0;\n\n\twhile (1) {\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_dir_item *di;\n\t\tstruct extent_buffer *leaf;\n\t\tu32 total_len, cur, this_len;\n\t\tint slot;\n\t\tconst struct hlist_head *handlers;\n\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != objectid)\n\t\t\tbreak;\n\t\tif (key.type != BTRFS_XATTR_ITEM_KEY)\n\t\t\tbreak;\n\n\t\thandlers = find_prop_handlers_by_hash(key.offset);\n\t\tif (!handlers)\n\t\t\tgoto next_slot;\n\n\t\tdi = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);\n\t\tcur = 0;\n\t\ttotal_len = btrfs_item_size_nr(leaf, slot);\n\n\t\twhile (cur < total_len) {\n\t\t\tu32 name_len = btrfs_dir_name_len(leaf, di);\n\t\t\tu32 data_len = btrfs_dir_data_len(leaf, di);\n\t\t\tunsigned long name_ptr, data_ptr;\n\t\t\tconst struct prop_handler *handler;\n\n\t\t\tthis_len = sizeof(*di) + name_len + data_len;\n\t\t\tname_ptr = (unsigned long)(di + 1);\n\t\t\tdata_ptr = name_ptr + name_len;\n\n\t\t\tif (name_len <= XATTR_BTRFS_PREFIX_LEN ||\n\t\t\t    memcmp_extent_buffer(leaf, XATTR_BTRFS_PREFIX,\n\t\t\t\t\t\t name_ptr,\n\t\t\t\t\t\t XATTR_BTRFS_PREFIX_LEN))\n\t\t\t\tgoto next_dir_item;\n\n\t\t\tif (name_len >= name_buf_len) {\n\t\t\t\tkfree(name_buf);\n\t\t\t\tname_buf_len = name_len + 1;\n\t\t\t\tname_buf = kmalloc(name_buf_len, GFP_NOFS);\n\t\t\t\tif (!name_buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_extent_buffer(leaf, name_buf, name_ptr, name_len);\n\t\t\tname_buf[name_len] = '\\0';\n\n\t\t\thandler = find_prop_handler(name_buf, handlers);\n\t\t\tif (!handler)\n\t\t\t\tgoto next_dir_item;\n\n\t\t\tif (data_len > value_buf_len) {\n\t\t\t\tkfree(value_buf);\n\t\t\t\tvalue_buf_len = data_len;\n\t\t\t\tvalue_buf = kmalloc(data_len, GFP_NOFS);\n\t\t\t\tif (!value_buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_extent_buffer(leaf, value_buf, data_ptr, data_len);\n\n\t\t\titerator(ctx, handler, value_buf, data_len);\nnext_dir_item:\n\t\t\tcur += this_len;\n\t\t\tdi = (struct btrfs_dir_item *)((char *) di + this_len);\n\t\t}\n\nnext_slot:\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tkfree(name_buf);\n\tkfree(value_buf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_set_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "150-157",
    "snippet": "int btrfs_set_prop(struct inode *inode,\n\t\t   const char *name,\n\t\t   const char *value,\n\t\t   size_t value_len,\n\t\t   int flags)\n{\n\treturn __btrfs_set_prop(NULL, inode, name, value, value_len, flags);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *prop_compression_extract(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_set_prop",
          "args": [
            "NULL",
            "inode",
            "name",
            "value",
            "value_len",
            "flags"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_set_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "102-148",
          "snippet": "static int __btrfs_set_prop(struct btrfs_trans_handle *trans,\n\t\t\t    struct inode *inode,\n\t\t\t    const char *name,\n\t\t\t    const char *value,\n\t\t\t    size_t value_len,\n\t\t\t    int flags)\n{\n\tconst struct prop_handler *handler;\n\tint ret;\n\n\tif (strlen(name) <= XATTR_BTRFS_PREFIX_LEN)\n\t\treturn -EINVAL;\n\n\thandler = find_prop_handler(name, NULL);\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tif (value_len == 0) {\n\t\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t       NULL, 0, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = handler->apply(inode, NULL, 0);\n\t\tASSERT(ret == 0);\n\n\t\treturn ret;\n\t}\n\n\tret = handler->validate(value, value_len);\n\tif (ret)\n\t\treturn ret;\n\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t       value, value_len, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = handler->apply(inode, value, value_len);\n\tif (ret) {\n\t\t__btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t NULL, 0, flags);\n\t\treturn ret;\n\t}\n\n\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *prop_compression_extract(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nstatic int __btrfs_set_prop(struct btrfs_trans_handle *trans,\n\t\t\t    struct inode *inode,\n\t\t\t    const char *name,\n\t\t\t    const char *value,\n\t\t\t    size_t value_len,\n\t\t\t    int flags)\n{\n\tconst struct prop_handler *handler;\n\tint ret;\n\n\tif (strlen(name) <= XATTR_BTRFS_PREFIX_LEN)\n\t\treturn -EINVAL;\n\n\thandler = find_prop_handler(name, NULL);\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tif (value_len == 0) {\n\t\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t       NULL, 0, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = handler->apply(inode, NULL, 0);\n\t\tASSERT(ret == 0);\n\n\t\treturn ret;\n\t}\n\n\tret = handler->validate(value, value_len);\n\tif (ret)\n\t\treturn ret;\n\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t       value, value_len, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = handler->apply(inode, value, value_len);\n\tif (ret) {\n\t\t__btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t NULL, 0, flags);\n\t\treturn ret;\n\t}\n\n\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nint btrfs_set_prop(struct inode *inode,\n\t\t   const char *name,\n\t\t   const char *value,\n\t\t   size_t value_len,\n\t\t   int flags)\n{\n\treturn __btrfs_set_prop(NULL, inode, name, value, value_len, flags);\n}"
  },
  {
    "function_name": "__btrfs_set_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "102-148",
    "snippet": "static int __btrfs_set_prop(struct btrfs_trans_handle *trans,\n\t\t\t    struct inode *inode,\n\t\t\t    const char *name,\n\t\t\t    const char *value,\n\t\t\t    size_t value_len,\n\t\t\t    int flags)\n{\n\tconst struct prop_handler *handler;\n\tint ret;\n\n\tif (strlen(name) <= XATTR_BTRFS_PREFIX_LEN)\n\t\treturn -EINVAL;\n\n\thandler = find_prop_handler(name, NULL);\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tif (value_len == 0) {\n\t\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t       NULL, 0, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = handler->apply(inode, NULL, 0);\n\t\tASSERT(ret == 0);\n\n\t\treturn ret;\n\t}\n\n\tret = handler->validate(value, value_len);\n\tif (ret)\n\t\treturn ret;\n\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t       value, value_len, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = handler->apply(inode, value, value_len);\n\tif (ret) {\n\t\t__btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t NULL, 0, flags);\n\t\treturn ret;\n\t}\n\n\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *prop_compression_extract(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_INODE_HAS_PROPS",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_setxattr",
          "args": [
            "trans",
            "inode",
            "handler->xattr_name",
            "NULL",
            "0",
            "flags"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "233-259",
          "snippet": "int __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handler->apply",
          "args": [
            "inode",
            "value",
            "value_len"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler->validate",
          "args": [
            "value",
            "value_len"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ret == 0"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler->apply",
          "args": [
            "inode",
            "NULL",
            "0"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_prop_handler",
          "args": [
            "name",
            "NULL"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "find_prop_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "81-100",
          "snippet": "static const struct prop_handler *\nfind_prop_handler(const char *name,\n\t\t  const struct hlist_head *handlers)\n{\n\tstruct prop_handler *h;\n\n\tif (!handlers) {\n\t\tu64 hash = btrfs_name_hash(name, strlen(name));\n\n\t\thandlers = find_prop_handlers_by_hash(hash);\n\t\tif (!handlers)\n\t\t\treturn NULL;\n\t}\n\n\thlist_for_each_entry(h, handlers, node)\n\t\tif (!strcmp(h->xattr_name, name))\n\t\t\treturn h;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const struct prop_handler *\nfind_prop_handler(const char *name,\n\t\t  const struct hlist_head *handlers)\n{\n\tstruct prop_handler *h;\n\n\tif (!handlers) {\n\t\tu64 hash = btrfs_name_hash(name, strlen(name));\n\n\t\thandlers = find_prop_handlers_by_hash(hash);\n\t\tif (!handlers)\n\t\t\treturn NULL;\n\t}\n\n\thlist_for_each_entry(h, handlers, node)\n\t\tif (!strcmp(h->xattr_name, name))\n\t\t\treturn h;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nstatic int __btrfs_set_prop(struct btrfs_trans_handle *trans,\n\t\t\t    struct inode *inode,\n\t\t\t    const char *name,\n\t\t\t    const char *value,\n\t\t\t    size_t value_len,\n\t\t\t    int flags)\n{\n\tconst struct prop_handler *handler;\n\tint ret;\n\n\tif (strlen(name) <= XATTR_BTRFS_PREFIX_LEN)\n\t\treturn -EINVAL;\n\n\thandler = find_prop_handler(name, NULL);\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tif (value_len == 0) {\n\t\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t       NULL, 0, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = handler->apply(inode, NULL, 0);\n\t\tASSERT(ret == 0);\n\n\t\treturn ret;\n\t}\n\n\tret = handler->validate(value, value_len);\n\tif (ret)\n\t\treturn ret;\n\tret = __btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t       value, value_len, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = handler->apply(inode, value, value_len);\n\tif (ret) {\n\t\t__btrfs_setxattr(trans, inode, handler->xattr_name,\n\t\t\t\t NULL, 0, flags);\n\t\treturn ret;\n\t}\n\n\tset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_prop_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "81-100",
    "snippet": "static const struct prop_handler *\nfind_prop_handler(const char *name,\n\t\t  const struct hlist_head *handlers)\n{\n\tstruct prop_handler *h;\n\n\tif (!handlers) {\n\t\tu64 hash = btrfs_name_hash(name, strlen(name));\n\n\t\thandlers = find_prop_handlers_by_hash(hash);\n\t\tif (!handlers)\n\t\t\treturn NULL;\n\t}\n\n\thlist_for_each_entry(h, handlers, node)\n\t\tif (!strcmp(h->xattr_name, name))\n\t\t\treturn h;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "h->xattr_name",
            "name"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "h",
            "handlers",
            "node"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_prop_handlers_by_hash",
          "args": [
            "hash"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "find_prop_handlers_by_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "70-79",
          "snippet": "static const struct hlist_head *find_prop_handlers_by_hash(const u64 hash)\n{\n\tstruct hlist_head *h;\n\n\th = &prop_handlers_ht[hash_min(hash, BTRFS_PROP_HANDLERS_HT_BITS)];\n\tif (hlist_empty(h))\n\t\treturn NULL;\n\n\treturn h;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [
            "#define BTRFS_PROP_HANDLERS_HT_BITS 8"
          ],
          "globals_used": [
            "static DEFINE_HASHTABLE(prop_handlers_ht, BTRFS_PROP_HANDLERS_HT_BITS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\n#define BTRFS_PROP_HANDLERS_HT_BITS 8\n\nstatic DEFINE_HASHTABLE(prop_handlers_ht, BTRFS_PROP_HANDLERS_HT_BITS);\n\nstatic const struct hlist_head *find_prop_handlers_by_hash(const u64 hash)\n{\n\tstruct hlist_head *h;\n\n\th = &prop_handlers_ht[hash_min(hash, BTRFS_PROP_HANDLERS_HT_BITS)];\n\tif (hlist_empty(h))\n\t\treturn NULL;\n\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_name_hash",
          "args": [
            "name",
            "strlen(name)"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.h",
          "lines": "28-31",
          "snippet": "static inline u64 btrfs_name_hash(const char *name, int len)\n{\n\treturn btrfs_crc32c((u32)~1, name, len);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 btrfs_name_hash(const char *name, int len)\n{\n\treturn btrfs_crc32c((u32)~1, name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const struct prop_handler *\nfind_prop_handler(const char *name,\n\t\t  const struct hlist_head *handlers)\n{\n\tstruct prop_handler *h;\n\n\tif (!handlers) {\n\t\tu64 hash = btrfs_name_hash(name, strlen(name));\n\n\t\thandlers = find_prop_handlers_by_hash(hash);\n\t\tif (!handlers)\n\t\t\treturn NULL;\n\t}\n\n\thlist_for_each_entry(h, handlers, node)\n\t\tif (!strcmp(h->xattr_name, name))\n\t\t\treturn h;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_prop_handlers_by_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "70-79",
    "snippet": "static const struct hlist_head *find_prop_handlers_by_hash(const u64 hash)\n{\n\tstruct hlist_head *h;\n\n\th = &prop_handlers_ht[hash_min(hash, BTRFS_PROP_HANDLERS_HT_BITS)];\n\tif (hlist_empty(h))\n\t\treturn NULL;\n\n\treturn h;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [
      "#define BTRFS_PROP_HANDLERS_HT_BITS 8"
    ],
    "globals_used": [
      "static DEFINE_HASHTABLE(prop_handlers_ht, BTRFS_PROP_HANDLERS_HT_BITS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "h"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_min",
          "args": [
            "hash",
            "BTRFS_PROP_HANDLERS_HT_BITS"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\n#define BTRFS_PROP_HANDLERS_HT_BITS 8\n\nstatic DEFINE_HASHTABLE(prop_handlers_ht, BTRFS_PROP_HANDLERS_HT_BITS);\n\nstatic const struct hlist_head *find_prop_handlers_by_hash(const u64 hash)\n{\n\tstruct hlist_head *h;\n\n\th = &prop_handlers_ht[hash_min(hash, BTRFS_PROP_HANDLERS_HT_BITS)];\n\tif (hlist_empty(h))\n\t\treturn NULL;\n\n\treturn h;\n}"
  },
  {
    "function_name": "btrfs_props_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
    "lines": "57-68",
    "snippet": "void __init btrfs_props_init(void)\n{\n\tstruct prop_handler *p;\n\n\thash_init(prop_handlers_ht);\n\n\tfor (p = &prop_handlers[0]; p->xattr_name; p++) {\n\t\tu64 h = btrfs_name_hash(p->xattr_name, strlen(p->xattr_name));\n\n\t\thash_add(prop_handlers_ht, &p->node, h);\n\t}\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"props.h\"",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct prop_handler prop_handlers[] = {\n\t{\n\t\t.xattr_name = XATTR_BTRFS_PREFIX \"compression\",\n\t\t.validate = prop_compression_validate,\n\t\t.apply = prop_compression_apply,\n\t\t.extract = prop_compression_extract,\n\t\t.inheritable = 1\n\t},\n\t{\n\t\t.xattr_name = NULL\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "prop_handlers_ht",
            "&p->node",
            "h"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_name_hash",
          "args": [
            "p->xattr_name",
            "strlen(p->xattr_name)"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.h",
          "lines": "28-31",
          "snippet": "static inline u64 btrfs_name_hash(const char *name, int len)\n{\n\treturn btrfs_crc32c((u32)~1, name, len);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 btrfs_name_hash(const char *name, int len)\n{\n\treturn btrfs_crc32c((u32)~1, name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p->xattr_name"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_init",
          "args": [
            "prop_handlers_ht"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "dir_hash_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "359-367",
          "snippet": "static void dir_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->dir_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->dir_hashtable[i]);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void dir_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->dir_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->dir_hashtable[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic struct prop_handler prop_handlers[] = {\n\t{\n\t\t.xattr_name = XATTR_BTRFS_PREFIX \"compression\",\n\t\t.validate = prop_compression_validate,\n\t\t.apply = prop_compression_apply,\n\t\t.extract = prop_compression_extract,\n\t\t.inheritable = 1\n\t},\n\t{\n\t\t.xattr_name = NULL\n\t}\n};\n\nvoid __init btrfs_props_init(void)\n{\n\tstruct prop_handler *p;\n\n\thash_init(prop_handlers_ht);\n\n\tfor (p = &prop_handlers[0]; p->xattr_name; p++) {\n\t\tu64 h = btrfs_name_hash(p->xattr_name, strlen(p->xattr_name));\n\n\t\thash_add(prop_handlers_ht, &p->node, h);\n\t}\n}"
  }
]