[
  {
    "function_name": "coda_iattr_to_vattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
    "lines": "123-185",
    "snippet": "void coda_iattr_to_vattr(struct iattr *iattr, struct coda_vattr *vattr)\n{\n        unsigned int valid;\n\n        /* clean out */        \n\tvattr->va_mode = -1;\n        vattr->va_uid = (vuid_t) -1; \n        vattr->va_gid = (vgid_t) -1;\n        vattr->va_size = (off_t) -1;\n\tvattr->va_atime.tv_sec = (time_t) -1;\n\tvattr->va_atime.tv_nsec =  (time_t) -1;\n        vattr->va_mtime.tv_sec = (time_t) -1;\n        vattr->va_mtime.tv_nsec = (time_t) -1;\n\tvattr->va_ctime.tv_sec = (time_t) -1;\n\tvattr->va_ctime.tv_nsec = (time_t) -1;\n        vattr->va_type = C_VNON;\n\tvattr->va_fileid = -1;\n\tvattr->va_gen = -1;\n\tvattr->va_bytes = -1;\n\tvattr->va_nlink = -1;\n\tvattr->va_blocksize = -1;\n\tvattr->va_rdev = -1;\n        vattr->va_flags = 0;\n\n        /* determine the type */\n#if 0\n        mode = iattr->ia_mode;\n                if ( S_ISDIR(mode) ) {\n                vattr->va_type = C_VDIR; \n        } else if ( S_ISREG(mode) ) {\n                vattr->va_type = C_VREG;\n        } else if ( S_ISLNK(mode) ) {\n                vattr->va_type = C_VLNK;\n        } else {\n                /* don't do others */\n                vattr->va_type = C_VNON;\n        }\n#endif \n\n        /* set those vattrs that need change */\n        valid = iattr->ia_valid;\n        if ( valid & ATTR_MODE ) {\n                vattr->va_mode = iattr->ia_mode;\n\t}\n        if ( valid & ATTR_UID ) {\n                vattr->va_uid = (vuid_t) from_kuid(&init_user_ns, iattr->ia_uid);\n\t}\n        if ( valid & ATTR_GID ) {\n                vattr->va_gid = (vgid_t) from_kgid(&init_user_ns, iattr->ia_gid);\n\t}\n        if ( valid & ATTR_SIZE ) {\n                vattr->va_size = iattr->ia_size;\n\t}\n        if ( valid & ATTR_ATIME ) {\n                vattr->va_atime = iattr->ia_atime;\n\t}\n        if ( valid & ATTR_MTIME ) {\n                vattr->va_mtime = iattr->ia_mtime;\n\t}\n        if ( valid & ATTR_CTIME ) {\n                vattr->va_ctime = iattr->ia_ctime;\n\t}\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "iattr->ia_gid"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "iattr->ia_uid"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid coda_iattr_to_vattr(struct iattr *iattr, struct coda_vattr *vattr)\n{\n        unsigned int valid;\n\n        /* clean out */        \n\tvattr->va_mode = -1;\n        vattr->va_uid = (vuid_t) -1; \n        vattr->va_gid = (vgid_t) -1;\n        vattr->va_size = (off_t) -1;\n\tvattr->va_atime.tv_sec = (time_t) -1;\n\tvattr->va_atime.tv_nsec =  (time_t) -1;\n        vattr->va_mtime.tv_sec = (time_t) -1;\n        vattr->va_mtime.tv_nsec = (time_t) -1;\n\tvattr->va_ctime.tv_sec = (time_t) -1;\n\tvattr->va_ctime.tv_nsec = (time_t) -1;\n        vattr->va_type = C_VNON;\n\tvattr->va_fileid = -1;\n\tvattr->va_gen = -1;\n\tvattr->va_bytes = -1;\n\tvattr->va_nlink = -1;\n\tvattr->va_blocksize = -1;\n\tvattr->va_rdev = -1;\n        vattr->va_flags = 0;\n\n        /* determine the type */\n#if 0\n        mode = iattr->ia_mode;\n                if ( S_ISDIR(mode) ) {\n                vattr->va_type = C_VDIR; \n        } else if ( S_ISREG(mode) ) {\n                vattr->va_type = C_VREG;\n        } else if ( S_ISLNK(mode) ) {\n                vattr->va_type = C_VLNK;\n        } else {\n                /* don't do others */\n                vattr->va_type = C_VNON;\n        }\n#endif \n\n        /* set those vattrs that need change */\n        valid = iattr->ia_valid;\n        if ( valid & ATTR_MODE ) {\n                vattr->va_mode = iattr->ia_mode;\n\t}\n        if ( valid & ATTR_UID ) {\n                vattr->va_uid = (vuid_t) from_kuid(&init_user_ns, iattr->ia_uid);\n\t}\n        if ( valid & ATTR_GID ) {\n                vattr->va_gid = (vgid_t) from_kgid(&init_user_ns, iattr->ia_gid);\n\t}\n        if ( valid & ATTR_SIZE ) {\n                vattr->va_size = iattr->ia_size;\n\t}\n        if ( valid & ATTR_ATIME ) {\n                vattr->va_atime = iattr->ia_atime;\n\t}\n        if ( valid & ATTR_MTIME ) {\n                vattr->va_mtime = iattr->ia_mtime;\n\t}\n        if ( valid & ATTR_CTIME ) {\n                vattr->va_ctime = iattr->ia_ctime;\n\t}\n}"
  },
  {
    "function_name": "coda_vattr_to_iattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
    "lines": "70-112",
    "snippet": "void coda_vattr_to_iattr(struct inode *inode, struct coda_vattr *attr)\n{\n        int inode_type;\n        /* inode's i_flags, i_ino are set by iget \n           XXX: is this all we need ??\n           */\n        switch (attr->va_type) {\n        case C_VNON:\n                inode_type  = 0;\n                break;\n        case C_VREG:\n                inode_type = S_IFREG;\n                break;\n        case C_VDIR:\n                inode_type = S_IFDIR;\n                break;\n        case C_VLNK:\n                inode_type = S_IFLNK;\n                break;\n        default:\n                inode_type = 0;\n        }\n\tinode->i_mode |= inode_type;\n\n\tif (attr->va_mode != (u_short) -1)\n\t        inode->i_mode = attr->va_mode | inode_type;\n        if (attr->va_uid != -1) \n\t        inode->i_uid = make_kuid(&init_user_ns, (uid_t) attr->va_uid);\n        if (attr->va_gid != -1)\n\t        inode->i_gid = make_kgid(&init_user_ns, (gid_t) attr->va_gid);\n\tif (attr->va_nlink != -1)\n\t\tset_nlink(inode, attr->va_nlink);\n\tif (attr->va_size != -1)\n\t        inode->i_size = attr->va_size;\n\tif (attr->va_size != -1)\n\t\tinode->i_blocks = (attr->va_size + 511) >> 9;\n\tif (attr->va_atime.tv_sec != -1) \n\t        inode->i_atime = attr->va_atime;\n\tif (attr->va_mtime.tv_sec != -1)\n\t        inode->i_mtime = attr->va_mtime;\n        if (attr->va_ctime.tv_sec != -1)\n\t        inode->i_ctime = attr->va_ctime;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "attr->va_nlink"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "(gid_t) attr->va_gid"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "(uid_t) attr->va_uid"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid coda_vattr_to_iattr(struct inode *inode, struct coda_vattr *attr)\n{\n        int inode_type;\n        /* inode's i_flags, i_ino are set by iget \n           XXX: is this all we need ??\n           */\n        switch (attr->va_type) {\n        case C_VNON:\n                inode_type  = 0;\n                break;\n        case C_VREG:\n                inode_type = S_IFREG;\n                break;\n        case C_VDIR:\n                inode_type = S_IFDIR;\n                break;\n        case C_VLNK:\n                inode_type = S_IFLNK;\n                break;\n        default:\n                inode_type = 0;\n        }\n\tinode->i_mode |= inode_type;\n\n\tif (attr->va_mode != (u_short) -1)\n\t        inode->i_mode = attr->va_mode | inode_type;\n        if (attr->va_uid != -1) \n\t        inode->i_uid = make_kuid(&init_user_ns, (uid_t) attr->va_uid);\n        if (attr->va_gid != -1)\n\t        inode->i_gid = make_kgid(&init_user_ns, (gid_t) attr->va_gid);\n\tif (attr->va_nlink != -1)\n\t\tset_nlink(inode, attr->va_nlink);\n\tif (attr->va_size != -1)\n\t        inode->i_size = attr->va_size;\n\tif (attr->va_size != -1)\n\t\tinode->i_blocks = (attr->va_size + 511) >> 9;\n\tif (attr->va_atime.tv_sec != -1) \n\t        inode->i_atime = attr->va_atime;\n\tif (attr->va_mtime.tv_sec != -1)\n\t        inode->i_mtime = attr->va_mtime;\n        if (attr->va_ctime.tv_sec != -1)\n\t        inode->i_ctime = attr->va_ctime;\n}"
  },
  {
    "function_name": "coda_flags_to_cflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
    "lines": "43-66",
    "snippet": "unsigned short coda_flags_to_cflags(unsigned short flags)\n{\n\tunsigned short coda_flags = 0;\n\t\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tcoda_flags |= C_O_READ;\n\n\tif ((flags & O_ACCMODE) == O_RDWR)\n\t\tcoda_flags |= C_O_READ | C_O_WRITE;\n\n\tif ((flags & O_ACCMODE) == O_WRONLY)\n\t\tcoda_flags |= C_O_WRITE;\n\n\tif (flags & O_TRUNC)\n\t\tcoda_flags |= C_O_TRUNC;\n\n\tif (flags & O_CREAT)\n\t\tcoda_flags |= C_O_CREAT;\n\n\tif (flags & O_EXCL)\n\t\tcoda_flags |= C_O_EXCL;\n\n\treturn coda_flags;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nunsigned short coda_flags_to_cflags(unsigned short flags)\n{\n\tunsigned short coda_flags = 0;\n\t\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tcoda_flags |= C_O_READ;\n\n\tif ((flags & O_ACCMODE) == O_RDWR)\n\t\tcoda_flags |= C_O_READ | C_O_WRITE;\n\n\tif ((flags & O_ACCMODE) == O_WRONLY)\n\t\tcoda_flags |= C_O_WRITE;\n\n\tif (flags & O_TRUNC)\n\t\tcoda_flags |= C_O_TRUNC;\n\n\tif (flags & O_CREAT)\n\t\tcoda_flags |= C_O_CREAT;\n\n\tif (flags & O_EXCL)\n\t\tcoda_flags |= C_O_EXCL;\n\n\treturn coda_flags;\n}"
  },
  {
    "function_name": "coda_iscontrol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
    "lines": "37-41",
    "snippet": "int coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "CODA_CONTROL",
            "CODA_CONTROLLEN"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}"
  },
  {
    "function_name": "coda_f2s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
    "lines": "27-34",
    "snippet": "char * coda_f2s(struct CodaFid *f)\n{\n\tstatic char s[60];\n\n \tsprintf(s, \"(%08x.%08x.%08x.%08x)\", f->opaque[0], f->opaque[1], f->opaque[2], f->opaque[3]);\n\n\treturn s;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"(%08x.%08x.%08x.%08x)\"",
            "f->opaque[0]",
            "f->opaque[1]",
            "f->opaque[2]",
            "f->opaque[3]"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nchar * coda_f2s(struct CodaFid *f)\n{\n\tstatic char s[60];\n\n \tsprintf(s, \"(%08x.%08x.%08x.%08x)\", f->opaque[0], f->opaque[1], f->opaque[2], f->opaque[3]);\n\n\treturn s;\n}"
  }
]