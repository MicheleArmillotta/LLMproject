[
  {
    "function_name": "cifs_prune_tlinks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "4088-4129",
    "snippet": "static void\ncifs_prune_tlinks(struct work_struct *work)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\n\t\t\t\t\t\t    prune_tlinks.work);\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node = rb_first(root);\n\tstruct rb_node *tmp;\n\tstruct tcon_link *tlink;\n\n\t/*\n\t * Because we drop the spinlock in the loop in order to put the tlink\n\t * it's not guarded against removal of links from the tree. The only\n\t * places that remove entries from the tree are this function and\n\t * umounts. Because this function is non-reentrant and is canceled\n\t * before umount can proceed, this is safe.\n\t */\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\tnode = rb_first(root);\n\twhile (node != NULL) {\n\t\ttmp = node;\n\t\tnode = rb_next(tmp);\n\t\ttlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\n\n\t\tif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\n\t\t    atomic_read(&tlink->tl_count) != 0 ||\n\t\t    time_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\n\t\t\tcontinue;\n\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(tmp, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define TLINK_IDLE_EXPIRE\t(600 * HZ)"
    ],
    "globals_used": [
      "static void cifs_prune_tlinks(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "cifsiod_wq",
            "&cifs_sb->prune_tlinks",
            "TLINK_IDLE_EXPIRE"
          ],
          "line": 4127
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_sb->tlink_tree_lock"
          ],
          "line": 4125
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_sb->tlink_tree_lock"
          ],
          "line": 4123
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 4122
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "tmp",
            "root"
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "TCON_LINK_IN_TREE",
            "&tlink->tl_flags"
          ],
          "line": 4118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_get_tlink",
          "args": [
            "tlink"
          ],
          "line": 4117
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "939-945",
          "snippet": "static inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "tlink->tl_time + TLINK_IDLE_EXPIRE",
            "jiffies"
          ],
          "line": 4114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tlink->tl_count"
          ],
          "line": 4113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TCON_LINK_MASTER",
            "&tlink->tl_flags"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "tmp",
            "structtcon_link",
            "tl_rbnode"
          ],
          "line": 4110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "tmp"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structcifs_sb_info",
            "prune_tlinks.work"
          ],
          "line": 4091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_IDLE_EXPIRE\t(600 * HZ)\n\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\nstatic void\ncifs_prune_tlinks(struct work_struct *work)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\n\t\t\t\t\t\t    prune_tlinks.work);\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node = rb_first(root);\n\tstruct rb_node *tmp;\n\tstruct tcon_link *tlink;\n\n\t/*\n\t * Because we drop the spinlock in the loop in order to put the tlink\n\t * it's not guarded against removal of links from the tree. The only\n\t * places that remove entries from the tree are this function and\n\t * umounts. Because this function is non-reentrant and is canceled\n\t * before umount can proceed, this is safe.\n\t */\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\tnode = rb_first(root);\n\twhile (node != NULL) {\n\t\ttmp = node;\n\t\tnode = rb_next(tmp);\n\t\ttlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\n\n\t\tif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\n\t\t    atomic_read(&tlink->tl_count) != 0 ||\n\t\t    time_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\n\t\t\tcontinue;\n\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(tmp, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n}"
  },
  {
    "function_name": "cifs_sb_tlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "4011-4082",
    "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 4077
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink->tl_tcon"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&tlink->tl_flags",
            "TCON_LINK_PENDING"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "TCON_LINK_PENDING",
            "&tlink->tl_flags"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_construct_tcon",
          "args": [
            "cifs_sb",
            "fsuid"
          ],
          "line": 4072
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_construct_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3890-3946",
          "snippet": "static struct cifs_tcon *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)\n{\n\tint rc;\n\tstruct cifs_tcon *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb_vol *vol_info;\n\n\tvol_info = kzalloc(sizeof(*vol_info), GFP_KERNEL);\n\tif (vol_info == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvol_info->local_nls = cifs_sb->local_nls;\n\tvol_info->linux_uid = fsuid;\n\tvol_info->cred_uid = fsuid;\n\tvol_info->UNC = master_tcon->treeName;\n\tvol_info->retry = master_tcon->retry;\n\tvol_info->nocase = master_tcon->nocase;\n\tvol_info->local_lease = master_tcon->local_lease;\n\tvol_info->no_linux_ext = !master_tcon->unix_ext;\n\tvol_info->sectype = master_tcon->ses->sectype;\n\tvol_info->sign = master_tcon->ses->sign;\n\n\trc = cifs_set_vol_auth(vol_info, master_tcon->ses);\n\tif (rc) {\n\t\ttcon = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\t/* get a reference for the same TCP session */\n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, vol_info);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifs_tcon *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, vol_info);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n\tif (cap_unix(ses))\n\t\treset_cifs_unix_caps(0, tcon, NULL, vol_info);\nout:\n\tkfree(vol_info->username);\n\tkfree(vol_info->password);\n\tkfree(vol_info);\n\n\treturn tcon;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct cifs_tcon *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)\n{\n\tint rc;\n\tstruct cifs_tcon *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb_vol *vol_info;\n\n\tvol_info = kzalloc(sizeof(*vol_info), GFP_KERNEL);\n\tif (vol_info == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvol_info->local_nls = cifs_sb->local_nls;\n\tvol_info->linux_uid = fsuid;\n\tvol_info->cred_uid = fsuid;\n\tvol_info->UNC = master_tcon->treeName;\n\tvol_info->retry = master_tcon->retry;\n\tvol_info->nocase = master_tcon->nocase;\n\tvol_info->local_lease = master_tcon->local_lease;\n\tvol_info->no_linux_ext = !master_tcon->unix_ext;\n\tvol_info->sectype = master_tcon->ses->sectype;\n\tvol_info->sign = master_tcon->ses->sign;\n\n\trc = cifs_set_vol_auth(vol_info, master_tcon->ses);\n\tif (rc) {\n\t\ttcon = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\t/* get a reference for the same TCP session */\n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, vol_info);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifs_tcon *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, vol_info);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n\tif (cap_unix(ses))\n\t\treset_cifs_unix_caps(0, tcon, NULL, vol_info);\nout:\n\tkfree(vol_info->username);\n\tkfree(vol_info->password);\n\tkfree(vol_info);\n\n\treturn tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "TCON_LINK_PENDING",
            "&tlink->tl_flags"
          ],
          "line": 4068
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "tlink->tl_time + TLINK_ERROR_EXPIRE"
          ],
          "line": 4063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink->tl_tcon"
          ],
          "line": 4059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ERESTARTSYS"
          ],
          "line": 4055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&tlink->tl_flags",
            "TCON_LINK_PENDING",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_sb->tlink_tree_lock"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_rb_insert",
          "args": [
            "&cifs_sb->tlink_tree",
            "tlink"
          ],
          "line": 4047
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_rb_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3975-3993",
          "snippet": "static void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);\n\nstatic void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newtlink"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_tlink",
          "args": [
            "tlink"
          ],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "939-945",
          "snippet": "static inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_rb_search",
          "args": [
            "&cifs_sb->tlink_tree",
            "fsuid"
          ],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_rb_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3955-3972",
          "snippet": "static struct tcon_link *\ntlink_rb_search(struct rb_root *root, kuid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (uid_gt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_left;\n\t\telse if (uid_lt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic struct tcon_link *\ntlink_rb_search(struct rb_root *root, kuid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (uid_gt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_left;\n\t\telse if (uid_lt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_sb->tlink_tree_lock"
          ],
          "line": 4037
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "TCON_LINK_IN_TREE",
            "&newtlink->tl_flags"
          ],
          "line": 4034
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tlink)",
            "GFP_KERNEL"
          ],
          "line": 4028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 4019
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2684-2688",
          "snippet": "static inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
  },
  {
    "function_name": "tlink_rb_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3975-3993",
    "snippet": "static void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new_tlink->tl_rbnode",
            "root"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new_tlink->tl_rbnode",
            "parent",
            "new"
          ],
          "line": 3991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_gt",
          "args": [
            "tlink->tl_uid",
            "new_tlink->tl_uid"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*new",
            "structtcon_link",
            "tl_rbnode"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);\n\nstatic void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}"
  },
  {
    "function_name": "tlink_rb_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3955-3972",
    "snippet": "static struct tcon_link *\ntlink_rb_search(struct rb_root *root, kuid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (uid_gt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_left;\n\t\telse if (uid_lt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_lt",
          "args": [
            "tlink->tl_uid",
            "uid"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_gt",
          "args": [
            "tlink->tl_uid",
            "uid"
          ],
          "line": 3964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structtcon_link",
            "tl_rbnode"
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic struct tcon_link *\ntlink_rb_search(struct rb_root *root, kuid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (uid_gt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_left;\n\t\telse if (uid_lt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "cifs_sb_master_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3948-3952",
    "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cifs_sb_master_tlink(cifs_sb)"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2684-2688",
          "snippet": "static inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
  },
  {
    "function_name": "cifs_construct_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3890-3946",
    "snippet": "static struct cifs_tcon *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)\n{\n\tint rc;\n\tstruct cifs_tcon *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb_vol *vol_info;\n\n\tvol_info = kzalloc(sizeof(*vol_info), GFP_KERNEL);\n\tif (vol_info == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvol_info->local_nls = cifs_sb->local_nls;\n\tvol_info->linux_uid = fsuid;\n\tvol_info->cred_uid = fsuid;\n\tvol_info->UNC = master_tcon->treeName;\n\tvol_info->retry = master_tcon->retry;\n\tvol_info->nocase = master_tcon->nocase;\n\tvol_info->local_lease = master_tcon->local_lease;\n\tvol_info->no_linux_ext = !master_tcon->unix_ext;\n\tvol_info->sectype = master_tcon->ses->sectype;\n\tvol_info->sign = master_tcon->ses->sign;\n\n\trc = cifs_set_vol_auth(vol_info, master_tcon->ses);\n\tif (rc) {\n\t\ttcon = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\t/* get a reference for the same TCP session */\n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, vol_info);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifs_tcon *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, vol_info);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n\tif (cap_unix(ses))\n\t\treset_cifs_unix_caps(0, tcon, NULL, vol_info);\nout:\n\tkfree(vol_info->username);\n\tkfree(vol_info->password);\n\tkfree(vol_info);\n\n\treturn tcon;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol_info"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol_info->password"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol_info->username"
          ],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_cifs_unix_caps",
          "args": [
            "0",
            "tcon",
            "NULL",
            "vol_info"
          ],
          "line": 3939
        },
        "resolved": true,
        "details": {
          "function_name": "reset_cifs_unix_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3072-3170",
          "snippet": "void reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\t} else\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nvoid reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\t} else\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "ses"
          ],
          "line": 3938
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_smb_ses",
          "args": [
            "ses"
          ],
          "line": 3934
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_smb_ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2266-2302",
          "snippet": "static void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tcon"
          ],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_tcon",
          "args": [
            "ses",
            "vol_info"
          ],
          "line": 3932
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2590-2664",
          "snippet": "static struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifs_tcon *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcifs_dbg(VFS, \"transport encryption setting conflicts with existing tid\\n\");\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t/*\n\t * BB Do we need to wrap session_mutex around this TCon call and Unix\n\t * SetFS as we do on SessSetup and reconnect?\n\t */\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, volume_info->UNC, tcon,\n\t\t\t\t\t    volume_info->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcifs_dbg(FYI, \"DFS disabled (%d)\\n\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/*\n\t * We can have only one retry value for a connection to a share so for\n\t * resources mounted more than once to the same server share the last\n\t * value passed in for the retry flag is used.\n\t */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_super_cookie(tcon);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifs_tcon *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcifs_dbg(VFS, \"transport encryption setting conflicts with existing tid\\n\");\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t/*\n\t * BB Do we need to wrap session_mutex around this TCon call and Unix\n\t * SetFS as we do on SessSetup and reconnect?\n\t */\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, volume_info->UNC, tcon,\n\t\t\t\t\t    volume_info->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcifs_dbg(FYI, \"DFS disabled (%d)\\n\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/*\n\t * We can have only one retry value for a connection to a share so for\n\t * resources mounted more than once to the same server share the last\n\t * value passed in for the retry flag is used.\n\t */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_super_cookie(tcon);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tcp_session",
          "args": [
            "master_tcon->ses->server"
          ],
          "line": 3928
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tcp_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2067-2099",
          "snippet": "static void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ses"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_smb_ses",
          "args": [
            "master_tcon->ses->server",
            "vol_info"
          ],
          "line": 3925
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_smb_ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2434-2534",
          "snippet": "static struct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->status);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tfree_xid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\", &addr->sin_addr);\n\n\tif (volume_info->username) {\n\t\tses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\tses->cred_uid = volume_info->cred_uid;\n\tses->linux_uid = volume_info->linux_uid;\n\n\tses->sectype = volume_info->sectype;\n\tses->sign = volume_info->sign;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tfree_xid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->status);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tfree_xid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\", &addr->sin_addr);\n\n\tif (volume_info->username) {\n\t\tses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\tses->cred_uid = volume_info->cred_uid;\n\tses->linux_uid = volume_info->linux_uid;\n\n\tses->sectype = volume_info->sectype;\n\tses->sign = volume_info->sign;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tfree_xid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 3923
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 3921
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_set_vol_auth",
          "args": [
            "vol_info",
            "master_tcon->ses"
          ],
          "line": 3914
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_vol_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3878-3888",
          "snippet": "static int\ncifs_set_vol_auth(struct smb_vol *vol, struct cifs_ses *ses)\n{\n\tvol->sectype = ses->sectype;\n\n\t/* krb5 is special, since we don't need username or pw */\n\tif (vol->sectype == Kerberos)\n\t\treturn 0;\n\n\treturn cifs_set_cifscreds(vol, ses);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_set_vol_auth(struct smb_vol *vol, struct cifs_ses *ses)\n{\n\tvol->sectype = ses->sectype;\n\n\t/* krb5 is special, since we don't need username or pw */\n\tif (vol->sectype == Kerberos)\n\t\treturn 0;\n\n\treturn cifs_set_cifscreds(vol, ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*vol_info)",
            "GFP_KERNEL"
          ],
          "line": 3899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 3894
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct cifs_tcon *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)\n{\n\tint rc;\n\tstruct cifs_tcon *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb_vol *vol_info;\n\n\tvol_info = kzalloc(sizeof(*vol_info), GFP_KERNEL);\n\tif (vol_info == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvol_info->local_nls = cifs_sb->local_nls;\n\tvol_info->linux_uid = fsuid;\n\tvol_info->cred_uid = fsuid;\n\tvol_info->UNC = master_tcon->treeName;\n\tvol_info->retry = master_tcon->retry;\n\tvol_info->nocase = master_tcon->nocase;\n\tvol_info->local_lease = master_tcon->local_lease;\n\tvol_info->no_linux_ext = !master_tcon->unix_ext;\n\tvol_info->sectype = master_tcon->ses->sectype;\n\tvol_info->sign = master_tcon->ses->sign;\n\n\trc = cifs_set_vol_auth(vol_info, master_tcon->ses);\n\tif (rc) {\n\t\ttcon = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\t/* get a reference for the same TCP session */\n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, vol_info);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifs_tcon *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, vol_info);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n\tif (cap_unix(ses))\n\t\treset_cifs_unix_caps(0, tcon, NULL, vol_info);\nout:\n\tkfree(vol_info->username);\n\tkfree(vol_info->password);\n\tkfree(vol_info);\n\n\treturn tcon;\n}"
  },
  {
    "function_name": "cifs_set_vol_auth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3878-3888",
    "snippet": "static int\ncifs_set_vol_auth(struct smb_vol *vol, struct cifs_ses *ses)\n{\n\tvol->sectype = ses->sectype;\n\n\t/* krb5 is special, since we don't need username or pw */\n\tif (vol->sectype == Kerberos)\n\t\treturn 0;\n\n\treturn cifs_set_cifscreds(vol, ses);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_set_cifscreds",
          "args": [
            "vol",
            "ses"
          ],
          "line": 3887
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_cifscreds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2426-2431",
          "snippet": "static inline int\ncifs_set_cifscreds(struct smb_vol *vol __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline int\ncifs_set_cifscreds(struct smb_vol *vol __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_set_vol_auth(struct smb_vol *vol, struct cifs_ses *ses)\n{\n\tvol->sectype = ses->sectype;\n\n\t/* krb5 is special, since we don't need username or pw */\n\tif (vol->sectype == Kerberos)\n\t\treturn 0;\n\n\treturn cifs_set_cifscreds(vol, ses);\n}"
  },
  {
    "function_name": "cifs_setup_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3855-3876",
    "snippet": "int\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, nls_info);\n\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Send error in SessSetup = %d\\n\"",
            "rc"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->sess_setup",
          "args": [
            "xid",
            "ses",
            "nls_info"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\"",
            "server->sec_mode",
            "server->capabilities",
            "server->timeAdj"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, nls_info);\n\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_negotiate_protocol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3827-3853",
    "snippet": "int\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tif (!server->ops->need_neg(server))\n\t\treturn 0;\n\n\tset_credits(server, 1);\n\n\trc = server->ops->negotiate(xid, ses);\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 3849
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->negotiate",
          "args": [
            "xid",
            "ses"
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_credits",
          "args": [
            "server",
            "1"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "127-134",
          "snippet": "static void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->need_neg",
          "args": [
            "server"
          ],
          "line": 3837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tif (!server->ops->need_neg(server))\n\t\treturn 0;\n\n\tset_credits(server, 1);\n\n\trc = server->ops->negotiate(xid, ses);\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3800-3825",
    "snippet": "void\ncifs_umount(struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct tcon_link *tlink;\n\n\tcancel_delayed_work_sync(&cifs_sb->prune_tlinks);\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\twhile ((node = rb_first(root))) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(node, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tbdi_destroy(&cifs_sb->bdi);\n\tkfree(cifs_sb->mountdata);\n\tcall_rcu(&cifs_sb->rcu, delayed_free);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&cifs_sb->rcu",
            "delayed_free"
          ],
          "line": 3824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cifs_sb->mountdata"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&cifs_sb->bdi"
          ],
          "line": 3822
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_sb->tlink_tree_lock"
          ],
          "line": 3820
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_sb->tlink_tree_lock"
          ],
          "line": 3818
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 3817
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "root"
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "TCON_LINK_IN_TREE",
            "&tlink->tl_flags"
          ],
          "line": 3813
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_get_tlink",
          "args": [
            "tlink"
          ],
          "line": 3812
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "939-945",
          "snippet": "static inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structtcon_link",
            "tl_rbnode"
          ],
          "line": 3811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root"
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&cifs_sb->prune_tlinks"
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_umount(struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct tcon_link *tlink;\n\n\tcancel_delayed_work_sync(&cifs_sb->prune_tlinks);\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\twhile ((node = rb_first(root))) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(node, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tbdi_destroy(&cifs_sb->bdi);\n\tkfree(cifs_sb->mountdata);\n\tcall_rcu(&cifs_sb->rcu, delayed_free);\n}"
  },
  {
    "function_name": "delayed_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3793-3798",
    "snippet": "static void delayed_free(struct rcu_head *p)\n{\n\tstruct cifs_sb_info *sbi = container_of(p, struct cifs_sb_info, rcu);\n\tunload_nls(sbi->local_nls);\n\tkfree(sbi);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "sbi->local_nls"
          ],
          "line": 3796
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structcifs_sb_info",
            "rcu"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void delayed_free(struct rcu_head *p)\n{\n\tstruct cifs_sb_info *sbi = container_of(p, struct cifs_sb_info, rcu);\n\tunload_nls(sbi->local_nls);\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "CIFSTCon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3637-3791",
    "snippet": "int\nCIFSTCon(const unsigned int xid, struct cifs_ses *ses,\n\t const char *tree, struct cifs_tcon *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = get_next_mid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\tif (!tcon || (ses->server->sec_mode & SECMODE_USER)) {\n\t\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t\t*bcc_ptr = 0; /* password is null byte */\n\t\tbcc_ptr++;              /* skip password */\n\t\t/* already aligned so no need to do it below */\n\t} else {\n\t\tpSMB->PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\t\t/* BB FIXME add code to fail this if NTLMv2 or Kerberos\n\t\t   specified as required (when that support is added to\n\t\t   the vfs in the future) as only NTLM or the much\n\t\t   weaker LANMAN (which we do not send by default) is accepted\n\t\t   by Samba (not sure whether other servers allow\n\t\t   NTLMv2 password here) */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\n\t\t    (ses->sectype == LANMAN))\n\t\t\tcalc_lanman_hash(tcon->password, ses->server->cryptkey,\n\t\t\t\t\t ses->server->sec_mode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false,\n\t\t\t\t\t bcc_ptr);\n\t\telse\n#endif /* CIFS_WEAK_PW_HASH */\n\t\trc = SMBNTencrypt(tcon->password, ses->server->cryptkey,\n\t\t\t\t\tbcc_ptr, nls_codepage);\n\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t\tif (ses->capabilities & CAP_UNICODE) {\n\t\t\t/* must align unicode strings */\n\t\t\t*bcc_ptr = 0; /* null byte password */\n\t\t\tbcc_ptr++;\n\t\t}\n\t}\n\n\tif (ses->server->sign)\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUTF16((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tpSMB->hdr.smb_buf_length = cpu_to_be32(be32_to_cpu(\n\t\t\t\t\tpSMB->hdr.smb_buf_length) + count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t/* above now done in SendReceive */\n\tif ((rc == 0) && (tcon != NULL)) {\n\t\tbool is_unicode;\n\n\t\ttcon->tidStatus = CifsGood;\n\t\ttcon->need_reconnect = false;\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcifs_dbg(FYI, \"IPC connection\\n\");\n\t\t\t\ttcon->ipc = 1;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcifs_dbg(FYI, \"disk share connection\\n\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_utf16(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcifs_dbg(FYI, \"nativeFileSystem=%s\\n\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcifs_dbg(FYI, \"Tcon flags: 0x%x\\n\", tcon->Flags);\n\t} else if ((rc == 0) && tcon == NULL) {\n\t\t/* all we need to save for IPC$ connection */\n\t\tses->ipc_tid = smb_buffer_response->Tid;\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "smb_buffer"
          ],
          "line": 3789
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Tcon flags: 0x%x\\n\"",
            "tcon->Flags"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->OptionalSupport"
          ],
          "line": 3780
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"nativeFileSystem=%s\\n\"",
            "tcon->nativeFileSystem"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_strndup_from_utf16",
          "args": [
            "bcc_ptr",
            "bytes_left",
            "is_unicode",
            "nls_codepage"
          ],
          "line": 3771
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strndup_from_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "310-335",
          "snippet": "char *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nchar *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tcon->nativeFileSystem"
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "tcon->treeName",
            "tree",
            "sizeof(tcon->treeName)"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"disk share connection\\n\""
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"IPC connection\\n\""
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "bcc_ptr",
            "bytes_left - 2"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "smb_buffer_response"
          ],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pByteArea",
          "args": [
            "smb_buffer_response"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "ses",
            "smb_buffer",
            "smb_buffer_response",
            "&length",
            "0"
          ],
          "line": 3733
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 3731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "be32_to_cpu(\n\t\t\t\t\tpSMB->hdr.smb_buf_length) + count"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pSMB->hdr.smb_buf_length"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"?????\""
          ],
          "line": 3726
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "bcc_ptr",
            "\"?????\""
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "bcc_ptr",
            "tree"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "(__le16 *) bcc_ptr",
            "tree",
            "6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */)",
            "nls_codepage"
          ],
          "line": 3716
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMBNTencrypt",
          "args": [
            "tcon->password",
            "ses->server->cryptkey",
            "bcc_ptr",
            "nls_codepage"
          ],
          "line": 3693
        },
        "resolved": true,
        "details": {
          "function_name": "SMBNTencrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smbencrypt.c",
          "lines": "230-249",
          "snippet": "int\nSMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24,\n\t\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tunsigned char p16[16], p21[21];\n\n\tmemset(p16, '\\0', 16);\n\tmemset(p21, '\\0', 21);\n\n\trc = E_md4hash(passwd, p16, codepage);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NT hash, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tmemcpy(p21, p16, 16);\n\trc = E_P24(p21, c8, p24);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsproto.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/random.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/random.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint\nSMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24,\n\t\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tunsigned char p16[16], p21[21];\n\n\tmemset(p16, '\\0', 16);\n\tmemset(p21, '\\0', 21);\n\n\trc = E_md4hash(passwd, p16, codepage);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NT hash, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tmemcpy(p21, p16, 16);\n\trc = E_P24(p21, c8, p24);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_lanman_hash",
          "args": [
            "tcon->password",
            "ses->server->cryptkey",
            "ses->server->sec_mode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false",
            "bcc_ptr"
          ],
          "line": 3687
        },
        "resolved": true,
        "details": {
          "function_name": "calc_lanman_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "301-335",
          "snippet": "int calc_lanman_hash(const char *password, const char *cryptkey, bool encrypt,\n\t\t\tchar *lnm_session_key)\n{\n\tint i;\n\tint rc;\n\tchar password_with_pad[CIFS_ENCPWD_SIZE];\n\n\tmemset(password_with_pad, 0, CIFS_ENCPWD_SIZE);\n\tif (password)\n\t\tstrncpy(password_with_pad, password, CIFS_ENCPWD_SIZE);\n\n\tif (!encrypt && global_secflags & CIFSSEC_MAY_PLNTXT) {\n\t\tmemcpy(lnm_session_key, password_with_pad,\n\t\t\tCIFS_ENCPWD_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* calculate old style session key */\n\t/* calling toupper is less broken than repeatedly\n\tcalling nls_toupper would be since that will never\n\twork for UTF8, but neither handles multibyte code pages\n\tbut the only alternative would be converting to UCS-16 (Unicode)\n\t(using a routine something like UniStrupr) then\n\tuppercasing and then converting back from Unicode - which\n\twould only worth doing it if we knew it were utf8. Basically\n\tutf8 and other multibyte codepages each need their own strupper\n\tfunction since a byte at a time will ont work. */\n\n\tfor (i = 0; i < CIFS_ENCPWD_SIZE; i++)\n\t\tpassword_with_pad[i] = toupper(password_with_pad[i]);\n\n\trc = SMBencrypt(password_with_pad, cryptkey, lnm_session_key);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint calc_lanman_hash(const char *password, const char *cryptkey, bool encrypt,\n\t\t\tchar *lnm_session_key)\n{\n\tint i;\n\tint rc;\n\tchar password_with_pad[CIFS_ENCPWD_SIZE];\n\n\tmemset(password_with_pad, 0, CIFS_ENCPWD_SIZE);\n\tif (password)\n\t\tstrncpy(password_with_pad, password, CIFS_ENCPWD_SIZE);\n\n\tif (!encrypt && global_secflags & CIFSSEC_MAY_PLNTXT) {\n\t\tmemcpy(lnm_session_key, password_with_pad,\n\t\t\tCIFS_ENCPWD_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* calculate old style session key */\n\t/* calling toupper is less broken than repeatedly\n\tcalling nls_toupper would be since that will never\n\twork for UTF8, but neither handles multibyte code pages\n\tbut the only alternative would be converting to UCS-16 (Unicode)\n\t(using a routine something like UniStrupr) then\n\tuppercasing and then converting back from Unicode - which\n\twould only worth doing it if we knew it were utf8. Basically\n\tutf8 and other multibyte codepages each need their own strupper\n\tfunction since a byte at a time will ont work. */\n\n\tfor (i = 0; i < CIFS_ENCPWD_SIZE; i++)\n\t\tpassword_with_pad[i] = toupper(password_with_pad[i]);\n\n\trc = SMBencrypt(password_with_pad, cryptkey, lnm_session_key);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_AUTH_RESP_SIZE"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TCON_EXTENDED_SECINFO"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_mid",
          "args": [
            "ses->server"
          ],
          "line": 3663
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_next_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "169-234",
          "snippet": "static __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "header_assemble",
          "args": [
            "smb_buffer",
            "SMB_COM_TREE_CONNECT_ANDX",
            "NULL/*no tid */",
            "4/*wct */"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "header_assemble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "240-287",
          "snippet": "void\nheader_assemble(struct smb_hdr *buffer, char smb_command /* command */ ,\n\t\tconst struct cifs_tcon *treeCon, int word_count\n\t\t/* length of fixed section (word count) in two byte units  */)\n{\n\tchar *temp = (char *) buffer;\n\n\tmemset(temp, 0, 256); /* bigger than MAX_CIFS_HDR_SIZE */\n\n\tbuffer->smb_buf_length = cpu_to_be32(\n\t    (2 * word_count) + sizeof(struct smb_hdr) -\n\t    4 /*  RFC 1001 length field does not count */  +\n\t    2 /* for bcc field itself */) ;\n\n\tbuffer->Protocol[0] = 0xFF;\n\tbuffer->Protocol[1] = 'S';\n\tbuffer->Protocol[2] = 'M';\n\tbuffer->Protocol[3] = 'B';\n\tbuffer->Command = smb_command;\n\tbuffer->Flags = 0x00;\t/* case sensitive */\n\tbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\n\tbuffer->Pid = cpu_to_le16((__u16)current->tgid);\n\tbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\n\tif (treeCon) {\n\t\tbuffer->Tid = treeCon->tid;\n\t\tif (treeCon->ses) {\n\t\t\tif (treeCon->ses->capabilities & CAP_UNICODE)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\t\t\tif (treeCon->ses->capabilities & CAP_STATUS32)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t\t\t/* Uid is not converted */\n\t\t\tbuffer->Uid = treeCon->ses->Suid;\n\t\t\tbuffer->Mid = get_next_mid(treeCon->ses->server);\n\t\t}\n\t\tif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\t\tbuffer->Flags2 |= SMBFLG2_DFS;\n\t\tif (treeCon->nocase)\n\t\t\tbuffer->Flags  |= SMBFLG_CASELESS;\n\t\tif ((treeCon->ses) && (treeCon->ses->server))\n\t\t\tif (treeCon->ses->server->sign)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n/*  endian conversion of flags is now done just before sending */\n\tbuffer->WordCount = (char) word_count;\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nheader_assemble(struct smb_hdr *buffer, char smb_command /* command */ ,\n\t\tconst struct cifs_tcon *treeCon, int word_count\n\t\t/* length of fixed section (word count) in two byte units  */)\n{\n\tchar *temp = (char *) buffer;\n\n\tmemset(temp, 0, 256); /* bigger than MAX_CIFS_HDR_SIZE */\n\n\tbuffer->smb_buf_length = cpu_to_be32(\n\t    (2 * word_count) + sizeof(struct smb_hdr) -\n\t    4 /*  RFC 1001 length field does not count */  +\n\t    2 /* for bcc field itself */) ;\n\n\tbuffer->Protocol[0] = 0xFF;\n\tbuffer->Protocol[1] = 'S';\n\tbuffer->Protocol[2] = 'M';\n\tbuffer->Protocol[3] = 'B';\n\tbuffer->Command = smb_command;\n\tbuffer->Flags = 0x00;\t/* case sensitive */\n\tbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\n\tbuffer->Pid = cpu_to_le16((__u16)current->tgid);\n\tbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\n\tif (treeCon) {\n\t\tbuffer->Tid = treeCon->tid;\n\t\tif (treeCon->ses) {\n\t\t\tif (treeCon->ses->capabilities & CAP_UNICODE)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\t\t\tif (treeCon->ses->capabilities & CAP_STATUS32)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t\t\t/* Uid is not converted */\n\t\t\tbuffer->Uid = treeCon->ses->Suid;\n\t\t\tbuffer->Mid = get_next_mid(treeCon->ses->server);\n\t\t}\n\t\tif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\t\tbuffer->Flags2 |= SMBFLG2_DFS;\n\t\tif (treeCon->nocase)\n\t\t\tbuffer->Flags  |= SMBFLG_CASELESS;\n\t\tif ((treeCon->ses) && (treeCon->ses->server))\n\t\t\tif (treeCon->ses->server->sign)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n/*  endian conversion of flags is now done just before sending */\n\tbuffer->WordCount = (char) word_count;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_buf_get",
          "args": [],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "146-178",
          "snippet": "struct smb_hdr *\ncifs_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\tsize_t buf_size = sizeof(struct smb_hdr);\n\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 header is bigger than CIFS one - no problems to clean some\n\t * more bytes for CIFS.\n\t */\n\tbuf_size = sizeof(struct smb2_hdr);\n#endif\n\t/*\n\t * We could use negotiated size instead of max_msgsize -\n\t * but it may be more efficient to always alloc same size\n\t * albeit slightly larger than necessary and maxbuffersize\n\t * defaults to this and can not be bigger.\n\t */\n\tret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\n\n\t/* clear the first few header bytes */\n\t/* for most paths, more is cleared in header_assemble */\n\tif (ret_buf) {\n\t\tmemset(ret_buf, 0, buf_size + 3);\n\t\tatomic_inc(&bufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\t}\n\n\treturn ret_buf;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nstruct smb_hdr *\ncifs_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\tsize_t buf_size = sizeof(struct smb_hdr);\n\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 header is bigger than CIFS one - no problems to clean some\n\t * more bytes for CIFS.\n\t */\n\tbuf_size = sizeof(struct smb2_hdr);\n#endif\n\t/*\n\t * We could use negotiated size instead of max_msgsize -\n\t * but it may be more efficient to always alloc same size\n\t * albeit slightly larger than necessary and maxbuffersize\n\t * defaults to this and can not be bigger.\n\t */\n\tret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\n\n\t/* clear the first few header bytes */\n\t/* for most paths, more is cleared in header_assemble */\n\tif (ret_buf) {\n\t\tmemset(ret_buf, 0, buf_size + 3);\n\t\tatomic_inc(&bufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\t}\n\n\treturn ret_buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\nCIFSTCon(const unsigned int xid, struct cifs_ses *ses,\n\t const char *tree, struct cifs_tcon *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = get_next_mid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\tif (!tcon || (ses->server->sec_mode & SECMODE_USER)) {\n\t\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t\t*bcc_ptr = 0; /* password is null byte */\n\t\tbcc_ptr++;              /* skip password */\n\t\t/* already aligned so no need to do it below */\n\t} else {\n\t\tpSMB->PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\t\t/* BB FIXME add code to fail this if NTLMv2 or Kerberos\n\t\t   specified as required (when that support is added to\n\t\t   the vfs in the future) as only NTLM or the much\n\t\t   weaker LANMAN (which we do not send by default) is accepted\n\t\t   by Samba (not sure whether other servers allow\n\t\t   NTLMv2 password here) */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\n\t\t    (ses->sectype == LANMAN))\n\t\t\tcalc_lanman_hash(tcon->password, ses->server->cryptkey,\n\t\t\t\t\t ses->server->sec_mode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false,\n\t\t\t\t\t bcc_ptr);\n\t\telse\n#endif /* CIFS_WEAK_PW_HASH */\n\t\trc = SMBNTencrypt(tcon->password, ses->server->cryptkey,\n\t\t\t\t\tbcc_ptr, nls_codepage);\n\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t\tif (ses->capabilities & CAP_UNICODE) {\n\t\t\t/* must align unicode strings */\n\t\t\t*bcc_ptr = 0; /* null byte password */\n\t\t\tbcc_ptr++;\n\t\t}\n\t}\n\n\tif (ses->server->sign)\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUTF16((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tpSMB->hdr.smb_buf_length = cpu_to_be32(be32_to_cpu(\n\t\t\t\t\tpSMB->hdr.smb_buf_length) + count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t/* above now done in SendReceive */\n\tif ((rc == 0) && (tcon != NULL)) {\n\t\tbool is_unicode;\n\n\t\ttcon->tidStatus = CifsGood;\n\t\ttcon->need_reconnect = false;\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcifs_dbg(FYI, \"IPC connection\\n\");\n\t\t\t\ttcon->ipc = 1;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcifs_dbg(FYI, \"disk share connection\\n\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_utf16(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcifs_dbg(FYI, \"nativeFileSystem=%s\\n\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcifs_dbg(FYI, \"Tcon flags: 0x%x\\n\", tcon->Flags);\n\t} else if ((rc == 0) && tcon == NULL) {\n\t\t/* all we need to save for IPC$ connection */\n\t\tses->ipc_tid = smb_buffer_response->Tid;\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3435-3631",
    "snippet": "int\ncifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar   *full_path;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint referral_walks_count = 0;\n#endif\n\n\trc = bdi_setup_and_register(&cifs_sb->bdi, \"cifs\");\n\tif (rc)\n\t\treturn rc;\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\ntry_mount_again:\n\t/* cleanup activities if we're chasing a referral */\n\tif (referral_walks_count) {\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\n\t\tfree_xid(xid);\n\t}\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tses = NULL;\n\tserver = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = get_xid();\n\n\t/* get a reference to a tcp session */\n\tserver = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(server)) {\n\t\trc = PTR_ERR(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tses = cifs_get_smb_ses(server, volume_info);\n\tif (IS_ERR(ses)) {\n\t\trc = PTR_ERR(ses);\n\t\tses = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(ses, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (cap_unix(tcon->ses)) {\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, cifs_sb, volume_info);\n\t\tif ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&\n\t\t    (le64_to_cpu(tcon->fsUnixInfo.Capability) &\n\t\t     CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t} else\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* do not care if a following call succeed - informational */\n\tif (!tcon->ipc && server->ops->qfs_tcon)\n\t\tserver->ops->qfs_tcon(xid, tcon);\n\n\tcifs_sb->wsize = server->ops->negotiate_wsize(tcon, volume_info);\n\tcifs_sb->rsize = server->ops->negotiate_rsize(tcon, volume_info);\n\n\t/* tune readahead according to rsize */\n\tcifs_sb->bdi.ra_pages = cifs_sb->rsize / PAGE_CACHE_SIZE;\n\nremote_path_check:\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t/*\n\t * Perform an unconditional check for whether there are DFS\n\t * referrals for this path without prefix, to provide support\n\t * for DFS referrals from w2k8 servers which don't seem to respond\n\t * with PATH_NOT_COVERED to requests that include the prefix.\n\t * Chase the referral if found, otherwise continue normally.\n\t */\n\tif (referral_walks_count == 0) {\n\t\tint refrc = expand_dfs_referral(xid, ses, volume_info, cifs_sb,\n\t\t\t\t\t\tfalse);\n\t\tif (!refrc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t}\n#endif\n\n\t/* check if a whole path is not remote */\n\tif (!rc && tcon) {\n\t\tif (!server->ops->is_path_accessible) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/*\n\t\t * cifs_build_path_to_root works only when we have a valid tcon\n\t\t */\n\t\tfull_path = cifs_build_path_to_root(volume_info, cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t\t     full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\trc = expand_dfs_referral(xid, ses, volume_info, cifs_sb, true);\n\n\t\tif (!rc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t\tgoto mount_fail_check;\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = ses->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\t\telse\n\t\t\tcifs_put_tcp_session(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define TLINK_IDLE_EXPIRE\t(600 * HZ)"
    ],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&cifs_sb->bdi"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tcp_session",
          "args": [
            "server"
          ],
          "line": 3624
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tcp_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2067-2099",
          "snippet": "static void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_smb_ses",
          "args": [
            "ses"
          ],
          "line": 3622
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_smb_ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2266-2302",
          "snippet": "static void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tcon",
          "args": [
            "tcon"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2564-2588",
          "snippet": "static void\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "cifsiod_wq",
            "&cifs_sb->prune_tlinks",
            "TLINK_IDLE_EXPIRE"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_sb->tlink_tree_lock"
          ],
          "line": 3609
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_rb_insert",
          "args": [
            "&cifs_sb->tlink_tree",
            "tlink"
          ],
          "line": 3608
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_rb_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3975-3993",
          "snippet": "static void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);\n\nstatic void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_sb->tlink_tree_lock"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "TCON_LINK_IN_TREE",
            "&tlink->tl_flags"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof *tlink",
            "GFP_KERNEL"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_dfs_referral",
          "args": [
            "xid",
            "ses",
            "volume_info",
            "cifs_sb",
            "true"
          ],
          "line": 3578
        },
        "resolved": true,
        "details": {
          "function_name": "expand_dfs_referral",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3331-3374",
          "snippet": "static int\nexpand_dfs_referral(const unsigned int xid, struct cifs_ses *ses,\n\t\t    struct smb_vol *volume_info, struct cifs_sb_info *cifs_sb,\n\t\t    int check_prefix)\n{\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\tchar *full_path = NULL, *ref_path = NULL, *mdata = NULL;\n\n\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\t/* For DFS paths, skip the first '\\' of the UNC */\n\tref_path = check_prefix ? full_path + 1 : volume_info->UNC + 1;\n\n\trc = get_dfs_path(xid, ses, ref_path, cifs_sb->local_nls,\n\t\t\t  &num_referrals, &referrals, cifs_remap(cifs_sb));\n\n\tif (!rc && num_referrals > 0) {\n\t\tchar *fake_devname = NULL;\n\n\t\tmdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\t\t\t\t   full_path + 1, referrals,\n\t\t\t\t\t\t   &fake_devname);\n\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\n\t\tif (IS_ERR(mdata)) {\n\t\t\trc = PTR_ERR(mdata);\n\t\t\tmdata = NULL;\n\t\t} else {\n\t\t\tcleanup_volume_info_contents(volume_info);\n\t\t\trc = cifs_setup_volume_info(volume_info, mdata,\n\t\t\t\t\t\t\tfake_devname);\n\t\t}\n\t\tkfree(fake_devname);\n\t\tkfree(cifs_sb->mountdata);\n\t\tcifs_sb->mountdata = mdata;\n\t}\n\tkfree(full_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int\nexpand_dfs_referral(const unsigned int xid, struct cifs_ses *ses,\n\t\t    struct smb_vol *volume_info, struct cifs_sb_info *cifs_sb,\n\t\t    int check_prefix)\n{\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\tchar *full_path = NULL, *ref_path = NULL, *mdata = NULL;\n\n\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\t/* For DFS paths, skip the first '\\' of the UNC */\n\tref_path = check_prefix ? full_path + 1 : volume_info->UNC + 1;\n\n\trc = get_dfs_path(xid, ses, ref_path, cifs_sb->local_nls,\n\t\t\t  &num_referrals, &referrals, cifs_remap(cifs_sb));\n\n\tif (!rc && num_referrals > 0) {\n\t\tchar *fake_devname = NULL;\n\n\t\tmdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\t\t\t\t   full_path + 1, referrals,\n\t\t\t\t\t\t   &fake_devname);\n\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\n\t\tif (IS_ERR(mdata)) {\n\t\t\trc = PTR_ERR(mdata);\n\t\t\tmdata = NULL;\n\t\t} else {\n\t\t\tcleanup_volume_info_contents(volume_info);\n\t\t\trc = cifs_setup_volume_info(volume_info, mdata,\n\t\t\t\t\t\t\tfake_devname);\n\t\t}\n\t\tkfree(fake_devname);\n\t\tkfree(cifs_sb->mountdata);\n\t\tcifs_sb->mountdata = mdata;\n\t}\n\tkfree(full_path);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->is_path_accessible",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "full_path"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_build_path_to_root",
          "args": [
            "volume_info",
            "cifs_sb",
            "tcon"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_build_path_to_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "48-78",
          "snippet": "char *\ncifs_build_path_to_root(struct smb_vol *vol, struct cifs_sb_info *cifs_sb,\n\t\t\tstruct cifs_tcon *tcon)\n{\n\tint pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tint dfsplen;\n\tchar *full_path = NULL;\n\n\t/* if no prefix path, simply set path to the root of share to \"\" */\n\tif (pplen == 0) {\n\t\tfull_path = kzalloc(1, GFP_KERNEL);\n\t\treturn full_path;\n\t}\n\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\n\n\tfull_path = kmalloc(dfsplen + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\n\tif (dfsplen)\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\tfull_path[dfsplen] = CIFS_DIR_SEP(cifs_sb);\n\tstrncpy(full_path + dfsplen + 1, vol->prepath, pplen);\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tfull_path[dfsplen + pplen] = 0; /* add trailing null */\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\ncifs_build_path_to_root(struct smb_vol *vol, struct cifs_sb_info *cifs_sb,\n\t\t\tstruct cifs_tcon *tcon)\n{\n\tint pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tint dfsplen;\n\tchar *full_path = NULL;\n\n\t/* if no prefix path, simply set path to the root of share to \"\" */\n\tif (pplen == 0) {\n\t\tfull_path = kzalloc(1, GFP_KERNEL);\n\t\treturn full_path;\n\t}\n\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\n\n\tfull_path = kmalloc(dfsplen + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\n\tif (dfsplen)\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\tfull_path[dfsplen] = CIFS_DIR_SEP(cifs_sb);\n\tstrncpy(full_path + dfsplen + 1, vol->prepath, pplen);\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tfull_path[dfsplen + pplen] = 0; /* add trailing null */\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->negotiate_rsize",
          "args": [
            "tcon",
            "volume_info"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->negotiate_wsize",
          "args": [
            "tcon",
            "volume_info"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->qfs_tcon",
          "args": [
            "xid",
            "tcon"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_cifs_unix_caps",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "volume_info"
          ],
          "line": 3502
        },
        "resolved": true,
        "details": {
          "function_name": "reset_cifs_unix_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3072-3170",
          "snippet": "void reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\t} else\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nvoid reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\t} else\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 3499
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tcon"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tcon"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_tcon",
          "args": [
            "ses",
            "volume_info"
          ],
          "line": 3491
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2590-2664",
          "snippet": "static struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifs_tcon *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcifs_dbg(VFS, \"transport encryption setting conflicts with existing tid\\n\");\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t/*\n\t * BB Do we need to wrap session_mutex around this TCon call and Unix\n\t * SetFS as we do on SessSetup and reconnect?\n\t */\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, volume_info->UNC, tcon,\n\t\t\t\t\t    volume_info->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcifs_dbg(FYI, \"DFS disabled (%d)\\n\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/*\n\t * We can have only one retry value for a connection to a share so for\n\t * resources mounted more than once to the same server share the last\n\t * value passed in for the retry flag is used.\n\t */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_super_cookie(tcon);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifs_tcon *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcifs_dbg(VFS, \"transport encryption setting conflicts with existing tid\\n\");\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t/*\n\t * BB Do we need to wrap session_mutex around this TCon call and Unix\n\t * SetFS as we do on SessSetup and reconnect?\n\t */\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, volume_info->UNC, tcon,\n\t\t\t\t\t    volume_info->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcifs_dbg(FYI, \"DFS disabled (%d)\\n\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/*\n\t * We can have only one retry value for a connection to a share so for\n\t * resources mounted more than once to the same server share the last\n\t * value passed in for the retry flag is used.\n\t */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_super_cookie(tcon);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ses"
          ],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ses"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_smb_ses",
          "args": [
            "server",
            "volume_info"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_smb_ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2434-2534",
          "snippet": "static struct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->status);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tfree_xid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\", &addr->sin_addr);\n\n\tif (volume_info->username) {\n\t\tses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\tses->cred_uid = volume_info->cred_uid;\n\tses->linux_uid = volume_info->linux_uid;\n\n\tses->sectype = volume_info->sectype;\n\tses->sign = volume_info->sign;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tfree_xid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->status);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tfree_xid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\", &addr->sin_addr);\n\n\tif (volume_info->username) {\n\t\tses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\tses->cred_uid = volume_info->cred_uid;\n\tses->linux_uid = volume_info->linux_uid;\n\n\tses->sectype = volume_info->sectype;\n\tses->sign = volume_info->sign;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tfree_xid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_tcp_session",
          "args": [
            "volume_info"
          ],
          "line": 3475
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_tcp_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2101-2211",
          "snippet": "static struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tint rc;\n\n\tcifs_dbg(FYI, \"UNC: %s\\n\", volume_info->UNC);\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session(volume_info);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->ops = volume_info->ops;\n\ttcp_ses->vals = volume_info->vals;\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\ttcp_ses->hostname = extract_hostname(volume_info->UNC);\n\tif (IS_ERR(tcp_ses->hostname)) {\n\t\trc = PTR_ERR(tcp_ses->hostname);\n\t\tgoto out_err_crypto_release;\n\t}\n\n\ttcp_ses->noblocksnd = volume_info->noblocksnd;\n\ttcp_ses->noautotune = volume_info->noautotune;\n\ttcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\n\ttcp_ses->in_flight = 0;\n\ttcp_ses->credits = 1;\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->lstrp = jiffies;\n\tspin_lock_init(&tcp_ses->req_lock);\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\tmemcpy(&tcp_ses->srcaddr, &volume_info->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\tmemcpy(&tcp_ses->dstaddr, &volume_info->dstaddr,\n\t\tsizeof(tcp_ses->dstaddr));\n#ifdef CONFIG_CIFS_SMB2\n\tget_random_bytes(tcp_ses->client_guid, SMB2_CLIENT_GUID_SIZE);\n#endif\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcifs_dbg(VFS, \"Error connecting to socket. Aborting operation.\\n\");\n\t\tgoto out_err_crypto_release;\n\t}\n\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run(cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcifs_dbg(VFS, \"error %d create cifsd thread\\n\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\ttcp_ses->tcpStatus = CifsNeedNegotiate;\n\n\t/* thread spawned, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_client_cookie(tcp_ses);\n\n\t/* queue echo request delayed work */\n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->echo, SMB_ECHO_INTERVAL);\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_shash_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (!IS_ERR(tcp_ses->hostname))\n\t\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cifs_prune_tlinks(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\nstatic struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tint rc;\n\n\tcifs_dbg(FYI, \"UNC: %s\\n\", volume_info->UNC);\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session(volume_info);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->ops = volume_info->ops;\n\ttcp_ses->vals = volume_info->vals;\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\ttcp_ses->hostname = extract_hostname(volume_info->UNC);\n\tif (IS_ERR(tcp_ses->hostname)) {\n\t\trc = PTR_ERR(tcp_ses->hostname);\n\t\tgoto out_err_crypto_release;\n\t}\n\n\ttcp_ses->noblocksnd = volume_info->noblocksnd;\n\ttcp_ses->noautotune = volume_info->noautotune;\n\ttcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\n\ttcp_ses->in_flight = 0;\n\ttcp_ses->credits = 1;\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->lstrp = jiffies;\n\tspin_lock_init(&tcp_ses->req_lock);\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\tmemcpy(&tcp_ses->srcaddr, &volume_info->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\tmemcpy(&tcp_ses->dstaddr, &volume_info->dstaddr,\n\t\tsizeof(tcp_ses->dstaddr));\n#ifdef CONFIG_CIFS_SMB2\n\tget_random_bytes(tcp_ses->client_guid, SMB2_CLIENT_GUID_SIZE);\n#endif\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcifs_dbg(VFS, \"Error connecting to socket. Aborting operation.\\n\");\n\t\tgoto out_err_crypto_release;\n\t}\n\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run(cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcifs_dbg(VFS, \"error %d create cifsd thread\\n\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\ttcp_ses->tcpStatus = CifsNeedNegotiate;\n\n\t/* thread spawned, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_client_cookie(tcp_ses);\n\n\t/* queue echo request delayed work */\n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->echo, SMB_ECHO_INTERVAL);\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_shash_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (!IS_ERR(tcp_ses->hostname))\n\t\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_setup_and_register",
          "args": [
            "&cifs_sb->bdi",
            "\"cifs\""
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_IDLE_EXPIRE\t(600 * HZ)\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar   *full_path;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint referral_walks_count = 0;\n#endif\n\n\trc = bdi_setup_and_register(&cifs_sb->bdi, \"cifs\");\n\tif (rc)\n\t\treturn rc;\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\ntry_mount_again:\n\t/* cleanup activities if we're chasing a referral */\n\tif (referral_walks_count) {\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\n\t\tfree_xid(xid);\n\t}\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tses = NULL;\n\tserver = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = get_xid();\n\n\t/* get a reference to a tcp session */\n\tserver = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(server)) {\n\t\trc = PTR_ERR(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tses = cifs_get_smb_ses(server, volume_info);\n\tif (IS_ERR(ses)) {\n\t\trc = PTR_ERR(ses);\n\t\tses = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(ses, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (cap_unix(tcon->ses)) {\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, cifs_sb, volume_info);\n\t\tif ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&\n\t\t    (le64_to_cpu(tcon->fsUnixInfo.Capability) &\n\t\t     CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t} else\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* do not care if a following call succeed - informational */\n\tif (!tcon->ipc && server->ops->qfs_tcon)\n\t\tserver->ops->qfs_tcon(xid, tcon);\n\n\tcifs_sb->wsize = server->ops->negotiate_wsize(tcon, volume_info);\n\tcifs_sb->rsize = server->ops->negotiate_rsize(tcon, volume_info);\n\n\t/* tune readahead according to rsize */\n\tcifs_sb->bdi.ra_pages = cifs_sb->rsize / PAGE_CACHE_SIZE;\n\nremote_path_check:\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t/*\n\t * Perform an unconditional check for whether there are DFS\n\t * referrals for this path without prefix, to provide support\n\t * for DFS referrals from w2k8 servers which don't seem to respond\n\t * with PATH_NOT_COVERED to requests that include the prefix.\n\t * Chase the referral if found, otherwise continue normally.\n\t */\n\tif (referral_walks_count == 0) {\n\t\tint refrc = expand_dfs_referral(xid, ses, volume_info, cifs_sb,\n\t\t\t\t\t\tfalse);\n\t\tif (!refrc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t}\n#endif\n\n\t/* check if a whole path is not remote */\n\tif (!rc && tcon) {\n\t\tif (!server->ops->is_path_accessible) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/*\n\t\t * cifs_build_path_to_root works only when we have a valid tcon\n\t\t */\n\t\tfull_path = cifs_build_path_to_root(volume_info, cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t\t     full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\trc = expand_dfs_referral(xid, ses, volume_info, cifs_sb, true);\n\n\t\tif (!rc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t\tgoto mount_fail_check;\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = ses->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\t\telse\n\t\t\tcifs_put_tcp_session(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_get_volume_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3416-3433",
    "snippet": "struct smb_vol *\ncifs_get_volume_info(char *mount_data, const char *devname)\n{\n\tint rc;\n\tstruct smb_vol *volume_info;\n\n\tvolume_info = kmalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_setup_volume_info(volume_info, mount_data, devname);\n\tif (rc) {\n\t\tcifs_cleanup_volume_info(volume_info);\n\t\tvolume_info = ERR_PTR(rc);\n\t}\n\n\treturn volume_info;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 3429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_cleanup_volume_info",
          "args": [
            "volume_info"
          ],
          "line": 3428
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_cleanup_volume_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3279-3286",
          "snippet": "void\ncifs_cleanup_volume_info(struct smb_vol *volume_info)\n{\n\tif (!volume_info)\n\t\treturn;\n\tcleanup_volume_info_contents(volume_info);\n\tkfree(volume_info);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_cleanup_volume_info(struct smb_vol *volume_info)\n{\n\tif (!volume_info)\n\t\treturn;\n\tcleanup_volume_info_contents(volume_info);\n\tkfree(volume_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_setup_volume_info",
          "args": [
            "volume_info",
            "mount_data",
            "devname"
          ],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_setup_volume_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3377-3414",
          "snippet": "static int\ncifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\tconst char *devname)\n{\n\tint rc = 0;\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info))\n\t\treturn -EINVAL;\n\n\tif (volume_info->nullauth) {\n\t\tcifs_dbg(FYI, \"Anonymous login\\n\");\n\t\tkfree(volume_info->username);\n\t\tvolume_info->username = NULL;\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcifs_dbg(FYI, \"Username: %s\\n\", volume_info->username);\n\t} else {\n\t\tcifs_dbg(VFS, \"No username specified\\n\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\treturn -EINVAL;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t volume_info->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\nstatic int\ncifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\tconst char *devname)\n{\n\tint rc = 0;\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info))\n\t\treturn -EINVAL;\n\n\tif (volume_info->nullauth) {\n\t\tcifs_dbg(FYI, \"Anonymous login\\n\");\n\t\tkfree(volume_info->username);\n\t\tvolume_info->username = NULL;\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcifs_dbg(FYI, \"Username: %s\\n\", volume_info->username);\n\t} else {\n\t\tcifs_dbg(VFS, \"No username specified\\n\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\treturn -EINVAL;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t volume_info->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct smb_vol)",
            "GFP_KERNEL"
          ],
          "line": 3422
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\nstruct smb_vol *\ncifs_get_volume_info(char *mount_data, const char *devname)\n{\n\tint rc;\n\tstruct smb_vol *volume_info;\n\n\tvolume_info = kmalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_setup_volume_info(volume_info, mount_data, devname);\n\tif (rc) {\n\t\tcifs_cleanup_volume_info(volume_info);\n\t\tvolume_info = ERR_PTR(rc);\n\t}\n\n\treturn volume_info;\n}"
  },
  {
    "function_name": "cifs_setup_volume_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3377-3414",
    "snippet": "static int\ncifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\tconst char *devname)\n{\n\tint rc = 0;\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info))\n\t\treturn -EINVAL;\n\n\tif (volume_info->nullauth) {\n\t\tcifs_dbg(FYI, \"Anonymous login\\n\");\n\t\tkfree(volume_info->username);\n\t\tvolume_info->username = NULL;\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcifs_dbg(FYI, \"Username: %s\\n\", volume_info->username);\n\t} else {\n\t\tcifs_dbg(VFS, \"No username specified\\n\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\treturn -EINVAL;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t volume_info->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"CIFS mount error: iocharset %s not found\\n\"",
            "volume_info->iocharset"
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_nls",
          "args": [
            "volume_info->iocharset"
          ],
          "line": 3405
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_nls_default",
          "args": [],
          "line": 3403
        },
        "resolved": true,
        "details": {
          "function_name": "load_nls_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "532-541",
          "snippet": "struct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nls_table default_table;",
            "static struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct nls_table default_table;\nstatic struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};\n\nstruct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"No username specified\\n\""
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Username: %s\\n\"",
            "volume_info->username"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "volume_info->username"
          ],
          "line": 3388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Anonymous login\\n\""
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_parse_mount_options",
          "args": [
            "mount_data",
            "devname",
            "volume_info"
          ],
          "line": 3383
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_parse_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "1191-1900",
          "snippet": "static int\ncifs_parse_mount_options(const char *mountdata, const char *devname,\n\t\t\t struct smb_vol *vol)\n{\n\tchar *data, *end;\n\tchar *mountdata_copy = NULL, *options;\n\tunsigned int  temp_len, i, j;\n\tchar separator[2];\n\tshort int override_uid = -1;\n\tshort int override_gid = -1;\n\tbool uid_specified = false;\n\tbool gid_specified = false;\n\tbool sloppy = false;\n\tchar *invalid = NULL;\n\tchar *nodename = utsname()->nodename;\n\tchar *string = NULL;\n\tchar *tmp_end, *value;\n\tchar delim;\n\tbool got_ip = false;\n\tunsigned short port = 0;\n\tstruct sockaddr *dstaddr = (struct sockaddr *)&vol->dstaddr;\n\n\tseparator[0] = ',';\n\tseparator[1] = 0;\n\tdelim = separator[0];\n\n\t/* ensure we always start with zeroed-out smb_vol */\n\tmemset(vol, 0, sizeof(*vol));\n\n\t/*\n\t * does not have to be perfect mapping since field is\n\t * informational, only used for servers that do not support\n\t * port 445 and it can be overridden at mount time\n\t */\n\tmemset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);\n\tfor (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)\n\t\tvol->source_rfc1001_name[i] = toupper(nodename[i]);\n\n\tvol->source_rfc1001_name[RFC1001_NAME_LEN] = 0;\n\t/* null target name indicates to use *SMBSERVR default called name\n\t   if we end up sending RFC1001 session initialize */\n\tvol->target_rfc1001_name[0] = 0;\n\tvol->cred_uid = current_uid();\n\tvol->linux_uid = current_uid();\n\tvol->linux_gid = current_gid();\n\n\t/*\n\t * default to SFM style remapping of seven reserved characters\n\t * unless user overrides it or we negotiate CIFS POSIX where\n\t * it is unnecessary.  Can not simultaneously use more than one mapping\n\t * since then readdir could list files that open could not open\n\t */\n\tvol->remap = true;\n\n\t/* default to only allowing write access to owner of the mount */\n\tvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t/* vol->retry default is 0 (i.e. \"soft\" limited retry not hard retry) */\n\t/* default is always to request posix paths. */\n\tvol->posix_paths = 1;\n\t/* default to using server inode numbers where available */\n\tvol->server_ino = 1;\n\n\t/* default is to use strict cifs caching semantics */\n\tvol->strict_io = true;\n\n\tvol->actimeo = CIFS_DEF_ACTIMEO;\n\n\t/* FIXME: add autonegotiation -- for now, SMB1 is default */\n\tvol->ops = &smb1_operations;\n\tvol->vals = &smb1_values;\n\n\tif (!mountdata)\n\t\tgoto cifs_parse_mount_err;\n\n\tmountdata_copy = kstrndup(mountdata, PAGE_SIZE, GFP_KERNEL);\n\tif (!mountdata_copy)\n\t\tgoto cifs_parse_mount_err;\n\n\toptions = mountdata_copy;\n\tend = options + strlen(options);\n\n\tif (strncmp(options, \"sep=\", 4) == 0) {\n\t\tif (options[4] != 0) {\n\t\t\tseparator[0] = options[4];\n\t\t\toptions += 5;\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"Null separator not allowed\\n\");\n\t\t}\n\t}\n\tvol->backupuid_specified = false; /* no backup intent for a user */\n\tvol->backupgid_specified = false; /* no backup intent for a group */\n\n\tswitch (cifs_parse_devname(devname, vol)) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOMEM:\n\t\tcifs_dbg(VFS, \"Unable to allocate memory for devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tcase -EINVAL:\n\t\tcifs_dbg(VFS, \"Malformed UNC in devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown error parsing devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\twhile ((data = strsep(&options, separator)) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned long option;\n\t\tint token;\n\n\t\tif (!*data)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(data, cifs_mount_option_tokens, args);\n\n\t\tswitch (token) {\n\n\t\t/* Ingnore the following */\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\n\t\t/* Boolean values */\n\t\tcase Opt_user_xattr:\n\t\t\tvol->no_xattr = 0;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tvol->no_xattr = 1;\n\t\t\tbreak;\n\t\tcase Opt_forceuid:\n\t\t\toverride_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforceuid:\n\t\t\toverride_uid = 0;\n\t\t\tbreak;\n\t\tcase Opt_forcegid:\n\t\t\toverride_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforcegid:\n\t\t\toverride_gid = 0;\n\t\t\tbreak;\n\t\tcase Opt_noblocksend:\n\t\t\tvol->noblocksnd = 1;\n\t\t\tbreak;\n\t\tcase Opt_noautotune:\n\t\t\tvol->noautotune = 1;\n\t\t\tbreak;\n\t\tcase Opt_hard:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_soft:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_perm:\n\t\t\tvol->noperm = 0;\n\t\t\tbreak;\n\t\tcase Opt_noperm:\n\t\t\tvol->noperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_mapchars:\n\t\t\tvol->sfu_remap = true;\n\t\t\tvol->remap = false; /* disable SFM mapping */\n\t\t\tbreak;\n\t\tcase Opt_nomapchars:\n\t\t\tvol->sfu_remap = false;\n\t\t\tbreak;\n\t\tcase Opt_mapposix:\n\t\t\tvol->remap = true;\n\t\t\tvol->sfu_remap = false; /* disable SFU mapping */\n\t\t\tbreak;\n\t\tcase Opt_nomapposix:\n\t\t\tvol->remap = false;\n\t\t\tbreak;\n\t\tcase Opt_sfu:\n\t\t\tvol->sfu_emul = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosfu:\n\t\t\tvol->sfu_emul = 0;\n\t\t\tbreak;\n\t\tcase Opt_nodfs:\n\t\t\tvol->nodfs = 1;\n\t\t\tbreak;\n\t\tcase Opt_posixpaths:\n\t\t\tvol->posix_paths = 1;\n\t\t\tbreak;\n\t\tcase Opt_noposixpaths:\n\t\t\tvol->posix_paths = 0;\n\t\t\tbreak;\n\t\tcase Opt_nounix:\n\t\t\tvol->no_linux_ext = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tvol->nocase = 1;\n\t\t\tbreak;\n\t\tcase Opt_brl:\n\t\t\tvol->nobrl =  0;\n\t\t\tbreak;\n\t\tcase Opt_nobrl:\n\t\t\tvol->nobrl =  1;\n\t\t\t/*\n\t\t\t * turn off mandatory locking in mode\n\t\t\t * if remote locking is turned off since the\n\t\t\t * local vfs will do advisory\n\t\t\t */\n\t\t\tif (vol->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tvol->file_mode = S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_forcemandatorylock:\n\t\t\tvol->mand_lock = 1;\n\t\t\tbreak;\n\t\tcase Opt_setuids:\n\t\t\tvol->setuids = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosetuids:\n\t\t\tvol->setuids = 0;\n\t\t\tbreak;\n\t\tcase Opt_dynperm:\n\t\t\tvol->dynperm = true;\n\t\t\tbreak;\n\t\tcase Opt_nodynperm:\n\t\t\tvol->dynperm = false;\n\t\t\tbreak;\n\t\tcase Opt_nohard:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_nosoft:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tvol->intr = 0;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tvol->intr = 1;\n\t\t\tbreak;\n\t\tcase Opt_nostrictsync:\n\t\t\tvol->nostrictsync = 1;\n\t\t\tbreak;\n\t\tcase Opt_strictsync:\n\t\t\tvol->nostrictsync = 0;\n\t\t\tbreak;\n\t\tcase Opt_serverino:\n\t\t\tvol->server_ino = 1;\n\t\t\tbreak;\n\t\tcase Opt_noserverino:\n\t\t\tvol->server_ino = 0;\n\t\t\tbreak;\n\t\tcase Opt_rwpidforward:\n\t\t\tvol->rwpidforward = 1;\n\t\t\tbreak;\n\t\tcase Opt_cifsacl:\n\t\t\tvol->cifs_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocifsacl:\n\t\t\tvol->cifs_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tvol->no_psx_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tvol->no_psx_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_locallease:\n\t\t\tvol->local_lease = 1;\n\t\t\tbreak;\n\t\tcase Opt_sign:\n\t\t\tvol->sign = true;\n\t\t\tbreak;\n\t\tcase Opt_seal:\n\t\t\t/* we do not do the following in secFlags because seal\n\t\t\t * is a per tree connection (mount) not a per socket\n\t\t\t * or per-smb connection option in the protocol\n\t\t\t * vol->secFlg |= CIFSSEC_MUST_SEAL;\n\t\t\t */\n\t\t\tvol->seal = 1;\n\t\t\tbreak;\n\t\tcase Opt_noac:\n\t\t\tpr_warn(\"CIFS: Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\t\tbreak;\n\t\tcase Opt_fsc:\n#ifndef CONFIG_CIFS_FSCACHE\n\t\t\tcifs_dbg(VFS, \"FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n#endif\n\t\t\tvol->fsc = true;\n\t\t\tbreak;\n\t\tcase Opt_mfsymlinks:\n\t\t\tvol->mfsymlinks = true;\n\t\t\tbreak;\n\t\tcase Opt_multiuser:\n\t\t\tvol->multiuser = true;\n\t\t\tbreak;\n\t\tcase Opt_sloppy:\n\t\t\tsloppy = true;\n\t\t\tbreak;\n\t\tcase Opt_nosharesock:\n\t\t\tvol->nosharesock = true;\n\t\t\tbreak;\n\n\t\t/* Numeric Values */\n\t\tcase Opt_backupuid:\n\t\t\tif (get_option_uid(args, &vol->backupuid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupuid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_backupgid:\n\t\t\tif (get_option_gid(args, &vol->backupgid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupgid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (get_option_uid(args, &vol->linux_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid uid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_cruid:\n\t\t\tif (get_option_uid(args, &vol->cred_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid cruid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (get_option_gid(args, &vol->linux_gid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid gid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_file_mode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid file_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->file_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_dirmode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid dir_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->dir_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_port:\n\t\t\tif (get_option_ul(args, &option) ||\n\t\t\t    option > USHRT_MAX) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid port value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tport = (unsigned short)option;\n\t\t\tbreak;\n\t\tcase Opt_rsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid rsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->rsize = option;\n\t\t\tbreak;\n\t\tcase Opt_wsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid wsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->wsize = option;\n\t\t\tbreak;\n\t\tcase Opt_actimeo:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid actimeo value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->actimeo = HZ * option;\n\t\t\tif (vol->actimeo > CIFS_MAX_ACTIMEO) {\n\t\t\t\tcifs_dbg(VFS, \"attribute cache timeout too large\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* String Arguments */\n\n\t\tcase Opt_blank_user:\n\t\t\t/* null user, ie. anonymous authentication */\n\t\t\tvol->nullauth = 1;\n\t\t\tvol->username = NULL;\n\t\t\tbreak;\n\t\tcase Opt_user:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, CIFS_MAX_USERNAME_LEN) >\n\t\t\t\t\t\t\tCIFS_MAX_USERNAME_LEN) {\n\t\t\t\tpr_warn(\"CIFS: username too long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->username = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->username)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_blank_pass:\n\t\t\t/* passwords have to be handled differently\n\t\t\t * to allow the character used for deliminator\n\t\t\t * to be passed within them\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Check if this is a case where the  password\n\t\t\t * starts with a delimiter\n\t\t\t */\n\t\t\ttmp_end = strchr(data, '=');\n\t\t\ttmp_end++;\n\t\t\tif (!(tmp_end < end && tmp_end[1] == delim)) {\n\t\t\t\t/* No it is not. Set the password to NULL */\n\t\t\t\tkfree(vol->password);\n\t\t\t\tvol->password = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Yes it is. Drop down to Opt_pass below.*/\n\t\tcase Opt_pass:\n\t\t\t/* Obtain the value string */\n\t\t\tvalue = strchr(data, '=');\n\t\t\tvalue++;\n\n\t\t\t/* Set tmp_end to end of the string */\n\t\t\ttmp_end = (char *) value + strlen(value);\n\n\t\t\t/* Check if following character is the deliminator\n\t\t\t * If yes, we have encountered a double deliminator\n\t\t\t * reset the NULL character to the deliminator\n\t\t\t */\n\t\t\tif (tmp_end < end && tmp_end[1] == delim) {\n\t\t\t\ttmp_end[0] = delim;\n\n\t\t\t\t/* Keep iterating until we get to a single\n\t\t\t\t * deliminator OR the end\n\t\t\t\t */\n\t\t\t\twhile ((tmp_end = strchr(tmp_end, delim))\n\t\t\t\t\t!= NULL && (tmp_end[1] == delim)) {\n\t\t\t\t\t\ttmp_end = (char *) &tmp_end[2];\n\t\t\t\t}\n\n\t\t\t\t/* Reset var options to point to next element */\n\t\t\t\tif (tmp_end) {\n\t\t\t\t\ttmp_end[0] = '\\0';\n\t\t\t\t\toptions = (char *) &tmp_end[1];\n\t\t\t\t} else\n\t\t\t\t\t/* Reached the end of the mount option\n\t\t\t\t\t * string */\n\t\t\t\t\toptions = end;\n\t\t\t}\n\n\t\t\tkfree(vol->password);\n\t\t\t/* Now build new password string */\n\t\t\ttemp_len = strlen(value);\n\t\t\tvol->password = kzalloc(temp_len+1, GFP_KERNEL);\n\t\t\tif (vol->password == NULL) {\n\t\t\t\tpr_warn(\"CIFS: no memory for password\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tfor (i = 0, j = 0; i < temp_len; i++, j++) {\n\t\t\t\tvol->password[j] = value[i];\n\t\t\t\tif ((value[i] == delim) &&\n\t\t\t\t     value[i+1] == delim)\n\t\t\t\t\t/* skip the second deliminator */\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t\tvol->password[j] = '\\0';\n\t\t\tbreak;\n\t\tcase Opt_blank_ip:\n\t\t\t/* FIXME: should this be an error instead? */\n\t\t\tgot_ip = false;\n\t\t\tbreak;\n\t\tcase Opt_ip:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(dstaddr, string,\n\t\t\t\t\tstrlen(string))) {\n\t\t\t\tpr_err(\"CIFS: bad ip= option (%s).\\n\", string);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgot_ip = true;\n\t\t\tbreak;\n\t\tcase Opt_domain:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, CIFS_MAX_DOMAINNAME_LEN)\n\t\t\t\t\t== CIFS_MAX_DOMAINNAME_LEN) {\n\t\t\t\tpr_warn(\"CIFS: domain name too long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tvol->domainname = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->domainname) {\n\t\t\t\tpr_warn(\"CIFS: no memory for domainname\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tcifs_dbg(FYI, \"Domain name set\\n\");\n\t\t\tbreak;\n\t\tcase Opt_srcaddr:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(\n\t\t\t\t\t(struct sockaddr *)&vol->srcaddr,\n\t\t\t\t\tstring, strlen(string))) {\n\t\t\t\tpr_warn(\"CIFS: Could not parse srcaddr: %s\\n\",\n\t\t\t\t\tstring);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, 1024) >= 65) {\n\t\t\t\tpr_warn(\"CIFS: iocharset name too long.\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\t if (strncasecmp(string, \"default\", 7) != 0) {\n\t\t\t\tvol->iocharset = kstrdup(string,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\t\tif (!vol->iocharset) {\n\t\t\t\t\tpr_warn(\"CIFS: no memory for charset\\n\");\n\t\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if iocharset not set then load_nls_default\n\t\t\t * is used by caller\n\t\t\t */\n\t\t\t cifs_dbg(FYI, \"iocharset set to %s\\n\", string);\n\t\t\tbreak;\n\t\tcase Opt_netbiosname:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tmemset(vol->source_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN);\n\t\t\t/*\n\t\t\t * FIXME: are there cases in which a comma can\n\t\t\t * be valid in workstation netbios name (and\n\t\t\t * need special handling)?\n\t\t\t */\n\t\t\tfor (i = 0; i < RFC1001_NAME_LEN; i++) {\n\t\t\t\t/* don't ucase netbiosname for user */\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->source_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t * set at top of the function\n\t\t\t */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tpr_warn(\"CIFS: netbiosname longer than 15 truncated.\\n\");\n\t\t\tbreak;\n\t\tcase Opt_servern:\n\t\t\t/* servernetbiosname specified override *SMBSERVER */\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\t/* last byte, type, is 0x20 for servr type */\n\t\t\tmemset(vol->target_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\t/* BB are there cases in which a comma can be\n\t\t\t   valid in this workstation netbios name\n\t\t\t   (and need special handling)? */\n\n\t\t\t/* user or mount helper must uppercase the\n\t\t\t   netbios name */\n\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->target_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t   set at top of the function  */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tpr_warn(\"CIFS: server netbiosname longer than 15 truncated.\\n\");\n\t\t\tbreak;\n\t\tcase Opt_ver:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strncasecmp(string, \"1\", 1) == 0) {\n\t\t\t\t/* This is the default */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For all other value, error */\n\t\t\tpr_warn(\"CIFS: Invalid version specified\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\tcase Opt_vers:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_smb_version(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_sec:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_security_flavors(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_cache_flavor(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * An option we don't recognize. Save it off for later\n\t\t\t * if we haven't already found one\n\t\t\t */\n\t\t\tif (!invalid)\n\t\t\t\tinvalid = data;\n\t\t\tbreak;\n\t\t}\n\t\t/* Free up any allocated string */\n\t\tkfree(string);\n\t\tstring = NULL;\n\t}\n\n\tif (!sloppy && invalid) {\n\t\tpr_err(\"CIFS: Unknown mount option \\\"%s\\\"\\n\", invalid);\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n#ifndef CONFIG_KEYS\n\t/* Muliuser mounts require CONFIG_KEYS support */\n\tif (vol->multiuser) {\n\t\tcifs_dbg(VFS, \"Multiuser mounts require kernels with CONFIG_KEYS enabled\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n#endif\n\tif (!vol->UNC) {\n\t\tcifs_dbg(VFS, \"CIFS mount error: No usable UNC path provided in device string!\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\t/* make sure UNC has a share name */\n\tif (!strchr(vol->UNC + 3, '\\\\')) {\n\t\tcifs_dbg(VFS, \"Malformed UNC. Unable to find share name.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\tif (!got_ip) {\n\t\t/* No ip= option specified? Try to get it from UNC */\n\t\tif (!cifs_convert_address(dstaddr, &vol->UNC[2],\n\t\t\t\t\t\tstrlen(&vol->UNC[2]))) {\n\t\t\tpr_err(\"Unable to determine destination address.\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t}\n\n\t/* set the port that we got earlier */\n\tcifs_set_port(dstaddr, port);\n\n\tif (uid_specified)\n\t\tvol->override_uid = override_uid;\n\telse if (override_uid == 1)\n\t\tpr_notice(\"CIFS: ignoring forceuid mount option specified with no uid= option.\\n\");\n\n\tif (gid_specified)\n\t\tvol->override_gid = override_gid;\n\telse if (override_gid == 1)\n\t\tpr_notice(\"CIFS: ignoring forcegid mount option specified with no gid= option.\\n\");\n\n\tkfree(mountdata_copy);\n\treturn 0;\n\nout_nomem:\n\tpr_warn(\"Could not allocate temporary buffer\\n\");\ncifs_parse_mount_err:\n\tkfree(string);\n\tkfree(mountdata_copy);\n\treturn 1;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t cifs_mount_option_tokens = {\n\n\t{ Opt_user_xattr, \"user_xattr\" },\n\t{ Opt_nouser_xattr, \"nouser_xattr\" },\n\t{ Opt_forceuid, \"forceuid\" },\n\t{ Opt_noforceuid, \"noforceuid\" },\n\t{ Opt_forcegid, \"forcegid\" },\n\t{ Opt_noforcegid, \"noforcegid\" },\n\t{ Opt_noblocksend, \"noblocksend\" },\n\t{ Opt_noautotune, \"noautotune\" },\n\t{ Opt_hard, \"hard\" },\n\t{ Opt_soft, \"soft\" },\n\t{ Opt_perm, \"perm\" },\n\t{ Opt_noperm, \"noperm\" },\n\t{ Opt_mapchars, \"mapchars\" }, /* SFU style */\n\t{ Opt_nomapchars, \"nomapchars\" },\n\t{ Opt_mapposix, \"mapposix\" }, /* SFM style */\n\t{ Opt_nomapposix, \"nomapposix\" },\n\t{ Opt_sfu, \"sfu\" },\n\t{ Opt_nosfu, \"nosfu\" },\n\t{ Opt_nodfs, \"nodfs\" },\n\t{ Opt_posixpaths, \"posixpaths\" },\n\t{ Opt_noposixpaths, \"noposixpaths\" },\n\t{ Opt_nounix, \"nounix\" },\n\t{ Opt_nounix, \"nolinux\" },\n\t{ Opt_nocase, \"nocase\" },\n\t{ Opt_nocase, \"ignorecase\" },\n\t{ Opt_brl, \"brl\" },\n\t{ Opt_nobrl, \"nobrl\" },\n\t{ Opt_nobrl, \"nolock\" },\n\t{ Opt_forcemandatorylock, \"forcemandatorylock\" },\n\t{ Opt_forcemandatorylock, \"forcemand\" },\n\t{ Opt_setuids, \"setuids\" },\n\t{ Opt_nosetuids, \"nosetuids\" },\n\t{ Opt_dynperm, \"dynperm\" },\n\t{ Opt_nodynperm, \"nodynperm\" },\n\t{ Opt_nohard, \"nohard\" },\n\t{ Opt_nosoft, \"nosoft\" },\n\t{ Opt_nointr, \"nointr\" },\n\t{ Opt_intr, \"intr\" },\n\t{ Opt_nostrictsync, \"nostrictsync\" },\n\t{ Opt_strictsync, \"strictsync\" },\n\t{ Opt_serverino, \"serverino\" },\n\t{ Opt_noserverino, \"noserverino\" },\n\t{ Opt_rwpidforward, \"rwpidforward\" },\n\t{ Opt_cifsacl, \"cifsacl\" },\n\t{ Opt_nocifsacl, \"nocifsacl\" },\n\t{ Opt_acl, \"acl\" },\n\t{ Opt_noacl, \"noacl\" },\n\t{ Opt_locallease, \"locallease\" },\n\t{ Opt_sign, \"sign\" },\n\t{ Opt_seal, \"seal\" },\n\t{ Opt_noac, \"noac\" },\n\t{ Opt_fsc, \"fsc\" },\n\t{ Opt_mfsymlinks, \"mfsymlinks\" },\n\t{ Opt_multiuser, \"multiuser\" },\n\t{ Opt_sloppy, \"sloppy\" },\n\t{ Opt_nosharesock, \"nosharesock\" },\n\n\t{ Opt_backupuid, \"backupuid=%s\" },\n\t{ Opt_backupgid, \"backupgid=%s\" },\n\t{ Opt_uid, \"uid=%s\" },\n\t{ Opt_cruid, \"cruid=%s\" },\n\t{ Opt_gid, \"gid=%s\" },\n\t{ Opt_file_mode, \"file_mode=%s\" },\n\t{ Opt_dirmode, \"dirmode=%s\" },\n\t{ Opt_dirmode, \"dir_mode=%s\" },\n\t{ Opt_port, \"port=%s\" },\n\t{ Opt_rsize, \"rsize=%s\" },\n\t{ Opt_wsize, \"wsize=%s\" },\n\t{ Opt_actimeo, \"actimeo=%s\" },\n\n\t{ Opt_blank_user, \"user=\" },\n\t{ Opt_blank_user, \"username=\" },\n\t{ Opt_user, \"user=%s\" },\n\t{ Opt_user, \"username=%s\" },\n\t{ Opt_blank_pass, \"pass=\" },\n\t{ Opt_blank_pass, \"password=\" },\n\t{ Opt_pass, \"pass=%s\" },\n\t{ Opt_pass, \"password=%s\" },\n\t{ Opt_blank_ip, \"ip=\" },\n\t{ Opt_blank_ip, \"addr=\" },\n\t{ Opt_ip, \"ip=%s\" },\n\t{ Opt_ip, \"addr=%s\" },\n\t{ Opt_ignore, \"unc=%s\" },\n\t{ Opt_ignore, \"target=%s\" },\n\t{ Opt_ignore, \"path=%s\" },\n\t{ Opt_domain, \"dom=%s\" },\n\t{ Opt_domain, \"domain=%s\" },\n\t{ Opt_domain, \"workgroup=%s\" },\n\t{ Opt_srcaddr, \"srcaddr=%s\" },\n\t{ Opt_ignore, \"prefixpath=%s\" },\n\t{ Opt_iocharset, \"iocharset=%s\" },\n\t{ Opt_netbiosname, \"netbiosname=%s\" },\n\t{ Opt_servern, \"servern=%s\" },\n\t{ Opt_ver, \"ver=%s\" },\n\t{ Opt_vers, \"vers=%s\" },\n\t{ Opt_sec, \"sec=%s\" },\n\t{ Opt_cache, \"cache=%s\" },\n\n\t{ Opt_ignore, \"cred\" },\n\t{ Opt_ignore, \"credentials\" },\n\t{ Opt_ignore, \"cred=%s\" },\n\t{ Opt_ignore, \"credentials=%s\" },\n\t{ Opt_ignore, \"guest\" },\n\t{ Opt_ignore, \"rw\" },\n\t{ Opt_ignore, \"ro\" },\n\t{ Opt_ignore, \"suid\" },\n\t{ Opt_ignore, \"nosuid\" },\n\t{ Opt_ignore, \"exec\" },\n\t{ Opt_ignore, \"noexec\" },\n\t{ Opt_ignore, \"nodev\" },\n\t{ Opt_ignore, \"noauto\" },\n\t{ Opt_ignore, \"dev\" },\n\t{ Opt_ignore, \"mand\" },\n\t{ Opt_ignore, \"nomand\" },\n\t{ Opt_ignore, \"_netdev\" },\n\n\t{ Opt_err, NULL }\n};",
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);",
            "static int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic const match_table_t cifs_mount_option_tokens = {\n\n\t{ Opt_user_xattr, \"user_xattr\" },\n\t{ Opt_nouser_xattr, \"nouser_xattr\" },\n\t{ Opt_forceuid, \"forceuid\" },\n\t{ Opt_noforceuid, \"noforceuid\" },\n\t{ Opt_forcegid, \"forcegid\" },\n\t{ Opt_noforcegid, \"noforcegid\" },\n\t{ Opt_noblocksend, \"noblocksend\" },\n\t{ Opt_noautotune, \"noautotune\" },\n\t{ Opt_hard, \"hard\" },\n\t{ Opt_soft, \"soft\" },\n\t{ Opt_perm, \"perm\" },\n\t{ Opt_noperm, \"noperm\" },\n\t{ Opt_mapchars, \"mapchars\" }, /* SFU style */\n\t{ Opt_nomapchars, \"nomapchars\" },\n\t{ Opt_mapposix, \"mapposix\" }, /* SFM style */\n\t{ Opt_nomapposix, \"nomapposix\" },\n\t{ Opt_sfu, \"sfu\" },\n\t{ Opt_nosfu, \"nosfu\" },\n\t{ Opt_nodfs, \"nodfs\" },\n\t{ Opt_posixpaths, \"posixpaths\" },\n\t{ Opt_noposixpaths, \"noposixpaths\" },\n\t{ Opt_nounix, \"nounix\" },\n\t{ Opt_nounix, \"nolinux\" },\n\t{ Opt_nocase, \"nocase\" },\n\t{ Opt_nocase, \"ignorecase\" },\n\t{ Opt_brl, \"brl\" },\n\t{ Opt_nobrl, \"nobrl\" },\n\t{ Opt_nobrl, \"nolock\" },\n\t{ Opt_forcemandatorylock, \"forcemandatorylock\" },\n\t{ Opt_forcemandatorylock, \"forcemand\" },\n\t{ Opt_setuids, \"setuids\" },\n\t{ Opt_nosetuids, \"nosetuids\" },\n\t{ Opt_dynperm, \"dynperm\" },\n\t{ Opt_nodynperm, \"nodynperm\" },\n\t{ Opt_nohard, \"nohard\" },\n\t{ Opt_nosoft, \"nosoft\" },\n\t{ Opt_nointr, \"nointr\" },\n\t{ Opt_intr, \"intr\" },\n\t{ Opt_nostrictsync, \"nostrictsync\" },\n\t{ Opt_strictsync, \"strictsync\" },\n\t{ Opt_serverino, \"serverino\" },\n\t{ Opt_noserverino, \"noserverino\" },\n\t{ Opt_rwpidforward, \"rwpidforward\" },\n\t{ Opt_cifsacl, \"cifsacl\" },\n\t{ Opt_nocifsacl, \"nocifsacl\" },\n\t{ Opt_acl, \"acl\" },\n\t{ Opt_noacl, \"noacl\" },\n\t{ Opt_locallease, \"locallease\" },\n\t{ Opt_sign, \"sign\" },\n\t{ Opt_seal, \"seal\" },\n\t{ Opt_noac, \"noac\" },\n\t{ Opt_fsc, \"fsc\" },\n\t{ Opt_mfsymlinks, \"mfsymlinks\" },\n\t{ Opt_multiuser, \"multiuser\" },\n\t{ Opt_sloppy, \"sloppy\" },\n\t{ Opt_nosharesock, \"nosharesock\" },\n\n\t{ Opt_backupuid, \"backupuid=%s\" },\n\t{ Opt_backupgid, \"backupgid=%s\" },\n\t{ Opt_uid, \"uid=%s\" },\n\t{ Opt_cruid, \"cruid=%s\" },\n\t{ Opt_gid, \"gid=%s\" },\n\t{ Opt_file_mode, \"file_mode=%s\" },\n\t{ Opt_dirmode, \"dirmode=%s\" },\n\t{ Opt_dirmode, \"dir_mode=%s\" },\n\t{ Opt_port, \"port=%s\" },\n\t{ Opt_rsize, \"rsize=%s\" },\n\t{ Opt_wsize, \"wsize=%s\" },\n\t{ Opt_actimeo, \"actimeo=%s\" },\n\n\t{ Opt_blank_user, \"user=\" },\n\t{ Opt_blank_user, \"username=\" },\n\t{ Opt_user, \"user=%s\" },\n\t{ Opt_user, \"username=%s\" },\n\t{ Opt_blank_pass, \"pass=\" },\n\t{ Opt_blank_pass, \"password=\" },\n\t{ Opt_pass, \"pass=%s\" },\n\t{ Opt_pass, \"password=%s\" },\n\t{ Opt_blank_ip, \"ip=\" },\n\t{ Opt_blank_ip, \"addr=\" },\n\t{ Opt_ip, \"ip=%s\" },\n\t{ Opt_ip, \"addr=%s\" },\n\t{ Opt_ignore, \"unc=%s\" },\n\t{ Opt_ignore, \"target=%s\" },\n\t{ Opt_ignore, \"path=%s\" },\n\t{ Opt_domain, \"dom=%s\" },\n\t{ Opt_domain, \"domain=%s\" },\n\t{ Opt_domain, \"workgroup=%s\" },\n\t{ Opt_srcaddr, \"srcaddr=%s\" },\n\t{ Opt_ignore, \"prefixpath=%s\" },\n\t{ Opt_iocharset, \"iocharset=%s\" },\n\t{ Opt_netbiosname, \"netbiosname=%s\" },\n\t{ Opt_servern, \"servern=%s\" },\n\t{ Opt_ver, \"ver=%s\" },\n\t{ Opt_vers, \"vers=%s\" },\n\t{ Opt_sec, \"sec=%s\" },\n\t{ Opt_cache, \"cache=%s\" },\n\n\t{ Opt_ignore, \"cred\" },\n\t{ Opt_ignore, \"credentials\" },\n\t{ Opt_ignore, \"cred=%s\" },\n\t{ Opt_ignore, \"credentials=%s\" },\n\t{ Opt_ignore, \"guest\" },\n\t{ Opt_ignore, \"rw\" },\n\t{ Opt_ignore, \"ro\" },\n\t{ Opt_ignore, \"suid\" },\n\t{ Opt_ignore, \"nosuid\" },\n\t{ Opt_ignore, \"exec\" },\n\t{ Opt_ignore, \"noexec\" },\n\t{ Opt_ignore, \"nodev\" },\n\t{ Opt_ignore, \"noauto\" },\n\t{ Opt_ignore, \"dev\" },\n\t{ Opt_ignore, \"mand\" },\n\t{ Opt_ignore, \"nomand\" },\n\t{ Opt_ignore, \"_netdev\" },\n\n\t{ Opt_err, NULL }\n};\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\nstatic int\ncifs_parse_mount_options(const char *mountdata, const char *devname,\n\t\t\t struct smb_vol *vol)\n{\n\tchar *data, *end;\n\tchar *mountdata_copy = NULL, *options;\n\tunsigned int  temp_len, i, j;\n\tchar separator[2];\n\tshort int override_uid = -1;\n\tshort int override_gid = -1;\n\tbool uid_specified = false;\n\tbool gid_specified = false;\n\tbool sloppy = false;\n\tchar *invalid = NULL;\n\tchar *nodename = utsname()->nodename;\n\tchar *string = NULL;\n\tchar *tmp_end, *value;\n\tchar delim;\n\tbool got_ip = false;\n\tunsigned short port = 0;\n\tstruct sockaddr *dstaddr = (struct sockaddr *)&vol->dstaddr;\n\n\tseparator[0] = ',';\n\tseparator[1] = 0;\n\tdelim = separator[0];\n\n\t/* ensure we always start with zeroed-out smb_vol */\n\tmemset(vol, 0, sizeof(*vol));\n\n\t/*\n\t * does not have to be perfect mapping since field is\n\t * informational, only used for servers that do not support\n\t * port 445 and it can be overridden at mount time\n\t */\n\tmemset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);\n\tfor (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)\n\t\tvol->source_rfc1001_name[i] = toupper(nodename[i]);\n\n\tvol->source_rfc1001_name[RFC1001_NAME_LEN] = 0;\n\t/* null target name indicates to use *SMBSERVR default called name\n\t   if we end up sending RFC1001 session initialize */\n\tvol->target_rfc1001_name[0] = 0;\n\tvol->cred_uid = current_uid();\n\tvol->linux_uid = current_uid();\n\tvol->linux_gid = current_gid();\n\n\t/*\n\t * default to SFM style remapping of seven reserved characters\n\t * unless user overrides it or we negotiate CIFS POSIX where\n\t * it is unnecessary.  Can not simultaneously use more than one mapping\n\t * since then readdir could list files that open could not open\n\t */\n\tvol->remap = true;\n\n\t/* default to only allowing write access to owner of the mount */\n\tvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t/* vol->retry default is 0 (i.e. \"soft\" limited retry not hard retry) */\n\t/* default is always to request posix paths. */\n\tvol->posix_paths = 1;\n\t/* default to using server inode numbers where available */\n\tvol->server_ino = 1;\n\n\t/* default is to use strict cifs caching semantics */\n\tvol->strict_io = true;\n\n\tvol->actimeo = CIFS_DEF_ACTIMEO;\n\n\t/* FIXME: add autonegotiation -- for now, SMB1 is default */\n\tvol->ops = &smb1_operations;\n\tvol->vals = &smb1_values;\n\n\tif (!mountdata)\n\t\tgoto cifs_parse_mount_err;\n\n\tmountdata_copy = kstrndup(mountdata, PAGE_SIZE, GFP_KERNEL);\n\tif (!mountdata_copy)\n\t\tgoto cifs_parse_mount_err;\n\n\toptions = mountdata_copy;\n\tend = options + strlen(options);\n\n\tif (strncmp(options, \"sep=\", 4) == 0) {\n\t\tif (options[4] != 0) {\n\t\t\tseparator[0] = options[4];\n\t\t\toptions += 5;\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"Null separator not allowed\\n\");\n\t\t}\n\t}\n\tvol->backupuid_specified = false; /* no backup intent for a user */\n\tvol->backupgid_specified = false; /* no backup intent for a group */\n\n\tswitch (cifs_parse_devname(devname, vol)) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOMEM:\n\t\tcifs_dbg(VFS, \"Unable to allocate memory for devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tcase -EINVAL:\n\t\tcifs_dbg(VFS, \"Malformed UNC in devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown error parsing devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\twhile ((data = strsep(&options, separator)) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned long option;\n\t\tint token;\n\n\t\tif (!*data)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(data, cifs_mount_option_tokens, args);\n\n\t\tswitch (token) {\n\n\t\t/* Ingnore the following */\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\n\t\t/* Boolean values */\n\t\tcase Opt_user_xattr:\n\t\t\tvol->no_xattr = 0;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tvol->no_xattr = 1;\n\t\t\tbreak;\n\t\tcase Opt_forceuid:\n\t\t\toverride_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforceuid:\n\t\t\toverride_uid = 0;\n\t\t\tbreak;\n\t\tcase Opt_forcegid:\n\t\t\toverride_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforcegid:\n\t\t\toverride_gid = 0;\n\t\t\tbreak;\n\t\tcase Opt_noblocksend:\n\t\t\tvol->noblocksnd = 1;\n\t\t\tbreak;\n\t\tcase Opt_noautotune:\n\t\t\tvol->noautotune = 1;\n\t\t\tbreak;\n\t\tcase Opt_hard:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_soft:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_perm:\n\t\t\tvol->noperm = 0;\n\t\t\tbreak;\n\t\tcase Opt_noperm:\n\t\t\tvol->noperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_mapchars:\n\t\t\tvol->sfu_remap = true;\n\t\t\tvol->remap = false; /* disable SFM mapping */\n\t\t\tbreak;\n\t\tcase Opt_nomapchars:\n\t\t\tvol->sfu_remap = false;\n\t\t\tbreak;\n\t\tcase Opt_mapposix:\n\t\t\tvol->remap = true;\n\t\t\tvol->sfu_remap = false; /* disable SFU mapping */\n\t\t\tbreak;\n\t\tcase Opt_nomapposix:\n\t\t\tvol->remap = false;\n\t\t\tbreak;\n\t\tcase Opt_sfu:\n\t\t\tvol->sfu_emul = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosfu:\n\t\t\tvol->sfu_emul = 0;\n\t\t\tbreak;\n\t\tcase Opt_nodfs:\n\t\t\tvol->nodfs = 1;\n\t\t\tbreak;\n\t\tcase Opt_posixpaths:\n\t\t\tvol->posix_paths = 1;\n\t\t\tbreak;\n\t\tcase Opt_noposixpaths:\n\t\t\tvol->posix_paths = 0;\n\t\t\tbreak;\n\t\tcase Opt_nounix:\n\t\t\tvol->no_linux_ext = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tvol->nocase = 1;\n\t\t\tbreak;\n\t\tcase Opt_brl:\n\t\t\tvol->nobrl =  0;\n\t\t\tbreak;\n\t\tcase Opt_nobrl:\n\t\t\tvol->nobrl =  1;\n\t\t\t/*\n\t\t\t * turn off mandatory locking in mode\n\t\t\t * if remote locking is turned off since the\n\t\t\t * local vfs will do advisory\n\t\t\t */\n\t\t\tif (vol->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tvol->file_mode = S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_forcemandatorylock:\n\t\t\tvol->mand_lock = 1;\n\t\t\tbreak;\n\t\tcase Opt_setuids:\n\t\t\tvol->setuids = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosetuids:\n\t\t\tvol->setuids = 0;\n\t\t\tbreak;\n\t\tcase Opt_dynperm:\n\t\t\tvol->dynperm = true;\n\t\t\tbreak;\n\t\tcase Opt_nodynperm:\n\t\t\tvol->dynperm = false;\n\t\t\tbreak;\n\t\tcase Opt_nohard:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_nosoft:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tvol->intr = 0;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tvol->intr = 1;\n\t\t\tbreak;\n\t\tcase Opt_nostrictsync:\n\t\t\tvol->nostrictsync = 1;\n\t\t\tbreak;\n\t\tcase Opt_strictsync:\n\t\t\tvol->nostrictsync = 0;\n\t\t\tbreak;\n\t\tcase Opt_serverino:\n\t\t\tvol->server_ino = 1;\n\t\t\tbreak;\n\t\tcase Opt_noserverino:\n\t\t\tvol->server_ino = 0;\n\t\t\tbreak;\n\t\tcase Opt_rwpidforward:\n\t\t\tvol->rwpidforward = 1;\n\t\t\tbreak;\n\t\tcase Opt_cifsacl:\n\t\t\tvol->cifs_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocifsacl:\n\t\t\tvol->cifs_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tvol->no_psx_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tvol->no_psx_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_locallease:\n\t\t\tvol->local_lease = 1;\n\t\t\tbreak;\n\t\tcase Opt_sign:\n\t\t\tvol->sign = true;\n\t\t\tbreak;\n\t\tcase Opt_seal:\n\t\t\t/* we do not do the following in secFlags because seal\n\t\t\t * is a per tree connection (mount) not a per socket\n\t\t\t * or per-smb connection option in the protocol\n\t\t\t * vol->secFlg |= CIFSSEC_MUST_SEAL;\n\t\t\t */\n\t\t\tvol->seal = 1;\n\t\t\tbreak;\n\t\tcase Opt_noac:\n\t\t\tpr_warn(\"CIFS: Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\t\tbreak;\n\t\tcase Opt_fsc:\n#ifndef CONFIG_CIFS_FSCACHE\n\t\t\tcifs_dbg(VFS, \"FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n#endif\n\t\t\tvol->fsc = true;\n\t\t\tbreak;\n\t\tcase Opt_mfsymlinks:\n\t\t\tvol->mfsymlinks = true;\n\t\t\tbreak;\n\t\tcase Opt_multiuser:\n\t\t\tvol->multiuser = true;\n\t\t\tbreak;\n\t\tcase Opt_sloppy:\n\t\t\tsloppy = true;\n\t\t\tbreak;\n\t\tcase Opt_nosharesock:\n\t\t\tvol->nosharesock = true;\n\t\t\tbreak;\n\n\t\t/* Numeric Values */\n\t\tcase Opt_backupuid:\n\t\t\tif (get_option_uid(args, &vol->backupuid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupuid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_backupgid:\n\t\t\tif (get_option_gid(args, &vol->backupgid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupgid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (get_option_uid(args, &vol->linux_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid uid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_cruid:\n\t\t\tif (get_option_uid(args, &vol->cred_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid cruid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (get_option_gid(args, &vol->linux_gid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid gid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_file_mode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid file_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->file_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_dirmode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid dir_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->dir_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_port:\n\t\t\tif (get_option_ul(args, &option) ||\n\t\t\t    option > USHRT_MAX) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid port value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tport = (unsigned short)option;\n\t\t\tbreak;\n\t\tcase Opt_rsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid rsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->rsize = option;\n\t\t\tbreak;\n\t\tcase Opt_wsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid wsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->wsize = option;\n\t\t\tbreak;\n\t\tcase Opt_actimeo:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid actimeo value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->actimeo = HZ * option;\n\t\t\tif (vol->actimeo > CIFS_MAX_ACTIMEO) {\n\t\t\t\tcifs_dbg(VFS, \"attribute cache timeout too large\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* String Arguments */\n\n\t\tcase Opt_blank_user:\n\t\t\t/* null user, ie. anonymous authentication */\n\t\t\tvol->nullauth = 1;\n\t\t\tvol->username = NULL;\n\t\t\tbreak;\n\t\tcase Opt_user:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, CIFS_MAX_USERNAME_LEN) >\n\t\t\t\t\t\t\tCIFS_MAX_USERNAME_LEN) {\n\t\t\t\tpr_warn(\"CIFS: username too long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->username = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->username)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_blank_pass:\n\t\t\t/* passwords have to be handled differently\n\t\t\t * to allow the character used for deliminator\n\t\t\t * to be passed within them\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Check if this is a case where the  password\n\t\t\t * starts with a delimiter\n\t\t\t */\n\t\t\ttmp_end = strchr(data, '=');\n\t\t\ttmp_end++;\n\t\t\tif (!(tmp_end < end && tmp_end[1] == delim)) {\n\t\t\t\t/* No it is not. Set the password to NULL */\n\t\t\t\tkfree(vol->password);\n\t\t\t\tvol->password = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Yes it is. Drop down to Opt_pass below.*/\n\t\tcase Opt_pass:\n\t\t\t/* Obtain the value string */\n\t\t\tvalue = strchr(data, '=');\n\t\t\tvalue++;\n\n\t\t\t/* Set tmp_end to end of the string */\n\t\t\ttmp_end = (char *) value + strlen(value);\n\n\t\t\t/* Check if following character is the deliminator\n\t\t\t * If yes, we have encountered a double deliminator\n\t\t\t * reset the NULL character to the deliminator\n\t\t\t */\n\t\t\tif (tmp_end < end && tmp_end[1] == delim) {\n\t\t\t\ttmp_end[0] = delim;\n\n\t\t\t\t/* Keep iterating until we get to a single\n\t\t\t\t * deliminator OR the end\n\t\t\t\t */\n\t\t\t\twhile ((tmp_end = strchr(tmp_end, delim))\n\t\t\t\t\t!= NULL && (tmp_end[1] == delim)) {\n\t\t\t\t\t\ttmp_end = (char *) &tmp_end[2];\n\t\t\t\t}\n\n\t\t\t\t/* Reset var options to point to next element */\n\t\t\t\tif (tmp_end) {\n\t\t\t\t\ttmp_end[0] = '\\0';\n\t\t\t\t\toptions = (char *) &tmp_end[1];\n\t\t\t\t} else\n\t\t\t\t\t/* Reached the end of the mount option\n\t\t\t\t\t * string */\n\t\t\t\t\toptions = end;\n\t\t\t}\n\n\t\t\tkfree(vol->password);\n\t\t\t/* Now build new password string */\n\t\t\ttemp_len = strlen(value);\n\t\t\tvol->password = kzalloc(temp_len+1, GFP_KERNEL);\n\t\t\tif (vol->password == NULL) {\n\t\t\t\tpr_warn(\"CIFS: no memory for password\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tfor (i = 0, j = 0; i < temp_len; i++, j++) {\n\t\t\t\tvol->password[j] = value[i];\n\t\t\t\tif ((value[i] == delim) &&\n\t\t\t\t     value[i+1] == delim)\n\t\t\t\t\t/* skip the second deliminator */\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t\tvol->password[j] = '\\0';\n\t\t\tbreak;\n\t\tcase Opt_blank_ip:\n\t\t\t/* FIXME: should this be an error instead? */\n\t\t\tgot_ip = false;\n\t\t\tbreak;\n\t\tcase Opt_ip:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(dstaddr, string,\n\t\t\t\t\tstrlen(string))) {\n\t\t\t\tpr_err(\"CIFS: bad ip= option (%s).\\n\", string);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgot_ip = true;\n\t\t\tbreak;\n\t\tcase Opt_domain:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, CIFS_MAX_DOMAINNAME_LEN)\n\t\t\t\t\t== CIFS_MAX_DOMAINNAME_LEN) {\n\t\t\t\tpr_warn(\"CIFS: domain name too long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tvol->domainname = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->domainname) {\n\t\t\t\tpr_warn(\"CIFS: no memory for domainname\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tcifs_dbg(FYI, \"Domain name set\\n\");\n\t\t\tbreak;\n\t\tcase Opt_srcaddr:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(\n\t\t\t\t\t(struct sockaddr *)&vol->srcaddr,\n\t\t\t\t\tstring, strlen(string))) {\n\t\t\t\tpr_warn(\"CIFS: Could not parse srcaddr: %s\\n\",\n\t\t\t\t\tstring);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, 1024) >= 65) {\n\t\t\t\tpr_warn(\"CIFS: iocharset name too long.\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\t if (strncasecmp(string, \"default\", 7) != 0) {\n\t\t\t\tvol->iocharset = kstrdup(string,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\t\tif (!vol->iocharset) {\n\t\t\t\t\tpr_warn(\"CIFS: no memory for charset\\n\");\n\t\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if iocharset not set then load_nls_default\n\t\t\t * is used by caller\n\t\t\t */\n\t\t\t cifs_dbg(FYI, \"iocharset set to %s\\n\", string);\n\t\t\tbreak;\n\t\tcase Opt_netbiosname:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tmemset(vol->source_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN);\n\t\t\t/*\n\t\t\t * FIXME: are there cases in which a comma can\n\t\t\t * be valid in workstation netbios name (and\n\t\t\t * need special handling)?\n\t\t\t */\n\t\t\tfor (i = 0; i < RFC1001_NAME_LEN; i++) {\n\t\t\t\t/* don't ucase netbiosname for user */\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->source_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t * set at top of the function\n\t\t\t */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tpr_warn(\"CIFS: netbiosname longer than 15 truncated.\\n\");\n\t\t\tbreak;\n\t\tcase Opt_servern:\n\t\t\t/* servernetbiosname specified override *SMBSERVER */\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\t/* last byte, type, is 0x20 for servr type */\n\t\t\tmemset(vol->target_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\t/* BB are there cases in which a comma can be\n\t\t\t   valid in this workstation netbios name\n\t\t\t   (and need special handling)? */\n\n\t\t\t/* user or mount helper must uppercase the\n\t\t\t   netbios name */\n\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->target_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t   set at top of the function  */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tpr_warn(\"CIFS: server netbiosname longer than 15 truncated.\\n\");\n\t\t\tbreak;\n\t\tcase Opt_ver:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strncasecmp(string, \"1\", 1) == 0) {\n\t\t\t\t/* This is the default */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For all other value, error */\n\t\t\tpr_warn(\"CIFS: Invalid version specified\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\tcase Opt_vers:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_smb_version(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_sec:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_security_flavors(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_cache_flavor(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * An option we don't recognize. Save it off for later\n\t\t\t * if we haven't already found one\n\t\t\t */\n\t\t\tif (!invalid)\n\t\t\t\tinvalid = data;\n\t\t\tbreak;\n\t\t}\n\t\t/* Free up any allocated string */\n\t\tkfree(string);\n\t\tstring = NULL;\n\t}\n\n\tif (!sloppy && invalid) {\n\t\tpr_err(\"CIFS: Unknown mount option \\\"%s\\\"\\n\", invalid);\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n#ifndef CONFIG_KEYS\n\t/* Muliuser mounts require CONFIG_KEYS support */\n\tif (vol->multiuser) {\n\t\tcifs_dbg(VFS, \"Multiuser mounts require kernels with CONFIG_KEYS enabled\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n#endif\n\tif (!vol->UNC) {\n\t\tcifs_dbg(VFS, \"CIFS mount error: No usable UNC path provided in device string!\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\t/* make sure UNC has a share name */\n\tif (!strchr(vol->UNC + 3, '\\\\')) {\n\t\tcifs_dbg(VFS, \"Malformed UNC. Unable to find share name.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\tif (!got_ip) {\n\t\t/* No ip= option specified? Try to get it from UNC */\n\t\tif (!cifs_convert_address(dstaddr, &vol->UNC[2],\n\t\t\t\t\t\tstrlen(&vol->UNC[2]))) {\n\t\t\tpr_err(\"Unable to determine destination address.\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t}\n\n\t/* set the port that we got earlier */\n\tcifs_set_port(dstaddr, port);\n\n\tif (uid_specified)\n\t\tvol->override_uid = override_uid;\n\telse if (override_uid == 1)\n\t\tpr_notice(\"CIFS: ignoring forceuid mount option specified with no uid= option.\\n\");\n\n\tif (gid_specified)\n\t\tvol->override_gid = override_gid;\n\telse if (override_gid == 1)\n\t\tpr_notice(\"CIFS: ignoring forcegid mount option specified with no gid= option.\\n\");\n\n\tkfree(mountdata_copy);\n\treturn 0;\n\nout_nomem:\n\tpr_warn(\"Could not allocate temporary buffer\\n\");\ncifs_parse_mount_err:\n\tkfree(string);\n\tkfree(mountdata_copy);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\nstatic int\ncifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\tconst char *devname)\n{\n\tint rc = 0;\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info))\n\t\treturn -EINVAL;\n\n\tif (volume_info->nullauth) {\n\t\tcifs_dbg(FYI, \"Anonymous login\\n\");\n\t\tkfree(volume_info->username);\n\t\tvolume_info->username = NULL;\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcifs_dbg(FYI, \"Username: %s\\n\", volume_info->username);\n\t} else {\n\t\tcifs_dbg(VFS, \"No username specified\\n\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\treturn -EINVAL;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t volume_info->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "expand_dfs_referral",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3331-3374",
    "snippet": "static int\nexpand_dfs_referral(const unsigned int xid, struct cifs_ses *ses,\n\t\t    struct smb_vol *volume_info, struct cifs_sb_info *cifs_sb,\n\t\t    int check_prefix)\n{\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\tchar *full_path = NULL, *ref_path = NULL, *mdata = NULL;\n\n\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\t/* For DFS paths, skip the first '\\' of the UNC */\n\tref_path = check_prefix ? full_path + 1 : volume_info->UNC + 1;\n\n\trc = get_dfs_path(xid, ses, ref_path, cifs_sb->local_nls,\n\t\t\t  &num_referrals, &referrals, cifs_remap(cifs_sb));\n\n\tif (!rc && num_referrals > 0) {\n\t\tchar *fake_devname = NULL;\n\n\t\tmdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\t\t\t\t   full_path + 1, referrals,\n\t\t\t\t\t\t   &fake_devname);\n\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\n\t\tif (IS_ERR(mdata)) {\n\t\t\trc = PTR_ERR(mdata);\n\t\t\tmdata = NULL;\n\t\t} else {\n\t\t\tcleanup_volume_info_contents(volume_info);\n\t\t\trc = cifs_setup_volume_info(volume_info, mdata,\n\t\t\t\t\t\t\tfake_devname);\n\t\t}\n\t\tkfree(fake_devname);\n\t\tkfree(cifs_sb->mountdata);\n\t\tcifs_sb->mountdata = mdata;\n\t}\n\tkfree(full_path);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cifs_sb->mountdata"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fake_devname"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_setup_volume_info",
          "args": [
            "volume_info",
            "mdata",
            "fake_devname"
          ],
          "line": 3365
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_setup_volume_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3377-3414",
          "snippet": "static int\ncifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\tconst char *devname)\n{\n\tint rc = 0;\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info))\n\t\treturn -EINVAL;\n\n\tif (volume_info->nullauth) {\n\t\tcifs_dbg(FYI, \"Anonymous login\\n\");\n\t\tkfree(volume_info->username);\n\t\tvolume_info->username = NULL;\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcifs_dbg(FYI, \"Username: %s\\n\", volume_info->username);\n\t} else {\n\t\tcifs_dbg(VFS, \"No username specified\\n\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\treturn -EINVAL;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t volume_info->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\nstatic int\ncifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\tconst char *devname)\n{\n\tint rc = 0;\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info))\n\t\treturn -EINVAL;\n\n\tif (volume_info->nullauth) {\n\t\tcifs_dbg(FYI, \"Anonymous login\\n\");\n\t\tkfree(volume_info->username);\n\t\tvolume_info->username = NULL;\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcifs_dbg(FYI, \"Username: %s\\n\", volume_info->username);\n\t} else {\n\t\tcifs_dbg(VFS, \"No username specified\\n\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\treturn -EINVAL;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t volume_info->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_volume_info_contents",
          "args": [
            "volume_info"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_volume_info_contents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3268-3277",
          "snippet": "static void\ncleanup_volume_info_contents(struct smb_vol *volume_info)\n{\n\tkfree(volume_info->username);\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->domainname);\n\tkfree(volume_info->iocharset);\n\tkfree(volume_info->prepath);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void\ncleanup_volume_info_contents(struct smb_vol *volume_info)\n{\n\tkfree(volume_info->username);\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->domainname);\n\tkfree(volume_info->iocharset);\n\tkfree(volume_info->prepath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mdata"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mdata"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_dfs_info_array",
          "args": [
            "referrals",
            "num_referrals"
          ],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "free_dfs_info_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1387-1398",
          "snippet": "static inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_compose_mount_options",
          "args": [
            "cifs_sb->mountdata",
            "full_path + 1",
            "referrals",
            "&fake_devname"
          ],
          "line": 3354
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_compose_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
          "lines": "136-235",
          "snippet": "char *cifs_compose_mount_options(const char *sb_mountdata,\n\t\t\t\t   const char *fullpath,\n\t\t\t\t   const struct dfs_info3_param *ref,\n\t\t\t\t   char **devname)\n{\n\tint rc;\n\tchar *mountdata = NULL;\n\tconst char *prepath = NULL;\n\tint md_len;\n\tchar *tkn_e;\n\tchar *srvIP = NULL;\n\tchar sep = ',';\n\tint off, noff;\n\n\tif (sb_mountdata == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strlen(fullpath) - ref->path_consumed)\n\t\tprepath = fullpath + ref->path_consumed;\n\n\t*devname = cifs_build_devname(ref->node_name, prepath);\n\tif (IS_ERR(*devname)) {\n\t\trc = PTR_ERR(*devname);\n\t\t*devname = NULL;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\trc = dns_resolve_server_name_to_ip(*devname, &srvIP);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"%s: Failed to resolve server part of %s to IP: %d\\n\",\n\t\t\t __func__, *devname, rc);\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/*\n\t * In most cases, we'll be building a shorter string than the original,\n\t * but we do have to assume that the address in the ip= option may be\n\t * much longer than the original. Add the max length of an address\n\t * string to the length of the original string to allow for worst case.\n\t */\n\tmd_len = strlen(sb_mountdata) + INET6_ADDRSTRLEN;\n\tmountdata = kzalloc(md_len + 1, GFP_KERNEL);\n\tif (mountdata == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/* copy all options except of unc,ip,prefixpath */\n\toff = 0;\n\tif (strncmp(sb_mountdata, \"sep=\", 4) == 0) {\n\t\t\tsep = sb_mountdata[4];\n\t\t\tstrncpy(mountdata, sb_mountdata, 5);\n\t\t\toff += 5;\n\t}\n\n\tdo {\n\t\ttkn_e = strchr(sb_mountdata + off, sep);\n\t\tif (tkn_e == NULL)\n\t\t\tnoff = strlen(sb_mountdata + off);\n\t\telse\n\t\t\tnoff = tkn_e - (sb_mountdata + off) + 1;\n\n\t\tif (strncasecmp(sb_mountdata + off, \"unc=\", 4) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"ip=\", 3) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"prefixpath=\", 11) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tstrncat(mountdata, sb_mountdata + off, noff);\n\t\toff += noff;\n\t} while (tkn_e);\n\tstrcat(mountdata, sb_mountdata + off);\n\tmountdata[md_len] = '\\0';\n\n\t/* copy new IP and ref share name */\n\tif (mountdata[strlen(mountdata) - 1] != sep)\n\t\tstrncat(mountdata, &sep, 1);\n\tstrcat(mountdata, \"ip=\");\n\tstrcat(mountdata, srvIP);\n\n\t/*cifs_dbg(FYI, \"%s: parent mountdata: %s\\n\", __func__, sb_mountdata);*/\n\t/*cifs_dbg(FYI, \"%s: submount mountdata: %s\\n\", __func__, mountdata );*/\n\ncompose_mount_options_out:\n\tkfree(srvIP);\n\treturn mountdata;\n\ncompose_mount_options_err:\n\tkfree(mountdata);\n\tmountdata = ERR_PTR(rc);\n\tkfree(*devname);\n\t*devname = NULL;\n\tgoto compose_mount_options_out;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"dns_resolve.h\"",
            "#include \"cifsfs.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nchar *cifs_compose_mount_options(const char *sb_mountdata,\n\t\t\t\t   const char *fullpath,\n\t\t\t\t   const struct dfs_info3_param *ref,\n\t\t\t\t   char **devname)\n{\n\tint rc;\n\tchar *mountdata = NULL;\n\tconst char *prepath = NULL;\n\tint md_len;\n\tchar *tkn_e;\n\tchar *srvIP = NULL;\n\tchar sep = ',';\n\tint off, noff;\n\n\tif (sb_mountdata == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strlen(fullpath) - ref->path_consumed)\n\t\tprepath = fullpath + ref->path_consumed;\n\n\t*devname = cifs_build_devname(ref->node_name, prepath);\n\tif (IS_ERR(*devname)) {\n\t\trc = PTR_ERR(*devname);\n\t\t*devname = NULL;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\trc = dns_resolve_server_name_to_ip(*devname, &srvIP);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"%s: Failed to resolve server part of %s to IP: %d\\n\",\n\t\t\t __func__, *devname, rc);\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/*\n\t * In most cases, we'll be building a shorter string than the original,\n\t * but we do have to assume that the address in the ip= option may be\n\t * much longer than the original. Add the max length of an address\n\t * string to the length of the original string to allow for worst case.\n\t */\n\tmd_len = strlen(sb_mountdata) + INET6_ADDRSTRLEN;\n\tmountdata = kzalloc(md_len + 1, GFP_KERNEL);\n\tif (mountdata == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/* copy all options except of unc,ip,prefixpath */\n\toff = 0;\n\tif (strncmp(sb_mountdata, \"sep=\", 4) == 0) {\n\t\t\tsep = sb_mountdata[4];\n\t\t\tstrncpy(mountdata, sb_mountdata, 5);\n\t\t\toff += 5;\n\t}\n\n\tdo {\n\t\ttkn_e = strchr(sb_mountdata + off, sep);\n\t\tif (tkn_e == NULL)\n\t\t\tnoff = strlen(sb_mountdata + off);\n\t\telse\n\t\t\tnoff = tkn_e - (sb_mountdata + off) + 1;\n\n\t\tif (strncasecmp(sb_mountdata + off, \"unc=\", 4) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"ip=\", 3) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"prefixpath=\", 11) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tstrncat(mountdata, sb_mountdata + off, noff);\n\t\toff += noff;\n\t} while (tkn_e);\n\tstrcat(mountdata, sb_mountdata + off);\n\tmountdata[md_len] = '\\0';\n\n\t/* copy new IP and ref share name */\n\tif (mountdata[strlen(mountdata) - 1] != sep)\n\t\tstrncat(mountdata, &sep, 1);\n\tstrcat(mountdata, \"ip=\");\n\tstrcat(mountdata, srvIP);\n\n\t/*cifs_dbg(FYI, \"%s: parent mountdata: %s\\n\", __func__, sb_mountdata);*/\n\t/*cifs_dbg(FYI, \"%s: submount mountdata: %s\\n\", __func__, mountdata );*/\n\ncompose_mount_options_out:\n\tkfree(srvIP);\n\treturn mountdata;\n\ncompose_mount_options_err:\n\tkfree(mountdata);\n\tmountdata = ERR_PTR(rc);\n\tkfree(*devname);\n\t*devname = NULL;\n\tgoto compose_mount_options_out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dfs_path",
          "args": [
            "xid",
            "ses",
            "ref_path",
            "cifs_sb->local_nls",
            "&num_referrals",
            "&referrals",
            "cifs_remap(cifs_sb)"
          ],
          "line": 3348
        },
        "resolved": true,
        "details": {
          "function_name": "get_dfs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2768-2807",
          "snippet": "int\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *num_referrals,\n\t     struct dfs_info3_param **referrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\tif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\n\t\treturn -ENOSYS;\n\n\t*num_referrals = 0;\n\t*referrals = NULL;\n\n\tif (ses->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2, GFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, ses->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(ses->serverName), \"\\\\IPC$\");\n\t\trc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\n\t\t\t\t\t\t    nls_codepage);\n\t\tcifs_dbg(FYI, \"Tcon rc = %d ipc_tid = %d\\n\", rc, ses->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\n\t\t\t\t\t\t     referrals, num_referrals,\n\t\t\t\t\t\t     nls_codepage, remap);\n\t/*\n\t * BB - map targetUNCs to dfs_info3 structures, here or in\n\t * ses->server->ops->get_dfs_refer.\n\t */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *num_referrals,\n\t     struct dfs_info3_param **referrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\tif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\n\t\treturn -ENOSYS;\n\n\t*num_referrals = 0;\n\t*referrals = NULL;\n\n\tif (ses->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2, GFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, ses->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(ses->serverName), \"\\\\IPC$\");\n\t\trc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\n\t\t\t\t\t\t    nls_codepage);\n\t\tcifs_dbg(FYI, \"Tcon rc = %d ipc_tid = %d\\n\", rc, ses->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\n\t\t\t\t\t\t     referrals, num_referrals,\n\t\t\t\t\t\t     nls_codepage, remap);\n\t/*\n\t * BB - map targetUNCs to dfs_info3 structures, here or in\n\t * ses->server->ops->get_dfs_refer.\n\t */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "full_path"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "full_path"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_unc_path_to_root",
          "args": [
            "volume_info",
            "cifs_sb"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "build_unc_path_to_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3294-3319",
          "snippet": "static char *\nbuild_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic char *\nbuild_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int\nexpand_dfs_referral(const unsigned int xid, struct cifs_ses *ses,\n\t\t    struct smb_vol *volume_info, struct cifs_sb_info *cifs_sb,\n\t\t    int check_prefix)\n{\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\tchar *full_path = NULL, *ref_path = NULL, *mdata = NULL;\n\n\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\t/* For DFS paths, skip the first '\\' of the UNC */\n\tref_path = check_prefix ? full_path + 1 : volume_info->UNC + 1;\n\n\trc = get_dfs_path(xid, ses, ref_path, cifs_sb->local_nls,\n\t\t\t  &num_referrals, &referrals, cifs_remap(cifs_sb));\n\n\tif (!rc && num_referrals > 0) {\n\t\tchar *fake_devname = NULL;\n\n\t\tmdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\t\t\t\t   full_path + 1, referrals,\n\t\t\t\t\t\t   &fake_devname);\n\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\n\t\tif (IS_ERR(mdata)) {\n\t\t\trc = PTR_ERR(mdata);\n\t\t\tmdata = NULL;\n\t\t} else {\n\t\t\tcleanup_volume_info_contents(volume_info);\n\t\t\trc = cifs_setup_volume_info(volume_info, mdata,\n\t\t\t\t\t\t\tfake_devname);\n\t\t}\n\t\tkfree(fake_devname);\n\t\tkfree(cifs_sb->mountdata);\n\t\tcifs_sb->mountdata = mdata;\n\t}\n\tkfree(full_path);\n\treturn rc;\n}"
  },
  {
    "function_name": "build_unc_path_to_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3294-3319",
    "snippet": "static char *\nbuild_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: full_path=%s\\n\"",
            "__func__",
            "full_path"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_delimiter",
          "args": [
            "full_path",
            "CIFS_DIR_SEP(cifs_sb)"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "convert_delimiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1185-1198",
          "snippet": "static inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_DIR_SEP",
          "args": [
            "cifs_sb"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_DIR_SEP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1177-1183",
          "snippet": "static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pos + 1",
            "vol->prepath",
            "pplen"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "full_path",
            "vol->UNC",
            "unc_len"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "unc_len + pplen + 1",
            "GFP_KERNEL"
          ],
          "line": 3302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "vol->UNC",
            "MAX_TREE_SIZE + 1"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vol->prepath"
          ],
          "line": 3299
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic char *\nbuild_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}"
  },
  {
    "function_name": "cifs_cleanup_volume_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3279-3286",
    "snippet": "void\ncifs_cleanup_volume_info(struct smb_vol *volume_info)\n{\n\tif (!volume_info)\n\t\treturn;\n\tcleanup_volume_info_contents(volume_info);\n\tkfree(volume_info);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "volume_info"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_volume_info_contents",
          "args": [
            "volume_info"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_volume_info_contents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3268-3277",
          "snippet": "static void\ncleanup_volume_info_contents(struct smb_vol *volume_info)\n{\n\tkfree(volume_info->username);\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->domainname);\n\tkfree(volume_info->iocharset);\n\tkfree(volume_info->prepath);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void\ncleanup_volume_info_contents(struct smb_vol *volume_info)\n{\n\tkfree(volume_info->username);\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->domainname);\n\tkfree(volume_info->iocharset);\n\tkfree(volume_info->prepath);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_cleanup_volume_info(struct smb_vol *volume_info)\n{\n\tif (!volume_info)\n\t\treturn;\n\tcleanup_volume_info_contents(volume_info);\n\tkfree(volume_info);\n}"
  },
  {
    "function_name": "cleanup_volume_info_contents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3268-3277",
    "snippet": "static void\ncleanup_volume_info_contents(struct smb_vol *volume_info)\n{\n\tkfree(volume_info->username);\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->domainname);\n\tkfree(volume_info->iocharset);\n\tkfree(volume_info->prepath);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "volume_info->prepath"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "volume_info->iocharset"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "volume_info->domainname"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "volume_info->UNC"
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "volume_info->password"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "volume_info->username"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void\ncleanup_volume_info_contents(struct smb_vol *volume_info)\n{\n\tkfree(volume_info->username);\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->domainname);\n\tkfree(volume_info->iocharset);\n\tkfree(volume_info->prepath);\n}"
  },
  {
    "function_name": "cifs_setup_cifs_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3172-3266",
    "snippet": "void cifs_setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\tstruct cifs_sb_info *cifs_sb)\n{\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tspin_lock_init(&cifs_sb->tlink_tree_lock);\n\tcifs_sb->tlink_tree = RB_ROOT;\n\n\t/*\n\t * Temporarily set r/wsize for matching superblock. If we end up using\n\t * new sb then client will later negotiate it downward if needed.\n\t */\n\tcifs_sb->rsize = pvolume_info->rsize;\n\tcifs_sb->wsize = pvolume_info->wsize;\n\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcifs_dbg(FYI, \"file mode: 0x%hx  dir mode: 0x%hx\\n\",\n\t\t cifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tcifs_sb->actimeo = pvolume_info->actimeo;\n\tcifs_sb->local_nls = pvolume_info->local_nls;\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SFM_CHR;\n\tif (pvolume_info->sfu_remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->rwpidforward)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RWPIDFORWARD;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->backupuid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPUID;\n\t\tcifs_sb->mnt_backupuid = pvolume_info->backupuid;\n\t}\n\tif (pvolume_info->backupgid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPGID;\n\t\tcifs_sb->mnt_backupgid = pvolume_info->backupgid;\n\t}\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->fsc)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_FSCACHE;\n\tif (pvolume_info->multiuser)\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_MULTIUSER |\n\t\t\t\t\t    CIFS_MOUNT_NO_PERM);\n\tif (pvolume_info->strict_io)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_STRICT_IO;\n\tif (pvolume_info->direct_io) {\n\t\tcifs_dbg(FYI, \"mounting share using direct i/o\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\tif (pvolume_info->mfsymlinks) {\n\t\tif (pvolume_info->sfu_emul) {\n\t\t\t/*\n\t\t\t * Our SFU (\"Services for Unix\" emulation does not allow\n\t\t\t * creating symlinks but does allow reading existing SFU\n\t\t\t * symlinks (it does allow both creating and reading SFU\n\t\t\t * style mknod and FIFOs though). When \"mfsymlinks\" and\n\t\t\t * \"sfu\" are both enabled at the same time, it allows\n\t\t\t * reading both types of symlinks, but will only create\n\t\t\t * them with mfsymlinks format. This allows better\n\t\t\t * Apple compatibility (probably better for Samba too)\n\t\t\t * while still recognizing old Windows style symlinks.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"mount options mfsymlinks and sfu both enabled\\n\");\n\t\t}\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MF_SYMLINKS;\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcifs_dbg(VFS, \"mount option dynperm ignored if cifsacl mount option supported\\n\");\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"mount option dynperm ignored if cifsacl mount option supported\\n\""
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"mount options mfsymlinks and sfu both enabled\\n\""
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"mounting share using direct i/o\\n\""
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"file mode: 0x%hx  dir mode: 0x%hx\\n\"",
            "cifs_sb->mnt_file_mode",
            "cifs_sb->mnt_dir_mode"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cifs_sb->tlink_tree_lock"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&cifs_sb->prune_tlinks",
            "cifs_prune_tlinks"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid cifs_setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\tstruct cifs_sb_info *cifs_sb)\n{\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tspin_lock_init(&cifs_sb->tlink_tree_lock);\n\tcifs_sb->tlink_tree = RB_ROOT;\n\n\t/*\n\t * Temporarily set r/wsize for matching superblock. If we end up using\n\t * new sb then client will later negotiate it downward if needed.\n\t */\n\tcifs_sb->rsize = pvolume_info->rsize;\n\tcifs_sb->wsize = pvolume_info->wsize;\n\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcifs_dbg(FYI, \"file mode: 0x%hx  dir mode: 0x%hx\\n\",\n\t\t cifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tcifs_sb->actimeo = pvolume_info->actimeo;\n\tcifs_sb->local_nls = pvolume_info->local_nls;\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SFM_CHR;\n\tif (pvolume_info->sfu_remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->rwpidforward)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RWPIDFORWARD;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->backupuid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPUID;\n\t\tcifs_sb->mnt_backupuid = pvolume_info->backupuid;\n\t}\n\tif (pvolume_info->backupgid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPGID;\n\t\tcifs_sb->mnt_backupgid = pvolume_info->backupgid;\n\t}\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->fsc)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_FSCACHE;\n\tif (pvolume_info->multiuser)\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_MULTIUSER |\n\t\t\t\t\t    CIFS_MOUNT_NO_PERM);\n\tif (pvolume_info->strict_io)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_STRICT_IO;\n\tif (pvolume_info->direct_io) {\n\t\tcifs_dbg(FYI, \"mounting share using direct i/o\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\tif (pvolume_info->mfsymlinks) {\n\t\tif (pvolume_info->sfu_emul) {\n\t\t\t/*\n\t\t\t * Our SFU (\"Services for Unix\" emulation does not allow\n\t\t\t * creating symlinks but does allow reading existing SFU\n\t\t\t * symlinks (it does allow both creating and reading SFU\n\t\t\t * style mknod and FIFOs though). When \"mfsymlinks\" and\n\t\t\t * \"sfu\" are both enabled at the same time, it allows\n\t\t\t * reading both types of symlinks, but will only create\n\t\t\t * them with mfsymlinks format. This allows better\n\t\t\t * Apple compatibility (probably better for Samba too)\n\t\t\t * while still recognizing old Windows style symlinks.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"mount options mfsymlinks and sfu both enabled\\n\");\n\t\t}\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MF_SYMLINKS;\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcifs_dbg(VFS, \"mount option dynperm ignored if cifsacl mount option supported\\n\");\n}"
  },
  {
    "function_name": "reset_cifs_unix_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3072-3170",
    "snippet": "void reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\t} else\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\""
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"resetting capabilities failed\\n\""
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBSetFSUnixInfo",
          "args": [
            "xid",
            "tcon",
            "cap"
          ],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBSetFSUnixInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5352-5422",
          "snippet": "int\nCIFSSMBSetFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon, __u64 cap)\n{\n/* level 0x200  SMB_SET_CIFS_UNIX_INFO */\n\tTRANSACTION2_SETFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_SETFSI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In SETFSUnixInfo\\n\");\nSETFSUnixRetry:\n\t/* BB switch to small buf init to save memory */\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t\t(void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 4;\t/* 2 bytes zero followed by info level. */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_setfsi_req, FileNum)\n\t\t\t\t- 4;\n\toffset = param_offset + params;\n\n\tpSMB->MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FS_INFORMATION);\n\tbyte_count = 1 /* pad */ + params + 12;\n\n\tpSMB->DataCount = cpu_to_le16(12);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\n\t/* Params. */\n\tpSMB->FileNum = 0;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_CIFS_UNIX_INFO);\n\n\t/* Data. */\n\tpSMB->ClientUnixMajor = cpu_to_le16(CIFS_UNIX_MAJOR_VERSION);\n\tpSMB->ClientUnixMinor = cpu_to_le16(CIFS_UNIX_MINOR_VERSION);\n\tpSMB->ClientUnixCap = cpu_to_le64(cap);\n\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in SETFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc)\n\t\t\trc = -EIO;\t/* bad smb */\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SETFSUnixRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon, __u64 cap)\n{\n/* level 0x200  SMB_SET_CIFS_UNIX_INFO */\n\tTRANSACTION2_SETFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_SETFSI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In SETFSUnixInfo\\n\");\nSETFSUnixRetry:\n\t/* BB switch to small buf init to save memory */\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t\t(void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 4;\t/* 2 bytes zero followed by info level. */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_setfsi_req, FileNum)\n\t\t\t\t- 4;\n\toffset = param_offset + params;\n\n\tpSMB->MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FS_INFORMATION);\n\tbyte_count = 1 /* pad */ + params + 12;\n\n\tpSMB->DataCount = cpu_to_le16(12);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\n\t/* Params. */\n\tpSMB->FileNum = 0;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_CIFS_UNIX_INFO);\n\n\t/* Data. */\n\tpSMB->ClientUnixMajor = cpu_to_le16(CIFS_UNIX_MAJOR_VERSION);\n\tpSMB->ClientUnixMinor = cpu_to_le16(CIFS_UNIX_MINOR_VERSION);\n\tpSMB->ClientUnixCap = cpu_to_le64(cap);\n\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in SETFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc)\n\t\t\trc = -EIO;\t/* bad smb */\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SETFSUnixRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"mandatory transport encryption cap\\n\""
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"transport encryption cap\\n\""
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"very large write cap\\n\""
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"very large read cap\\n\""
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"POSIX ACL cap\\n\""
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"XATTR cap\\n\""
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"POSIX path cap\\n\""
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"EXTATTR cap\\n\""
          ],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"FCNTL cap\\n\""
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Negotiate caps 0x%x\\n\"",
            "(int)cap"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"negotiate posix pathnames\\n\""
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"negotiated posix acl support\\n\""
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"per-share encryption not supported yet\\n\""
          ],
          "line": 3120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"server disabled POSIX path support\\n\""
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"possible reconnect error\\n\""
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"POSIXPATH support change\\n\""
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"unix caps which server supports %lld\\n\"",
            "cap"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 3100
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBQFSUnixInfo",
          "args": [
            "xid",
            "tcon"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBQFSUnixInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5282-5350",
          "snippet": "int\nCIFSSMBQFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x200  SMB_QUERY_CIFS_UNIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_UNIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSUnixInfo\\n\");\nQFSUnixRetry:\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t   (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_CIFS_UNIX_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in QFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_UNIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsUnixInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_UNIX_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSUnixRetry;\n\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x200  SMB_QUERY_CIFS_UNIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_UNIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSUnixInfo\\n\");\nQFSUnixRetry:\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t   (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_CIFS_UNIX_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in QFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_UNIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsUnixInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_UNIX_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSUnixRetry;\n\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unix extensions disabled so not set on reconnect\\n\""
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Linux protocol extensions disabled\\n\""
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nvoid reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\t} else\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ip_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "3043-3070",
    "snippet": "static int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t/* try with 445 port at first */\n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t/* if it failed, try with 139 port */\n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define RFC1001_PORT 139",
      "#define CIFS_PORT 445"
    ],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_ip_connect",
          "args": [
            "server"
          ],
          "line": 3069
        },
        "resolved": true,
        "details": {
          "function_name": "generic_ip_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2956-3041",
          "snippet": "static int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t} else {\n\t\tsport = ((struct sockaddr_in *) saddr)->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tint val = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcifs_dbg(FYI, \"set TCP_NODELAY socket option error %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = socket->ops->connect(socket, saddr, slen, 0);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RFC1001_PORT 139"
          ],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define RFC1001_PORT 139\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t} else {\n\t\tsport = ((struct sockaddr_in *) saddr)->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tint val = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcifs_dbg(FYI, \"set TCP_NODELAY socket option error %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = socket->ops->connect(socket, saddr, slen, 0);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "RFC1001_PORT"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "CIFS_PORT"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define RFC1001_PORT 139\n#define CIFS_PORT 445\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t/* try with 445 port at first */\n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t/* if it failed, try with 139 port */\n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}"
  },
  {
    "function_name": "generic_ip_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2956-3041",
    "snippet": "static int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t} else {\n\t\tsport = ((struct sockaddr_in *) saddr)->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tint val = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcifs_dbg(FYI, \"set TCP_NODELAY socket option error %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = socket->ops->connect(socket, saddr, slen, 0);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define RFC1001_PORT 139"
    ],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_rfc1001_connect",
          "args": [
            "server"
          ],
          "line": 3038
        },
        "resolved": true,
        "details": {
          "function_name": "ip_rfc1001_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2882-2954",
          "snippet": "static int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tstruct smb_hdr *smb_buf;\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name &&\n\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name &&\n\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\tsmb_buf->smb_buf_length = cpu_to_be32(0x81000044);\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);",
            "static void cifs_prune_tlinks(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\nstatic int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tstruct smb_hdr *smb_buf;\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name &&\n\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name &&\n\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\tsmb_buf->smb_buf_length = cpu_to_be32(0x81000044);\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "RFC1001_PORT"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "socket"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Error %d connecting to server\\n\"",
            "rc"
          ],
          "line": 3031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket->ops->connect",
          "args": [
            "socket",
            "saddr",
            "slen",
            "0"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\"",
            "socket->sk->sk_sndbuf",
            "socket->sk->sk_rcvbuf",
            "socket->sk->sk_rcvtimeo"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"set TCP_NODELAY socket option error %d\\n\"",
            "rc"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "socket",
            "SOL_TCP",
            "TCP_NODELAY",
            "(char *)&val",
            "sizeof(val)"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind_socket",
          "args": [
            "server"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "bind_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2856-2880",
          "snippet": "static int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t/* Bind to the specified local IP address */\n\t\tstruct socket *socket = server->ssocket;\n\t\trc = socket->ops->bind(socket,\n\t\t\t\t       (struct sockaddr *) &server->srcaddr,\n\t\t\t\t       sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t\t &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t\t &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t/* Bind to the specified local IP address */\n\t\tstruct socket *socket = server->ssocket;\n\t\trc = socket->ops->bind(socket,\n\t\t\t\t       (struct sockaddr *) &server->srcaddr,\n\t\t\t\t       sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t\t &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t\t &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_reclassify_socket4",
          "args": [
            "socket"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reclassify_socket4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2831-2834",
          "snippet": "static inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_reclassify_socket6",
          "args": [
            "socket"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reclassify_socket6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2836-2839",
          "snippet": "static inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Socket created\\n\""
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Error %d creating socket\\n\"",
            "rc"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sock_create",
          "args": [
            "cifs_net_ns(server)",
            "sfamily",
            "SOCK_STREAM",
            "IPPROTO_TCP",
            "&socket",
            "1"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_net_ns",
          "args": [
            "server"
          ],
          "line": 2978
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_net_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "757-760",
          "snippet": "static inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)\n{\n\treturn &init_net;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)\n{\n\treturn &init_net;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define RFC1001_PORT 139\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t} else {\n\t\tsport = ((struct sockaddr_in *) saddr)->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tint val = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcifs_dbg(FYI, \"set TCP_NODELAY socket option error %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = socket->ops->connect(socket, saddr, slen, 0);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ip_rfc1001_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2882-2954",
    "snippet": "static int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tstruct smb_hdr *smb_buf;\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name &&\n\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name &&\n\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\tsmb_buf->smb_buf_length = cpu_to_be32(0x81000044);\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);",
      "static void cifs_prune_tlinks(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep_range",
          "args": [
            "1000",
            "2000"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses_init_buf"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_send",
          "args": [
            "server",
            "smb_buf",
            "0x44"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "smb_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "378-388",
          "snippet": "int\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = smb_buffer;\n\tiov.iov_len = smb_buf_length + 4;\n\n\treturn smb_sendv(server, &iov, 1);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = smb_buffer;\n\tiov.iov_len = smb_buf_length + 4;\n\n\treturn smb_sendv(server, &iov, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0x81000044"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfc1002mangle",
          "args": [
            "ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name",
            "\"LINUX_CIFS_CLNT\"",
            "RFC1001_NAME_LEN_WITH_NULL"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "rfc1002mangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2843-2854",
          "snippet": "static void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct rfc1002_session_packet)",
            "GFP_KERNEL"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\nstatic int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tstruct smb_hdr *smb_buf;\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name &&\n\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name &&\n\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\tsmb_buf->smb_buf_length = cpu_to_be32(0x81000044);\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "bind_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2856-2880",
    "snippet": "static int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t/* Bind to the specified local IP address */\n\t\tstruct socket *socket = server->ssocket;\n\t\trc = socket->ops->bind(socket,\n\t\t\t\t       (struct sockaddr *) &server->srcaddr,\n\t\t\t\t       sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t\t &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t\t &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Failed to bind to: %pI4, error: %d\\n\"",
            "&saddr4->sin_addr.s_addr",
            "rc"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Failed to bind to: %pI6c, error: %d\\n\"",
            "&saddr6->sin6_addr",
            "rc"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket->ops->bind",
          "args": [
            "socket",
            "(struct sockaddr *) &server->srcaddr",
            "sizeof(server->srcaddr)"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t/* Bind to the specified local IP address */\n\t\tstruct socket *socket = server->ssocket;\n\t\trc = socket->ops->bind(socket,\n\t\t\t\t       (struct sockaddr *) &server->srcaddr,\n\t\t\t\t       sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t\t &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t\t &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "rfc1002mangle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2843-2854",
    "snippet": "static void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}"
  },
  {
    "function_name": "cifs_reclassify_socket6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2836-2839",
    "snippet": "static inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}"
  },
  {
    "function_name": "cifs_reclassify_socket4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2831-2834",
    "snippet": "static inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}"
  },
  {
    "function_name": "cifs_reclassify_socket6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2822-2829",
    "snippet": "static inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_lock_init_class_and_name",
          "args": [
            "sk",
            "\"slock-AF_INET6-CIFS\"",
            "&cifs_slock_key[1]",
            "\"sk_lock-AF_INET6-CIFS\"",
            "&cifs_key[1]"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sock_owned_by_user(sk)"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_owned_by_user",
          "args": [
            "sk"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}"
  },
  {
    "function_name": "cifs_reclassify_socket4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2813-2820",
    "snippet": "static inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_lock_init_class_and_name",
          "args": [
            "sk",
            "\"slock-AF_INET-CIFS\"",
            "&cifs_slock_key[0]",
            "\"sk_lock-AF_INET-CIFS\"",
            "&cifs_key[0]"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sock_owned_by_user(sk)"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_owned_by_user",
          "args": [
            "sk"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}"
  },
  {
    "function_name": "get_dfs_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2768-2807",
    "snippet": "int\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *num_referrals,\n\t     struct dfs_info3_param **referrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\tif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\n\t\treturn -ENOSYS;\n\n\t*num_referrals = 0;\n\t*referrals = NULL;\n\n\tif (ses->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2, GFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, ses->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(ses->serverName), \"\\\\IPC$\");\n\t\trc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\n\t\t\t\t\t\t    nls_codepage);\n\t\tcifs_dbg(FYI, \"Tcon rc = %d ipc_tid = %d\\n\", rc, ses->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\n\t\t\t\t\t\t     referrals, num_referrals,\n\t\t\t\t\t\t     nls_codepage, remap);\n\t/*\n\t * BB - map targetUNCs to dfs_info3 structures, here or in\n\t * ses->server->ops->get_dfs_refer.\n\t */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ses->server->ops->get_dfs_refer",
          "args": [
            "xid",
            "ses",
            "old_path",
            "referrals",
            "num_referrals",
            "nls_codepage",
            "remap"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "temp_unc"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Tcon rc = %d ipc_tid = %d\\n\"",
            "rc",
            "ses->ipc_tid"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ses->server->ops->tree_connect",
          "args": [
            "xid",
            "ses",
            "temp_unc",
            "NULL",
            "nls_codepage"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "temp_unc + 2 + strlen(ses->serverName)",
            "\"\\\\IPC$\""
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ses->serverName"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "temp_unc + 2",
            "ses->serverName"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2",
            "GFP_KERNEL"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "ses->serverName",
            "SERVER_NAME_LEN_WITH_NULL * 2"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *num_referrals,\n\t     struct dfs_info3_param **referrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\tif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\n\t\treturn -ENOSYS;\n\n\t*num_referrals = 0;\n\t*referrals = NULL;\n\n\tif (ses->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2, GFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, ses->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(ses->serverName), \"\\\\IPC$\");\n\t\trc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\n\t\t\t\t\t\t    nls_codepage);\n\t\tcifs_dbg(FYI, \"Tcon rc = %d ipc_tid = %d\\n\", rc, ses->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\n\t\t\t\t\t\t     referrals, num_referrals,\n\t\t\t\t\t\t     nls_codepage, remap);\n\t/*\n\t * BB - map targetUNCs to dfs_info3 structures, here or in\n\t * ses->server->ops->get_dfs_refer.\n\t */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_match_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2729-2766",
    "snippet": "int\ncifs_match_super(struct super_block *sb, void *data)\n{\n\tstruct cifs_mnt_data *mnt_data = (struct cifs_mnt_data *)data;\n\tstruct smb_vol *volume_info;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *tcp_srv;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tint rc = 0;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tcifs_sb = CIFS_SB(sb);\n\ttlink = cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\tif (IS_ERR(tlink)) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn rc;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tses = tcon->ses;\n\ttcp_srv = ses->server;\n\n\tvolume_info = mnt_data->vol;\n\n\tif (!match_server(tcp_srv, volume_info) ||\n\t    !match_session(ses, volume_info) ||\n\t    !match_tcon(tcon, volume_info->UNC)) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = compare_mount_options(sb, mnt_data);\nout:\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "compare_mount_options",
          "args": [
            "sb",
            "mnt_data"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "compare_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2690-2727",
          "snippet": "static int\ncompare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\n\tif ((sb->s_flags & CIFS_MS_MASK) != (mnt_data->flags & CIFS_MS_MASK))\n\t\treturn 0;\n\n\tif ((old->mnt_cifs_flags & CIFS_MOUNT_MASK) !=\n\t    (new->mnt_cifs_flags & CIFS_MOUNT_MASK))\n\t\treturn 0;\n\n\t/*\n\t * We want to share sb only if we don't specify an r/wsize or\n\t * specified r/wsize is greater than or equal to existing one.\n\t */\n\tif (new->wsize && new->wsize < old->wsize)\n\t\treturn 0;\n\n\tif (new->rsize && new->rsize < old->rsize)\n\t\treturn 0;\n\n\tif (!uid_eq(old->mnt_uid, new->mnt_uid) || !gid_eq(old->mnt_gid, new->mnt_gid))\n\t\treturn 0;\n\n\tif (old->mnt_file_mode != new->mnt_file_mode ||\n\t    old->mnt_dir_mode != new->mnt_dir_mode)\n\t\treturn 0;\n\n\tif (strcmp(old->local_nls->charset, new->local_nls->charset))\n\t\treturn 0;\n\n\tif (old->actimeo != new->actimeo)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int\ncompare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\n\tif ((sb->s_flags & CIFS_MS_MASK) != (mnt_data->flags & CIFS_MS_MASK))\n\t\treturn 0;\n\n\tif ((old->mnt_cifs_flags & CIFS_MOUNT_MASK) !=\n\t    (new->mnt_cifs_flags & CIFS_MOUNT_MASK))\n\t\treturn 0;\n\n\t/*\n\t * We want to share sb only if we don't specify an r/wsize or\n\t * specified r/wsize is greater than or equal to existing one.\n\t */\n\tif (new->wsize && new->wsize < old->wsize)\n\t\treturn 0;\n\n\tif (new->rsize && new->rsize < old->rsize)\n\t\treturn 0;\n\n\tif (!uid_eq(old->mnt_uid, new->mnt_uid) || !gid_eq(old->mnt_gid, new->mnt_gid))\n\t\treturn 0;\n\n\tif (old->mnt_file_mode != new->mnt_file_mode ||\n\t    old->mnt_dir_mode != new->mnt_dir_mode)\n\t\treturn 0;\n\n\tif (strcmp(old->local_nls->charset, new->local_nls->charset))\n\t\treturn 0;\n\n\tif (old->actimeo != new->actimeo)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_tcon",
          "args": [
            "tcon",
            "volume_info->UNC"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "match_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2536-2543",
          "snippet": "static int match_tcon(struct cifs_tcon *tcon, const char *unc)\n{\n\tif (tcon->tidStatus == CifsExiting)\n\t\treturn 0;\n\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int match_tcon(struct cifs_tcon *tcon, const char *unc)\n{\n\tif (tcon->tidStatus == CifsExiting)\n\t\treturn 0;\n\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_session",
          "args": [
            "ses",
            "volume_info"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "match_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2213-2245",
          "snippet": "static int match_session(struct cifs_ses *ses, struct smb_vol *vol)\n{\n\tif (vol->sectype != Unspecified &&\n\t    vol->sectype != ses->sectype)\n\t\treturn 0;\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tif (!uid_eq(vol->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t/* NULL username means anonymous session */\n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!vol->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* anything else takes username/password */\n\t\tif (strncmp(ses->user_name,\n\t\t\t    vol->username ? vol->username : \"\",\n\t\t\t    CIFS_MAX_USERNAME_LEN))\n\t\t\treturn 0;\n\t\tif ((vol->username && strlen(vol->username) != 0) &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    vol->password ? vol->password : \"\",\n\t\t\t    CIFS_MAX_PASSWORD_LEN))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int match_session(struct cifs_ses *ses, struct smb_vol *vol)\n{\n\tif (vol->sectype != Unspecified &&\n\t    vol->sectype != ses->sectype)\n\t\treturn 0;\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tif (!uid_eq(vol->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t/* NULL username means anonymous session */\n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!vol->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* anything else takes username/password */\n\t\tif (strncmp(ses->user_name,\n\t\t\t    vol->username ? vol->username : \"\",\n\t\t\t    CIFS_MAX_USERNAME_LEN))\n\t\t\treturn 0;\n\t\tif ((vol->username && strlen(vol->username) != 0) &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    vol->password ? vol->password : \"\",\n\t\t\t    CIFS_MAX_PASSWORD_LEN))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_server",
          "args": [
            "tcp_srv",
            "volume_info"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "match_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2022-2046",
          "snippet": "static int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&vol->dstaddr;\n\n\tif (vol->nosharesock)\n\t\treturn 0;\n\n\tif ((server->vals != vol->vals) || (server->ops != vol->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, vol))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&vol->dstaddr;\n\n\tif (vol->nosharesock)\n\t\treturn 0;\n\n\tif ((server->vals != vol->vals) || (server->ops != vol->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, vol))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_tlink",
          "args": [
            "cifs_sb_master_tlink(cifs_sb)"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "939-945",
          "snippet": "static inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2684-2688",
          "snippet": "static inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_match_super(struct super_block *sb, void *data)\n{\n\tstruct cifs_mnt_data *mnt_data = (struct cifs_mnt_data *)data;\n\tstruct smb_vol *volume_info;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *tcp_srv;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tint rc = 0;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tcifs_sb = CIFS_SB(sb);\n\ttlink = cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\tif (IS_ERR(tlink)) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn rc;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tses = tcon->ses;\n\ttcp_srv = ses->server;\n\n\tvolume_info = mnt_data->vol;\n\n\tif (!match_server(tcp_srv, volume_info) ||\n\t    !match_session(ses, volume_info) ||\n\t    !match_tcon(tcon, volume_info->UNC)) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = compare_mount_options(sb, mnt_data);\nout:\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}"
  },
  {
    "function_name": "compare_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2690-2727",
    "snippet": "static int\ncompare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\n\tif ((sb->s_flags & CIFS_MS_MASK) != (mnt_data->flags & CIFS_MS_MASK))\n\t\treturn 0;\n\n\tif ((old->mnt_cifs_flags & CIFS_MOUNT_MASK) !=\n\t    (new->mnt_cifs_flags & CIFS_MOUNT_MASK))\n\t\treturn 0;\n\n\t/*\n\t * We want to share sb only if we don't specify an r/wsize or\n\t * specified r/wsize is greater than or equal to existing one.\n\t */\n\tif (new->wsize && new->wsize < old->wsize)\n\t\treturn 0;\n\n\tif (new->rsize && new->rsize < old->rsize)\n\t\treturn 0;\n\n\tif (!uid_eq(old->mnt_uid, new->mnt_uid) || !gid_eq(old->mnt_gid, new->mnt_gid))\n\t\treturn 0;\n\n\tif (old->mnt_file_mode != new->mnt_file_mode ||\n\t    old->mnt_dir_mode != new->mnt_dir_mode)\n\t\treturn 0;\n\n\tif (strcmp(old->local_nls->charset, new->local_nls->charset))\n\t\treturn 0;\n\n\tif (old->actimeo != new->actimeo)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "old->local_nls->charset",
            "new->local_nls->charset"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "old->mnt_gid",
            "new->mnt_gid"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->mnt_uid",
            "new->mnt_uid"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int\ncompare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\n\tif ((sb->s_flags & CIFS_MS_MASK) != (mnt_data->flags & CIFS_MS_MASK))\n\t\treturn 0;\n\n\tif ((old->mnt_cifs_flags & CIFS_MOUNT_MASK) !=\n\t    (new->mnt_cifs_flags & CIFS_MOUNT_MASK))\n\t\treturn 0;\n\n\t/*\n\t * We want to share sb only if we don't specify an r/wsize or\n\t * specified r/wsize is greater than or equal to existing one.\n\t */\n\tif (new->wsize && new->wsize < old->wsize)\n\t\treturn 0;\n\n\tif (new->rsize && new->rsize < old->rsize)\n\t\treturn 0;\n\n\tif (!uid_eq(old->mnt_uid, new->mnt_uid) || !gid_eq(old->mnt_gid, new->mnt_gid))\n\t\treturn 0;\n\n\tif (old->mnt_file_mode != new->mnt_file_mode ||\n\t    old->mnt_dir_mode != new->mnt_dir_mode)\n\t\treturn 0;\n\n\tif (strcmp(old->local_nls->charset, new->local_nls->charset))\n\t\treturn 0;\n\n\tif (old->actimeo != new->actimeo)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cifs_sb_master_tlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2684-2688",
    "snippet": "static inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}"
  },
  {
    "function_name": "cifs_put_tlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2666-2682",
    "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tlink"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_tcon",
          "args": [
            "tlink_tcon(tlink)"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2564-2588",
          "snippet": "static void\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink_tcon(tlink)"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TCON_LINK_IN_TREE",
            "&tlink->tl_flags"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&tlink->tl_count"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
  },
  {
    "function_name": "cifs_get_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2590-2664",
    "snippet": "static struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifs_tcon *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcifs_dbg(VFS, \"transport encryption setting conflicts with existing tid\\n\");\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t/*\n\t * BB Do we need to wrap session_mutex around this TCon call and Unix\n\t * SetFS as we do on SessSetup and reconnect?\n\t */\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, volume_info->UNC, tcon,\n\t\t\t\t\t    volume_info->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcifs_dbg(FYI, \"DFS disabled (%d)\\n\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/*\n\t * We can have only one retry value for a connection to a share so for\n\t * resources mounted more than once to the same server share the last\n\t * value passed in for the retry flag is used.\n\t */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_super_cookie(tcon);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tconInfoFree",
          "args": [
            "tcon"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "tconInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "130-144",
          "snippet": "void\ntconInfoFree(struct cifs_tcon *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to tconInfoFree\\n\");\n\t\treturn;\n\t}\n\tatomic_dec(&tconInfoAllocCount);\n\tkfree(buf_to_free->nativeFileSystem);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ntconInfoFree(struct cifs_tcon *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to tconInfoFree\\n\");\n\t\treturn;\n\t}\n\tatomic_dec(&tconInfoAllocCount);\n\tkfree(buf_to_free->nativeFileSystem);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fscache_get_super_cookie",
          "args": [
            "tcon"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_get_super_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "43-52",
          "snippet": "void cifs_fscache_get_super_cookie(struct cifs_tcon *tcon)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\ttcon->fscache =\n\t\tfscache_acquire_cookie(server->fscache,\n\t\t\t\t&cifs_fscache_super_index_def, tcon, true);\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server->fscache, tcon->fscache);\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_get_super_cookie(struct cifs_tcon *tcon)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\ttcon->fscache =\n\t\tfscache_acquire_cookie(server->fscache,\n\t\t\t\t&cifs_fscache_super_index_def, tcon, true);\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server->fscache, tcon->fscache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tcon->tcon_list",
            "&ses->tcon_list"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tcon->pending_opens"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"DFS disabled (%d)\\n\"",
            "tcon->Flags"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Tcon rc = %d\\n\"",
            "rc"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ses->server->ops->tree_connect",
          "args": [
            "xid",
            "ses",
            "volume_info->UNC",
            "tcon",
            "volume_info->local_nls"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "volume_info->password",
            "GFP_KERNEL"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tconInfoAlloc",
          "args": [],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "tconInfoAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "112-128",
          "snippet": "struct cifs_tcon *\ntconInfoAlloc(void)\n{\n\tstruct cifs_tcon *ret_buf;\n\tret_buf = kzalloc(sizeof(struct cifs_tcon), GFP_KERNEL);\n\tif (ret_buf) {\n\t\tatomic_inc(&tconInfoAllocCount);\n\t\tret_buf->tidStatus = CifsNew;\n\t\t++ret_buf->tc_count;\n\t\tINIT_LIST_HEAD(&ret_buf->openFileList);\n\t\tINIT_LIST_HEAD(&ret_buf->tcon_list);\n#ifdef CONFIG_CIFS_STATS\n\t\tspin_lock_init(&ret_buf->stat_lock);\n#endif\n\t}\n\treturn ret_buf;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nstruct cifs_tcon *\ntconInfoAlloc(void)\n{\n\tstruct cifs_tcon *ret_buf;\n\tret_buf = kzalloc(sizeof(struct cifs_tcon), GFP_KERNEL);\n\tif (ret_buf) {\n\t\tatomic_inc(&tconInfoAllocCount);\n\t\tret_buf->tidStatus = CifsNew;\n\t\t++ret_buf->tc_count;\n\t\tINIT_LIST_HEAD(&ret_buf->openFileList);\n\t\tINIT_LIST_HEAD(&ret_buf->tcon_list);\n#ifdef CONFIG_CIFS_STATS\n\t\tspin_lock_init(&ret_buf->stat_lock);\n#endif\n\t}\n\treturn ret_buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"transport encryption setting conflicts with existing tid\\n\""
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_smb_ses",
          "args": [
            "ses"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_smb_ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2266-2302",
          "snippet": "static void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Found match on UNC path\\n\""
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_find_tcon",
          "args": [
            "ses",
            "volume_info->UNC"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_find_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2545-2562",
          "snippet": "static struct cifs_tcon *\ncifs_find_tcon(struct cifs_ses *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifs_tcon, tcon_list);\n\t\tif (!match_tcon(tcon, unc))\n\t\t\tcontinue;\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic struct cifs_tcon *\ncifs_find_tcon(struct cifs_ses *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifs_tcon, tcon_list);\n\t\tif (!match_tcon(tcon, unc))\n\t\t\tcontinue;\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifs_tcon *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcifs_dbg(VFS, \"transport encryption setting conflicts with existing tid\\n\");\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t/*\n\t * BB Do we need to wrap session_mutex around this TCon call and Unix\n\t * SetFS as we do on SessSetup and reconnect?\n\t */\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, volume_info->UNC, tcon,\n\t\t\t\t\t    volume_info->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcifs_dbg(FYI, \"DFS disabled (%d)\\n\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/*\n\t * We can have only one retry value for a connection to a share so for\n\t * resources mounted more than once to the same server share the last\n\t * value passed in for the retry flag is used.\n\t */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_super_cookie(tcon);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}"
  },
  {
    "function_name": "cifs_put_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2564-2588",
    "snippet": "static void\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_smb_ses",
          "args": [
            "ses"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_smb_ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2266-2302",
          "snippet": "static void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tconInfoFree",
          "args": [
            "tcon"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "tconInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "130-144",
          "snippet": "void\ntconInfoFree(struct cifs_tcon *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to tconInfoFree\\n\");\n\t\treturn;\n\t}\n\tatomic_dec(&tconInfoAllocCount);\n\tkfree(buf_to_free->nativeFileSystem);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ntconInfoFree(struct cifs_tcon *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to tconInfoFree\\n\");\n\t\treturn;\n\t}\n\tatomic_dec(&tconInfoAllocCount);\n\tkfree(buf_to_free->nativeFileSystem);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fscache_release_super_cookie",
          "args": [
            "tcon"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_release_super_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "54-59",
          "snippet": "void cifs_fscache_release_super_cookie(struct cifs_tcon *tcon)\n{\n\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, tcon->fscache);\n\tfscache_relinquish_cookie(tcon->fscache, 0);\n\ttcon->fscache = NULL;\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_release_super_cookie(struct cifs_tcon *tcon)\n{\n\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, tcon->fscache);\n\tfscache_relinquish_cookie(tcon->fscache, 0);\n\ttcon->fscache = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_free_xid",
          "args": [
            "xid"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ses->server->ops->tree_disconnect",
          "args": [
            "xid",
            "tcon"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tcon->tcon_list"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: tc_count=%d\\n\"",
            "__func__",
            "tcon->tc_count"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}"
  },
  {
    "function_name": "cifs_find_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2545-2562",
    "snippet": "static struct cifs_tcon *\ncifs_find_tcon(struct cifs_ses *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifs_tcon, tcon_list);\n\t\tif (!match_tcon(tcon, unc))\n\t\t\tcontinue;\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_tcon",
          "args": [
            "tcon",
            "unc"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "match_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2536-2543",
          "snippet": "static int match_tcon(struct cifs_tcon *tcon, const char *unc)\n{\n\tif (tcon->tidStatus == CifsExiting)\n\t\treturn 0;\n\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int match_tcon(struct cifs_tcon *tcon, const char *unc)\n{\n\tif (tcon->tidStatus == CifsExiting)\n\t\treturn 0;\n\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structcifs_tcon",
            "tcon_list"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "&ses->tcon_list"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic struct cifs_tcon *\ncifs_find_tcon(struct cifs_ses *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifs_tcon, tcon_list);\n\t\tif (!match_tcon(tcon, unc))\n\t\t\tcontinue;\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "match_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2536-2543",
    "snippet": "static int match_tcon(struct cifs_tcon *tcon, const char *unc)\n{\n\tif (tcon->tidStatus == CifsExiting)\n\t\treturn 0;\n\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "tcon->treeName",
            "unc",
            "MAX_TREE_SIZE"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int match_tcon(struct cifs_tcon *tcon, const char *unc)\n{\n\tif (tcon->tidStatus == CifsExiting)\n\t\treturn 0;\n\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "cifs_get_smb_ses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2434-2534",
    "snippet": "static struct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->status);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tfree_xid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\", &addr->sin_addr);\n\n\tif (volume_info->username) {\n\t\tses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\tses->cred_uid = volume_info->cred_uid;\n\tses->linux_uid = volume_info->linux_uid;\n\n\tses->sectype = volume_info->sectype;\n\tses->sign = volume_info->sign;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tfree_xid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sesInfoFree",
          "args": [
            "ses"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "sesInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "90-110",
          "snippet": "void\nsesInfoFree(struct cifs_ses *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to sesInfoFree\\n\");\n\t\treturn;\n\t}\n\n\tatomic_dec(&sesInfoAllocCount);\n\tkfree(buf_to_free->serverOS);\n\tkfree(buf_to_free->serverDomain);\n\tkfree(buf_to_free->serverNOS);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free->user_name);\n\tkfree(buf_to_free->domainName);\n\tkfree(buf_to_free->auth_key.response);\n\tkfree(buf_to_free);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nsesInfoFree(struct cifs_ses *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to sesInfoFree\\n\");\n\t\treturn;\n\t}\n\n\tatomic_dec(&sesInfoAllocCount);\n\tkfree(buf_to_free->serverOS);\n\tkfree(buf_to_free->serverDomain);\n\tkfree(buf_to_free->serverNOS);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free->user_name);\n\tkfree(buf_to_free->domainName);\n\tkfree(buf_to_free->auth_key.response);\n\tkfree(buf_to_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ses->smb_ses_list",
            "&server->smb_ses_list"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_setup_session",
          "args": [
            "xid",
            "ses",
            "volume_info->local_nls"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_setup_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3855-3876",
          "snippet": "int\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, nls_info);\n\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, nls_info);\n\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_negotiate_protocol",
          "args": [
            "xid",
            "ses"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_negotiate_protocol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3827-3853",
          "snippet": "int\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tif (!server->ops->need_neg(server))\n\t\treturn 0;\n\n\tset_credits(server, 1);\n\n\trc = server->ops->negotiate(xid, ses);\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tif (!server->ops->need_neg(server))\n\t\treturn 0;\n\n\tset_credits(server, 1);\n\n\trc = server->ops->negotiate(xid, ses);\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "volume_info->domainname",
            "GFP_KERNEL"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "volume_info->password",
            "GFP_KERNEL"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "volume_info->username",
            "GFP_KERNEL"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ses->serverName",
            "\"%pI4\"",
            "&addr->sin_addr"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ses->serverName",
            "\"%pI6\"",
            "&addr6->sin6_addr"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sesInfoAlloc",
          "args": [],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "sesInfoAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "73-88",
          "snippet": "struct cifs_ses *\nsesInfoAlloc(void)\n{\n\tstruct cifs_ses *ret_buf;\n\n\tret_buf = kzalloc(sizeof(struct cifs_ses), GFP_KERNEL);\n\tif (ret_buf) {\n\t\tatomic_inc(&sesInfoAllocCount);\n\t\tret_buf->status = CifsNew;\n\t\t++ret_buf->ses_count;\n\t\tINIT_LIST_HEAD(&ret_buf->smb_ses_list);\n\t\tINIT_LIST_HEAD(&ret_buf->tcon_list);\n\t\tmutex_init(&ret_buf->session_mutex);\n\t}\n\treturn ret_buf;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nstruct cifs_ses *\nsesInfoAlloc(void)\n{\n\tstruct cifs_ses *ret_buf;\n\n\tret_buf = kzalloc(sizeof(struct cifs_ses), GFP_KERNEL);\n\tif (ret_buf) {\n\t\tatomic_inc(&sesInfoAllocCount);\n\t\tret_buf->status = CifsNew;\n\t\t++ret_buf->ses_count;\n\t\tINIT_LIST_HEAD(&ret_buf->smb_ses_list);\n\t\tINIT_LIST_HEAD(&ret_buf->tcon_list);\n\t\tmutex_init(&ret_buf->session_mutex);\n\t}\n\treturn ret_buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Existing smb sess not found\\n\""
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_tcp_session",
          "args": [
            "server"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tcp_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2067-2099",
          "snippet": "static void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_smb_ses",
          "args": [
            "ses"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_smb_ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2266-2302",
          "snippet": "static void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Session needs reconnect\\n\""
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Existing smb sess found (status=%d)\\n\"",
            "ses->status"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_find_smb_ses",
          "args": [
            "server",
            "volume_info"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_find_smb_ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2247-2264",
          "snippet": "static struct cifs_ses *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifs_ses *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tif (ses->status == CifsExiting)\n\t\t\tcontinue;\n\t\tif (!match_session(ses, vol))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct cifs_ses *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifs_ses *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tif (ses->status == CifsExiting)\n\t\t\tcontinue;\n\t\tif (!match_session(ses, vol))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->status);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tfree_xid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\", &addr->sin_addr);\n\n\tif (volume_info->username) {\n\t\tses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\tses->cred_uid = volume_info->cred_uid;\n\tses->linux_uid = volume_info->linux_uid;\n\n\tses->sectype = volume_info->sectype;\n\tses->sign = volume_info->sign;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tfree_xid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}"
  },
  {
    "function_name": "cifs_set_cifscreds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2426-2431",
    "snippet": "static inline int\ncifs_set_cifscreds(struct smb_vol *vol __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic inline int\ncifs_set_cifscreds(struct smb_vol *vol __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "cifs_set_cifscreds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2310-2424",
    "snippet": "static int\ncifs_set_cifscreds(struct smb_vol *vol, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tchar *desc, *delim, *payload;\n\tssize_t len;\n\tstruct key *key;\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct sockaddr_in *sa;\n\tstruct sockaddr_in6 *sa6;\n\tstruct user_key_payload *upayload;\n\n\tdesc = kmalloc(CIFSCREDS_DESC_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\t/* try to find an address key first */\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tsa = (struct sockaddr_in *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsa6 = (struct sockaddr_in6 *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI6c\", &sa6->sin6_addr.s6_addr);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Bad ss_family (%hu)\\n\",\n\t\t\t server->dstaddr.ss_family);\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\tkey = request_key(&key_type_logon, desc, \"\");\n\tif (IS_ERR(key)) {\n\t\tif (!ses->domainName) {\n\t\t\tcifs_dbg(FYI, \"domainName is NULL\\n\");\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t/* didn't work, try to find a domain key */\n\t\tsprintf(desc, \"cifs:d:%s\", ses->domainName);\n\t\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\t\tkey = request_key(&key_type_logon, desc, \"\");\n\t\tif (IS_ERR(key)) {\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tdown_read(&key->sem);\n\tupayload = key->payload.data;\n\tif (IS_ERR_OR_NULL(upayload)) {\n\t\trc = upayload ? PTR_ERR(upayload) : -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\t/* find first : in payload */\n\tpayload = (char *)upayload->data;\n\tdelim = strnchr(payload, upayload->datalen, ':');\n\tcifs_dbg(FYI, \"payload=%s\\n\", payload);\n\tif (!delim) {\n\t\tcifs_dbg(FYI, \"Unable to find ':' in payload (datalen=%d)\\n\",\n\t\t\t upayload->datalen);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tlen = delim - payload;\n\tif (len > CIFS_MAX_USERNAME_LEN || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad value from username search (len=%zd)\\n\",\n\t\t\t len);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tvol->username = kstrndup(payload, len, GFP_KERNEL);\n\tif (!vol->username) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for username\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tgoto out_key_put;\n\t}\n\tcifs_dbg(FYI, \"%s: username=%s\\n\", __func__, vol->username);\n\n\tlen = key->datalen - (len + 1);\n\tif (len > CIFS_MAX_PASSWORD_LEN || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad len for password search (len=%zd)\\n\", len);\n\t\trc = -EINVAL;\n\t\tkfree(vol->username);\n\t\tvol->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\n\t++delim;\n\tvol->password = kstrndup(delim, len, GFP_KERNEL);\n\tif (!vol->password) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for password\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tkfree(vol->username);\n\t\tvol->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\nout_key_put:\n\tup_read(&key->sem);\n\tkey_put(key);\nout_err:\n\tkfree(desc);\n\tcifs_dbg(FYI, \"%s: returning %d\\n\", __func__, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFSCREDS_DESC_SIZE (7 + CIFS_MAX_DOMAINNAME_LEN + 1)"
    ],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);",
      "static void cifs_prune_tlinks(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: returning %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "desc"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&key->sem"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol->username"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unable to allocate %zd bytes for password\\n\"",
            "len"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "delim",
            "len",
            "GFP_KERNEL"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol->username"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Bad len for password search (len=%zd)\\n\"",
            "len"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: username=%s\\n\"",
            "__func__",
            "vol->username"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unable to allocate %zd bytes for username\\n\"",
            "len"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "payload",
            "len",
            "GFP_KERNEL"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Bad value from username search (len=%zd)\\n\"",
            "len"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unable to find ':' in payload (datalen=%d)\\n\"",
            "upayload->datalen"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"payload=%s\\n\"",
            "payload"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnchr",
          "args": [
            "payload",
            "upayload->datalen",
            "':'"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "upayload"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "upayload"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&key->sem"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&key_type_logon",
            "desc",
            "\"\""
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: desc=%s\\n\"",
            "__func__",
            "desc"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "desc",
            "\"cifs:d:%s\"",
            "ses->domainName"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"domainName is NULL\\n\""
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&key_type_logon",
            "desc",
            "\"\""
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: desc=%s\\n\"",
            "__func__",
            "desc"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Bad ss_family (%hu)\\n\"",
            "server->dstaddr.ss_family"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "desc",
            "\"cifs:a:%pI6c\"",
            "&sa6->sin6_addr.s6_addr"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "desc",
            "\"cifs:a:%pI4\"",
            "&sa->sin_addr.s_addr"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "CIFSCREDS_DESC_SIZE",
            "GFP_KERNEL"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define CIFSCREDS_DESC_SIZE (7 + CIFS_MAX_DOMAINNAME_LEN + 1)\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\nstatic int\ncifs_set_cifscreds(struct smb_vol *vol, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tchar *desc, *delim, *payload;\n\tssize_t len;\n\tstruct key *key;\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct sockaddr_in *sa;\n\tstruct sockaddr_in6 *sa6;\n\tstruct user_key_payload *upayload;\n\n\tdesc = kmalloc(CIFSCREDS_DESC_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\t/* try to find an address key first */\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tsa = (struct sockaddr_in *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsa6 = (struct sockaddr_in6 *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI6c\", &sa6->sin6_addr.s6_addr);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Bad ss_family (%hu)\\n\",\n\t\t\t server->dstaddr.ss_family);\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\tkey = request_key(&key_type_logon, desc, \"\");\n\tif (IS_ERR(key)) {\n\t\tif (!ses->domainName) {\n\t\t\tcifs_dbg(FYI, \"domainName is NULL\\n\");\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t/* didn't work, try to find a domain key */\n\t\tsprintf(desc, \"cifs:d:%s\", ses->domainName);\n\t\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\t\tkey = request_key(&key_type_logon, desc, \"\");\n\t\tif (IS_ERR(key)) {\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tdown_read(&key->sem);\n\tupayload = key->payload.data;\n\tif (IS_ERR_OR_NULL(upayload)) {\n\t\trc = upayload ? PTR_ERR(upayload) : -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\t/* find first : in payload */\n\tpayload = (char *)upayload->data;\n\tdelim = strnchr(payload, upayload->datalen, ':');\n\tcifs_dbg(FYI, \"payload=%s\\n\", payload);\n\tif (!delim) {\n\t\tcifs_dbg(FYI, \"Unable to find ':' in payload (datalen=%d)\\n\",\n\t\t\t upayload->datalen);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tlen = delim - payload;\n\tif (len > CIFS_MAX_USERNAME_LEN || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad value from username search (len=%zd)\\n\",\n\t\t\t len);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tvol->username = kstrndup(payload, len, GFP_KERNEL);\n\tif (!vol->username) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for username\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tgoto out_key_put;\n\t}\n\tcifs_dbg(FYI, \"%s: username=%s\\n\", __func__, vol->username);\n\n\tlen = key->datalen - (len + 1);\n\tif (len > CIFS_MAX_PASSWORD_LEN || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad len for password search (len=%zd)\\n\", len);\n\t\trc = -EINVAL;\n\t\tkfree(vol->username);\n\t\tvol->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\n\t++delim;\n\tvol->password = kstrndup(delim, len, GFP_KERNEL);\n\tif (!vol->password) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for password\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tkfree(vol->username);\n\t\tvol->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\nout_key_put:\n\tup_read(&key->sem);\n\tkey_put(key);\nout_err:\n\tkfree(desc);\n\tcifs_dbg(FYI, \"%s: returning %d\\n\", __func__, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_put_smb_ses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2266-2302",
    "snippet": "static void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_tcp_session",
          "args": [
            "server"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tcp_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2067-2099",
          "snippet": "static void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sesInfoFree",
          "args": [
            "ses"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "sesInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "90-110",
          "snippet": "void\nsesInfoFree(struct cifs_ses *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to sesInfoFree\\n\");\n\t\treturn;\n\t}\n\n\tatomic_dec(&sesInfoAllocCount);\n\tkfree(buf_to_free->serverOS);\n\tkfree(buf_to_free->serverDomain);\n\tkfree(buf_to_free->serverNOS);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free->user_name);\n\tkfree(buf_to_free->domainName);\n\tkfree(buf_to_free->auth_key.response);\n\tkfree(buf_to_free);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nsesInfoFree(struct cifs_ses *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to sesInfoFree\\n\");\n\t\treturn;\n\t}\n\n\tatomic_dec(&sesInfoAllocCount);\n\tkfree(buf_to_free->serverOS);\n\tkfree(buf_to_free->serverDomain);\n\tkfree(buf_to_free->serverNOS);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free->user_name);\n\tkfree(buf_to_free->domainName);\n\tkfree(buf_to_free->auth_key.response);\n\tkfree(buf_to_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ses->smb_ses_list"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_free_xid",
          "args": [
            "xid"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Session Logoff failure rc=%d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->logoff",
          "args": [
            "xid",
            "ses"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: ses_count=%d\\n\"",
            "__func__",
            "ses->ses_count"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (ses->status == CifsExiting) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tif (ses->status == CifsGood)\n\t\tses->status = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsExiting && server->ops->logoff) {\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}"
  },
  {
    "function_name": "cifs_find_smb_ses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2247-2264",
    "snippet": "static struct cifs_ses *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifs_ses *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tif (ses->status == CifsExiting)\n\t\t\tcontinue;\n\t\tif (!match_session(ses, vol))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_session",
          "args": [
            "ses",
            "vol"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "match_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2213-2245",
          "snippet": "static int match_session(struct cifs_ses *ses, struct smb_vol *vol)\n{\n\tif (vol->sectype != Unspecified &&\n\t    vol->sectype != ses->sectype)\n\t\treturn 0;\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tif (!uid_eq(vol->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t/* NULL username means anonymous session */\n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!vol->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* anything else takes username/password */\n\t\tif (strncmp(ses->user_name,\n\t\t\t    vol->username ? vol->username : \"\",\n\t\t\t    CIFS_MAX_USERNAME_LEN))\n\t\t\treturn 0;\n\t\tif ((vol->username && strlen(vol->username) != 0) &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    vol->password ? vol->password : \"\",\n\t\t\t    CIFS_MAX_PASSWORD_LEN))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int match_session(struct cifs_ses *ses, struct smb_vol *vol)\n{\n\tif (vol->sectype != Unspecified &&\n\t    vol->sectype != ses->sectype)\n\t\treturn 0;\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tif (!uid_eq(vol->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t/* NULL username means anonymous session */\n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!vol->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* anything else takes username/password */\n\t\tif (strncmp(ses->user_name,\n\t\t\t    vol->username ? vol->username : \"\",\n\t\t\t    CIFS_MAX_USERNAME_LEN))\n\t\t\treturn 0;\n\t\tif ((vol->username && strlen(vol->username) != 0) &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    vol->password ? vol->password : \"\",\n\t\t\t    CIFS_MAX_PASSWORD_LEN))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ses",
            "&server->smb_ses_list",
            "smb_ses_list"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct cifs_ses *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifs_ses *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tif (ses->status == CifsExiting)\n\t\t\tcontinue;\n\t\tif (!match_session(ses, vol))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "match_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2213-2245",
    "snippet": "static int match_session(struct cifs_ses *ses, struct smb_vol *vol)\n{\n\tif (vol->sectype != Unspecified &&\n\t    vol->sectype != ses->sectype)\n\t\treturn 0;\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tif (!uid_eq(vol->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t/* NULL username means anonymous session */\n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!vol->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* anything else takes username/password */\n\t\tif (strncmp(ses->user_name,\n\t\t\t    vol->username ? vol->username : \"\",\n\t\t\t    CIFS_MAX_USERNAME_LEN))\n\t\t\treturn 0;\n\t\tif ((vol->username && strlen(vol->username) != 0) &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    vol->password ? vol->password : \"\",\n\t\t\t    CIFS_MAX_PASSWORD_LEN))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ses->password",
            "vol->password ? vol->password : \"\"",
            "CIFS_MAX_PASSWORD_LEN"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vol->username"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ses->user_name",
            "vol->username ? vol->username : \"\"",
            "CIFS_MAX_USERNAME_LEN"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "vol->cred_uid",
            "ses->cred_uid"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int match_session(struct cifs_ses *ses, struct smb_vol *vol)\n{\n\tif (vol->sectype != Unspecified &&\n\t    vol->sectype != ses->sectype)\n\t\treturn 0;\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tif (!uid_eq(vol->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t/* NULL username means anonymous session */\n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!vol->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* anything else takes username/password */\n\t\tif (strncmp(ses->user_name,\n\t\t\t    vol->username ? vol->username : \"\",\n\t\t\t    CIFS_MAX_USERNAME_LEN))\n\t\t\treturn 0;\n\t\tif ((vol->username && strlen(vol->username) != 0) &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    vol->password ? vol->password : \"\",\n\t\t\t    CIFS_MAX_PASSWORD_LEN))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "cifs_get_tcp_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2101-2211",
    "snippet": "static struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tint rc;\n\n\tcifs_dbg(FYI, \"UNC: %s\\n\", volume_info->UNC);\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session(volume_info);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->ops = volume_info->ops;\n\ttcp_ses->vals = volume_info->vals;\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\ttcp_ses->hostname = extract_hostname(volume_info->UNC);\n\tif (IS_ERR(tcp_ses->hostname)) {\n\t\trc = PTR_ERR(tcp_ses->hostname);\n\t\tgoto out_err_crypto_release;\n\t}\n\n\ttcp_ses->noblocksnd = volume_info->noblocksnd;\n\ttcp_ses->noautotune = volume_info->noautotune;\n\ttcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\n\ttcp_ses->in_flight = 0;\n\ttcp_ses->credits = 1;\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->lstrp = jiffies;\n\tspin_lock_init(&tcp_ses->req_lock);\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\tmemcpy(&tcp_ses->srcaddr, &volume_info->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\tmemcpy(&tcp_ses->dstaddr, &volume_info->dstaddr,\n\t\tsizeof(tcp_ses->dstaddr));\n#ifdef CONFIG_CIFS_SMB2\n\tget_random_bytes(tcp_ses->client_guid, SMB2_CLIENT_GUID_SIZE);\n#endif\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcifs_dbg(VFS, \"Error connecting to socket. Aborting operation.\\n\");\n\t\tgoto out_err_crypto_release;\n\t}\n\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run(cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcifs_dbg(VFS, \"error %d create cifsd thread\\n\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\ttcp_ses->tcpStatus = CifsNeedNegotiate;\n\n\t/* thread spawned, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_client_cookie(tcp_ses);\n\n\t/* queue echo request delayed work */\n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->echo, SMB_ECHO_INTERVAL);\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_shash_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (!IS_ERR(tcp_ses->hostname))\n\t\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cifs_prune_tlinks(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tcp_ses"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "tcp_ses->ssocket"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tcp_ses->hostname"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tcp_ses->hostname"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "cifs_net_ns(tcp_ses)"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_net_ns",
          "args": [
            "tcp_ses"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_net_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "757-760",
          "snippet": "static inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)\n{\n\treturn &init_net;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)\n{\n\treturn &init_net;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_crypto_shash_release",
          "args": [
            "tcp_ses"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_crypto_shash_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "783-814",
          "snippet": "void\ncifs_crypto_shash_release(struct TCP_Server_Info *server)\n{\n\tif (server->secmech.cmacaes) {\n\t\tcrypto_free_shash(server->secmech.cmacaes);\n\t\tserver->secmech.cmacaes = NULL;\n\t}\n\n\tif (server->secmech.hmacsha256) {\n\t\tcrypto_free_shash(server->secmech.hmacsha256);\n\t\tserver->secmech.hmacsha256 = NULL;\n\t}\n\n\tif (server->secmech.md5) {\n\t\tcrypto_free_shash(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t}\n\n\tif (server->secmech.hmacmd5) {\n\t\tcrypto_free_shash(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t}\n\n\tkfree(server->secmech.sdesccmacaes);\n\tserver->secmech.sdesccmacaes = NULL;\n\tkfree(server->secmech.sdeschmacsha256);\n\tserver->secmech.sdeschmacsha256 = NULL;\n\tkfree(server->secmech.sdeschmacmd5);\n\tserver->secmech.sdeschmacmd5 = NULL;\n\tkfree(server->secmech.sdescmd5);\n\tserver->secmech.sdescmd5 = NULL;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid\ncifs_crypto_shash_release(struct TCP_Server_Info *server)\n{\n\tif (server->secmech.cmacaes) {\n\t\tcrypto_free_shash(server->secmech.cmacaes);\n\t\tserver->secmech.cmacaes = NULL;\n\t}\n\n\tif (server->secmech.hmacsha256) {\n\t\tcrypto_free_shash(server->secmech.hmacsha256);\n\t\tserver->secmech.hmacsha256 = NULL;\n\t}\n\n\tif (server->secmech.md5) {\n\t\tcrypto_free_shash(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t}\n\n\tif (server->secmech.hmacmd5) {\n\t\tcrypto_free_shash(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t}\n\n\tkfree(server->secmech.sdesccmacaes);\n\tserver->secmech.sdesccmacaes = NULL;\n\tkfree(server->secmech.sdeschmacsha256);\n\tserver->secmech.sdeschmacsha256 = NULL;\n\tkfree(server->secmech.sdeschmacmd5);\n\tserver->secmech.sdeschmacmd5 = NULL;\n\tkfree(server->secmech.sdescmd5);\n\tserver->secmech.sdescmd5 = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "cifsiod_wq",
            "&tcp_ses->echo",
            "SMB_ECHO_INTERVAL"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fscache_get_client_cookie",
          "args": [
            "tcp_ses"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_get_client_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "26-33",
          "snippet": "void cifs_fscache_get_client_cookie(struct TCP_Server_Info *server)\n{\n\tserver->fscache =\n\t\tfscache_acquire_cookie(cifs_fscache_netfs.primary_index,\n\t\t\t\t&cifs_fscache_server_index_def, server, true);\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server, server->fscache);\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_get_client_cookie(struct TCP_Server_Info *server)\n{\n\tserver->fscache =\n\t\tfscache_acquire_cookie(cifs_fscache_netfs.primary_index,\n\t\t\t\t&cifs_fscache_server_index_def, server, true);\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server, server->fscache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tcp_ses->tcp_ses_list",
            "&cifs_tcp_ses_list"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "THIS_MODULE"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"error %d create cifsd thread\\n\"",
            "rc"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tcp_ses->tsk"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tcp_ses->tsk"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "cifs_demultiplex_thread",
            "tcp_ses",
            "\"cifsd\""
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__module_get",
          "args": [
            "THIS_MODULE"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Error connecting to socket. Aborting operation.\\n\""
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_connect",
          "args": [
            "tcp_ses"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "ip_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3043-3070",
          "snippet": "static int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t/* try with 445 port at first */\n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t/* if it failed, try with 139 port */\n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RFC1001_PORT 139",
            "#define CIFS_PORT 445"
          ],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define RFC1001_PORT 139\n#define CIFS_PORT 445\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t/* try with 445 port at first */\n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t/* if it failed, try with 139 port */\n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "tcp_ses->client_guid",
            "SMB2_CLIENT_GUID_SIZE"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tcp_ses->dstaddr",
            "&volume_info->dstaddr",
            "sizeof(tcp_ses->dstaddr)"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tcp_ses->srcaddr",
            "&volume_info->srcaddr",
            "sizeof(tcp_ses->srcaddr)"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&tcp_ses->echo",
            "cifs_echo_request"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tcp_ses->smb_ses_list"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tcp_ses->tcp_ses_list"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&tcp_ses->req_lock"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tcp_ses->server_RFC1001_name",
            "volume_info->target_rfc1001_name",
            "RFC1001_NAME_LEN_WITH_NULL"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tcp_ses->workstation_RFC1001_name",
            "volume_info->source_rfc1001_name",
            "RFC1001_NAME_LEN_WITH_NULL"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&tcp_ses->srv_mutex"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tcp_ses->pending_mid_q"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&tcp_ses->request_q"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&tcp_ses->response_q"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tcp_ses->hostname"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tcp_ses->hostname"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_hostname",
          "args": [
            "volume_info->UNC"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "extract_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "951-976",
          "snippet": "static char *\nextract_hostname(const char *unc)\n{\n\tconst char *src;\n\tchar *dst, *delim;\n\tunsigned int len;\n\n\t/* skip double chars at beginning of string */\n\t/* BB: check validity of these bytes? */\n\tsrc = unc + 2;\n\n\t/* delimiter between hostname and sharename is always '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = delim - src;\n\tdst = kmalloc((len + 1), GFP_KERNEL);\n\tif (dst == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(dst, src, len);\n\tdst[len] = '\\0';\n\n\treturn dst;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic char *\nextract_hostname(const char *unc)\n{\n\tconst char *src;\n\tchar *dst, *delim;\n\tunsigned int len;\n\n\t/* skip double chars at beginning of string */\n\t/* BB: check validity of these bytes? */\n\tsrc = unc + 2;\n\n\t/* delimiter between hostname and sharename is always '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = delim - src;\n\tdst = kmalloc((len + 1), GFP_KERNEL);\n\tif (dst == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(dst, src, len);\n\tdst[len] = '\\0';\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_set_net_ns",
          "args": [
            "tcp_ses",
            "get_net(current->nsproxy->net_ns)"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_net_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "762-764",
          "snippet": "static inline void cifs_set_net_ns(struct TCP_Server_Info *srv, struct net *net)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_set_net_ns(struct TCP_Server_Info *srv, struct net *net)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "current->nsproxy->net_ns"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct TCP_Server_Info)",
            "GFP_KERNEL"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_find_tcp_session",
          "args": [
            "volume_info"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_find_tcp_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2048-2065",
          "snippet": "static struct TCP_Server_Info *\ncifs_find_tcp_session(struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tif (!match_server(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcifs_dbg(FYI, \"Existing tcp session with server found\\n\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct TCP_Server_Info *\ncifs_find_tcp_session(struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tif (!match_server(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcifs_dbg(FYI, \"Existing tcp session with server found\\n\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"UNC: %s\\n\"",
            "volume_info->UNC"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\nstatic struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tint rc;\n\n\tcifs_dbg(FYI, \"UNC: %s\\n\", volume_info->UNC);\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session(volume_info);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->ops = volume_info->ops;\n\ttcp_ses->vals = volume_info->vals;\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\ttcp_ses->hostname = extract_hostname(volume_info->UNC);\n\tif (IS_ERR(tcp_ses->hostname)) {\n\t\trc = PTR_ERR(tcp_ses->hostname);\n\t\tgoto out_err_crypto_release;\n\t}\n\n\ttcp_ses->noblocksnd = volume_info->noblocksnd;\n\ttcp_ses->noautotune = volume_info->noautotune;\n\ttcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\n\ttcp_ses->in_flight = 0;\n\ttcp_ses->credits = 1;\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->lstrp = jiffies;\n\tspin_lock_init(&tcp_ses->req_lock);\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\tmemcpy(&tcp_ses->srcaddr, &volume_info->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\tmemcpy(&tcp_ses->dstaddr, &volume_info->dstaddr,\n\t\tsizeof(tcp_ses->dstaddr));\n#ifdef CONFIG_CIFS_SMB2\n\tget_random_bytes(tcp_ses->client_guid, SMB2_CLIENT_GUID_SIZE);\n#endif\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcifs_dbg(VFS, \"Error connecting to socket. Aborting operation.\\n\");\n\t\tgoto out_err_crypto_release;\n\t}\n\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run(cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcifs_dbg(VFS, \"error %d create cifsd thread\\n\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\ttcp_ses->tcpStatus = CifsNeedNegotiate;\n\n\t/* thread spawned, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_client_cookie(tcp_ses);\n\n\t/* queue echo request delayed work */\n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->echo, SMB_ECHO_INTERVAL);\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_shash_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (!IS_ERR(tcp_ses->hostname))\n\t\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}"
  },
  {
    "function_name": "cifs_put_tcp_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2067-2099",
    "snippet": "static void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGKILL",
            "task"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&server->tsk",
            "NULL"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->session_key.response"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fscache_release_client_cookie",
          "args": [
            "server"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_release_client_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "35-41",
          "snippet": "void cifs_fscache_release_client_cookie(struct TCP_Server_Info *server)\n{\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server, server->fscache);\n\tfscache_relinquish_cookie(server->fscache, 0);\n\tserver->fscache = NULL;\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_release_client_cookie(struct TCP_Server_Info *server)\n{\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server, server->fscache);\n\tfscache_relinquish_cookie(server->fscache, 0);\n\tserver->fscache = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_crypto_shash_release",
          "args": [
            "server"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_crypto_shash_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "783-814",
          "snippet": "void\ncifs_crypto_shash_release(struct TCP_Server_Info *server)\n{\n\tif (server->secmech.cmacaes) {\n\t\tcrypto_free_shash(server->secmech.cmacaes);\n\t\tserver->secmech.cmacaes = NULL;\n\t}\n\n\tif (server->secmech.hmacsha256) {\n\t\tcrypto_free_shash(server->secmech.hmacsha256);\n\t\tserver->secmech.hmacsha256 = NULL;\n\t}\n\n\tif (server->secmech.md5) {\n\t\tcrypto_free_shash(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t}\n\n\tif (server->secmech.hmacmd5) {\n\t\tcrypto_free_shash(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t}\n\n\tkfree(server->secmech.sdesccmacaes);\n\tserver->secmech.sdesccmacaes = NULL;\n\tkfree(server->secmech.sdeschmacsha256);\n\tserver->secmech.sdeschmacsha256 = NULL;\n\tkfree(server->secmech.sdeschmacmd5);\n\tserver->secmech.sdeschmacmd5 = NULL;\n\tkfree(server->secmech.sdescmd5);\n\tserver->secmech.sdescmd5 = NULL;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid\ncifs_crypto_shash_release(struct TCP_Server_Info *server)\n{\n\tif (server->secmech.cmacaes) {\n\t\tcrypto_free_shash(server->secmech.cmacaes);\n\t\tserver->secmech.cmacaes = NULL;\n\t}\n\n\tif (server->secmech.hmacsha256) {\n\t\tcrypto_free_shash(server->secmech.hmacsha256);\n\t\tserver->secmech.hmacsha256 = NULL;\n\t}\n\n\tif (server->secmech.md5) {\n\t\tcrypto_free_shash(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t}\n\n\tif (server->secmech.hmacmd5) {\n\t\tcrypto_free_shash(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t}\n\n\tkfree(server->secmech.sdesccmacaes);\n\tserver->secmech.sdesccmacaes = NULL;\n\tkfree(server->secmech.sdeschmacsha256);\n\tserver->secmech.sdeschmacsha256 = NULL;\n\tkfree(server->secmech.sdeschmacmd5);\n\tserver->secmech.sdeschmacmd5 = NULL;\n\tkfree(server->secmech.sdescmd5);\n\tserver->secmech.sdescmd5 = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&server->echo"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&server->tcp_ses_list"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "cifs_net_ns(server)"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_net_ns",
          "args": [
            "server"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_net_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "757-760",
          "snippet": "static inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)\n{\n\treturn &init_net;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)\n{\n\treturn &init_net;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}"
  },
  {
    "function_name": "cifs_find_tcp_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2048-2065",
    "snippet": "static struct TCP_Server_Info *\ncifs_find_tcp_session(struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tif (!match_server(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcifs_dbg(FYI, \"Existing tcp session with server found\\n\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Existing tcp session with server found\\n\""
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_server",
          "args": [
            "server",
            "vol"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "match_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2022-2046",
          "snippet": "static int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&vol->dstaddr;\n\n\tif (vol->nosharesock)\n\t\treturn 0;\n\n\tif ((server->vals != vol->vals) || (server->ops != vol->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, vol))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&vol->dstaddr;\n\n\tif (vol->nosharesock)\n\t\treturn 0;\n\n\tif ((server->vals != vol->vals) || (server->ops != vol->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, vol))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "server",
            "&cifs_tcp_ses_list",
            "tcp_ses_list"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct TCP_Server_Info *\ncifs_find_tcp_session(struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tif (!match_server(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcifs_dbg(FYI, \"Existing tcp session with server found\\n\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "match_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2022-2046",
    "snippet": "static int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&vol->dstaddr;\n\n\tif (vol->nosharesock)\n\t\treturn 0;\n\n\tif ((server->vals != vol->vals) || (server->ops != vol->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, vol))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_security",
          "args": [
            "server",
            "vol"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "match_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2000-2020",
          "snippet": "static bool\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\t/*\n\t * The select_sectype function should either return the vol->sectype\n\t * that was specified, or \"Unspecified\" if that sectype was not\n\t * compatible with the given NEGOTIATE request.\n\t */\n\tif (select_sectype(server, vol->sectype) == Unspecified)\n\t\treturn false;\n\n\t/*\n\t * Now check if signing mode is acceptable. No need to check\n\t * global_secflags at this point since if MUST_SIGN is set then\n\t * the server->sign had better be too.\n\t */\n\tif (vol->sign && !server->sign)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\t/*\n\t * The select_sectype function should either return the vol->sectype\n\t * that was specified, or \"Unspecified\" if that sectype was not\n\t * compatible with the given NEGOTIATE request.\n\t */\n\tif (select_sectype(server, vol->sectype) == Unspecified)\n\t\treturn false;\n\n\t/*\n\t * Now check if signing mode is acceptable. No need to check\n\t * global_secflags at this point since if MUST_SIGN is set then\n\t * the server->sign had better be too.\n\t */\n\tif (vol->sign && !server->sign)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_port",
          "args": [
            "server",
            "addr"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "match_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "1933-1961",
          "snippet": "static bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RFC1001_PORT 139",
            "#define CIFS_PORT 445"
          ],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define RFC1001_PORT 139\n#define CIFS_PORT 445\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_address",
          "args": [
            "server",
            "addr",
            "(struct sockaddr *)&vol->srcaddr"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "match_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "1963-1998",
          "snippet": "static bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\n\t      struct sockaddr *srcaddr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\tstruct sockaddr_in *srv_addr4 =\n\t\t\t\t\t(struct sockaddr_in *)&server->dstaddr;\n\n\t\tif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\tstruct sockaddr_in6 *srv_addr6 =\n\t\t\t\t\t(struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &srv_addr6->sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n\n\tif (!srcip_matches(srcaddr, (struct sockaddr *)&server->srcaddr))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\n\t      struct sockaddr *srcaddr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\tstruct sockaddr_in *srv_addr4 =\n\t\t\t\t\t(struct sockaddr_in *)&server->dstaddr;\n\n\t\tif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\tstruct sockaddr_in6 *srv_addr6 =\n\t\t\t\t\t(struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &srv_addr6->sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n\n\tif (!srcip_matches(srcaddr, (struct sockaddr *)&server->srcaddr))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_eq",
          "args": [
            "cifs_net_ns(server)",
            "current->nsproxy->net_ns"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_net_ns",
          "args": [
            "server"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_net_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "757-760",
          "snippet": "static inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)\n{\n\treturn &init_net;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)\n{\n\treturn &init_net;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&vol->dstaddr;\n\n\tif (vol->nosharesock)\n\t\treturn 0;\n\n\tif ((server->vals != vol->vals) || (server->ops != vol->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, vol))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "match_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "2000-2020",
    "snippet": "static bool\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\t/*\n\t * The select_sectype function should either return the vol->sectype\n\t * that was specified, or \"Unspecified\" if that sectype was not\n\t * compatible with the given NEGOTIATE request.\n\t */\n\tif (select_sectype(server, vol->sectype) == Unspecified)\n\t\treturn false;\n\n\t/*\n\t * Now check if signing mode is acceptable. No need to check\n\t * global_secflags at this point since if MUST_SIGN is set then\n\t * the server->sign had better be too.\n\t */\n\tif (vol->sign && !server->sign)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "select_sectype",
          "args": [
            "server",
            "vol->sectype"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "select_sectype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "474-522",
          "snippet": "enum securityEnum\nselect_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (server->negflavor) {\n\tcase CIFS_NEGFLAVOR_EXTENDED:\n\t\tswitch (requested) {\n\t\tcase Kerberos:\n\t\tcase RawNTLMSSP:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (server->sec_ntlmssp &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\t\treturn RawNTLMSSP;\n\t\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\t\treturn Kerberos;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tcase CIFS_NEGFLAVOR_UNENCAP:\n\t\tswitch (requested) {\n\t\tcase NTLM:\n\t\tcase NTLMv2:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLMV2)\n\t\t\t\treturn NTLMv2;\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLM)\n\t\t\t\treturn NTLM;\n\t\tdefault:\n\t\t\t/* Fallthrough to attempt LANMAN authentication next */\n\t\t\tbreak;\n\t\t}\n\tcase CIFS_NEGFLAVOR_LANMAN:\n\t\tswitch (requested) {\n\t\tcase LANMAN:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_LANMAN)\n\t\t\t\treturn LANMAN;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nenum securityEnum\nselect_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (server->negflavor) {\n\tcase CIFS_NEGFLAVOR_EXTENDED:\n\t\tswitch (requested) {\n\t\tcase Kerberos:\n\t\tcase RawNTLMSSP:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (server->sec_ntlmssp &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\t\treturn RawNTLMSSP;\n\t\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\t\treturn Kerberos;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tcase CIFS_NEGFLAVOR_UNENCAP:\n\t\tswitch (requested) {\n\t\tcase NTLM:\n\t\tcase NTLMv2:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLMV2)\n\t\t\t\treturn NTLMv2;\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLM)\n\t\t\t\treturn NTLM;\n\t\tdefault:\n\t\t\t/* Fallthrough to attempt LANMAN authentication next */\n\t\t\tbreak;\n\t\t}\n\tcase CIFS_NEGFLAVOR_LANMAN:\n\t\tswitch (requested) {\n\t\tcase LANMAN:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_LANMAN)\n\t\t\t\treturn LANMAN;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\t/*\n\t * The select_sectype function should either return the vol->sectype\n\t * that was specified, or \"Unspecified\" if that sectype was not\n\t * compatible with the given NEGOTIATE request.\n\t */\n\tif (select_sectype(server, vol->sectype) == Unspecified)\n\t\treturn false;\n\n\t/*\n\t * Now check if signing mode is acceptable. No need to check\n\t * global_secflags at this point since if MUST_SIGN is set then\n\t * the server->sign had better be too.\n\t */\n\tif (vol->sign && !server->sign)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "match_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "1963-1998",
    "snippet": "static bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\n\t      struct sockaddr *srcaddr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\tstruct sockaddr_in *srv_addr4 =\n\t\t\t\t\t(struct sockaddr_in *)&server->dstaddr;\n\n\t\tif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\tstruct sockaddr_in6 *srv_addr6 =\n\t\t\t\t\t(struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &srv_addr6->sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n\n\tif (!srcip_matches(srcaddr, (struct sockaddr *)&server->srcaddr))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcip_matches",
          "args": [
            "srcaddr",
            "(struct sockaddr *)&server->srcaddr"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "srcip_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "1906-1926",
          "snippet": "static bool\nsrcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\n\t\treturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic bool\nsrcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\n\t\treturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_addr_equal",
          "args": [
            "&addr6->sin6_addr",
            "&srv_addr6->sin6_addr"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\n\t      struct sockaddr *srcaddr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\tstruct sockaddr_in *srv_addr4 =\n\t\t\t\t\t(struct sockaddr_in *)&server->dstaddr;\n\n\t\tif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\tstruct sockaddr_in6 *srv_addr6 =\n\t\t\t\t\t(struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &srv_addr6->sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n\n\tif (!srcip_matches(srcaddr, (struct sockaddr *)&server->srcaddr))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "match_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "1933-1961",
    "snippet": "static bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define RFC1001_PORT 139",
      "#define CIFS_PORT 445"
    ],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "RFC1001_PORT"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "CIFS_PORT"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define RFC1001_PORT 139\n#define CIFS_PORT 445\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}"
  },
  {
    "function_name": "srcip_matches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "1906-1926",
    "snippet": "static bool\nsrcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\n\t\treturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_addr_equal",
          "args": [
            "&saddr6->sin6_addr",
            "&vaddr6->sin6_addr"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic bool\nsrcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\n\t\treturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n}"
  },
  {
    "function_name": "cifs_parse_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "1191-1900",
    "snippet": "static int\ncifs_parse_mount_options(const char *mountdata, const char *devname,\n\t\t\t struct smb_vol *vol)\n{\n\tchar *data, *end;\n\tchar *mountdata_copy = NULL, *options;\n\tunsigned int  temp_len, i, j;\n\tchar separator[2];\n\tshort int override_uid = -1;\n\tshort int override_gid = -1;\n\tbool uid_specified = false;\n\tbool gid_specified = false;\n\tbool sloppy = false;\n\tchar *invalid = NULL;\n\tchar *nodename = utsname()->nodename;\n\tchar *string = NULL;\n\tchar *tmp_end, *value;\n\tchar delim;\n\tbool got_ip = false;\n\tunsigned short port = 0;\n\tstruct sockaddr *dstaddr = (struct sockaddr *)&vol->dstaddr;\n\n\tseparator[0] = ',';\n\tseparator[1] = 0;\n\tdelim = separator[0];\n\n\t/* ensure we always start with zeroed-out smb_vol */\n\tmemset(vol, 0, sizeof(*vol));\n\n\t/*\n\t * does not have to be perfect mapping since field is\n\t * informational, only used for servers that do not support\n\t * port 445 and it can be overridden at mount time\n\t */\n\tmemset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);\n\tfor (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)\n\t\tvol->source_rfc1001_name[i] = toupper(nodename[i]);\n\n\tvol->source_rfc1001_name[RFC1001_NAME_LEN] = 0;\n\t/* null target name indicates to use *SMBSERVR default called name\n\t   if we end up sending RFC1001 session initialize */\n\tvol->target_rfc1001_name[0] = 0;\n\tvol->cred_uid = current_uid();\n\tvol->linux_uid = current_uid();\n\tvol->linux_gid = current_gid();\n\n\t/*\n\t * default to SFM style remapping of seven reserved characters\n\t * unless user overrides it or we negotiate CIFS POSIX where\n\t * it is unnecessary.  Can not simultaneously use more than one mapping\n\t * since then readdir could list files that open could not open\n\t */\n\tvol->remap = true;\n\n\t/* default to only allowing write access to owner of the mount */\n\tvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t/* vol->retry default is 0 (i.e. \"soft\" limited retry not hard retry) */\n\t/* default is always to request posix paths. */\n\tvol->posix_paths = 1;\n\t/* default to using server inode numbers where available */\n\tvol->server_ino = 1;\n\n\t/* default is to use strict cifs caching semantics */\n\tvol->strict_io = true;\n\n\tvol->actimeo = CIFS_DEF_ACTIMEO;\n\n\t/* FIXME: add autonegotiation -- for now, SMB1 is default */\n\tvol->ops = &smb1_operations;\n\tvol->vals = &smb1_values;\n\n\tif (!mountdata)\n\t\tgoto cifs_parse_mount_err;\n\n\tmountdata_copy = kstrndup(mountdata, PAGE_SIZE, GFP_KERNEL);\n\tif (!mountdata_copy)\n\t\tgoto cifs_parse_mount_err;\n\n\toptions = mountdata_copy;\n\tend = options + strlen(options);\n\n\tif (strncmp(options, \"sep=\", 4) == 0) {\n\t\tif (options[4] != 0) {\n\t\t\tseparator[0] = options[4];\n\t\t\toptions += 5;\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"Null separator not allowed\\n\");\n\t\t}\n\t}\n\tvol->backupuid_specified = false; /* no backup intent for a user */\n\tvol->backupgid_specified = false; /* no backup intent for a group */\n\n\tswitch (cifs_parse_devname(devname, vol)) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOMEM:\n\t\tcifs_dbg(VFS, \"Unable to allocate memory for devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tcase -EINVAL:\n\t\tcifs_dbg(VFS, \"Malformed UNC in devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown error parsing devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\twhile ((data = strsep(&options, separator)) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned long option;\n\t\tint token;\n\n\t\tif (!*data)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(data, cifs_mount_option_tokens, args);\n\n\t\tswitch (token) {\n\n\t\t/* Ingnore the following */\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\n\t\t/* Boolean values */\n\t\tcase Opt_user_xattr:\n\t\t\tvol->no_xattr = 0;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tvol->no_xattr = 1;\n\t\t\tbreak;\n\t\tcase Opt_forceuid:\n\t\t\toverride_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforceuid:\n\t\t\toverride_uid = 0;\n\t\t\tbreak;\n\t\tcase Opt_forcegid:\n\t\t\toverride_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforcegid:\n\t\t\toverride_gid = 0;\n\t\t\tbreak;\n\t\tcase Opt_noblocksend:\n\t\t\tvol->noblocksnd = 1;\n\t\t\tbreak;\n\t\tcase Opt_noautotune:\n\t\t\tvol->noautotune = 1;\n\t\t\tbreak;\n\t\tcase Opt_hard:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_soft:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_perm:\n\t\t\tvol->noperm = 0;\n\t\t\tbreak;\n\t\tcase Opt_noperm:\n\t\t\tvol->noperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_mapchars:\n\t\t\tvol->sfu_remap = true;\n\t\t\tvol->remap = false; /* disable SFM mapping */\n\t\t\tbreak;\n\t\tcase Opt_nomapchars:\n\t\t\tvol->sfu_remap = false;\n\t\t\tbreak;\n\t\tcase Opt_mapposix:\n\t\t\tvol->remap = true;\n\t\t\tvol->sfu_remap = false; /* disable SFU mapping */\n\t\t\tbreak;\n\t\tcase Opt_nomapposix:\n\t\t\tvol->remap = false;\n\t\t\tbreak;\n\t\tcase Opt_sfu:\n\t\t\tvol->sfu_emul = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosfu:\n\t\t\tvol->sfu_emul = 0;\n\t\t\tbreak;\n\t\tcase Opt_nodfs:\n\t\t\tvol->nodfs = 1;\n\t\t\tbreak;\n\t\tcase Opt_posixpaths:\n\t\t\tvol->posix_paths = 1;\n\t\t\tbreak;\n\t\tcase Opt_noposixpaths:\n\t\t\tvol->posix_paths = 0;\n\t\t\tbreak;\n\t\tcase Opt_nounix:\n\t\t\tvol->no_linux_ext = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tvol->nocase = 1;\n\t\t\tbreak;\n\t\tcase Opt_brl:\n\t\t\tvol->nobrl =  0;\n\t\t\tbreak;\n\t\tcase Opt_nobrl:\n\t\t\tvol->nobrl =  1;\n\t\t\t/*\n\t\t\t * turn off mandatory locking in mode\n\t\t\t * if remote locking is turned off since the\n\t\t\t * local vfs will do advisory\n\t\t\t */\n\t\t\tif (vol->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tvol->file_mode = S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_forcemandatorylock:\n\t\t\tvol->mand_lock = 1;\n\t\t\tbreak;\n\t\tcase Opt_setuids:\n\t\t\tvol->setuids = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosetuids:\n\t\t\tvol->setuids = 0;\n\t\t\tbreak;\n\t\tcase Opt_dynperm:\n\t\t\tvol->dynperm = true;\n\t\t\tbreak;\n\t\tcase Opt_nodynperm:\n\t\t\tvol->dynperm = false;\n\t\t\tbreak;\n\t\tcase Opt_nohard:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_nosoft:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tvol->intr = 0;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tvol->intr = 1;\n\t\t\tbreak;\n\t\tcase Opt_nostrictsync:\n\t\t\tvol->nostrictsync = 1;\n\t\t\tbreak;\n\t\tcase Opt_strictsync:\n\t\t\tvol->nostrictsync = 0;\n\t\t\tbreak;\n\t\tcase Opt_serverino:\n\t\t\tvol->server_ino = 1;\n\t\t\tbreak;\n\t\tcase Opt_noserverino:\n\t\t\tvol->server_ino = 0;\n\t\t\tbreak;\n\t\tcase Opt_rwpidforward:\n\t\t\tvol->rwpidforward = 1;\n\t\t\tbreak;\n\t\tcase Opt_cifsacl:\n\t\t\tvol->cifs_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocifsacl:\n\t\t\tvol->cifs_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tvol->no_psx_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tvol->no_psx_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_locallease:\n\t\t\tvol->local_lease = 1;\n\t\t\tbreak;\n\t\tcase Opt_sign:\n\t\t\tvol->sign = true;\n\t\t\tbreak;\n\t\tcase Opt_seal:\n\t\t\t/* we do not do the following in secFlags because seal\n\t\t\t * is a per tree connection (mount) not a per socket\n\t\t\t * or per-smb connection option in the protocol\n\t\t\t * vol->secFlg |= CIFSSEC_MUST_SEAL;\n\t\t\t */\n\t\t\tvol->seal = 1;\n\t\t\tbreak;\n\t\tcase Opt_noac:\n\t\t\tpr_warn(\"CIFS: Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\t\tbreak;\n\t\tcase Opt_fsc:\n#ifndef CONFIG_CIFS_FSCACHE\n\t\t\tcifs_dbg(VFS, \"FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n#endif\n\t\t\tvol->fsc = true;\n\t\t\tbreak;\n\t\tcase Opt_mfsymlinks:\n\t\t\tvol->mfsymlinks = true;\n\t\t\tbreak;\n\t\tcase Opt_multiuser:\n\t\t\tvol->multiuser = true;\n\t\t\tbreak;\n\t\tcase Opt_sloppy:\n\t\t\tsloppy = true;\n\t\t\tbreak;\n\t\tcase Opt_nosharesock:\n\t\t\tvol->nosharesock = true;\n\t\t\tbreak;\n\n\t\t/* Numeric Values */\n\t\tcase Opt_backupuid:\n\t\t\tif (get_option_uid(args, &vol->backupuid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupuid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_backupgid:\n\t\t\tif (get_option_gid(args, &vol->backupgid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupgid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (get_option_uid(args, &vol->linux_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid uid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_cruid:\n\t\t\tif (get_option_uid(args, &vol->cred_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid cruid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (get_option_gid(args, &vol->linux_gid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid gid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_file_mode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid file_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->file_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_dirmode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid dir_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->dir_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_port:\n\t\t\tif (get_option_ul(args, &option) ||\n\t\t\t    option > USHRT_MAX) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid port value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tport = (unsigned short)option;\n\t\t\tbreak;\n\t\tcase Opt_rsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid rsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->rsize = option;\n\t\t\tbreak;\n\t\tcase Opt_wsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid wsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->wsize = option;\n\t\t\tbreak;\n\t\tcase Opt_actimeo:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid actimeo value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->actimeo = HZ * option;\n\t\t\tif (vol->actimeo > CIFS_MAX_ACTIMEO) {\n\t\t\t\tcifs_dbg(VFS, \"attribute cache timeout too large\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* String Arguments */\n\n\t\tcase Opt_blank_user:\n\t\t\t/* null user, ie. anonymous authentication */\n\t\t\tvol->nullauth = 1;\n\t\t\tvol->username = NULL;\n\t\t\tbreak;\n\t\tcase Opt_user:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, CIFS_MAX_USERNAME_LEN) >\n\t\t\t\t\t\t\tCIFS_MAX_USERNAME_LEN) {\n\t\t\t\tpr_warn(\"CIFS: username too long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->username = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->username)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_blank_pass:\n\t\t\t/* passwords have to be handled differently\n\t\t\t * to allow the character used for deliminator\n\t\t\t * to be passed within them\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Check if this is a case where the  password\n\t\t\t * starts with a delimiter\n\t\t\t */\n\t\t\ttmp_end = strchr(data, '=');\n\t\t\ttmp_end++;\n\t\t\tif (!(tmp_end < end && tmp_end[1] == delim)) {\n\t\t\t\t/* No it is not. Set the password to NULL */\n\t\t\t\tkfree(vol->password);\n\t\t\t\tvol->password = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Yes it is. Drop down to Opt_pass below.*/\n\t\tcase Opt_pass:\n\t\t\t/* Obtain the value string */\n\t\t\tvalue = strchr(data, '=');\n\t\t\tvalue++;\n\n\t\t\t/* Set tmp_end to end of the string */\n\t\t\ttmp_end = (char *) value + strlen(value);\n\n\t\t\t/* Check if following character is the deliminator\n\t\t\t * If yes, we have encountered a double deliminator\n\t\t\t * reset the NULL character to the deliminator\n\t\t\t */\n\t\t\tif (tmp_end < end && tmp_end[1] == delim) {\n\t\t\t\ttmp_end[0] = delim;\n\n\t\t\t\t/* Keep iterating until we get to a single\n\t\t\t\t * deliminator OR the end\n\t\t\t\t */\n\t\t\t\twhile ((tmp_end = strchr(tmp_end, delim))\n\t\t\t\t\t!= NULL && (tmp_end[1] == delim)) {\n\t\t\t\t\t\ttmp_end = (char *) &tmp_end[2];\n\t\t\t\t}\n\n\t\t\t\t/* Reset var options to point to next element */\n\t\t\t\tif (tmp_end) {\n\t\t\t\t\ttmp_end[0] = '\\0';\n\t\t\t\t\toptions = (char *) &tmp_end[1];\n\t\t\t\t} else\n\t\t\t\t\t/* Reached the end of the mount option\n\t\t\t\t\t * string */\n\t\t\t\t\toptions = end;\n\t\t\t}\n\n\t\t\tkfree(vol->password);\n\t\t\t/* Now build new password string */\n\t\t\ttemp_len = strlen(value);\n\t\t\tvol->password = kzalloc(temp_len+1, GFP_KERNEL);\n\t\t\tif (vol->password == NULL) {\n\t\t\t\tpr_warn(\"CIFS: no memory for password\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tfor (i = 0, j = 0; i < temp_len; i++, j++) {\n\t\t\t\tvol->password[j] = value[i];\n\t\t\t\tif ((value[i] == delim) &&\n\t\t\t\t     value[i+1] == delim)\n\t\t\t\t\t/* skip the second deliminator */\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t\tvol->password[j] = '\\0';\n\t\t\tbreak;\n\t\tcase Opt_blank_ip:\n\t\t\t/* FIXME: should this be an error instead? */\n\t\t\tgot_ip = false;\n\t\t\tbreak;\n\t\tcase Opt_ip:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(dstaddr, string,\n\t\t\t\t\tstrlen(string))) {\n\t\t\t\tpr_err(\"CIFS: bad ip= option (%s).\\n\", string);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgot_ip = true;\n\t\t\tbreak;\n\t\tcase Opt_domain:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, CIFS_MAX_DOMAINNAME_LEN)\n\t\t\t\t\t== CIFS_MAX_DOMAINNAME_LEN) {\n\t\t\t\tpr_warn(\"CIFS: domain name too long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tvol->domainname = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->domainname) {\n\t\t\t\tpr_warn(\"CIFS: no memory for domainname\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tcifs_dbg(FYI, \"Domain name set\\n\");\n\t\t\tbreak;\n\t\tcase Opt_srcaddr:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(\n\t\t\t\t\t(struct sockaddr *)&vol->srcaddr,\n\t\t\t\t\tstring, strlen(string))) {\n\t\t\t\tpr_warn(\"CIFS: Could not parse srcaddr: %s\\n\",\n\t\t\t\t\tstring);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, 1024) >= 65) {\n\t\t\t\tpr_warn(\"CIFS: iocharset name too long.\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\t if (strncasecmp(string, \"default\", 7) != 0) {\n\t\t\t\tvol->iocharset = kstrdup(string,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\t\tif (!vol->iocharset) {\n\t\t\t\t\tpr_warn(\"CIFS: no memory for charset\\n\");\n\t\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if iocharset not set then load_nls_default\n\t\t\t * is used by caller\n\t\t\t */\n\t\t\t cifs_dbg(FYI, \"iocharset set to %s\\n\", string);\n\t\t\tbreak;\n\t\tcase Opt_netbiosname:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tmemset(vol->source_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN);\n\t\t\t/*\n\t\t\t * FIXME: are there cases in which a comma can\n\t\t\t * be valid in workstation netbios name (and\n\t\t\t * need special handling)?\n\t\t\t */\n\t\t\tfor (i = 0; i < RFC1001_NAME_LEN; i++) {\n\t\t\t\t/* don't ucase netbiosname for user */\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->source_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t * set at top of the function\n\t\t\t */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tpr_warn(\"CIFS: netbiosname longer than 15 truncated.\\n\");\n\t\t\tbreak;\n\t\tcase Opt_servern:\n\t\t\t/* servernetbiosname specified override *SMBSERVER */\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\t/* last byte, type, is 0x20 for servr type */\n\t\t\tmemset(vol->target_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\t/* BB are there cases in which a comma can be\n\t\t\t   valid in this workstation netbios name\n\t\t\t   (and need special handling)? */\n\n\t\t\t/* user or mount helper must uppercase the\n\t\t\t   netbios name */\n\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->target_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t   set at top of the function  */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tpr_warn(\"CIFS: server netbiosname longer than 15 truncated.\\n\");\n\t\t\tbreak;\n\t\tcase Opt_ver:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strncasecmp(string, \"1\", 1) == 0) {\n\t\t\t\t/* This is the default */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For all other value, error */\n\t\t\tpr_warn(\"CIFS: Invalid version specified\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\tcase Opt_vers:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_smb_version(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_sec:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_security_flavors(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_cache_flavor(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * An option we don't recognize. Save it off for later\n\t\t\t * if we haven't already found one\n\t\t\t */\n\t\t\tif (!invalid)\n\t\t\t\tinvalid = data;\n\t\t\tbreak;\n\t\t}\n\t\t/* Free up any allocated string */\n\t\tkfree(string);\n\t\tstring = NULL;\n\t}\n\n\tif (!sloppy && invalid) {\n\t\tpr_err(\"CIFS: Unknown mount option \\\"%s\\\"\\n\", invalid);\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n#ifndef CONFIG_KEYS\n\t/* Muliuser mounts require CONFIG_KEYS support */\n\tif (vol->multiuser) {\n\t\tcifs_dbg(VFS, \"Multiuser mounts require kernels with CONFIG_KEYS enabled\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n#endif\n\tif (!vol->UNC) {\n\t\tcifs_dbg(VFS, \"CIFS mount error: No usable UNC path provided in device string!\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\t/* make sure UNC has a share name */\n\tif (!strchr(vol->UNC + 3, '\\\\')) {\n\t\tcifs_dbg(VFS, \"Malformed UNC. Unable to find share name.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\tif (!got_ip) {\n\t\t/* No ip= option specified? Try to get it from UNC */\n\t\tif (!cifs_convert_address(dstaddr, &vol->UNC[2],\n\t\t\t\t\t\tstrlen(&vol->UNC[2]))) {\n\t\t\tpr_err(\"Unable to determine destination address.\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t}\n\n\t/* set the port that we got earlier */\n\tcifs_set_port(dstaddr, port);\n\n\tif (uid_specified)\n\t\tvol->override_uid = override_uid;\n\telse if (override_uid == 1)\n\t\tpr_notice(\"CIFS: ignoring forceuid mount option specified with no uid= option.\\n\");\n\n\tif (gid_specified)\n\t\tvol->override_gid = override_gid;\n\telse if (override_gid == 1)\n\t\tpr_notice(\"CIFS: ignoring forcegid mount option specified with no gid= option.\\n\");\n\n\tkfree(mountdata_copy);\n\treturn 0;\n\nout_nomem:\n\tpr_warn(\"Could not allocate temporary buffer\\n\");\ncifs_parse_mount_err:\n\tkfree(string);\n\tkfree(mountdata_copy);\n\treturn 1;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t cifs_mount_option_tokens = {\n\n\t{ Opt_user_xattr, \"user_xattr\" },\n\t{ Opt_nouser_xattr, \"nouser_xattr\" },\n\t{ Opt_forceuid, \"forceuid\" },\n\t{ Opt_noforceuid, \"noforceuid\" },\n\t{ Opt_forcegid, \"forcegid\" },\n\t{ Opt_noforcegid, \"noforcegid\" },\n\t{ Opt_noblocksend, \"noblocksend\" },\n\t{ Opt_noautotune, \"noautotune\" },\n\t{ Opt_hard, \"hard\" },\n\t{ Opt_soft, \"soft\" },\n\t{ Opt_perm, \"perm\" },\n\t{ Opt_noperm, \"noperm\" },\n\t{ Opt_mapchars, \"mapchars\" }, /* SFU style */\n\t{ Opt_nomapchars, \"nomapchars\" },\n\t{ Opt_mapposix, \"mapposix\" }, /* SFM style */\n\t{ Opt_nomapposix, \"nomapposix\" },\n\t{ Opt_sfu, \"sfu\" },\n\t{ Opt_nosfu, \"nosfu\" },\n\t{ Opt_nodfs, \"nodfs\" },\n\t{ Opt_posixpaths, \"posixpaths\" },\n\t{ Opt_noposixpaths, \"noposixpaths\" },\n\t{ Opt_nounix, \"nounix\" },\n\t{ Opt_nounix, \"nolinux\" },\n\t{ Opt_nocase, \"nocase\" },\n\t{ Opt_nocase, \"ignorecase\" },\n\t{ Opt_brl, \"brl\" },\n\t{ Opt_nobrl, \"nobrl\" },\n\t{ Opt_nobrl, \"nolock\" },\n\t{ Opt_forcemandatorylock, \"forcemandatorylock\" },\n\t{ Opt_forcemandatorylock, \"forcemand\" },\n\t{ Opt_setuids, \"setuids\" },\n\t{ Opt_nosetuids, \"nosetuids\" },\n\t{ Opt_dynperm, \"dynperm\" },\n\t{ Opt_nodynperm, \"nodynperm\" },\n\t{ Opt_nohard, \"nohard\" },\n\t{ Opt_nosoft, \"nosoft\" },\n\t{ Opt_nointr, \"nointr\" },\n\t{ Opt_intr, \"intr\" },\n\t{ Opt_nostrictsync, \"nostrictsync\" },\n\t{ Opt_strictsync, \"strictsync\" },\n\t{ Opt_serverino, \"serverino\" },\n\t{ Opt_noserverino, \"noserverino\" },\n\t{ Opt_rwpidforward, \"rwpidforward\" },\n\t{ Opt_cifsacl, \"cifsacl\" },\n\t{ Opt_nocifsacl, \"nocifsacl\" },\n\t{ Opt_acl, \"acl\" },\n\t{ Opt_noacl, \"noacl\" },\n\t{ Opt_locallease, \"locallease\" },\n\t{ Opt_sign, \"sign\" },\n\t{ Opt_seal, \"seal\" },\n\t{ Opt_noac, \"noac\" },\n\t{ Opt_fsc, \"fsc\" },\n\t{ Opt_mfsymlinks, \"mfsymlinks\" },\n\t{ Opt_multiuser, \"multiuser\" },\n\t{ Opt_sloppy, \"sloppy\" },\n\t{ Opt_nosharesock, \"nosharesock\" },\n\n\t{ Opt_backupuid, \"backupuid=%s\" },\n\t{ Opt_backupgid, \"backupgid=%s\" },\n\t{ Opt_uid, \"uid=%s\" },\n\t{ Opt_cruid, \"cruid=%s\" },\n\t{ Opt_gid, \"gid=%s\" },\n\t{ Opt_file_mode, \"file_mode=%s\" },\n\t{ Opt_dirmode, \"dirmode=%s\" },\n\t{ Opt_dirmode, \"dir_mode=%s\" },\n\t{ Opt_port, \"port=%s\" },\n\t{ Opt_rsize, \"rsize=%s\" },\n\t{ Opt_wsize, \"wsize=%s\" },\n\t{ Opt_actimeo, \"actimeo=%s\" },\n\n\t{ Opt_blank_user, \"user=\" },\n\t{ Opt_blank_user, \"username=\" },\n\t{ Opt_user, \"user=%s\" },\n\t{ Opt_user, \"username=%s\" },\n\t{ Opt_blank_pass, \"pass=\" },\n\t{ Opt_blank_pass, \"password=\" },\n\t{ Opt_pass, \"pass=%s\" },\n\t{ Opt_pass, \"password=%s\" },\n\t{ Opt_blank_ip, \"ip=\" },\n\t{ Opt_blank_ip, \"addr=\" },\n\t{ Opt_ip, \"ip=%s\" },\n\t{ Opt_ip, \"addr=%s\" },\n\t{ Opt_ignore, \"unc=%s\" },\n\t{ Opt_ignore, \"target=%s\" },\n\t{ Opt_ignore, \"path=%s\" },\n\t{ Opt_domain, \"dom=%s\" },\n\t{ Opt_domain, \"domain=%s\" },\n\t{ Opt_domain, \"workgroup=%s\" },\n\t{ Opt_srcaddr, \"srcaddr=%s\" },\n\t{ Opt_ignore, \"prefixpath=%s\" },\n\t{ Opt_iocharset, \"iocharset=%s\" },\n\t{ Opt_netbiosname, \"netbiosname=%s\" },\n\t{ Opt_servern, \"servern=%s\" },\n\t{ Opt_ver, \"ver=%s\" },\n\t{ Opt_vers, \"vers=%s\" },\n\t{ Opt_sec, \"sec=%s\" },\n\t{ Opt_cache, \"cache=%s\" },\n\n\t{ Opt_ignore, \"cred\" },\n\t{ Opt_ignore, \"credentials\" },\n\t{ Opt_ignore, \"cred=%s\" },\n\t{ Opt_ignore, \"credentials=%s\" },\n\t{ Opt_ignore, \"guest\" },\n\t{ Opt_ignore, \"rw\" },\n\t{ Opt_ignore, \"ro\" },\n\t{ Opt_ignore, \"suid\" },\n\t{ Opt_ignore, \"nosuid\" },\n\t{ Opt_ignore, \"exec\" },\n\t{ Opt_ignore, \"noexec\" },\n\t{ Opt_ignore, \"nodev\" },\n\t{ Opt_ignore, \"noauto\" },\n\t{ Opt_ignore, \"dev\" },\n\t{ Opt_ignore, \"mand\" },\n\t{ Opt_ignore, \"nomand\" },\n\t{ Opt_ignore, \"_netdev\" },\n\n\t{ Opt_err, NULL }\n};",
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);",
      "static int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mountdata_copy"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "string"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not allocate temporary buffer\\n\""
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mountdata_copy"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"CIFS: ignoring forcegid mount option specified with no gid= option.\\n\""
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"CIFS: ignoring forceuid mount option specified with no uid= option.\\n\""
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_set_port",
          "args": [
            "dstaddr",
            "port"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "207-218",
          "snippet": "void\ncifs_set_port(struct sockaddr *addr, const unsigned short int port)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)addr)->sin_port = htons(port);\n\t\tbreak;\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)addr)->sin6_port = htons(port);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\nvoid\ncifs_set_port(struct sockaddr *addr, const unsigned short int port)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)addr)->sin_port = htons(port);\n\t\tbreak;\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)addr)->sin6_port = htons(port);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to determine destination address.\\n\""
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_convert_address",
          "args": [
            "dstaddr",
            "&vol->UNC[2]",
            "strlen(&vol->UNC[2])"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "168-205",
          "snippet": "int\ncifs_convert_address(struct sockaddr *dst, const char *src, int len)\n{\n\tint rc, alen, slen;\n\tconst char *pct;\n\tchar scope_id[13];\n\tstruct sockaddr_in *s4 = (struct sockaddr_in *) dst;\n\tstruct sockaddr_in6 *s6 = (struct sockaddr_in6 *) dst;\n\n\t/* IPv4 address */\n\tif (cifs_inet_pton(AF_INET, src, len, &s4->sin_addr.s_addr)) {\n\t\ts4->sin_family = AF_INET;\n\t\treturn 1;\n\t}\n\n\t/* attempt to exclude the scope ID from the address part */\n\tpct = memchr(src, '%', len);\n\talen = pct ? pct - src : len;\n\n\trc = cifs_inet_pton(AF_INET6, src, alen, &s6->sin6_addr.s6_addr);\n\tif (!rc)\n\t\treturn rc;\n\n\ts6->sin6_family = AF_INET6;\n\tif (pct) {\n\t\t/* grab the scope ID */\n\t\tslen = len - (alen + 1);\n\t\tif (slen <= 0 || slen > 12)\n\t\t\treturn 0;\n\t\tmemcpy(scope_id, pct + 1, slen);\n\t\tscope_id[slen] = '\\0';\n\n\t\trc = kstrtouint(scope_id, 0, &s6->sin6_scope_id);\n\t\trc = (rc == 0) ? 1 : 0;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\nint\ncifs_convert_address(struct sockaddr *dst, const char *src, int len)\n{\n\tint rc, alen, slen;\n\tconst char *pct;\n\tchar scope_id[13];\n\tstruct sockaddr_in *s4 = (struct sockaddr_in *) dst;\n\tstruct sockaddr_in6 *s6 = (struct sockaddr_in6 *) dst;\n\n\t/* IPv4 address */\n\tif (cifs_inet_pton(AF_INET, src, len, &s4->sin_addr.s_addr)) {\n\t\ts4->sin_family = AF_INET;\n\t\treturn 1;\n\t}\n\n\t/* attempt to exclude the scope ID from the address part */\n\tpct = memchr(src, '%', len);\n\talen = pct ? pct - src : len;\n\n\trc = cifs_inet_pton(AF_INET6, src, alen, &s6->sin6_addr.s6_addr);\n\tif (!rc)\n\t\treturn rc;\n\n\ts6->sin6_family = AF_INET6;\n\tif (pct) {\n\t\t/* grab the scope ID */\n\t\tslen = len - (alen + 1);\n\t\tif (slen <= 0 || slen > 12)\n\t\t\treturn 0;\n\t\tmemcpy(scope_id, pct + 1, slen);\n\t\tscope_id[slen] = '\\0';\n\n\t\trc = kstrtouint(scope_id, 0, &s6->sin6_scope_id);\n\t\trc = (rc == 0) ? 1 : 0;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "&vol->UNC[2]"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Malformed UNC. Unable to find share name.\\n\""
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "vol->UNC + 3",
            "'\\\\'"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"CIFS mount error: No usable UNC path provided in device string!\\n\""
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Multiuser mounts require kernels with CONFIG_KEYS enabled\\n\""
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"CIFS: Unknown mount option \\\"%s\\\"\\n\"",
            "invalid"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "string"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_parse_cache_flavor",
          "args": [
            "string",
            "vol"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_parse_cache_flavor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "1085-1108",
          "snippet": "static int\ncifs_parse_cache_flavor(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_cacheflavor_tokens, args)) {\n\tcase Opt_cache_loose:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tcase Opt_cache_strict:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = true;\n\t\tbreak;\n\tcase Opt_cache_none:\n\t\tvol->direct_io = true;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad cache= option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t cifs_cacheflavor_tokens = {\n\t{ Opt_cache_loose, \"loose\" },\n\t{ Opt_cache_strict, \"strict\" },\n\t{ Opt_cache_none, \"none\" },\n\t{ Opt_cache_err, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic const match_table_t cifs_cacheflavor_tokens = {\n\t{ Opt_cache_loose, \"loose\" },\n\t{ Opt_cache_strict, \"strict\" },\n\t{ Opt_cache_none, \"none\" },\n\t{ Opt_cache_err, NULL }\n};\n\nstatic int\ncifs_parse_cache_flavor(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_cacheflavor_tokens, args)) {\n\tcase Opt_cache_loose:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tcase Opt_cache_strict:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = true;\n\t\tbreak;\n\tcase Opt_cache_none:\n\t\tvol->direct_io = true;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad cache= option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_parse_security_flavors",
          "args": [
            "string",
            "vol"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_parse_security_flavors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "1028-1083",
          "snippet": "static int cifs_parse_security_flavors(char *value,\n\t\t\t\t       struct smb_vol *vol)\n{\n\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t/*\n\t * With mount options, the last one should win. Reset any existing\n\t * settings back to default.\n\t */\n\tvol->sectype = Unspecified;\n\tvol->sign = false;\n\n\tswitch (match_token(value, cifs_secflavor_tokens, args)) {\n\tcase Opt_sec_krb5p:\n\t\tcifs_dbg(VFS, \"sec=krb5p is not supported!\\n\");\n\t\treturn 1;\n\tcase Opt_sec_krb5i:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_krb5:\n\t\tvol->sectype = Kerberos;\n\t\tbreak;\n\tcase Opt_sec_ntlmsspi:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_ntlmssp:\n\t\tvol->sectype = RawNTLMSSP;\n\t\tbreak;\n\tcase Opt_sec_ntlmi:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_ntlm:\n\t\tvol->sectype = NTLM;\n\t\tbreak;\n\tcase Opt_sec_ntlmv2i:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_ntlmv2:\n\t\tvol->sectype = NTLMv2;\n\t\tbreak;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\tcase Opt_sec_lanman:\n\t\tvol->sectype = LANMAN;\n\t\tbreak;\n#endif\n\tcase Opt_sec_none:\n\t\tvol->nullauth = 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad security option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t cifs_secflavor_tokens = {\n\t{ Opt_sec_krb5, \"krb5\" },\n\t{ Opt_sec_krb5i, \"krb5i\" },\n\t{ Opt_sec_krb5p, \"krb5p\" },\n\t{ Opt_sec_ntlmsspi, \"ntlmsspi\" },\n\t{ Opt_sec_ntlmssp, \"ntlmssp\" },\n\t{ Opt_ntlm, \"ntlm\" },\n\t{ Opt_sec_ntlmi, \"ntlmi\" },\n\t{ Opt_sec_ntlmv2, \"nontlm\" },\n\t{ Opt_sec_ntlmv2, \"ntlmv2\" },\n\t{ Opt_sec_ntlmv2i, \"ntlmv2i\" },\n\t{ Opt_sec_lanman, \"lanman\" },\n\t{ Opt_sec_none, \"none\" },\n\n\t{ Opt_sec_err, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic const match_table_t cifs_secflavor_tokens = {\n\t{ Opt_sec_krb5, \"krb5\" },\n\t{ Opt_sec_krb5i, \"krb5i\" },\n\t{ Opt_sec_krb5p, \"krb5p\" },\n\t{ Opt_sec_ntlmsspi, \"ntlmsspi\" },\n\t{ Opt_sec_ntlmssp, \"ntlmssp\" },\n\t{ Opt_ntlm, \"ntlm\" },\n\t{ Opt_sec_ntlmi, \"ntlmi\" },\n\t{ Opt_sec_ntlmv2, \"nontlm\" },\n\t{ Opt_sec_ntlmv2, \"ntlmv2\" },\n\t{ Opt_sec_ntlmv2i, \"ntlmv2i\" },\n\t{ Opt_sec_lanman, \"lanman\" },\n\t{ Opt_sec_none, \"none\" },\n\n\t{ Opt_sec_err, NULL }\n};\n\nstatic int cifs_parse_security_flavors(char *value,\n\t\t\t\t       struct smb_vol *vol)\n{\n\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t/*\n\t * With mount options, the last one should win. Reset any existing\n\t * settings back to default.\n\t */\n\tvol->sectype = Unspecified;\n\tvol->sign = false;\n\n\tswitch (match_token(value, cifs_secflavor_tokens, args)) {\n\tcase Opt_sec_krb5p:\n\t\tcifs_dbg(VFS, \"sec=krb5p is not supported!\\n\");\n\t\treturn 1;\n\tcase Opt_sec_krb5i:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_krb5:\n\t\tvol->sectype = Kerberos;\n\t\tbreak;\n\tcase Opt_sec_ntlmsspi:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_ntlmssp:\n\t\tvol->sectype = RawNTLMSSP;\n\t\tbreak;\n\tcase Opt_sec_ntlmi:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_ntlm:\n\t\tvol->sectype = NTLM;\n\t\tbreak;\n\tcase Opt_sec_ntlmv2i:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_ntlmv2:\n\t\tvol->sectype = NTLMv2;\n\t\tbreak;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\tcase Opt_sec_lanman:\n\t\tvol->sectype = LANMAN;\n\t\tbreak;\n#endif\n\tcase Opt_sec_none:\n\t\tvol->nullauth = 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad security option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_parse_smb_version",
          "args": [
            "string",
            "vol"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_parse_smb_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "1110-1143",
          "snippet": "static int\ncifs_parse_smb_version(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_smb_version_tokens, args)) {\n\tcase Smb_1:\n\t\tvol->ops = &smb1_operations;\n\t\tvol->vals = &smb1_values;\n\t\tbreak;\n#ifdef CONFIG_CIFS_SMB2\n\tcase Smb_20:\n\t\tvol->ops = &smb20_operations;\n\t\tvol->vals = &smb20_values;\n\t\tbreak;\n\tcase Smb_21:\n\t\tvol->ops = &smb21_operations;\n\t\tvol->vals = &smb21_values;\n\t\tbreak;\n\tcase Smb_30:\n\t\tvol->ops = &smb30_operations;\n\t\tvol->vals = &smb30_values;\n\t\tbreak;\n\tcase Smb_302:\n\t\tvol->ops = &smb30_operations; /* currently identical with 3.0 */\n\t\tvol->vals = &smb302_values;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown vers= option specified: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t cifs_smb_version_tokens = {\n\t{ Smb_1, SMB1_VERSION_STRING },\n\t{ Smb_20, SMB20_VERSION_STRING},\n\t{ Smb_21, SMB21_VERSION_STRING },\n\t{ Smb_30, SMB30_VERSION_STRING },\n\t{ Smb_302, SMB302_VERSION_STRING },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic const match_table_t cifs_smb_version_tokens = {\n\t{ Smb_1, SMB1_VERSION_STRING },\n\t{ Smb_20, SMB20_VERSION_STRING},\n\t{ Smb_21, SMB21_VERSION_STRING },\n\t{ Smb_30, SMB30_VERSION_STRING },\n\t{ Smb_302, SMB302_VERSION_STRING },\n};\n\nstatic int\ncifs_parse_smb_version(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_smb_version_tokens, args)) {\n\tcase Smb_1:\n\t\tvol->ops = &smb1_operations;\n\t\tvol->vals = &smb1_values;\n\t\tbreak;\n#ifdef CONFIG_CIFS_SMB2\n\tcase Smb_20:\n\t\tvol->ops = &smb20_operations;\n\t\tvol->vals = &smb20_values;\n\t\tbreak;\n\tcase Smb_21:\n\t\tvol->ops = &smb21_operations;\n\t\tvol->vals = &smb21_values;\n\t\tbreak;\n\tcase Smb_30:\n\t\tvol->ops = &smb30_operations;\n\t\tvol->vals = &smb30_values;\n\t\tbreak;\n\tcase Smb_302:\n\t\tvol->ops = &smb30_operations; /* currently identical with 3.0 */\n\t\tvol->vals = &smb302_values;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown vers= option specified: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: Invalid version specified\\n\""
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "string",
            "\"1\"",
            "1"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: server netbiosname longer than 15 truncated.\\n\""
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vol->target_rfc1001_name",
            "0x20",
            "RFC1001_NAME_LEN_WITH_NULL"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: netbiosname longer than 15 truncated.\\n\""
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vol->source_rfc1001_name",
            "0x20",
            "RFC1001_NAME_LEN"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"iocharset set to %s\\n\"",
            "string"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: no memory for charset\\n\""
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "string",
            "GFP_KERNEL"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "string",
            "\"default\"",
            "7"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: iocharset name too long.\\n\""
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "string",
            "1024"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: Could not parse srcaddr: %s\\n\"",
            "string"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Domain name set\\n\""
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: no memory for domainname\\n\""
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "string",
            "GFP_KERNEL"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: domain name too long\\n\""
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "string",
            "CIFS_MAX_DOMAINNAME_LEN"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"CIFS: bad ip= option (%s).\\n\"",
            "string"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: no memory for password\\n\""
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "temp_len+1",
            "GFP_KERNEL"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol->password"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tmp_end",
            "delim"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "data",
            "'='"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol->password"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "data",
            "'='"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "string",
            "GFP_KERNEL"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: username too long\\n\""
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "string",
            "CIFS_MAX_USERNAME_LEN"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"attribute cache timeout too large\\n\""
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid actimeo value\\n\"",
            "__func__"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option_ul",
          "args": [
            "args",
            "&option"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "get_option_ul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "978-990",
          "snippet": "static int get_option_ul(substring_t args[], unsigned long *option)\n{\n\tint rc;\n\tchar *string;\n\n\tstring = match_strdup(args);\n\tif (string == NULL)\n\t\treturn -ENOMEM;\n\trc = kstrtoul(string, 0, option);\n\tkfree(string);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int get_option_ul(substring_t args[], unsigned long *option)\n{\n\tint rc;\n\tchar *string;\n\n\tstring = match_strdup(args);\n\tif (string == NULL)\n\t\treturn -ENOMEM;\n\trc = kstrtoul(string, 0, option);\n\tkfree(string);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid wsize value\\n\"",
            "__func__"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid rsize value\\n\"",
            "__func__"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid port value\\n\"",
            "__func__"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid dir_mode value\\n\"",
            "__func__"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid file_mode value\\n\"",
            "__func__"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid gid value\\n\"",
            "__func__"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option_gid",
          "args": [
            "args",
            "&vol->linux_gid"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "get_option_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "1010-1026",
          "snippet": "static int get_option_gid(substring_t args[], kgid_t *result)\n{\n\tunsigned long value;\n\tkgid_t gid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tgid = make_kgid(current_user_ns(), value);\n\tif (!gid_valid(gid))\n\t\treturn -EINVAL;\n\n\t*result = gid;\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int get_option_gid(substring_t args[], kgid_t *result)\n{\n\tunsigned long value;\n\tkgid_t gid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tgid = make_kgid(current_user_ns(), value);\n\tif (!gid_valid(gid))\n\t\treturn -EINVAL;\n\n\t*result = gid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid cruid value\\n\"",
            "__func__"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option_uid",
          "args": [
            "args",
            "&vol->cred_uid"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "get_option_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "992-1008",
          "snippet": "static int get_option_uid(substring_t args[], kuid_t *result)\n{\n\tunsigned long value;\n\tkuid_t uid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tuid = make_kuid(current_user_ns(), value);\n\tif (!uid_valid(uid))\n\t\treturn -EINVAL;\n\n\t*result = uid;\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int get_option_uid(substring_t args[], kuid_t *result)\n{\n\tunsigned long value;\n\tkuid_t uid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tuid = make_kuid(current_user_ns(), value);\n\tif (!uid_valid(uid))\n\t\treturn -EINVAL;\n\n\t*result = uid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid uid value\\n\"",
            "__func__"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid backupgid value\\n\"",
            "__func__"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Invalid backupuid value\\n\"",
            "__func__"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\\n\""
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CIFS: Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\\n\""
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "data",
            "cifs_mount_option_tokens",
            "args"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "separator"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Unknown error parsing devname.\\n\""
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Malformed UNC in devname.\\n\""
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Unable to allocate memory for devname.\\n\""
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_parse_devname",
          "args": [
            "devname",
            "vol"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_parse_devname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "1149-1189",
          "snippet": "static int\ncifs_parse_devname(const char *devname, struct smb_vol *vol)\n{\n\tchar *pos;\n\tconst char *delims = \"/\\\\\";\n\tsize_t len;\n\n\t/* make sure we have a valid UNC double delimiter prefix */\n\tlen = strspn(devname, delims);\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\t/* find delimiter between host and sharename */\n\tpos = strpbrk(devname + 2, delims);\n\tif (!pos)\n\t\treturn -EINVAL;\n\n\t/* skip past delimiter */\n\t++pos;\n\n\t/* now go until next delimiter or end of string */\n\tlen = strcspn(pos, delims);\n\n\t/* move \"pos\" up to delimiter or NULL */\n\tpos += len;\n\tvol->UNC = kstrndup(devname, pos - devname, GFP_KERNEL);\n\tif (!vol->UNC)\n\t\treturn -ENOMEM;\n\n\tconvert_delimiter(vol->UNC, '\\\\');\n\n\t/* If pos is NULL, or is a bogus trailing delimiter then no prepath */\n\tif (!*pos++ || !*pos)\n\t\treturn 0;\n\n\tvol->prepath = kstrdup(pos, GFP_KERNEL);\n\tif (!vol->prepath)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\nstatic int\ncifs_parse_devname(const char *devname, struct smb_vol *vol)\n{\n\tchar *pos;\n\tconst char *delims = \"/\\\\\";\n\tsize_t len;\n\n\t/* make sure we have a valid UNC double delimiter prefix */\n\tlen = strspn(devname, delims);\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\t/* find delimiter between host and sharename */\n\tpos = strpbrk(devname + 2, delims);\n\tif (!pos)\n\t\treturn -EINVAL;\n\n\t/* skip past delimiter */\n\t++pos;\n\n\t/* now go until next delimiter or end of string */\n\tlen = strcspn(pos, delims);\n\n\t/* move \"pos\" up to delimiter or NULL */\n\tpos += len;\n\tvol->UNC = kstrndup(devname, pos - devname, GFP_KERNEL);\n\tif (!vol->UNC)\n\t\treturn -ENOMEM;\n\n\tconvert_delimiter(vol->UNC, '\\\\');\n\n\t/* If pos is NULL, or is a bogus trailing delimiter then no prepath */\n\tif (!*pos++ || !*pos)\n\t\treturn 0;\n\n\tvol->prepath = kstrdup(pos, GFP_KERNEL);\n\tif (!vol->prepath)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Null separator not allowed\\n\""
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "options",
            "\"sep=\"",
            "4"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "mountdata",
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "nodename[i]"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/winucase.c",
          "lines": "639-663",
          "snippet": "wchar_t\ncifs_toupper(wchar_t in)\n{\n\tunsigned char idx;\n\tconst wchar_t *tbl;\n\twchar_t out;\n\n\t/* grab upper byte */\n\tidx = (in & 0xff00) >> 8;\n\n\t/* find pointer to 2nd layer table */\n\ttbl = toplevel[idx];\n\tif (!tbl)\n\t\treturn in;\n\n\t/* grab lower byte */\n\tidx = in & 0xff;\n\n\t/* look up character in table */\n\tout = tbl[idx];\n\tif (out)\n\t\treturn out;\n\n\treturn in;\n}",
          "includes": [
            "#include <linux/nls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wchar_t cifs_toupper(wchar_t in);",
            "static const wchar_t *const toplevel[256] = {\n\tt2_00, t2_01, t2_02, t2_03, t2_04, t2_05,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL, t2_1d, t2_1e, t2_1f,\n\tNULL, t2_21,  NULL,  NULL, t2_24,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL, t2_2c, t2_2d,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_a6, t2_a7,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_ff,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n\nwchar_t cifs_toupper(wchar_t in);\nstatic const wchar_t *const toplevel[256] = {\n\tt2_00, t2_01, t2_02, t2_03, t2_04, t2_05,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL, t2_1d, t2_1e, t2_1f,\n\tNULL, t2_21,  NULL,  NULL, t2_24,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL, t2_2c, t2_2d,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_a6, t2_a7,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_ff,\n};\n\nwchar_t\ncifs_toupper(wchar_t in)\n{\n\tunsigned char idx;\n\tconst wchar_t *tbl;\n\twchar_t out;\n\n\t/* grab upper byte */\n\tidx = (in & 0xff00) >> 8;\n\n\t/* find pointer to 2nd layer table */\n\ttbl = toplevel[idx];\n\tif (!tbl)\n\t\treturn in;\n\n\t/* grab lower byte */\n\tidx = in & 0xff;\n\n\t/* look up character in table */\n\tout = tbl[idx];\n\tif (out)\n\t\treturn out;\n\n\treturn in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "nodename",
            "RFC1001_NAME_LEN"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vol->source_rfc1001_name",
            "0x20",
            "RFC1001_NAME_LEN"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vol",
            "0",
            "sizeof(*vol)"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utsname",
          "args": [],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic const match_table_t cifs_mount_option_tokens = {\n\n\t{ Opt_user_xattr, \"user_xattr\" },\n\t{ Opt_nouser_xattr, \"nouser_xattr\" },\n\t{ Opt_forceuid, \"forceuid\" },\n\t{ Opt_noforceuid, \"noforceuid\" },\n\t{ Opt_forcegid, \"forcegid\" },\n\t{ Opt_noforcegid, \"noforcegid\" },\n\t{ Opt_noblocksend, \"noblocksend\" },\n\t{ Opt_noautotune, \"noautotune\" },\n\t{ Opt_hard, \"hard\" },\n\t{ Opt_soft, \"soft\" },\n\t{ Opt_perm, \"perm\" },\n\t{ Opt_noperm, \"noperm\" },\n\t{ Opt_mapchars, \"mapchars\" }, /* SFU style */\n\t{ Opt_nomapchars, \"nomapchars\" },\n\t{ Opt_mapposix, \"mapposix\" }, /* SFM style */\n\t{ Opt_nomapposix, \"nomapposix\" },\n\t{ Opt_sfu, \"sfu\" },\n\t{ Opt_nosfu, \"nosfu\" },\n\t{ Opt_nodfs, \"nodfs\" },\n\t{ Opt_posixpaths, \"posixpaths\" },\n\t{ Opt_noposixpaths, \"noposixpaths\" },\n\t{ Opt_nounix, \"nounix\" },\n\t{ Opt_nounix, \"nolinux\" },\n\t{ Opt_nocase, \"nocase\" },\n\t{ Opt_nocase, \"ignorecase\" },\n\t{ Opt_brl, \"brl\" },\n\t{ Opt_nobrl, \"nobrl\" },\n\t{ Opt_nobrl, \"nolock\" },\n\t{ Opt_forcemandatorylock, \"forcemandatorylock\" },\n\t{ Opt_forcemandatorylock, \"forcemand\" },\n\t{ Opt_setuids, \"setuids\" },\n\t{ Opt_nosetuids, \"nosetuids\" },\n\t{ Opt_dynperm, \"dynperm\" },\n\t{ Opt_nodynperm, \"nodynperm\" },\n\t{ Opt_nohard, \"nohard\" },\n\t{ Opt_nosoft, \"nosoft\" },\n\t{ Opt_nointr, \"nointr\" },\n\t{ Opt_intr, \"intr\" },\n\t{ Opt_nostrictsync, \"nostrictsync\" },\n\t{ Opt_strictsync, \"strictsync\" },\n\t{ Opt_serverino, \"serverino\" },\n\t{ Opt_noserverino, \"noserverino\" },\n\t{ Opt_rwpidforward, \"rwpidforward\" },\n\t{ Opt_cifsacl, \"cifsacl\" },\n\t{ Opt_nocifsacl, \"nocifsacl\" },\n\t{ Opt_acl, \"acl\" },\n\t{ Opt_noacl, \"noacl\" },\n\t{ Opt_locallease, \"locallease\" },\n\t{ Opt_sign, \"sign\" },\n\t{ Opt_seal, \"seal\" },\n\t{ Opt_noac, \"noac\" },\n\t{ Opt_fsc, \"fsc\" },\n\t{ Opt_mfsymlinks, \"mfsymlinks\" },\n\t{ Opt_multiuser, \"multiuser\" },\n\t{ Opt_sloppy, \"sloppy\" },\n\t{ Opt_nosharesock, \"nosharesock\" },\n\n\t{ Opt_backupuid, \"backupuid=%s\" },\n\t{ Opt_backupgid, \"backupgid=%s\" },\n\t{ Opt_uid, \"uid=%s\" },\n\t{ Opt_cruid, \"cruid=%s\" },\n\t{ Opt_gid, \"gid=%s\" },\n\t{ Opt_file_mode, \"file_mode=%s\" },\n\t{ Opt_dirmode, \"dirmode=%s\" },\n\t{ Opt_dirmode, \"dir_mode=%s\" },\n\t{ Opt_port, \"port=%s\" },\n\t{ Opt_rsize, \"rsize=%s\" },\n\t{ Opt_wsize, \"wsize=%s\" },\n\t{ Opt_actimeo, \"actimeo=%s\" },\n\n\t{ Opt_blank_user, \"user=\" },\n\t{ Opt_blank_user, \"username=\" },\n\t{ Opt_user, \"user=%s\" },\n\t{ Opt_user, \"username=%s\" },\n\t{ Opt_blank_pass, \"pass=\" },\n\t{ Opt_blank_pass, \"password=\" },\n\t{ Opt_pass, \"pass=%s\" },\n\t{ Opt_pass, \"password=%s\" },\n\t{ Opt_blank_ip, \"ip=\" },\n\t{ Opt_blank_ip, \"addr=\" },\n\t{ Opt_ip, \"ip=%s\" },\n\t{ Opt_ip, \"addr=%s\" },\n\t{ Opt_ignore, \"unc=%s\" },\n\t{ Opt_ignore, \"target=%s\" },\n\t{ Opt_ignore, \"path=%s\" },\n\t{ Opt_domain, \"dom=%s\" },\n\t{ Opt_domain, \"domain=%s\" },\n\t{ Opt_domain, \"workgroup=%s\" },\n\t{ Opt_srcaddr, \"srcaddr=%s\" },\n\t{ Opt_ignore, \"prefixpath=%s\" },\n\t{ Opt_iocharset, \"iocharset=%s\" },\n\t{ Opt_netbiosname, \"netbiosname=%s\" },\n\t{ Opt_servern, \"servern=%s\" },\n\t{ Opt_ver, \"ver=%s\" },\n\t{ Opt_vers, \"vers=%s\" },\n\t{ Opt_sec, \"sec=%s\" },\n\t{ Opt_cache, \"cache=%s\" },\n\n\t{ Opt_ignore, \"cred\" },\n\t{ Opt_ignore, \"credentials\" },\n\t{ Opt_ignore, \"cred=%s\" },\n\t{ Opt_ignore, \"credentials=%s\" },\n\t{ Opt_ignore, \"guest\" },\n\t{ Opt_ignore, \"rw\" },\n\t{ Opt_ignore, \"ro\" },\n\t{ Opt_ignore, \"suid\" },\n\t{ Opt_ignore, \"nosuid\" },\n\t{ Opt_ignore, \"exec\" },\n\t{ Opt_ignore, \"noexec\" },\n\t{ Opt_ignore, \"nodev\" },\n\t{ Opt_ignore, \"noauto\" },\n\t{ Opt_ignore, \"dev\" },\n\t{ Opt_ignore, \"mand\" },\n\t{ Opt_ignore, \"nomand\" },\n\t{ Opt_ignore, \"_netdev\" },\n\n\t{ Opt_err, NULL }\n};\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\nstatic int\ncifs_parse_mount_options(const char *mountdata, const char *devname,\n\t\t\t struct smb_vol *vol)\n{\n\tchar *data, *end;\n\tchar *mountdata_copy = NULL, *options;\n\tunsigned int  temp_len, i, j;\n\tchar separator[2];\n\tshort int override_uid = -1;\n\tshort int override_gid = -1;\n\tbool uid_specified = false;\n\tbool gid_specified = false;\n\tbool sloppy = false;\n\tchar *invalid = NULL;\n\tchar *nodename = utsname()->nodename;\n\tchar *string = NULL;\n\tchar *tmp_end, *value;\n\tchar delim;\n\tbool got_ip = false;\n\tunsigned short port = 0;\n\tstruct sockaddr *dstaddr = (struct sockaddr *)&vol->dstaddr;\n\n\tseparator[0] = ',';\n\tseparator[1] = 0;\n\tdelim = separator[0];\n\n\t/* ensure we always start with zeroed-out smb_vol */\n\tmemset(vol, 0, sizeof(*vol));\n\n\t/*\n\t * does not have to be perfect mapping since field is\n\t * informational, only used for servers that do not support\n\t * port 445 and it can be overridden at mount time\n\t */\n\tmemset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);\n\tfor (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)\n\t\tvol->source_rfc1001_name[i] = toupper(nodename[i]);\n\n\tvol->source_rfc1001_name[RFC1001_NAME_LEN] = 0;\n\t/* null target name indicates to use *SMBSERVR default called name\n\t   if we end up sending RFC1001 session initialize */\n\tvol->target_rfc1001_name[0] = 0;\n\tvol->cred_uid = current_uid();\n\tvol->linux_uid = current_uid();\n\tvol->linux_gid = current_gid();\n\n\t/*\n\t * default to SFM style remapping of seven reserved characters\n\t * unless user overrides it or we negotiate CIFS POSIX where\n\t * it is unnecessary.  Can not simultaneously use more than one mapping\n\t * since then readdir could list files that open could not open\n\t */\n\tvol->remap = true;\n\n\t/* default to only allowing write access to owner of the mount */\n\tvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t/* vol->retry default is 0 (i.e. \"soft\" limited retry not hard retry) */\n\t/* default is always to request posix paths. */\n\tvol->posix_paths = 1;\n\t/* default to using server inode numbers where available */\n\tvol->server_ino = 1;\n\n\t/* default is to use strict cifs caching semantics */\n\tvol->strict_io = true;\n\n\tvol->actimeo = CIFS_DEF_ACTIMEO;\n\n\t/* FIXME: add autonegotiation -- for now, SMB1 is default */\n\tvol->ops = &smb1_operations;\n\tvol->vals = &smb1_values;\n\n\tif (!mountdata)\n\t\tgoto cifs_parse_mount_err;\n\n\tmountdata_copy = kstrndup(mountdata, PAGE_SIZE, GFP_KERNEL);\n\tif (!mountdata_copy)\n\t\tgoto cifs_parse_mount_err;\n\n\toptions = mountdata_copy;\n\tend = options + strlen(options);\n\n\tif (strncmp(options, \"sep=\", 4) == 0) {\n\t\tif (options[4] != 0) {\n\t\t\tseparator[0] = options[4];\n\t\t\toptions += 5;\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"Null separator not allowed\\n\");\n\t\t}\n\t}\n\tvol->backupuid_specified = false; /* no backup intent for a user */\n\tvol->backupgid_specified = false; /* no backup intent for a group */\n\n\tswitch (cifs_parse_devname(devname, vol)) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOMEM:\n\t\tcifs_dbg(VFS, \"Unable to allocate memory for devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tcase -EINVAL:\n\t\tcifs_dbg(VFS, \"Malformed UNC in devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown error parsing devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\twhile ((data = strsep(&options, separator)) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned long option;\n\t\tint token;\n\n\t\tif (!*data)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(data, cifs_mount_option_tokens, args);\n\n\t\tswitch (token) {\n\n\t\t/* Ingnore the following */\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\n\t\t/* Boolean values */\n\t\tcase Opt_user_xattr:\n\t\t\tvol->no_xattr = 0;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tvol->no_xattr = 1;\n\t\t\tbreak;\n\t\tcase Opt_forceuid:\n\t\t\toverride_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforceuid:\n\t\t\toverride_uid = 0;\n\t\t\tbreak;\n\t\tcase Opt_forcegid:\n\t\t\toverride_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforcegid:\n\t\t\toverride_gid = 0;\n\t\t\tbreak;\n\t\tcase Opt_noblocksend:\n\t\t\tvol->noblocksnd = 1;\n\t\t\tbreak;\n\t\tcase Opt_noautotune:\n\t\t\tvol->noautotune = 1;\n\t\t\tbreak;\n\t\tcase Opt_hard:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_soft:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_perm:\n\t\t\tvol->noperm = 0;\n\t\t\tbreak;\n\t\tcase Opt_noperm:\n\t\t\tvol->noperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_mapchars:\n\t\t\tvol->sfu_remap = true;\n\t\t\tvol->remap = false; /* disable SFM mapping */\n\t\t\tbreak;\n\t\tcase Opt_nomapchars:\n\t\t\tvol->sfu_remap = false;\n\t\t\tbreak;\n\t\tcase Opt_mapposix:\n\t\t\tvol->remap = true;\n\t\t\tvol->sfu_remap = false; /* disable SFU mapping */\n\t\t\tbreak;\n\t\tcase Opt_nomapposix:\n\t\t\tvol->remap = false;\n\t\t\tbreak;\n\t\tcase Opt_sfu:\n\t\t\tvol->sfu_emul = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosfu:\n\t\t\tvol->sfu_emul = 0;\n\t\t\tbreak;\n\t\tcase Opt_nodfs:\n\t\t\tvol->nodfs = 1;\n\t\t\tbreak;\n\t\tcase Opt_posixpaths:\n\t\t\tvol->posix_paths = 1;\n\t\t\tbreak;\n\t\tcase Opt_noposixpaths:\n\t\t\tvol->posix_paths = 0;\n\t\t\tbreak;\n\t\tcase Opt_nounix:\n\t\t\tvol->no_linux_ext = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tvol->nocase = 1;\n\t\t\tbreak;\n\t\tcase Opt_brl:\n\t\t\tvol->nobrl =  0;\n\t\t\tbreak;\n\t\tcase Opt_nobrl:\n\t\t\tvol->nobrl =  1;\n\t\t\t/*\n\t\t\t * turn off mandatory locking in mode\n\t\t\t * if remote locking is turned off since the\n\t\t\t * local vfs will do advisory\n\t\t\t */\n\t\t\tif (vol->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tvol->file_mode = S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_forcemandatorylock:\n\t\t\tvol->mand_lock = 1;\n\t\t\tbreak;\n\t\tcase Opt_setuids:\n\t\t\tvol->setuids = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosetuids:\n\t\t\tvol->setuids = 0;\n\t\t\tbreak;\n\t\tcase Opt_dynperm:\n\t\t\tvol->dynperm = true;\n\t\t\tbreak;\n\t\tcase Opt_nodynperm:\n\t\t\tvol->dynperm = false;\n\t\t\tbreak;\n\t\tcase Opt_nohard:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_nosoft:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tvol->intr = 0;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tvol->intr = 1;\n\t\t\tbreak;\n\t\tcase Opt_nostrictsync:\n\t\t\tvol->nostrictsync = 1;\n\t\t\tbreak;\n\t\tcase Opt_strictsync:\n\t\t\tvol->nostrictsync = 0;\n\t\t\tbreak;\n\t\tcase Opt_serverino:\n\t\t\tvol->server_ino = 1;\n\t\t\tbreak;\n\t\tcase Opt_noserverino:\n\t\t\tvol->server_ino = 0;\n\t\t\tbreak;\n\t\tcase Opt_rwpidforward:\n\t\t\tvol->rwpidforward = 1;\n\t\t\tbreak;\n\t\tcase Opt_cifsacl:\n\t\t\tvol->cifs_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocifsacl:\n\t\t\tvol->cifs_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tvol->no_psx_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tvol->no_psx_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_locallease:\n\t\t\tvol->local_lease = 1;\n\t\t\tbreak;\n\t\tcase Opt_sign:\n\t\t\tvol->sign = true;\n\t\t\tbreak;\n\t\tcase Opt_seal:\n\t\t\t/* we do not do the following in secFlags because seal\n\t\t\t * is a per tree connection (mount) not a per socket\n\t\t\t * or per-smb connection option in the protocol\n\t\t\t * vol->secFlg |= CIFSSEC_MUST_SEAL;\n\t\t\t */\n\t\t\tvol->seal = 1;\n\t\t\tbreak;\n\t\tcase Opt_noac:\n\t\t\tpr_warn(\"CIFS: Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\t\tbreak;\n\t\tcase Opt_fsc:\n#ifndef CONFIG_CIFS_FSCACHE\n\t\t\tcifs_dbg(VFS, \"FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n#endif\n\t\t\tvol->fsc = true;\n\t\t\tbreak;\n\t\tcase Opt_mfsymlinks:\n\t\t\tvol->mfsymlinks = true;\n\t\t\tbreak;\n\t\tcase Opt_multiuser:\n\t\t\tvol->multiuser = true;\n\t\t\tbreak;\n\t\tcase Opt_sloppy:\n\t\t\tsloppy = true;\n\t\t\tbreak;\n\t\tcase Opt_nosharesock:\n\t\t\tvol->nosharesock = true;\n\t\t\tbreak;\n\n\t\t/* Numeric Values */\n\t\tcase Opt_backupuid:\n\t\t\tif (get_option_uid(args, &vol->backupuid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupuid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_backupgid:\n\t\t\tif (get_option_gid(args, &vol->backupgid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupgid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (get_option_uid(args, &vol->linux_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid uid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_cruid:\n\t\t\tif (get_option_uid(args, &vol->cred_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid cruid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (get_option_gid(args, &vol->linux_gid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid gid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_file_mode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid file_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->file_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_dirmode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid dir_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->dir_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_port:\n\t\t\tif (get_option_ul(args, &option) ||\n\t\t\t    option > USHRT_MAX) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid port value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tport = (unsigned short)option;\n\t\t\tbreak;\n\t\tcase Opt_rsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid rsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->rsize = option;\n\t\t\tbreak;\n\t\tcase Opt_wsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid wsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->wsize = option;\n\t\t\tbreak;\n\t\tcase Opt_actimeo:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid actimeo value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->actimeo = HZ * option;\n\t\t\tif (vol->actimeo > CIFS_MAX_ACTIMEO) {\n\t\t\t\tcifs_dbg(VFS, \"attribute cache timeout too large\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* String Arguments */\n\n\t\tcase Opt_blank_user:\n\t\t\t/* null user, ie. anonymous authentication */\n\t\t\tvol->nullauth = 1;\n\t\t\tvol->username = NULL;\n\t\t\tbreak;\n\t\tcase Opt_user:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, CIFS_MAX_USERNAME_LEN) >\n\t\t\t\t\t\t\tCIFS_MAX_USERNAME_LEN) {\n\t\t\t\tpr_warn(\"CIFS: username too long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->username = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->username)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_blank_pass:\n\t\t\t/* passwords have to be handled differently\n\t\t\t * to allow the character used for deliminator\n\t\t\t * to be passed within them\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Check if this is a case where the  password\n\t\t\t * starts with a delimiter\n\t\t\t */\n\t\t\ttmp_end = strchr(data, '=');\n\t\t\ttmp_end++;\n\t\t\tif (!(tmp_end < end && tmp_end[1] == delim)) {\n\t\t\t\t/* No it is not. Set the password to NULL */\n\t\t\t\tkfree(vol->password);\n\t\t\t\tvol->password = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Yes it is. Drop down to Opt_pass below.*/\n\t\tcase Opt_pass:\n\t\t\t/* Obtain the value string */\n\t\t\tvalue = strchr(data, '=');\n\t\t\tvalue++;\n\n\t\t\t/* Set tmp_end to end of the string */\n\t\t\ttmp_end = (char *) value + strlen(value);\n\n\t\t\t/* Check if following character is the deliminator\n\t\t\t * If yes, we have encountered a double deliminator\n\t\t\t * reset the NULL character to the deliminator\n\t\t\t */\n\t\t\tif (tmp_end < end && tmp_end[1] == delim) {\n\t\t\t\ttmp_end[0] = delim;\n\n\t\t\t\t/* Keep iterating until we get to a single\n\t\t\t\t * deliminator OR the end\n\t\t\t\t */\n\t\t\t\twhile ((tmp_end = strchr(tmp_end, delim))\n\t\t\t\t\t!= NULL && (tmp_end[1] == delim)) {\n\t\t\t\t\t\ttmp_end = (char *) &tmp_end[2];\n\t\t\t\t}\n\n\t\t\t\t/* Reset var options to point to next element */\n\t\t\t\tif (tmp_end) {\n\t\t\t\t\ttmp_end[0] = '\\0';\n\t\t\t\t\toptions = (char *) &tmp_end[1];\n\t\t\t\t} else\n\t\t\t\t\t/* Reached the end of the mount option\n\t\t\t\t\t * string */\n\t\t\t\t\toptions = end;\n\t\t\t}\n\n\t\t\tkfree(vol->password);\n\t\t\t/* Now build new password string */\n\t\t\ttemp_len = strlen(value);\n\t\t\tvol->password = kzalloc(temp_len+1, GFP_KERNEL);\n\t\t\tif (vol->password == NULL) {\n\t\t\t\tpr_warn(\"CIFS: no memory for password\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tfor (i = 0, j = 0; i < temp_len; i++, j++) {\n\t\t\t\tvol->password[j] = value[i];\n\t\t\t\tif ((value[i] == delim) &&\n\t\t\t\t     value[i+1] == delim)\n\t\t\t\t\t/* skip the second deliminator */\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t\tvol->password[j] = '\\0';\n\t\t\tbreak;\n\t\tcase Opt_blank_ip:\n\t\t\t/* FIXME: should this be an error instead? */\n\t\t\tgot_ip = false;\n\t\t\tbreak;\n\t\tcase Opt_ip:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(dstaddr, string,\n\t\t\t\t\tstrlen(string))) {\n\t\t\t\tpr_err(\"CIFS: bad ip= option (%s).\\n\", string);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgot_ip = true;\n\t\t\tbreak;\n\t\tcase Opt_domain:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, CIFS_MAX_DOMAINNAME_LEN)\n\t\t\t\t\t== CIFS_MAX_DOMAINNAME_LEN) {\n\t\t\t\tpr_warn(\"CIFS: domain name too long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tvol->domainname = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->domainname) {\n\t\t\t\tpr_warn(\"CIFS: no memory for domainname\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tcifs_dbg(FYI, \"Domain name set\\n\");\n\t\t\tbreak;\n\t\tcase Opt_srcaddr:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(\n\t\t\t\t\t(struct sockaddr *)&vol->srcaddr,\n\t\t\t\t\tstring, strlen(string))) {\n\t\t\t\tpr_warn(\"CIFS: Could not parse srcaddr: %s\\n\",\n\t\t\t\t\tstring);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, 1024) >= 65) {\n\t\t\t\tpr_warn(\"CIFS: iocharset name too long.\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\t if (strncasecmp(string, \"default\", 7) != 0) {\n\t\t\t\tvol->iocharset = kstrdup(string,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\t\tif (!vol->iocharset) {\n\t\t\t\t\tpr_warn(\"CIFS: no memory for charset\\n\");\n\t\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if iocharset not set then load_nls_default\n\t\t\t * is used by caller\n\t\t\t */\n\t\t\t cifs_dbg(FYI, \"iocharset set to %s\\n\", string);\n\t\t\tbreak;\n\t\tcase Opt_netbiosname:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tmemset(vol->source_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN);\n\t\t\t/*\n\t\t\t * FIXME: are there cases in which a comma can\n\t\t\t * be valid in workstation netbios name (and\n\t\t\t * need special handling)?\n\t\t\t */\n\t\t\tfor (i = 0; i < RFC1001_NAME_LEN; i++) {\n\t\t\t\t/* don't ucase netbiosname for user */\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->source_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t * set at top of the function\n\t\t\t */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tpr_warn(\"CIFS: netbiosname longer than 15 truncated.\\n\");\n\t\t\tbreak;\n\t\tcase Opt_servern:\n\t\t\t/* servernetbiosname specified override *SMBSERVER */\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\t/* last byte, type, is 0x20 for servr type */\n\t\t\tmemset(vol->target_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\t/* BB are there cases in which a comma can be\n\t\t\t   valid in this workstation netbios name\n\t\t\t   (and need special handling)? */\n\n\t\t\t/* user or mount helper must uppercase the\n\t\t\t   netbios name */\n\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->target_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t   set at top of the function  */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tpr_warn(\"CIFS: server netbiosname longer than 15 truncated.\\n\");\n\t\t\tbreak;\n\t\tcase Opt_ver:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strncasecmp(string, \"1\", 1) == 0) {\n\t\t\t\t/* This is the default */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For all other value, error */\n\t\t\tpr_warn(\"CIFS: Invalid version specified\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\tcase Opt_vers:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_smb_version(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_sec:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_security_flavors(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_cache_flavor(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * An option we don't recognize. Save it off for later\n\t\t\t * if we haven't already found one\n\t\t\t */\n\t\t\tif (!invalid)\n\t\t\t\tinvalid = data;\n\t\t\tbreak;\n\t\t}\n\t\t/* Free up any allocated string */\n\t\tkfree(string);\n\t\tstring = NULL;\n\t}\n\n\tif (!sloppy && invalid) {\n\t\tpr_err(\"CIFS: Unknown mount option \\\"%s\\\"\\n\", invalid);\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n#ifndef CONFIG_KEYS\n\t/* Muliuser mounts require CONFIG_KEYS support */\n\tif (vol->multiuser) {\n\t\tcifs_dbg(VFS, \"Multiuser mounts require kernels with CONFIG_KEYS enabled\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n#endif\n\tif (!vol->UNC) {\n\t\tcifs_dbg(VFS, \"CIFS mount error: No usable UNC path provided in device string!\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\t/* make sure UNC has a share name */\n\tif (!strchr(vol->UNC + 3, '\\\\')) {\n\t\tcifs_dbg(VFS, \"Malformed UNC. Unable to find share name.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\tif (!got_ip) {\n\t\t/* No ip= option specified? Try to get it from UNC */\n\t\tif (!cifs_convert_address(dstaddr, &vol->UNC[2],\n\t\t\t\t\t\tstrlen(&vol->UNC[2]))) {\n\t\t\tpr_err(\"Unable to determine destination address.\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t}\n\n\t/* set the port that we got earlier */\n\tcifs_set_port(dstaddr, port);\n\n\tif (uid_specified)\n\t\tvol->override_uid = override_uid;\n\telse if (override_uid == 1)\n\t\tpr_notice(\"CIFS: ignoring forceuid mount option specified with no uid= option.\\n\");\n\n\tif (gid_specified)\n\t\tvol->override_gid = override_gid;\n\telse if (override_gid == 1)\n\t\tpr_notice(\"CIFS: ignoring forcegid mount option specified with no gid= option.\\n\");\n\n\tkfree(mountdata_copy);\n\treturn 0;\n\nout_nomem:\n\tpr_warn(\"Could not allocate temporary buffer\\n\");\ncifs_parse_mount_err:\n\tkfree(string);\n\tkfree(mountdata_copy);\n\treturn 1;\n}"
  },
  {
    "function_name": "cifs_parse_devname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "1149-1189",
    "snippet": "static int\ncifs_parse_devname(const char *devname, struct smb_vol *vol)\n{\n\tchar *pos;\n\tconst char *delims = \"/\\\\\";\n\tsize_t len;\n\n\t/* make sure we have a valid UNC double delimiter prefix */\n\tlen = strspn(devname, delims);\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\t/* find delimiter between host and sharename */\n\tpos = strpbrk(devname + 2, delims);\n\tif (!pos)\n\t\treturn -EINVAL;\n\n\t/* skip past delimiter */\n\t++pos;\n\n\t/* now go until next delimiter or end of string */\n\tlen = strcspn(pos, delims);\n\n\t/* move \"pos\" up to delimiter or NULL */\n\tpos += len;\n\tvol->UNC = kstrndup(devname, pos - devname, GFP_KERNEL);\n\tif (!vol->UNC)\n\t\treturn -ENOMEM;\n\n\tconvert_delimiter(vol->UNC, '\\\\');\n\n\t/* If pos is NULL, or is a bogus trailing delimiter then no prepath */\n\tif (!*pos++ || !*pos)\n\t\treturn 0;\n\n\tvol->prepath = kstrdup(pos, GFP_KERNEL);\n\tif (!vol->prepath)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "pos",
            "GFP_KERNEL"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_delimiter",
          "args": [
            "vol->UNC",
            "'\\\\'"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "convert_delimiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1185-1198",
          "snippet": "static inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "devname",
            "pos - devname",
            "GFP_KERNEL"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "pos",
            "delims"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "devname + 2",
            "delims"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "devname",
            "delims"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\nstatic int\ncifs_parse_devname(const char *devname, struct smb_vol *vol)\n{\n\tchar *pos;\n\tconst char *delims = \"/\\\\\";\n\tsize_t len;\n\n\t/* make sure we have a valid UNC double delimiter prefix */\n\tlen = strspn(devname, delims);\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\t/* find delimiter between host and sharename */\n\tpos = strpbrk(devname + 2, delims);\n\tif (!pos)\n\t\treturn -EINVAL;\n\n\t/* skip past delimiter */\n\t++pos;\n\n\t/* now go until next delimiter or end of string */\n\tlen = strcspn(pos, delims);\n\n\t/* move \"pos\" up to delimiter or NULL */\n\tpos += len;\n\tvol->UNC = kstrndup(devname, pos - devname, GFP_KERNEL);\n\tif (!vol->UNC)\n\t\treturn -ENOMEM;\n\n\tconvert_delimiter(vol->UNC, '\\\\');\n\n\t/* If pos is NULL, or is a bogus trailing delimiter then no prepath */\n\tif (!*pos++ || !*pos)\n\t\treturn 0;\n\n\tvol->prepath = kstrdup(pos, GFP_KERNEL);\n\tif (!vol->prepath)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_parse_smb_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "1110-1143",
    "snippet": "static int\ncifs_parse_smb_version(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_smb_version_tokens, args)) {\n\tcase Smb_1:\n\t\tvol->ops = &smb1_operations;\n\t\tvol->vals = &smb1_values;\n\t\tbreak;\n#ifdef CONFIG_CIFS_SMB2\n\tcase Smb_20:\n\t\tvol->ops = &smb20_operations;\n\t\tvol->vals = &smb20_values;\n\t\tbreak;\n\tcase Smb_21:\n\t\tvol->ops = &smb21_operations;\n\t\tvol->vals = &smb21_values;\n\t\tbreak;\n\tcase Smb_30:\n\t\tvol->ops = &smb30_operations;\n\t\tvol->vals = &smb30_values;\n\t\tbreak;\n\tcase Smb_302:\n\t\tvol->ops = &smb30_operations; /* currently identical with 3.0 */\n\t\tvol->vals = &smb302_values;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown vers= option specified: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t cifs_smb_version_tokens = {\n\t{ Smb_1, SMB1_VERSION_STRING },\n\t{ Smb_20, SMB20_VERSION_STRING},\n\t{ Smb_21, SMB21_VERSION_STRING },\n\t{ Smb_30, SMB30_VERSION_STRING },\n\t{ Smb_302, SMB302_VERSION_STRING },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Unknown vers= option specified: %s\\n\"",
            "value"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "value",
            "cifs_smb_version_tokens",
            "args"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic const match_table_t cifs_smb_version_tokens = {\n\t{ Smb_1, SMB1_VERSION_STRING },\n\t{ Smb_20, SMB20_VERSION_STRING},\n\t{ Smb_21, SMB21_VERSION_STRING },\n\t{ Smb_30, SMB30_VERSION_STRING },\n\t{ Smb_302, SMB302_VERSION_STRING },\n};\n\nstatic int\ncifs_parse_smb_version(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_smb_version_tokens, args)) {\n\tcase Smb_1:\n\t\tvol->ops = &smb1_operations;\n\t\tvol->vals = &smb1_values;\n\t\tbreak;\n#ifdef CONFIG_CIFS_SMB2\n\tcase Smb_20:\n\t\tvol->ops = &smb20_operations;\n\t\tvol->vals = &smb20_values;\n\t\tbreak;\n\tcase Smb_21:\n\t\tvol->ops = &smb21_operations;\n\t\tvol->vals = &smb21_values;\n\t\tbreak;\n\tcase Smb_30:\n\t\tvol->ops = &smb30_operations;\n\t\tvol->vals = &smb30_values;\n\t\tbreak;\n\tcase Smb_302:\n\t\tvol->ops = &smb30_operations; /* currently identical with 3.0 */\n\t\tvol->vals = &smb302_values;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown vers= option specified: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_parse_cache_flavor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "1085-1108",
    "snippet": "static int\ncifs_parse_cache_flavor(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_cacheflavor_tokens, args)) {\n\tcase Opt_cache_loose:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tcase Opt_cache_strict:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = true;\n\t\tbreak;\n\tcase Opt_cache_none:\n\t\tvol->direct_io = true;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad cache= option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t cifs_cacheflavor_tokens = {\n\t{ Opt_cache_loose, \"loose\" },\n\t{ Opt_cache_strict, \"strict\" },\n\t{ Opt_cache_none, \"none\" },\n\t{ Opt_cache_err, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad cache= option: %s\\n\"",
            "value"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "value",
            "cifs_cacheflavor_tokens",
            "args"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic const match_table_t cifs_cacheflavor_tokens = {\n\t{ Opt_cache_loose, \"loose\" },\n\t{ Opt_cache_strict, \"strict\" },\n\t{ Opt_cache_none, \"none\" },\n\t{ Opt_cache_err, NULL }\n};\n\nstatic int\ncifs_parse_cache_flavor(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_cacheflavor_tokens, args)) {\n\tcase Opt_cache_loose:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tcase Opt_cache_strict:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = true;\n\t\tbreak;\n\tcase Opt_cache_none:\n\t\tvol->direct_io = true;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad cache= option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_parse_security_flavors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "1028-1083",
    "snippet": "static int cifs_parse_security_flavors(char *value,\n\t\t\t\t       struct smb_vol *vol)\n{\n\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t/*\n\t * With mount options, the last one should win. Reset any existing\n\t * settings back to default.\n\t */\n\tvol->sectype = Unspecified;\n\tvol->sign = false;\n\n\tswitch (match_token(value, cifs_secflavor_tokens, args)) {\n\tcase Opt_sec_krb5p:\n\t\tcifs_dbg(VFS, \"sec=krb5p is not supported!\\n\");\n\t\treturn 1;\n\tcase Opt_sec_krb5i:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_krb5:\n\t\tvol->sectype = Kerberos;\n\t\tbreak;\n\tcase Opt_sec_ntlmsspi:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_ntlmssp:\n\t\tvol->sectype = RawNTLMSSP;\n\t\tbreak;\n\tcase Opt_sec_ntlmi:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_ntlm:\n\t\tvol->sectype = NTLM;\n\t\tbreak;\n\tcase Opt_sec_ntlmv2i:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_ntlmv2:\n\t\tvol->sectype = NTLMv2;\n\t\tbreak;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\tcase Opt_sec_lanman:\n\t\tvol->sectype = LANMAN;\n\t\tbreak;\n#endif\n\tcase Opt_sec_none:\n\t\tvol->nullauth = 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad security option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t cifs_secflavor_tokens = {\n\t{ Opt_sec_krb5, \"krb5\" },\n\t{ Opt_sec_krb5i, \"krb5i\" },\n\t{ Opt_sec_krb5p, \"krb5p\" },\n\t{ Opt_sec_ntlmsspi, \"ntlmsspi\" },\n\t{ Opt_sec_ntlmssp, \"ntlmssp\" },\n\t{ Opt_ntlm, \"ntlm\" },\n\t{ Opt_sec_ntlmi, \"ntlmi\" },\n\t{ Opt_sec_ntlmv2, \"nontlm\" },\n\t{ Opt_sec_ntlmv2, \"ntlmv2\" },\n\t{ Opt_sec_ntlmv2i, \"ntlmv2i\" },\n\t{ Opt_sec_lanman, \"lanman\" },\n\t{ Opt_sec_none, \"none\" },\n\n\t{ Opt_sec_err, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad security option: %s\\n\"",
            "value"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"sec=krb5p is not supported!\\n\""
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "value",
            "cifs_secflavor_tokens",
            "args"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic const match_table_t cifs_secflavor_tokens = {\n\t{ Opt_sec_krb5, \"krb5\" },\n\t{ Opt_sec_krb5i, \"krb5i\" },\n\t{ Opt_sec_krb5p, \"krb5p\" },\n\t{ Opt_sec_ntlmsspi, \"ntlmsspi\" },\n\t{ Opt_sec_ntlmssp, \"ntlmssp\" },\n\t{ Opt_ntlm, \"ntlm\" },\n\t{ Opt_sec_ntlmi, \"ntlmi\" },\n\t{ Opt_sec_ntlmv2, \"nontlm\" },\n\t{ Opt_sec_ntlmv2, \"ntlmv2\" },\n\t{ Opt_sec_ntlmv2i, \"ntlmv2i\" },\n\t{ Opt_sec_lanman, \"lanman\" },\n\t{ Opt_sec_none, \"none\" },\n\n\t{ Opt_sec_err, NULL }\n};\n\nstatic int cifs_parse_security_flavors(char *value,\n\t\t\t\t       struct smb_vol *vol)\n{\n\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t/*\n\t * With mount options, the last one should win. Reset any existing\n\t * settings back to default.\n\t */\n\tvol->sectype = Unspecified;\n\tvol->sign = false;\n\n\tswitch (match_token(value, cifs_secflavor_tokens, args)) {\n\tcase Opt_sec_krb5p:\n\t\tcifs_dbg(VFS, \"sec=krb5p is not supported!\\n\");\n\t\treturn 1;\n\tcase Opt_sec_krb5i:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_krb5:\n\t\tvol->sectype = Kerberos;\n\t\tbreak;\n\tcase Opt_sec_ntlmsspi:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_ntlmssp:\n\t\tvol->sectype = RawNTLMSSP;\n\t\tbreak;\n\tcase Opt_sec_ntlmi:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_ntlm:\n\t\tvol->sectype = NTLM;\n\t\tbreak;\n\tcase Opt_sec_ntlmv2i:\n\t\tvol->sign = true;\n\t\t/* Fallthrough */\n\tcase Opt_sec_ntlmv2:\n\t\tvol->sectype = NTLMv2;\n\t\tbreak;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\tcase Opt_sec_lanman:\n\t\tvol->sectype = LANMAN;\n\t\tbreak;\n#endif\n\tcase Opt_sec_none:\n\t\tvol->nullauth = 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad security option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_option_gid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "1010-1026",
    "snippet": "static int get_option_gid(substring_t args[], kgid_t *result)\n{\n\tunsigned long value;\n\tkgid_t gid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tgid = make_kgid(current_user_ns(), value);\n\tif (!gid_valid(gid))\n\t\treturn -EINVAL;\n\n\t*result = gid;\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "value"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option_ul",
          "args": [
            "args",
            "&value"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "get_option_ul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "978-990",
          "snippet": "static int get_option_ul(substring_t args[], unsigned long *option)\n{\n\tint rc;\n\tchar *string;\n\n\tstring = match_strdup(args);\n\tif (string == NULL)\n\t\treturn -ENOMEM;\n\trc = kstrtoul(string, 0, option);\n\tkfree(string);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int get_option_ul(substring_t args[], unsigned long *option)\n{\n\tint rc;\n\tchar *string;\n\n\tstring = match_strdup(args);\n\tif (string == NULL)\n\t\treturn -ENOMEM;\n\trc = kstrtoul(string, 0, option);\n\tkfree(string);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int get_option_gid(substring_t args[], kgid_t *result)\n{\n\tunsigned long value;\n\tkgid_t gid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tgid = make_kgid(current_user_ns(), value);\n\tif (!gid_valid(gid))\n\t\treturn -EINVAL;\n\n\t*result = gid;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_option_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "992-1008",
    "snippet": "static int get_option_uid(substring_t args[], kuid_t *result)\n{\n\tunsigned long value;\n\tkuid_t uid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tuid = make_kuid(current_user_ns(), value);\n\tif (!uid_valid(uid))\n\t\treturn -EINVAL;\n\n\t*result = uid;\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "value"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option_ul",
          "args": [
            "args",
            "&value"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "get_option_ul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "978-990",
          "snippet": "static int get_option_ul(substring_t args[], unsigned long *option)\n{\n\tint rc;\n\tchar *string;\n\n\tstring = match_strdup(args);\n\tif (string == NULL)\n\t\treturn -ENOMEM;\n\trc = kstrtoul(string, 0, option);\n\tkfree(string);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int get_option_ul(substring_t args[], unsigned long *option)\n{\n\tint rc;\n\tchar *string;\n\n\tstring = match_strdup(args);\n\tif (string == NULL)\n\t\treturn -ENOMEM;\n\trc = kstrtoul(string, 0, option);\n\tkfree(string);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int get_option_uid(substring_t args[], kuid_t *result)\n{\n\tunsigned long value;\n\tkuid_t uid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tuid = make_kuid(current_user_ns(), value);\n\tif (!uid_valid(uid))\n\t\treturn -EINVAL;\n\n\t*result = uid;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_option_ul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "978-990",
    "snippet": "static int get_option_ul(substring_t args[], unsigned long *option)\n{\n\tint rc;\n\tchar *string;\n\n\tstring = match_strdup(args);\n\tif (string == NULL)\n\t\treturn -ENOMEM;\n\trc = kstrtoul(string, 0, option);\n\tkfree(string);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "string"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "string",
            "0",
            "option"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int get_option_ul(substring_t args[], unsigned long *option)\n{\n\tint rc;\n\tchar *string;\n\n\tstring = match_strdup(args);\n\tif (string == NULL)\n\t\treturn -ENOMEM;\n\trc = kstrtoul(string, 0, option);\n\tkfree(string);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "extract_hostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "951-976",
    "snippet": "static char *\nextract_hostname(const char *unc)\n{\n\tconst char *src;\n\tchar *dst, *delim;\n\tunsigned int len;\n\n\t/* skip double chars at beginning of string */\n\t/* BB: check validity of these bytes? */\n\tsrc = unc + 2;\n\n\t/* delimiter between hostname and sharename is always '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = delim - src;\n\tdst = kmalloc((len + 1), GFP_KERNEL);\n\tif (dst == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(dst, src, len);\n\tdst[len] = '\\0';\n\n\treturn dst;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "len"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(len + 1)",
            "GFP_KERNEL"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src",
            "'\\\\'"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic char *\nextract_hostname(const char *unc)\n{\n\tconst char *src;\n\tchar *dst, *delim;\n\tunsigned int len;\n\n\t/* skip double chars at beginning of string */\n\t/* BB: check validity of these bytes? */\n\tsrc = unc + 2;\n\n\t/* delimiter between hostname and sharename is always '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = delim - src;\n\tdst = kmalloc((len + 1), GFP_KERNEL);\n\tif (dst == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(dst, src, len);\n\tdst[len] = '\\0';\n\n\treturn dst;\n}"
  },
  {
    "function_name": "cifs_demultiplex_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "836-948",
    "snippet": "static int\ncifs_demultiplex_thread(void *p)\n{\n\tint length;\n\tstruct TCP_Server_Info *server = p;\n\tunsigned int pdu_length;\n\tchar *buf = NULL;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mid_entry;\n\n\tcurrent->flags |= PF_MEMALLOC;\n\tcifs_dbg(FYI, \"Demultiplex PID: %d\\n\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\tset_freezable();\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tif (!allocate_buffers(server))\n\t\t\tcontinue;\n\n\t\tserver->large_buf = false;\n\t\tbuf = server->smallbuf;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\n\n\t\tlength = cifs_read_from_socket(server, buf, pdu_length);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read = length;\n\n\t\t/*\n\t\t * The right amount was read from socket - 4 bytes,\n\t\t * so we can now interpret the length field.\n\t\t */\n\t\tpdu_length = get_rfc1002_length(buf);\n\n\t\tcifs_dbg(FYI, \"RFC1002 header 0x%x\\n\", pdu_length);\n\t\tif (!is_smb_response(server, buf[0]))\n\t\t\tcontinue;\n\n\t\t/* make sure we have enough to get to the MID */\n\t\tif (pdu_length < HEADER_SIZE(server) - 1 - 4) {\n\t\t\tcifs_dbg(VFS, \"SMB response too short (%u bytes)\\n\",\n\t\t\t\t pdu_length);\n\t\t\tcifs_reconnect(server);\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* read down to the MID */\n\t\tlength = cifs_read_from_socket(server, buf + 4,\n\t\t\t\t\t       HEADER_SIZE(server) - 1 - 4);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read += length;\n\n\t\tmid_entry = server->ops->find_mid(server, buf);\n\n\t\tif (!mid_entry || !mid_entry->receive)\n\t\t\tlength = standard_receive3(server, mid_entry);\n\t\telse\n\t\t\tlength = mid_entry->receive(server, mid_entry);\n\n\t\tif (length < 0)\n\t\t\tcontinue;\n\n\t\tif (server->large_buf)\n\t\t\tbuf = server->bigbuf;\n\n\t\tserver->lstrp = jiffies;\n\t\tif (mid_entry != NULL) {\n\t\t\tif (!mid_entry->multiRsp || mid_entry->multiEnd)\n\t\t\t\tmid_entry->callback(mid_entry);\n\t\t} else if (!server->ops->is_oplock_break ||\n\t\t\t   !server->ops->is_oplock_break(buf, server)) {\n\t\t\tcifs_dbg(VFS, \"No task to wake, unknown frame received! NumMids %d\\n\",\n\t\t\t\t atomic_read(&midCount));\n\t\t\tcifs_dump_mem(\"Received Data is: \", buf,\n\t\t\t\t      HEADER_SIZE(server));\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tif (server->ops->dump_detail)\n\t\t\t\tserver->ops->dump_detail(buf);\n\t\t\tcifs_dump_mids(server);\n#endif /* CIFS_DEBUG2 */\n\n\t\t}\n\t} /* end while !EXITING */\n\n\t/* buffer usually freed in free_mid - need to free it here on exit */\n\tcifs_buf_release(server->bigbuf);\n\tif (server->smallbuf) /* no sense logging a debug message if NULL */\n\t\tcifs_small_buf_release(server->smallbuf);\n\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tclean_demultiplex_info(server);\n\n\t/* if server->tsk was NULL then wait for a signal before exiting */\n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmodule_put_and_exit(0);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern mempool_t *cifs_req_poolp;",
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put_and_exit",
          "args": [
            "0"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_demultiplex_info",
          "args": [
            "server"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "clean_demultiplex_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "692-778",
          "snippet": "static void clean_demultiplex_info(struct TCP_Server_Info *server)\n{\n\tint length;\n\n\t/* take it off the list, if it's not already */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\tspin_lock(&server->req_lock);\n\tif (server->credits <= 0)\n\t\tserver->credits = 1;\n\tspin_unlock(&server->req_lock);\n\t/*\n\t * Although there should not be any requests blocked on this queue it\n\t * can not hurt to be paranoid and try to wake up requests that may\n\t * haven been blocked when more than 50 at time were on the wire to the\n\t * same server - they now will see the session is in exit state and get\n\t * out of SendReceive.\n\t */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\n\tif (server->ssocket) {\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tstruct list_head dispose_list;\n\t\tstruct mid_q_entry *mid_entry;\n\t\tstruct list_head *tmp, *tmp2;\n\n\t\tINIT_LIST_HEAD(&dispose_list);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Clearing mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tmid_entry->mid_state = MID_SHUTDOWN;\n\t\t\tlist_move(&mid_entry->qhead, &dispose_list);\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t\t/* now walk dispose list and issue callbacks */\n\t\tlist_for_each_safe(tmp, tmp2, &dispose_list) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Callback mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t}\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/*\n\t\t * mpx threads have not exited yet give them at least the smb\n\t\t * send timeout time for long ops.\n\t\t *\n\t\t * Due to delays on oplock break requests, we need to wait at\n\t\t * least 45 seconds before giving up on a request getting a\n\t\t * response and going ahead and killing cifsd.\n\t\t */\n\t\tcifs_dbg(FYI, \"Wait for exit from demultiplex thread\\n\");\n\t\tmsleep(46000);\n\t\t/*\n\t\t * If threads still have not exited they are probably never\n\t\t * coming home not much else we can do but free the memory.\n\t\t */\n\t}\n\n\tkfree(server->hostname);\n\tkfree(server->iov);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;",
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nextern mempool_t *cifs_req_poolp;\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void clean_demultiplex_info(struct TCP_Server_Info *server)\n{\n\tint length;\n\n\t/* take it off the list, if it's not already */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\tspin_lock(&server->req_lock);\n\tif (server->credits <= 0)\n\t\tserver->credits = 1;\n\tspin_unlock(&server->req_lock);\n\t/*\n\t * Although there should not be any requests blocked on this queue it\n\t * can not hurt to be paranoid and try to wake up requests that may\n\t * haven been blocked when more than 50 at time were on the wire to the\n\t * same server - they now will see the session is in exit state and get\n\t * out of SendReceive.\n\t */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\n\tif (server->ssocket) {\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tstruct list_head dispose_list;\n\t\tstruct mid_q_entry *mid_entry;\n\t\tstruct list_head *tmp, *tmp2;\n\n\t\tINIT_LIST_HEAD(&dispose_list);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Clearing mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tmid_entry->mid_state = MID_SHUTDOWN;\n\t\t\tlist_move(&mid_entry->qhead, &dispose_list);\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t\t/* now walk dispose list and issue callbacks */\n\t\tlist_for_each_safe(tmp, tmp2, &dispose_list) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Callback mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t}\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/*\n\t\t * mpx threads have not exited yet give them at least the smb\n\t\t * send timeout time for long ops.\n\t\t *\n\t\t * Due to delays on oplock break requests, we need to wait at\n\t\t * least 45 seconds before giving up on a request getting a\n\t\t * response and going ahead and killing cifsd.\n\t\t */\n\t\tcifs_dbg(FYI, \"Wait for exit from demultiplex thread\\n\");\n\t\tmsleep(46000);\n\t\t/*\n\t\t * If threads still have not exited they are probably never\n\t\t * coming home not much else we can do but free the memory.\n\t\t */\n\t}\n\n\tkfree(server->hostname);\n\tkfree(server->iov);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&server->tsk",
            "NULL"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "server->smallbuf"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "server->bigbuf"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dump_mids",
          "args": [
            "server"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_dump_mids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "71-107",
          "snippet": "void cifs_dump_mids(struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct list_head *tmp;\n\tstruct mid_q_entry *mid_entry;\n\n\tif (server == NULL)\n\t\treturn;\n\n\tcifs_dbg(VFS, \"Dump pending requests:\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each(tmp, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tcifs_dbg(VFS, \"State: %d Cmd: %d Pid: %d Cbdata: %p Mid %llu\\n\",\n\t\t\t mid_entry->mid_state,\n\t\t\t le16_to_cpu(mid_entry->command),\n\t\t\t mid_entry->pid,\n\t\t\t mid_entry->callback_data,\n\t\t\t mid_entry->mid);\n#ifdef CONFIG_CIFS_STATS2\n\t\tcifs_dbg(VFS, \"IsLarge: %d buf: %p time rcv: %ld now: %ld\\n\",\n\t\t\t mid_entry->large_buf,\n\t\t\t mid_entry->resp_buf,\n\t\t\t mid_entry->when_received,\n\t\t\t jiffies);\n#endif /* STATS2 */\n\t\tcifs_dbg(VFS, \"IsMult: %d IsEnd: %d\\n\",\n\t\t\t mid_entry->multiRsp, mid_entry->multiEnd);\n\t\tif (mid_entry->resp_buf) {\n\t\t\tcifs_dump_detail(mid_entry->resp_buf);\n\t\t\tcifs_dump_mem(\"existing buf: \",\n\t\t\t\tmid_entry->resp_buf, 62);\n\t\t}\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n#endif /* CONFIG_CIFS_DEBUG2 */\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_dump_mids(struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct list_head *tmp;\n\tstruct mid_q_entry *mid_entry;\n\n\tif (server == NULL)\n\t\treturn;\n\n\tcifs_dbg(VFS, \"Dump pending requests:\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each(tmp, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tcifs_dbg(VFS, \"State: %d Cmd: %d Pid: %d Cbdata: %p Mid %llu\\n\",\n\t\t\t mid_entry->mid_state,\n\t\t\t le16_to_cpu(mid_entry->command),\n\t\t\t mid_entry->pid,\n\t\t\t mid_entry->callback_data,\n\t\t\t mid_entry->mid);\n#ifdef CONFIG_CIFS_STATS2\n\t\tcifs_dbg(VFS, \"IsLarge: %d buf: %p time rcv: %ld now: %ld\\n\",\n\t\t\t mid_entry->large_buf,\n\t\t\t mid_entry->resp_buf,\n\t\t\t mid_entry->when_received,\n\t\t\t jiffies);\n#endif /* STATS2 */\n\t\tcifs_dbg(VFS, \"IsMult: %d IsEnd: %d\\n\",\n\t\t\t mid_entry->multiRsp, mid_entry->multiEnd);\n\t\tif (mid_entry->resp_buf) {\n\t\t\tcifs_dump_detail(mid_entry->resp_buf);\n\t\t\tcifs_dump_mem(\"existing buf: \",\n\t\t\t\tmid_entry->resp_buf, 62);\n\t\t}\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n#endif /* CONFIG_CIFS_DEBUG2 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->dump_detail",
          "args": [
            "buf"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dump_mem",
          "args": [
            "\"Received Data is: \"",
            "buf",
            "HEADER_SIZE(server)"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_dump_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "34-40",
          "snippet": "void\ncifs_dump_mem(char *label, void *data, int length)\n{\n\tpr_debug(\"%s: dump of %d bytes of data at 0x%p\\n\", label, length, data);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       data, length, true);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid\ncifs_dump_mem(char *label, void *data, int length)\n{\n\tpr_debug(\"%s: dump of %d bytes of data at 0x%p\\n\", label, length, data);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       data, length, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"No task to wake, unknown frame received! NumMids %d\\n\"",
            "atomic_read(&midCount)"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&midCount"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->is_oplock_break",
          "args": [
            "buf",
            "server"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mid_entry->callback",
          "args": [
            "mid_entry"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mid_entry->receive",
          "args": [
            "server",
            "mid_entry"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "standard_receive3",
          "args": [
            "server",
            "mid_entry"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "standard_receive3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "780-834",
          "snippet": "static int\nstandard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length;\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = get_rfc1002_length(buf);\n\n\t/* make sure this will fit in a large buffer */\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server) - 4) {\n\t\tcifs_dbg(VFS, \"SMB response too long (%u bytes)\\n\", pdu_length);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn -ECONNABORTED;\n\t}\n\n\t/* switch to large buffer if too big for a small one */\n\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\tserver->large_buf = true;\n\t\tmemcpy(server->bigbuf, buf, server->total_read);\n\t\tbuf = server->bigbuf;\n\t}\n\n\t/* now read the rest */\n\tlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\n\t\t\t\tpdu_length - HEADER_SIZE(server) + 1 + 4);\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tdump_smb(buf, server->total_read);\n\n\t/*\n\t * We know that we received enough to get to the MID as we\n\t * checked the pdu_length earlier. Now check to see\n\t * if the rest of the header is OK. We borrow the length\n\t * var for the rest of the loop to avoid a new stack var.\n\t *\n\t * 48 bytes is enough to display the header and a little bit\n\t * into the payload for debugging purposes.\n\t */\n\tlength = server->ops->check_message(buf, server->total_read);\n\tif (length != 0)\n\t\tcifs_dump_mem(\"Bad SMB: \", buf,\n\t\t\tmin_t(unsigned int, server->total_read, 48));\n\n\tif (server->ops->is_status_pending &&\n\t    server->ops->is_status_pending(buf, server, length))\n\t\treturn -1;\n\n\tif (!mid)\n\t\treturn length;\n\n\thandle_mid(mid, server, buf, length);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int\nstandard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length;\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = get_rfc1002_length(buf);\n\n\t/* make sure this will fit in a large buffer */\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server) - 4) {\n\t\tcifs_dbg(VFS, \"SMB response too long (%u bytes)\\n\", pdu_length);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn -ECONNABORTED;\n\t}\n\n\t/* switch to large buffer if too big for a small one */\n\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\tserver->large_buf = true;\n\t\tmemcpy(server->bigbuf, buf, server->total_read);\n\t\tbuf = server->bigbuf;\n\t}\n\n\t/* now read the rest */\n\tlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\n\t\t\t\tpdu_length - HEADER_SIZE(server) + 1 + 4);\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tdump_smb(buf, server->total_read);\n\n\t/*\n\t * We know that we received enough to get to the MID as we\n\t * checked the pdu_length earlier. Now check to see\n\t * if the rest of the header is OK. We borrow the length\n\t * var for the rest of the loop to avoid a new stack var.\n\t *\n\t * 48 bytes is enough to display the header and a little bit\n\t * into the payload for debugging purposes.\n\t */\n\tlength = server->ops->check_message(buf, server->total_read);\n\tif (length != 0)\n\t\tcifs_dump_mem(\"Bad SMB: \", buf,\n\t\t\tmin_t(unsigned int, server->total_read, 48));\n\n\tif (server->ops->is_status_pending &&\n\t    server->ops->is_status_pending(buf, server, length))\n\t\treturn -1;\n\n\tif (!mid)\n\t\treturn length;\n\n\thandle_mid(mid, server, buf, length);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->find_mid",
          "args": [
            "server",
            "buf"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_read_from_socket",
          "args": [
            "server",
            "buf + 4",
            "HEADER_SIZE(server) - 1 - 4"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_read_from_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "601-611",
          "snippet": "int\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn cifs_readv_from_socket(server, &iov, 1, to_read);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn cifs_readv_from_socket(server, &iov, 1, to_read);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&server->response_q"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_wake_up_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "40-44",
          "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_reconnect",
          "args": [
            "server"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "300-401",
          "snippet": "int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"SMB response too short (%u bytes)\\n\"",
            "pdu_length"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_smb_response",
          "args": [
            "server",
            "buf[0]"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "is_smb_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "613-655",
          "snippet": "static bool\nis_smb_response(struct TCP_Server_Info *server, unsigned char type)\n{\n\t/*\n\t * The first byte big endian of the length field,\n\t * is actually not part of the length but the type\n\t * with the most common, zero, as regular data.\n\t */\n\tswitch (type) {\n\tcase RFC1002_SESSION_MESSAGE:\n\t\t/* Regular SMB response */\n\t\treturn true;\n\tcase RFC1002_SESSION_KEEP_ALIVE:\n\t\tcifs_dbg(FYI, \"RFC 1002 session keep alive\\n\");\n\t\tbreak;\n\tcase RFC1002_POSITIVE_SESSION_RESPONSE:\n\t\tcifs_dbg(FYI, \"RFC 1002 positive session response\\n\");\n\t\tbreak;\n\tcase RFC1002_NEGATIVE_SESSION_RESPONSE:\n\t\t/*\n\t\t * We get this from Windows 98 instead of an error on\n\t\t * SMB negprot response.\n\t\t */\n\t\tcifs_dbg(FYI, \"RFC 1002 negative session response\\n\");\n\t\t/* give server a second to clean up */\n\t\tmsleep(1000);\n\t\t/*\n\t\t * Always try 445 first on reconnect since we get NACK\n\t\t * on some if we ever connected to port 139 (the NACK\n\t\t * is since we do not begin with RFC1001 session\n\t\t * initialize frame).\n\t\t */\n\t\tcifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"RFC 1002 unknown response type 0x%x\\n\", type);\n\t\tcifs_reconnect(server);\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_PORT 445"
          ],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define CIFS_PORT 445\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nis_smb_response(struct TCP_Server_Info *server, unsigned char type)\n{\n\t/*\n\t * The first byte big endian of the length field,\n\t * is actually not part of the length but the type\n\t * with the most common, zero, as regular data.\n\t */\n\tswitch (type) {\n\tcase RFC1002_SESSION_MESSAGE:\n\t\t/* Regular SMB response */\n\t\treturn true;\n\tcase RFC1002_SESSION_KEEP_ALIVE:\n\t\tcifs_dbg(FYI, \"RFC 1002 session keep alive\\n\");\n\t\tbreak;\n\tcase RFC1002_POSITIVE_SESSION_RESPONSE:\n\t\tcifs_dbg(FYI, \"RFC 1002 positive session response\\n\");\n\t\tbreak;\n\tcase RFC1002_NEGATIVE_SESSION_RESPONSE:\n\t\t/*\n\t\t * We get this from Windows 98 instead of an error on\n\t\t * SMB negprot response.\n\t\t */\n\t\tcifs_dbg(FYI, \"RFC 1002 negative session response\\n\");\n\t\t/* give server a second to clean up */\n\t\tmsleep(1000);\n\t\t/*\n\t\t * Always try 445 first on reconnect since we get NACK\n\t\t * on some if we ever connected to port 139 (the NACK\n\t\t * is since we do not begin with RFC1001 session\n\t\t * initialize frame).\n\t\t */\n\t\tcifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"RFC 1002 unknown response type 0x%x\\n\", type);\n\t\tcifs_reconnect(server);\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"RFC1002 header 0x%x\\n\"",
            "pdu_length"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "buf"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_buffers",
          "args": [
            "server"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "430-461",
          "snippet": "static bool\nallocate_buffers(struct TCP_Server_Info *server)\n{\n\tif (!server->bigbuf) {\n\t\tserver->bigbuf = (char *)cifs_buf_get();\n\t\tif (!server->bigbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for large SMB response\\n\");\n\t\t\tmsleep(3000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t} else if (server->large_buf) {\n\t\t/* we are reusing a dirty large buf, clear its start */\n\t\tmemset(server->bigbuf, 0, HEADER_SIZE(server));\n\t}\n\n\tif (!server->smallbuf) {\n\t\tserver->smallbuf = (char *)cifs_small_buf_get();\n\t\tif (!server->smallbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for SMB response\\n\");\n\t\t\tmsleep(1000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t} else {\n\t\t/* if existing small buf clear beginning */\n\t\tmemset(server->smallbuf, 0, HEADER_SIZE(server));\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nallocate_buffers(struct TCP_Server_Info *server)\n{\n\tif (!server->bigbuf) {\n\t\tserver->bigbuf = (char *)cifs_buf_get();\n\t\tif (!server->bigbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for large SMB response\\n\");\n\t\t\tmsleep(3000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t} else if (server->large_buf) {\n\t\t/* we are reusing a dirty large buf, clear its start */\n\t\tmemset(server->bigbuf, 0, HEADER_SIZE(server));\n\t}\n\n\tif (!server->smallbuf) {\n\t\tserver->smallbuf = (char *)cifs_small_buf_get();\n\t\tif (!server->smallbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for SMB response\\n\");\n\t\t\tmsleep(1000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t} else {\n\t\t/* if existing small buf clear beginning */\n\t\tmemset(server->smallbuf, 0, HEADER_SIZE(server));\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_resize",
          "args": [
            "cifs_req_poolp",
            "length + cifs_min_rcv",
            "GFP_KERNEL"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&tcpSesAllocCount"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Demultiplex PID: %d\\n\"",
            "task_pid_nr(current)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nextern mempool_t *cifs_req_poolp;\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int\ncifs_demultiplex_thread(void *p)\n{\n\tint length;\n\tstruct TCP_Server_Info *server = p;\n\tunsigned int pdu_length;\n\tchar *buf = NULL;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mid_entry;\n\n\tcurrent->flags |= PF_MEMALLOC;\n\tcifs_dbg(FYI, \"Demultiplex PID: %d\\n\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\tset_freezable();\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tif (!allocate_buffers(server))\n\t\t\tcontinue;\n\n\t\tserver->large_buf = false;\n\t\tbuf = server->smallbuf;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\n\n\t\tlength = cifs_read_from_socket(server, buf, pdu_length);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read = length;\n\n\t\t/*\n\t\t * The right amount was read from socket - 4 bytes,\n\t\t * so we can now interpret the length field.\n\t\t */\n\t\tpdu_length = get_rfc1002_length(buf);\n\n\t\tcifs_dbg(FYI, \"RFC1002 header 0x%x\\n\", pdu_length);\n\t\tif (!is_smb_response(server, buf[0]))\n\t\t\tcontinue;\n\n\t\t/* make sure we have enough to get to the MID */\n\t\tif (pdu_length < HEADER_SIZE(server) - 1 - 4) {\n\t\t\tcifs_dbg(VFS, \"SMB response too short (%u bytes)\\n\",\n\t\t\t\t pdu_length);\n\t\t\tcifs_reconnect(server);\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* read down to the MID */\n\t\tlength = cifs_read_from_socket(server, buf + 4,\n\t\t\t\t\t       HEADER_SIZE(server) - 1 - 4);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read += length;\n\n\t\tmid_entry = server->ops->find_mid(server, buf);\n\n\t\tif (!mid_entry || !mid_entry->receive)\n\t\t\tlength = standard_receive3(server, mid_entry);\n\t\telse\n\t\t\tlength = mid_entry->receive(server, mid_entry);\n\n\t\tif (length < 0)\n\t\t\tcontinue;\n\n\t\tif (server->large_buf)\n\t\t\tbuf = server->bigbuf;\n\n\t\tserver->lstrp = jiffies;\n\t\tif (mid_entry != NULL) {\n\t\t\tif (!mid_entry->multiRsp || mid_entry->multiEnd)\n\t\t\t\tmid_entry->callback(mid_entry);\n\t\t} else if (!server->ops->is_oplock_break ||\n\t\t\t   !server->ops->is_oplock_break(buf, server)) {\n\t\t\tcifs_dbg(VFS, \"No task to wake, unknown frame received! NumMids %d\\n\",\n\t\t\t\t atomic_read(&midCount));\n\t\t\tcifs_dump_mem(\"Received Data is: \", buf,\n\t\t\t\t      HEADER_SIZE(server));\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tif (server->ops->dump_detail)\n\t\t\t\tserver->ops->dump_detail(buf);\n\t\t\tcifs_dump_mids(server);\n#endif /* CIFS_DEBUG2 */\n\n\t\t}\n\t} /* end while !EXITING */\n\n\t/* buffer usually freed in free_mid - need to free it here on exit */\n\tcifs_buf_release(server->bigbuf);\n\tif (server->smallbuf) /* no sense logging a debug message if NULL */\n\t\tcifs_small_buf_release(server->smallbuf);\n\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tclean_demultiplex_info(server);\n\n\t/* if server->tsk was NULL then wait for a signal before exiting */\n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmodule_put_and_exit(0);\n}"
  },
  {
    "function_name": "standard_receive3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "780-834",
    "snippet": "static int\nstandard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length;\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = get_rfc1002_length(buf);\n\n\t/* make sure this will fit in a large buffer */\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server) - 4) {\n\t\tcifs_dbg(VFS, \"SMB response too long (%u bytes)\\n\", pdu_length);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn -ECONNABORTED;\n\t}\n\n\t/* switch to large buffer if too big for a small one */\n\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\tserver->large_buf = true;\n\t\tmemcpy(server->bigbuf, buf, server->total_read);\n\t\tbuf = server->bigbuf;\n\t}\n\n\t/* now read the rest */\n\tlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\n\t\t\t\tpdu_length - HEADER_SIZE(server) + 1 + 4);\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tdump_smb(buf, server->total_read);\n\n\t/*\n\t * We know that we received enough to get to the MID as we\n\t * checked the pdu_length earlier. Now check to see\n\t * if the rest of the header is OK. We borrow the length\n\t * var for the rest of the loop to avoid a new stack var.\n\t *\n\t * 48 bytes is enough to display the header and a little bit\n\t * into the payload for debugging purposes.\n\t */\n\tlength = server->ops->check_message(buf, server->total_read);\n\tif (length != 0)\n\t\tcifs_dump_mem(\"Bad SMB: \", buf,\n\t\t\tmin_t(unsigned int, server->total_read, 48));\n\n\tif (server->ops->is_status_pending &&\n\t    server->ops->is_status_pending(buf, server, length))\n\t\treturn -1;\n\n\tif (!mid)\n\t\treturn length;\n\n\thandle_mid(mid, server, buf, length);\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_mid",
          "args": [
            "mid",
            "server",
            "buf",
            "length"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "handle_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "672-690",
          "snippet": "static void\nhandle_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t   char *buf, int malformed)\n{\n\tif (server->ops->check_trans2 &&\n\t    server->ops->check_trans2(mid, server, buf, malformed))\n\t\treturn;\n\tmid->resp_buf = buf;\n\tmid->large_buf = server->large_buf;\n\t/* Was previous buf put in mpx struct for multi-rsp? */\n\tif (!mid->multiRsp) {\n\t\t/* smb buffer will be freed by user thread */\n\t\tif (server->large_buf)\n\t\t\tserver->bigbuf = NULL;\n\t\telse\n\t\t\tserver->smallbuf = NULL;\n\t}\n\tdequeue_mid(mid, malformed);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\nhandle_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t   char *buf, int malformed)\n{\n\tif (server->ops->check_trans2 &&\n\t    server->ops->check_trans2(mid, server, buf, malformed))\n\t\treturn;\n\tmid->resp_buf = buf;\n\tmid->large_buf = server->large_buf;\n\t/* Was previous buf put in mpx struct for multi-rsp? */\n\tif (!mid->multiRsp) {\n\t\t/* smb buffer will be freed by user thread */\n\t\tif (server->large_buf)\n\t\t\tserver->bigbuf = NULL;\n\t\telse\n\t\t\tserver->smallbuf = NULL;\n\t}\n\tdequeue_mid(mid, malformed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->is_status_pending",
          "args": [
            "buf",
            "server",
            "length"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dump_mem",
          "args": [
            "\"Bad SMB: \"",
            "buf",
            "min_t(unsigned int, server->total_read, 48)"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_dump_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "34-40",
          "snippet": "void\ncifs_dump_mem(char *label, void *data, int length)\n{\n\tpr_debug(\"%s: dump of %d bytes of data at 0x%p\\n\", label, length, data);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       data, length, true);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid\ncifs_dump_mem(char *label, void *data, int length)\n{\n\tpr_debug(\"%s: dump of %d bytes of data at 0x%p\\n\", label, length, data);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       data, length, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "server->total_read",
            "48"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->check_message",
          "args": [
            "buf",
            "server->total_read"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_smb",
          "args": [
            "buf",
            "server->total_read"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "dump_smb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "513-521",
          "snippet": "void\ndump_smb(void *buf, int smb_buf_length)\n{\n\tif (traceSMB == 0)\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_NONE, 8, 2, buf,\n\t\t       smb_buf_length, true);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ndump_smb(void *buf, int smb_buf_length)\n{\n\tif (traceSMB == 0)\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_NONE, 8, 2, buf,\n\t\t       smb_buf_length, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_read_from_socket",
          "args": [
            "server",
            "buf + HEADER_SIZE(server) - 1",
            "pdu_length - HEADER_SIZE(server) + 1 + 4"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_read_from_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "601-611",
          "snippet": "int\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn cifs_readv_from_socket(server, &iov, 1, to_read);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn cifs_readv_from_socket(server, &iov, 1, to_read);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "server->bigbuf",
            "buf",
            "server->total_read"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&server->response_q"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_wake_up_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "40-44",
          "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_reconnect",
          "args": [
            "server"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "300-401",
          "snippet": "int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"SMB response too long (%u bytes)\\n\"",
            "pdu_length"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "buf"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int\nstandard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length;\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = get_rfc1002_length(buf);\n\n\t/* make sure this will fit in a large buffer */\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server) - 4) {\n\t\tcifs_dbg(VFS, \"SMB response too long (%u bytes)\\n\", pdu_length);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn -ECONNABORTED;\n\t}\n\n\t/* switch to large buffer if too big for a small one */\n\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\tserver->large_buf = true;\n\t\tmemcpy(server->bigbuf, buf, server->total_read);\n\t\tbuf = server->bigbuf;\n\t}\n\n\t/* now read the rest */\n\tlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\n\t\t\t\tpdu_length - HEADER_SIZE(server) + 1 + 4);\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tdump_smb(buf, server->total_read);\n\n\t/*\n\t * We know that we received enough to get to the MID as we\n\t * checked the pdu_length earlier. Now check to see\n\t * if the rest of the header is OK. We borrow the length\n\t * var for the rest of the loop to avoid a new stack var.\n\t *\n\t * 48 bytes is enough to display the header and a little bit\n\t * into the payload for debugging purposes.\n\t */\n\tlength = server->ops->check_message(buf, server->total_read);\n\tif (length != 0)\n\t\tcifs_dump_mem(\"Bad SMB: \", buf,\n\t\t\tmin_t(unsigned int, server->total_read, 48));\n\n\tif (server->ops->is_status_pending &&\n\t    server->ops->is_status_pending(buf, server, length))\n\t\treturn -1;\n\n\tif (!mid)\n\t\treturn length;\n\n\thandle_mid(mid, server, buf, length);\n\treturn 0;\n}"
  },
  {
    "function_name": "clean_demultiplex_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "692-778",
    "snippet": "static void clean_demultiplex_info(struct TCP_Server_Info *server)\n{\n\tint length;\n\n\t/* take it off the list, if it's not already */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\tspin_lock(&server->req_lock);\n\tif (server->credits <= 0)\n\t\tserver->credits = 1;\n\tspin_unlock(&server->req_lock);\n\t/*\n\t * Although there should not be any requests blocked on this queue it\n\t * can not hurt to be paranoid and try to wake up requests that may\n\t * haven been blocked when more than 50 at time were on the wire to the\n\t * same server - they now will see the session is in exit state and get\n\t * out of SendReceive.\n\t */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\n\tif (server->ssocket) {\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tstruct list_head dispose_list;\n\t\tstruct mid_q_entry *mid_entry;\n\t\tstruct list_head *tmp, *tmp2;\n\n\t\tINIT_LIST_HEAD(&dispose_list);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Clearing mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tmid_entry->mid_state = MID_SHUTDOWN;\n\t\t\tlist_move(&mid_entry->qhead, &dispose_list);\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t\t/* now walk dispose list and issue callbacks */\n\t\tlist_for_each_safe(tmp, tmp2, &dispose_list) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Callback mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t}\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/*\n\t\t * mpx threads have not exited yet give them at least the smb\n\t\t * send timeout time for long ops.\n\t\t *\n\t\t * Due to delays on oplock break requests, we need to wait at\n\t\t * least 45 seconds before giving up on a request getting a\n\t\t * response and going ahead and killing cifsd.\n\t\t */\n\t\tcifs_dbg(FYI, \"Wait for exit from demultiplex thread\\n\");\n\t\tmsleep(46000);\n\t\t/*\n\t\t * If threads still have not exited they are probably never\n\t\t * coming home not much else we can do but free the memory.\n\t\t */\n\t}\n\n\tkfree(server->hostname);\n\tkfree(server->iov);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern mempool_t *cifs_req_poolp;",
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_resize",
          "args": [
            "cifs_req_poolp",
            "length + cifs_min_rcv",
            "GFP_KERNEL"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&tcpSesAllocCount"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->iov"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->hostname"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "46000"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Wait for exit from demultiplex thread\\n\""
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&server->pending_mid_q"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "125"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mid_entry->callback",
          "args": [
            "mid_entry"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mid_entry->qhead"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Callback mid 0x%llx\\n\"",
            "mid_entry->mid"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structmid_q_entry",
            "qhead"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "tmp",
            "tmp2",
            "&dispose_list"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&mid_entry->qhead",
            "&dispose_list"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Clearing mid 0x%llx\\n\"",
            "mid_entry->mid"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structmid_q_entry",
            "qhead"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "tmp",
            "tmp2",
            "&server->pending_mid_q"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dispose_list"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "server->ssocket"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "125"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&server->request_q"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&server->response_q"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&server->tcp_ses_list"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nextern mempool_t *cifs_req_poolp;\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void clean_demultiplex_info(struct TCP_Server_Info *server)\n{\n\tint length;\n\n\t/* take it off the list, if it's not already */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\tspin_lock(&server->req_lock);\n\tif (server->credits <= 0)\n\t\tserver->credits = 1;\n\tspin_unlock(&server->req_lock);\n\t/*\n\t * Although there should not be any requests blocked on this queue it\n\t * can not hurt to be paranoid and try to wake up requests that may\n\t * haven been blocked when more than 50 at time were on the wire to the\n\t * same server - they now will see the session is in exit state and get\n\t * out of SendReceive.\n\t */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\n\tif (server->ssocket) {\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tstruct list_head dispose_list;\n\t\tstruct mid_q_entry *mid_entry;\n\t\tstruct list_head *tmp, *tmp2;\n\n\t\tINIT_LIST_HEAD(&dispose_list);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Clearing mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tmid_entry->mid_state = MID_SHUTDOWN;\n\t\t\tlist_move(&mid_entry->qhead, &dispose_list);\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t\t/* now walk dispose list and issue callbacks */\n\t\tlist_for_each_safe(tmp, tmp2, &dispose_list) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Callback mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t}\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/*\n\t\t * mpx threads have not exited yet give them at least the smb\n\t\t * send timeout time for long ops.\n\t\t *\n\t\t * Due to delays on oplock break requests, we need to wait at\n\t\t * least 45 seconds before giving up on a request getting a\n\t\t * response and going ahead and killing cifsd.\n\t\t */\n\t\tcifs_dbg(FYI, \"Wait for exit from demultiplex thread\\n\");\n\t\tmsleep(46000);\n\t\t/*\n\t\t * If threads still have not exited they are probably never\n\t\t * coming home not much else we can do but free the memory.\n\t\t */\n\t}\n\n\tkfree(server->hostname);\n\tkfree(server->iov);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n}"
  },
  {
    "function_name": "handle_mid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "672-690",
    "snippet": "static void\nhandle_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t   char *buf, int malformed)\n{\n\tif (server->ops->check_trans2 &&\n\t    server->ops->check_trans2(mid, server, buf, malformed))\n\t\treturn;\n\tmid->resp_buf = buf;\n\tmid->large_buf = server->large_buf;\n\t/* Was previous buf put in mpx struct for multi-rsp? */\n\tif (!mid->multiRsp) {\n\t\t/* smb buffer will be freed by user thread */\n\t\tif (server->large_buf)\n\t\t\tserver->bigbuf = NULL;\n\t\telse\n\t\t\tserver->smallbuf = NULL;\n\t}\n\tdequeue_mid(mid, malformed);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dequeue_mid",
          "args": [
            "mid",
            "malformed"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "657-670",
          "snippet": "void\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->check_trans2",
          "args": [
            "mid",
            "server",
            "buf",
            "malformed"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic void\nhandle_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t   char *buf, int malformed)\n{\n\tif (server->ops->check_trans2 &&\n\t    server->ops->check_trans2(mid, server, buf, malformed))\n\t\treturn;\n\tmid->resp_buf = buf;\n\tmid->large_buf = server->large_buf;\n\t/* Was previous buf put in mpx struct for multi-rsp? */\n\tif (!mid->multiRsp) {\n\t\t/* smb buffer will be freed by user thread */\n\t\tif (server->large_buf)\n\t\t\tserver->bigbuf = NULL;\n\t\telse\n\t\t\tserver->smallbuf = NULL;\n\t}\n\tdequeue_mid(mid, malformed);\n}"
  },
  {
    "function_name": "dequeue_mid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "657-670",
    "snippet": "void\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mid->qhead"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}"
  },
  {
    "function_name": "is_smb_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "613-655",
    "snippet": "static bool\nis_smb_response(struct TCP_Server_Info *server, unsigned char type)\n{\n\t/*\n\t * The first byte big endian of the length field,\n\t * is actually not part of the length but the type\n\t * with the most common, zero, as regular data.\n\t */\n\tswitch (type) {\n\tcase RFC1002_SESSION_MESSAGE:\n\t\t/* Regular SMB response */\n\t\treturn true;\n\tcase RFC1002_SESSION_KEEP_ALIVE:\n\t\tcifs_dbg(FYI, \"RFC 1002 session keep alive\\n\");\n\t\tbreak;\n\tcase RFC1002_POSITIVE_SESSION_RESPONSE:\n\t\tcifs_dbg(FYI, \"RFC 1002 positive session response\\n\");\n\t\tbreak;\n\tcase RFC1002_NEGATIVE_SESSION_RESPONSE:\n\t\t/*\n\t\t * We get this from Windows 98 instead of an error on\n\t\t * SMB negprot response.\n\t\t */\n\t\tcifs_dbg(FYI, \"RFC 1002 negative session response\\n\");\n\t\t/* give server a second to clean up */\n\t\tmsleep(1000);\n\t\t/*\n\t\t * Always try 445 first on reconnect since we get NACK\n\t\t * on some if we ever connected to port 139 (the NACK\n\t\t * is since we do not begin with RFC1001 session\n\t\t * initialize frame).\n\t\t */\n\t\tcifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"RFC 1002 unknown response type 0x%x\\n\", type);\n\t\tcifs_reconnect(server);\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_PORT 445"
    ],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_reconnect",
          "args": [
            "server"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "300-401",
          "snippet": "int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"RFC 1002 unknown response type 0x%x\\n\"",
            "type"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&server->response_q"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_wake_up_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "40-44",
          "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_set_port",
          "args": [
            "(struct sockaddr *)&server->dstaddr",
            "CIFS_PORT"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "207-218",
          "snippet": "void\ncifs_set_port(struct sockaddr *addr, const unsigned short int port)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)addr)->sin_port = htons(port);\n\t\tbreak;\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)addr)->sin6_port = htons(port);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\nvoid\ncifs_set_port(struct sockaddr *addr, const unsigned short int port)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)addr)->sin_port = htons(port);\n\t\tbreak;\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)addr)->sin6_port = htons(port);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1000"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"RFC 1002 negative session response\\n\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"RFC 1002 positive session response\\n\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"RFC 1002 session keep alive\\n\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define CIFS_PORT 445\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nis_smb_response(struct TCP_Server_Info *server, unsigned char type)\n{\n\t/*\n\t * The first byte big endian of the length field,\n\t * is actually not part of the length but the type\n\t * with the most common, zero, as regular data.\n\t */\n\tswitch (type) {\n\tcase RFC1002_SESSION_MESSAGE:\n\t\t/* Regular SMB response */\n\t\treturn true;\n\tcase RFC1002_SESSION_KEEP_ALIVE:\n\t\tcifs_dbg(FYI, \"RFC 1002 session keep alive\\n\");\n\t\tbreak;\n\tcase RFC1002_POSITIVE_SESSION_RESPONSE:\n\t\tcifs_dbg(FYI, \"RFC 1002 positive session response\\n\");\n\t\tbreak;\n\tcase RFC1002_NEGATIVE_SESSION_RESPONSE:\n\t\t/*\n\t\t * We get this from Windows 98 instead of an error on\n\t\t * SMB negprot response.\n\t\t */\n\t\tcifs_dbg(FYI, \"RFC 1002 negative session response\\n\");\n\t\t/* give server a second to clean up */\n\t\tmsleep(1000);\n\t\t/*\n\t\t * Always try 445 first on reconnect since we get NACK\n\t\t * on some if we ever connected to port 139 (the NACK\n\t\t * is since we do not begin with RFC1001 session\n\t\t * initialize frame).\n\t\t */\n\t\tcifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"RFC 1002 unknown response type 0x%x\\n\", type);\n\t\tcifs_reconnect(server);\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "cifs_read_from_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "601-611",
    "snippet": "int\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn cifs_readv_from_socket(server, &iov, 1, to_read);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_readv_from_socket",
          "args": [
            "server",
            "&iov",
            "1",
            "to_read"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readv_from_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "542-599",
          "snippet": "int\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn cifs_readv_from_socket(server, &iov, 1, to_read);\n}"
  },
  {
    "function_name": "cifs_readv_from_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "542-599",
    "snippet": "int\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_reconnect",
          "args": [
            "server"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "300-401",
          "snippet": "int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\"",
            "to_read",
            "length"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep_range",
          "args": [
            "1000",
            "2000"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_recvmsg",
          "args": [
            "server->ssocket",
            "&smb_msg",
            "iov",
            "segs",
            "to_read",
            "0"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvec_array_init",
          "args": [
            "iov",
            "iov_orig",
            "nr_segs",
            "total_read"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "kvec_array_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "501-522",
          "snippet": "static unsigned int\nkvec_array_init(struct kvec *new, struct kvec *iov, unsigned int nr_segs,\n\t\tsize_t bytes)\n{\n\tsize_t base = 0;\n\n\twhile (bytes || !iov->iov_len) {\n\t\tint copy = min(bytes, iov->iov_len);\n\n\t\tbytes -= copy;\n\t\tbase += copy;\n\t\tif (iov->iov_len == base) {\n\t\t\tiov++;\n\t\t\tnr_segs--;\n\t\t\tbase = 0;\n\t\t}\n\t}\n\tmemcpy(new, iov, sizeof(*iov) * nr_segs);\n\tnew->iov_base += base;\n\tnew->iov_len -= base;\n\treturn nr_segs;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic unsigned int\nkvec_array_init(struct kvec *new, struct kvec *iov, unsigned int nr_segs,\n\t\tsize_t bytes)\n{\n\tsize_t base = 0;\n\n\twhile (bytes || !iov->iov_len) {\n\t\tint copy = min(bytes, iov->iov_len);\n\n\t\tbytes -= copy;\n\t\tbase += copy;\n\t\tif (iov->iov_len == base) {\n\t\t\tiov++;\n\t\t\tnr_segs--;\n\t\t\tbase = 0;\n\t\t}\n\t}\n\tmemcpy(new, iov, sizeof(*iov) * nr_segs);\n\tnew->iov_base += base;\n\tnew->iov_len -= base;\n\treturn nr_segs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server_unresponsive",
          "args": [
            "server"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "server_unresponsive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "463-487",
          "snippet": "static bool\nserver_unresponsive(struct TCP_Server_Info *server)\n{\n\t/*\n\t * We need to wait 2 echo intervals to make sure we handle such\n\t * situations right:\n\t * 1s  client sends a normal SMB request\n\t * 2s  client gets a response\n\t * 30s echo workqueue job pops, and decides we got a response recently\n\t *     and don't need to send another\n\t * ...\n\t * 65s kernel_recvmsg times out, and we see that we haven't gotten\n\t *     a response in >60s.\n\t */\n\tif (server->tcpStatus == CifsGood &&\n\t    time_after(jiffies, server->lstrp + 2 * SMB_ECHO_INTERVAL)) {\n\t\tcifs_dbg(VFS, \"Server %s has not responded in %d seconds. Reconnecting...\\n\",\n\t\t\t server->hostname, (2 * SMB_ECHO_INTERVAL) / HZ);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nserver_unresponsive(struct TCP_Server_Info *server)\n{\n\t/*\n\t * We need to wait 2 echo intervals to make sure we handle such\n\t * situations right:\n\t * 1s  client sends a normal SMB request\n\t * 2s  client gets a response\n\t * 30s echo workqueue job pops, and decides we got a response recently\n\t *     and don't need to send another\n\t * ...\n\t * 65s kernel_recvmsg times out, and we see that we haven't gotten\n\t *     a response in >60s.\n\t */\n\tif (server->tcpStatus == CifsGood &&\n\t    time_after(jiffies, server->lstrp + 2 * SMB_ECHO_INTERVAL)) {\n\t\tcifs_dbg(VFS, \"Server %s has not responded in %d seconds. Reconnecting...\\n\",\n\t\t\t server->hostname, (2 * SMB_ECHO_INTERVAL) / HZ);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_server_iovec",
          "args": [
            "server",
            "nr_segs"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "get_server_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "524-540",
          "snippet": "static struct kvec *\nget_server_iovec(struct TCP_Server_Info *server, unsigned int nr_segs)\n{\n\tstruct kvec *new_iov;\n\n\tif (server->iov && nr_segs <= server->nr_iov)\n\t\treturn server->iov;\n\n\t/* not big enough -- allocate a new one and release the old */\n\tnew_iov = kmalloc(sizeof(*new_iov) * nr_segs, GFP_NOFS);\n\tif (new_iov) {\n\t\tkfree(server->iov);\n\t\tserver->iov = new_iov;\n\t\tserver->nr_iov = nr_segs;\n\t}\n\treturn new_iov;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct kvec *\nget_server_iovec(struct TCP_Server_Info *server, unsigned int nr_segs)\n{\n\tstruct kvec *new_iov;\n\n\tif (server->iov && nr_segs <= server->nr_iov)\n\t\treturn server->iov;\n\n\t/* not big enough -- allocate a new one and release the old */\n\tnew_iov = kmalloc(sizeof(*new_iov) * nr_segs, GFP_NOFS);\n\tif (new_iov) {\n\t\tkfree(server->iov);\n\t\tserver->iov = new_iov;\n\t\tserver->nr_iov = nr_segs;\n\t}\n\treturn new_iov;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}"
  },
  {
    "function_name": "get_server_iovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "524-540",
    "snippet": "static struct kvec *\nget_server_iovec(struct TCP_Server_Info *server, unsigned int nr_segs)\n{\n\tstruct kvec *new_iov;\n\n\tif (server->iov && nr_segs <= server->nr_iov)\n\t\treturn server->iov;\n\n\t/* not big enough -- allocate a new one and release the old */\n\tnew_iov = kmalloc(sizeof(*new_iov) * nr_segs, GFP_NOFS);\n\tif (new_iov) {\n\t\tkfree(server->iov);\n\t\tserver->iov = new_iov;\n\t\tserver->nr_iov = nr_segs;\n\t}\n\treturn new_iov;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->iov"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*new_iov) * nr_segs",
            "GFP_NOFS"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic struct kvec *\nget_server_iovec(struct TCP_Server_Info *server, unsigned int nr_segs)\n{\n\tstruct kvec *new_iov;\n\n\tif (server->iov && nr_segs <= server->nr_iov)\n\t\treturn server->iov;\n\n\t/* not big enough -- allocate a new one and release the old */\n\tnew_iov = kmalloc(sizeof(*new_iov) * nr_segs, GFP_NOFS);\n\tif (new_iov) {\n\t\tkfree(server->iov);\n\t\tserver->iov = new_iov;\n\t\tserver->nr_iov = nr_segs;\n\t}\n\treturn new_iov;\n}"
  },
  {
    "function_name": "kvec_array_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "501-522",
    "snippet": "static unsigned int\nkvec_array_init(struct kvec *new, struct kvec *iov, unsigned int nr_segs,\n\t\tsize_t bytes)\n{\n\tsize_t base = 0;\n\n\twhile (bytes || !iov->iov_len) {\n\t\tint copy = min(bytes, iov->iov_len);\n\n\t\tbytes -= copy;\n\t\tbase += copy;\n\t\tif (iov->iov_len == base) {\n\t\t\tiov++;\n\t\t\tnr_segs--;\n\t\t\tbase = 0;\n\t\t}\n\t}\n\tmemcpy(new, iov, sizeof(*iov) * nr_segs);\n\tnew->iov_base += base;\n\tnew->iov_len -= base;\n\treturn nr_segs;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new",
            "iov",
            "sizeof(*iov) * nr_segs"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "iov->iov_len"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic unsigned int\nkvec_array_init(struct kvec *new, struct kvec *iov, unsigned int nr_segs,\n\t\tsize_t bytes)\n{\n\tsize_t base = 0;\n\n\twhile (bytes || !iov->iov_len) {\n\t\tint copy = min(bytes, iov->iov_len);\n\n\t\tbytes -= copy;\n\t\tbase += copy;\n\t\tif (iov->iov_len == base) {\n\t\t\tiov++;\n\t\t\tnr_segs--;\n\t\t\tbase = 0;\n\t\t}\n\t}\n\tmemcpy(new, iov, sizeof(*iov) * nr_segs);\n\tnew->iov_base += base;\n\tnew->iov_len -= base;\n\treturn nr_segs;\n}"
  },
  {
    "function_name": "server_unresponsive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "463-487",
    "snippet": "static bool\nserver_unresponsive(struct TCP_Server_Info *server)\n{\n\t/*\n\t * We need to wait 2 echo intervals to make sure we handle such\n\t * situations right:\n\t * 1s  client sends a normal SMB request\n\t * 2s  client gets a response\n\t * 30s echo workqueue job pops, and decides we got a response recently\n\t *     and don't need to send another\n\t * ...\n\t * 65s kernel_recvmsg times out, and we see that we haven't gotten\n\t *     a response in >60s.\n\t */\n\tif (server->tcpStatus == CifsGood &&\n\t    time_after(jiffies, server->lstrp + 2 * SMB_ECHO_INTERVAL)) {\n\t\tcifs_dbg(VFS, \"Server %s has not responded in %d seconds. Reconnecting...\\n\",\n\t\t\t server->hostname, (2 * SMB_ECHO_INTERVAL) / HZ);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&server->response_q"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_wake_up_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "40-44",
          "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_reconnect",
          "args": [
            "server"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "300-401",
          "snippet": "int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Server %s has not responded in %d seconds. Reconnecting...\\n\"",
            "server->hostname",
            "(2 * SMB_ECHO_INTERVAL) / HZ"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "server->lstrp + 2 * SMB_ECHO_INTERVAL"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nserver_unresponsive(struct TCP_Server_Info *server)\n{\n\t/*\n\t * We need to wait 2 echo intervals to make sure we handle such\n\t * situations right:\n\t * 1s  client sends a normal SMB request\n\t * 2s  client gets a response\n\t * 30s echo workqueue job pops, and decides we got a response recently\n\t *     and don't need to send another\n\t * ...\n\t * 65s kernel_recvmsg times out, and we see that we haven't gotten\n\t *     a response in >60s.\n\t */\n\tif (server->tcpStatus == CifsGood &&\n\t    time_after(jiffies, server->lstrp + 2 * SMB_ECHO_INTERVAL)) {\n\t\tcifs_dbg(VFS, \"Server %s has not responded in %d seconds. Reconnecting...\\n\",\n\t\t\t server->hostname, (2 * SMB_ECHO_INTERVAL) / HZ);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "allocate_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "430-461",
    "snippet": "static bool\nallocate_buffers(struct TCP_Server_Info *server)\n{\n\tif (!server->bigbuf) {\n\t\tserver->bigbuf = (char *)cifs_buf_get();\n\t\tif (!server->bigbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for large SMB response\\n\");\n\t\t\tmsleep(3000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t} else if (server->large_buf) {\n\t\t/* we are reusing a dirty large buf, clear its start */\n\t\tmemset(server->bigbuf, 0, HEADER_SIZE(server));\n\t}\n\n\tif (!server->smallbuf) {\n\t\tserver->smallbuf = (char *)cifs_small_buf_get();\n\t\tif (!server->smallbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for SMB response\\n\");\n\t\t\tmsleep(1000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t} else {\n\t\t/* if existing small buf clear beginning */\n\t\tmemset(server->smallbuf, 0, HEADER_SIZE(server));\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "server->smallbuf",
            "0",
            "HEADER_SIZE(server)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1000"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"No memory for SMB response\\n\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_get",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "193-213",
          "snippet": "struct smb_hdr *\ncifs_small_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\n/* We could use negotiated size instead of max_msgsize -\n   but it may be more efficient to always alloc same size\n   albeit slightly larger than necessary and maxbuffersize\n   defaults to this and can not be bigger */\n\tret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\n\tif (ret_buf) {\n\t/* No need to clear memory here, cleared in header assemble */\n\t/*\tmemset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/\n\t\tatomic_inc(&smBufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totSmBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\n\t}\n\treturn ret_buf;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nstruct smb_hdr *\ncifs_small_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\n/* We could use negotiated size instead of max_msgsize -\n   but it may be more efficient to always alloc same size\n   albeit slightly larger than necessary and maxbuffersize\n   defaults to this and can not be bigger */\n\tret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\n\tif (ret_buf) {\n\t/* No need to clear memory here, cleared in header assemble */\n\t/*\tmemset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/\n\t\tatomic_inc(&smBufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totSmBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\n\t}\n\treturn ret_buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "server->bigbuf",
            "0",
            "HEADER_SIZE(server)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "3000"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"No memory for large SMB response\\n\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_buf_get",
          "args": [],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "146-178",
          "snippet": "struct smb_hdr *\ncifs_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\tsize_t buf_size = sizeof(struct smb_hdr);\n\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 header is bigger than CIFS one - no problems to clean some\n\t * more bytes for CIFS.\n\t */\n\tbuf_size = sizeof(struct smb2_hdr);\n#endif\n\t/*\n\t * We could use negotiated size instead of max_msgsize -\n\t * but it may be more efficient to always alloc same size\n\t * albeit slightly larger than necessary and maxbuffersize\n\t * defaults to this and can not be bigger.\n\t */\n\tret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\n\n\t/* clear the first few header bytes */\n\t/* for most paths, more is cleared in header_assemble */\n\tif (ret_buf) {\n\t\tmemset(ret_buf, 0, buf_size + 3);\n\t\tatomic_inc(&bufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\t}\n\n\treturn ret_buf;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nstruct smb_hdr *\ncifs_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\tsize_t buf_size = sizeof(struct smb_hdr);\n\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 header is bigger than CIFS one - no problems to clean some\n\t * more bytes for CIFS.\n\t */\n\tbuf_size = sizeof(struct smb2_hdr);\n#endif\n\t/*\n\t * We could use negotiated size instead of max_msgsize -\n\t * but it may be more efficient to always alloc same size\n\t * albeit slightly larger than necessary and maxbuffersize\n\t * defaults to this and can not be bigger.\n\t */\n\tret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\n\n\t/* clear the first few header bytes */\n\t/* for most paths, more is cleared in header_assemble */\n\tif (ret_buf) {\n\t\tmemset(ret_buf, 0, buf_size + 3);\n\t\tatomic_inc(&bufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\t}\n\n\treturn ret_buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic bool\nallocate_buffers(struct TCP_Server_Info *server)\n{\n\tif (!server->bigbuf) {\n\t\tserver->bigbuf = (char *)cifs_buf_get();\n\t\tif (!server->bigbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for large SMB response\\n\");\n\t\t\tmsleep(3000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t} else if (server->large_buf) {\n\t\t/* we are reusing a dirty large buf, clear its start */\n\t\tmemset(server->bigbuf, 0, HEADER_SIZE(server));\n\t}\n\n\tif (!server->smallbuf) {\n\t\tserver->smallbuf = (char *)cifs_small_buf_get();\n\t\tif (!server->smallbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for SMB response\\n\");\n\t\t\tmsleep(1000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t} else {\n\t\t/* if existing small buf clear beginning */\n\t\tmemset(server->smallbuf, 0, HEADER_SIZE(server));\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "cifs_echo_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "403-428",
    "snippet": "static void\ncifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t/*\n\t * We cannot send an echo if it is disabled or until the\n\t * NEGOTIATE_PROTOCOL request is done, which is indicated by\n\t * server->ops->need_neg() == true. Also, no need to ping if\n\t * we got a response recently.\n\t */\n\tif (!server->ops->need_neg || server->ops->need_neg(server) ||\n\t    (server->ops->can_echo && !server->ops->can_echo(server)) ||\n\t    time_before(jiffies, server->lstrp + SMB_ECHO_INTERVAL - HZ))\n\t\tgoto requeue_echo;\n\n\trc = server->ops->echo ? server->ops->echo(server) : -ENOSYS;\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Unable to send echo request to server: %s\\n\",\n\t\t\t server->hostname);\n\nrequeue_echo:\n\tqueue_delayed_work(cifsiod_wq, &server->echo, SMB_ECHO_INTERVAL);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);",
      "static void cifs_prune_tlinks(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "cifsiod_wq",
            "&server->echo",
            "SMB_ECHO_INTERVAL"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unable to send echo request to server: %s\\n\"",
            "server->hostname"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->echo",
          "args": [
            "server"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "server->lstrp + SMB_ECHO_INTERVAL - HZ"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->can_echo",
          "args": [
            "server"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->need_neg",
          "args": [
            "server"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structTCP_Server_Info",
            "echo.work"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\nstatic void\ncifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t/*\n\t * We cannot send an echo if it is disabled or until the\n\t * NEGOTIATE_PROTOCOL request is done, which is indicated by\n\t * server->ops->need_neg() == true. Also, no need to ping if\n\t * we got a response recently.\n\t */\n\tif (!server->ops->need_neg || server->ops->need_neg(server) ||\n\t    (server->ops->can_echo && !server->ops->can_echo(server)) ||\n\t    time_before(jiffies, server->lstrp + SMB_ECHO_INTERVAL - HZ))\n\t\tgoto requeue_echo;\n\n\trc = server->ops->echo ? server->ops->echo(server) : -ENOSYS;\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Unable to send echo request to server: %s\\n\",\n\t\t\t server->hostname);\n\nrequeue_echo:\n\tqueue_delayed_work(cifsiod_wq, &server->echo, SMB_ECHO_INTERVAL);\n}"
  },
  {
    "function_name": "cifs_reconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
    "lines": "300-401",
    "snippet": "int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"rfc1002pdu.h\"",
      "#include \"nterr.h\"",
      "#include \"ntlmssp.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/parser.h>",
      "#include <net/ipv6.h>",
      "#include <keys/user-type.h>",
      "#include <linux/module.h>",
      "#include <linux/inet.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/utsname.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/net.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ip_connect(struct TCP_Server_Info *server);",
      "static int generic_ip_connect(struct TCP_Server_Info *server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&tcpSesReconnectCount"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "3000"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"reconnect error %d\\n\"",
            "rc"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_ip_connect",
          "args": [
            "server"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "generic_ip_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2956-3041",
          "snippet": "static int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t} else {\n\t\tsport = ((struct sockaddr_in *) saddr)->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tint val = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcifs_dbg(FYI, \"set TCP_NODELAY socket option error %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = socket->ops->connect(socket, saddr, slen, 0);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RFC1001_PORT 139"
          ],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define RFC1001_PORT 139\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nstatic int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t} else {\n\t\tsport = ((struct sockaddr_in *) saddr)->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tint val = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcifs_dbg(FYI, \"set TCP_NODELAY socket option error %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = socket->ops->connect(socket, saddr, slen, 0);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mid_entry->callback",
          "args": [
            "mid_entry"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mid_entry->qhead"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structmid_q_entry",
            "qhead"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "tmp",
            "tmp2",
            "&retry_list"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: issuing mid callbacks\\n\"",
            "__func__"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&mid_entry->qhead",
            "&retry_list"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structmid_q_entry",
            "qhead"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "tmp",
            "tmp2",
            "&server->pending_mid_q"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: moving mids to private list\\n\"",
            "__func__"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&retry_list"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->session_key.response"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "server->ssocket"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Post shutdown state: 0x%x Flags: 0x%lx\\n\"",
            "server->ssocket->state",
            "server->ssocket->flags"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_sock_shutdown",
          "args": [
            "server->ssocket",
            "SHUT_WR"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"State: 0x%x Flags: 0x%lx\\n\"",
            "server->ssocket->state",
            "server->ssocket->flags"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: tearing down socket\\n\"",
            "__func__"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp2",
            "structcifs_tcon",
            "tcon_list"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp2",
            "&ses->tcon_list"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structcifs_ses",
            "smb_ses_list"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "&server->smb_ses_list"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: marking sessions and tcons for reconnect\\n\"",
            "__func__"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Reconnecting tcp session\\n\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}"
  }
]