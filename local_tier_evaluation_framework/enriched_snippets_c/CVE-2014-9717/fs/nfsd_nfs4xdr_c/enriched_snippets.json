[
  {
    "function_name": "nfs4svc_encode_compoundres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4410-4431",
    "snippet": "int\nnfs4svc_encode_compoundres(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compoundres *resp)\n{\n\t/*\n\t * All that remains is to write the tag and operation count...\n\t */\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\n\tWARN_ON_ONCE(buf->len != buf->head[0].iov_len + buf->page_len +\n\t\t\t\t buf->tail[0].iov_len);\n\n\trqstp->rq_next_page = resp->xdr.page_ptr + 1;\n\n\tp = resp->tagp;\n\t*p++ = htonl(resp->taglen);\n\tmemcpy(p, resp->tag, resp->taglen);\n\tp += XDR_QUADLEN(resp->taglen);\n\t*p++ = htonl(resp->opcnt);\n\n\tnfsd4_sequence_done(resp);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_sequence_done",
          "args": [
            "resp"
          ],
          "line": 4429
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_sequence_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2828-2842",
          "snippet": "void\nnfsd4_sequence_done(struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_compound_state *cs = &resp->cstate;\n\n\tif (nfsd4_has_session(cs)) {\n\t\tif (cs->status != nfserr_replay_cache) {\n\t\t\tnfsd4_store_cache_entry(resp);\n\t\t\tcs->slot->sl_flags &= ~NFSD4_SLOT_INUSE;\n\t\t}\n\t\t/* Drop session reference that was taken in nfsd4_sequence() */\n\t\tnfsd4_put_session(cs->session);\n\t} else if (cs->clp)\n\t\tput_client_renew(cs->clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_sequence_done(struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_compound_state *cs = &resp->cstate;\n\n\tif (nfsd4_has_session(cs)) {\n\t\tif (cs->status != nfserr_replay_cache) {\n\t\t\tnfsd4_store_cache_entry(resp);\n\t\t\tcs->slot->sl_flags &= ~NFSD4_SLOT_INUSE;\n\t\t}\n\t\t/* Drop session reference that was taken in nfsd4_sequence() */\n\t\tnfsd4_put_session(cs->session);\n\t} else if (cs->clp)\n\t\tput_client_renew(cs->clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->opcnt"
          ],
          "line": 4427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "resp->taglen"
          ],
          "line": 4426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "resp->tag",
            "resp->taglen"
          ],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->taglen"
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "buf->len != buf->head[0].iov_len + buf->page_len +\n\t\t\t\t buf->tail[0].iov_len"
          ],
          "line": 4418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint\nnfs4svc_encode_compoundres(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compoundres *resp)\n{\n\t/*\n\t * All that remains is to write the tag and operation count...\n\t */\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\n\tWARN_ON_ONCE(buf->len != buf->head[0].iov_len + buf->page_len +\n\t\t\t\t buf->tail[0].iov_len);\n\n\trqstp->rq_next_page = resp->xdr.page_ptr + 1;\n\n\tp = resp->tagp;\n\t*p++ = htonl(resp->taglen);\n\tmemcpy(p, resp->tag, resp->taglen);\n\tp += XDR_QUADLEN(resp->taglen);\n\t*p++ = htonl(resp->opcnt);\n\n\tnfsd4_sequence_done(resp);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs4svc_decode_compoundargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4389-4408",
    "snippet": "int\nnfs4svc_decode_compoundargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compoundargs *args)\n{\n\tif (rqstp->rq_arg.head[0].iov_len % 4) {\n\t\t/* client is nuts */\n\t\tdprintk(\"%s: compound not properly padded! (peeraddr=%pISc xid=0x%x)\",\n\t\t\t__func__, svc_addr(rqstp), be32_to_cpu(rqstp->rq_xid));\n\t\treturn 0;\n\t}\n\targs->p = p;\n\targs->end = rqstp->rq_arg.head[0].iov_base + rqstp->rq_arg.head[0].iov_len;\n\targs->pagelist = rqstp->rq_arg.pages;\n\targs->pagelen = rqstp->rq_arg.page_len;\n\targs->tmpp = NULL;\n\targs->to_free = NULL;\n\targs->ops = args->iops;\n\targs->rqstp = rqstp;\n\n\treturn !nfsd4_decode_compound(args);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_compound",
          "args": [
            "args"
          ],
          "line": 4407
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_compound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1791-1876",
          "snippet": "static __be32\nnfsd4_decode_compound(struct nfsd4_compoundargs *argp)\n{\n\tDECODE_HEAD;\n\tstruct nfsd4_op *op;\n\tbool cachethis = false;\n\tint auth_slack= argp->rqstp->rq_auth_slack;\n\tint max_reply = auth_slack + 8; /* opcnt, status */\n\tint readcount = 0;\n\tint readbytes = 0;\n\tint i;\n\n\tREAD_BUF(4);\n\targp->taglen = be32_to_cpup(p++);\n\tREAD_BUF(argp->taglen + 8);\n\tSAVEMEM(argp->tag, argp->taglen);\n\targp->minorversion = be32_to_cpup(p++);\n\targp->opcnt = be32_to_cpup(p++);\n\tmax_reply += 4 + (XDR_QUADLEN(argp->taglen) << 2);\n\n\tif (argp->taglen > NFSD4_MAX_TAGLEN)\n\t\tgoto xdr_error;\n\tif (argp->opcnt > 100)\n\t\tgoto xdr_error;\n\n\tif (argp->opcnt > ARRAY_SIZE(argp->iops)) {\n\t\targp->ops = kzalloc(argp->opcnt * sizeof(*argp->ops), GFP_KERNEL);\n\t\tif (!argp->ops) {\n\t\t\targp->ops = argp->iops;\n\t\t\tdprintk(\"nfsd: couldn't allocate room for COMPOUND\\n\");\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tif (argp->minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\targp->opcnt = 0;\n\n\tfor (i = 0; i < argp->opcnt; i++) {\n\t\top = &argp->ops[i];\n\t\top->replay = NULL;\n\n\t\tREAD_BUF(4);\n\t\top->opnum = be32_to_cpup(p++);\n\n\t\tif (nfsd4_opnum_in_range(argp, op))\n\t\t\top->status = nfsd4_dec_ops[op->opnum](argp, &op->u);\n\t\telse {\n\t\t\top->opnum = OP_ILLEGAL;\n\t\t\top->status = nfserr_op_illegal;\n\t\t}\n\t\t/*\n\t\t * We'll try to cache the result in the DRC if any one\n\t\t * op in the compound wants to be cached:\n\t\t */\n\t\tcachethis |= nfsd4_cache_this_op(op);\n\n\t\tif (op->opnum == OP_READ) {\n\t\t\treadcount++;\n\t\t\treadbytes += nfsd4_max_reply(argp->rqstp, op);\n\t\t} else\n\t\t\tmax_reply += nfsd4_max_reply(argp->rqstp, op);\n\t\t/*\n\t\t * OP_LOCK may return a conflicting lock.  (Special case\n\t\t * because it will just skip encoding this if it runs\n\t\t * out of xdr buffer space, and it is the only operation\n\t\t * that behaves this way.)\n\t\t */\n\t\tif (op->opnum == OP_LOCK)\n\t\t\tmax_reply += NFS4_OPAQUE_LIMIT;\n\n\t\tif (op->status) {\n\t\t\targp->opcnt = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Sessions make the DRC unnecessary: */\n\tif (argp->minorversion)\n\t\tcachethis = false;\n\tsvc_reserve(argp->rqstp, max_reply + readbytes);\n\targp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;\n\n\tif (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)\n\t\tclear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [
            "static nfsd4_dec nfsd4_dec_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_dec)nfsd4_decode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_dec)nfsd4_decode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_dec)nfsd4_decode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_dec)nfsd4_decode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DELEGRETURN]\t= (nfsd4_dec)nfsd4_decode_delegreturn,\n\t[OP_GETATTR]\t\t= (nfsd4_dec)nfsd4_decode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_LINK]\t\t= (nfsd4_dec)nfsd4_decode_link,\n\t[OP_LOCK]\t\t= (nfsd4_dec)nfsd4_decode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_dec)nfsd4_decode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_dec)nfsd4_decode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_dec)nfsd4_decode_lookup,\n\t[OP_LOOKUPP]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_OPEN]\t\t= (nfsd4_dec)nfsd4_decode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_dec)nfsd4_decode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_dec)nfsd4_decode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_dec)nfsd4_decode_putfh,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_dec)nfsd4_decode_putpubfh,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_READ]\t\t= (nfsd4_dec)nfsd4_decode_read,\n\t[OP_READDIR]\t\t= (nfsd4_dec)nfsd4_decode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_REMOVE]\t\t= (nfsd4_dec)nfsd4_decode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_dec)nfsd4_decode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_dec)nfsd4_decode_renew,\n\t[OP_RESTOREFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_dec)nfsd4_decode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_dec)nfsd4_decode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_dec)nfsd4_decode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_dec)nfsd4_decode_setclientid_confirm,\n\t[OP_VERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_WRITE]\t\t= (nfsd4_dec)nfsd4_decode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_dec)nfsd4_decode_release_lockowner,\n\n\t/* new operations for NFSv4.1 */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_dec)nfsd4_decode_backchannel_ctl,\n\t[OP_BIND_CONN_TO_SESSION]= (nfsd4_dec)nfsd4_decode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_dec)nfsd4_decode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_dec)nfsd4_decode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_dec)nfsd4_decode_destroy_session,\n\t[OP_FREE_STATEID]\t= (nfsd4_dec)nfsd4_decode_free_stateid,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_dec)nfsd4_decode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_dec)nfsd4_decode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_TEST_STATEID]\t= (nfsd4_dec)nfsd4_decode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_dec)nfsd4_decode_destroy_clientid,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_dec)nfsd4_decode_reclaim_complete,\n\n\t/* new operations for NFSv4.2 */\n\t[OP_ALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_COPY]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTERROR]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_READ_PLUS]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_SEEK]\t\t= (nfsd4_dec)nfsd4_decode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic nfsd4_dec nfsd4_dec_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_dec)nfsd4_decode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_dec)nfsd4_decode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_dec)nfsd4_decode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_dec)nfsd4_decode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DELEGRETURN]\t= (nfsd4_dec)nfsd4_decode_delegreturn,\n\t[OP_GETATTR]\t\t= (nfsd4_dec)nfsd4_decode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_LINK]\t\t= (nfsd4_dec)nfsd4_decode_link,\n\t[OP_LOCK]\t\t= (nfsd4_dec)nfsd4_decode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_dec)nfsd4_decode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_dec)nfsd4_decode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_dec)nfsd4_decode_lookup,\n\t[OP_LOOKUPP]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_OPEN]\t\t= (nfsd4_dec)nfsd4_decode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_dec)nfsd4_decode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_dec)nfsd4_decode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_dec)nfsd4_decode_putfh,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_dec)nfsd4_decode_putpubfh,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_READ]\t\t= (nfsd4_dec)nfsd4_decode_read,\n\t[OP_READDIR]\t\t= (nfsd4_dec)nfsd4_decode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_REMOVE]\t\t= (nfsd4_dec)nfsd4_decode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_dec)nfsd4_decode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_dec)nfsd4_decode_renew,\n\t[OP_RESTOREFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_dec)nfsd4_decode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_dec)nfsd4_decode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_dec)nfsd4_decode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_dec)nfsd4_decode_setclientid_confirm,\n\t[OP_VERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_WRITE]\t\t= (nfsd4_dec)nfsd4_decode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_dec)nfsd4_decode_release_lockowner,\n\n\t/* new operations for NFSv4.1 */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_dec)nfsd4_decode_backchannel_ctl,\n\t[OP_BIND_CONN_TO_SESSION]= (nfsd4_dec)nfsd4_decode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_dec)nfsd4_decode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_dec)nfsd4_decode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_dec)nfsd4_decode_destroy_session,\n\t[OP_FREE_STATEID]\t= (nfsd4_dec)nfsd4_decode_free_stateid,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_dec)nfsd4_decode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_dec)nfsd4_decode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_TEST_STATEID]\t= (nfsd4_dec)nfsd4_decode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_dec)nfsd4_decode_destroy_clientid,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_dec)nfsd4_decode_reclaim_complete,\n\n\t/* new operations for NFSv4.2 */\n\t[OP_ALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_COPY]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTERROR]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_READ_PLUS]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_SEEK]\t\t= (nfsd4_dec)nfsd4_decode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n};\n\nstatic __be32\nnfsd4_decode_compound(struct nfsd4_compoundargs *argp)\n{\n\tDECODE_HEAD;\n\tstruct nfsd4_op *op;\n\tbool cachethis = false;\n\tint auth_slack= argp->rqstp->rq_auth_slack;\n\tint max_reply = auth_slack + 8; /* opcnt, status */\n\tint readcount = 0;\n\tint readbytes = 0;\n\tint i;\n\n\tREAD_BUF(4);\n\targp->taglen = be32_to_cpup(p++);\n\tREAD_BUF(argp->taglen + 8);\n\tSAVEMEM(argp->tag, argp->taglen);\n\targp->minorversion = be32_to_cpup(p++);\n\targp->opcnt = be32_to_cpup(p++);\n\tmax_reply += 4 + (XDR_QUADLEN(argp->taglen) << 2);\n\n\tif (argp->taglen > NFSD4_MAX_TAGLEN)\n\t\tgoto xdr_error;\n\tif (argp->opcnt > 100)\n\t\tgoto xdr_error;\n\n\tif (argp->opcnt > ARRAY_SIZE(argp->iops)) {\n\t\targp->ops = kzalloc(argp->opcnt * sizeof(*argp->ops), GFP_KERNEL);\n\t\tif (!argp->ops) {\n\t\t\targp->ops = argp->iops;\n\t\t\tdprintk(\"nfsd: couldn't allocate room for COMPOUND\\n\");\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tif (argp->minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\targp->opcnt = 0;\n\n\tfor (i = 0; i < argp->opcnt; i++) {\n\t\top = &argp->ops[i];\n\t\top->replay = NULL;\n\n\t\tREAD_BUF(4);\n\t\top->opnum = be32_to_cpup(p++);\n\n\t\tif (nfsd4_opnum_in_range(argp, op))\n\t\t\top->status = nfsd4_dec_ops[op->opnum](argp, &op->u);\n\t\telse {\n\t\t\top->opnum = OP_ILLEGAL;\n\t\t\top->status = nfserr_op_illegal;\n\t\t}\n\t\t/*\n\t\t * We'll try to cache the result in the DRC if any one\n\t\t * op in the compound wants to be cached:\n\t\t */\n\t\tcachethis |= nfsd4_cache_this_op(op);\n\n\t\tif (op->opnum == OP_READ) {\n\t\t\treadcount++;\n\t\t\treadbytes += nfsd4_max_reply(argp->rqstp, op);\n\t\t} else\n\t\t\tmax_reply += nfsd4_max_reply(argp->rqstp, op);\n\t\t/*\n\t\t * OP_LOCK may return a conflicting lock.  (Special case\n\t\t * because it will just skip encoding this if it runs\n\t\t * out of xdr buffer space, and it is the only operation\n\t\t * that behaves this way.)\n\t\t */\n\t\tif (op->opnum == OP_LOCK)\n\t\t\tmax_reply += NFS4_OPAQUE_LIMIT;\n\n\t\tif (op->status) {\n\t\t\targp->opcnt = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Sessions make the DRC unnecessary: */\n\tif (argp->minorversion)\n\t\tcachethis = false;\n\tsvc_reserve(argp->rqstp, max_reply + readbytes);\n\targp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;\n\n\tif (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)\n\t\tclear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: compound not properly padded! (peeraddr=%pISc xid=0x%x)\"",
            "__func__",
            "svc_addr(rqstp)",
            "be32_to_cpu(rqstp->rq_xid)"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rqstp->rq_xid"
          ],
          "line": 4395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 4395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint\nnfs4svc_decode_compoundargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compoundargs *args)\n{\n\tif (rqstp->rq_arg.head[0].iov_len % 4) {\n\t\t/* client is nuts */\n\t\tdprintk(\"%s: compound not properly padded! (peeraddr=%pISc xid=0x%x)\",\n\t\t\t__func__, svc_addr(rqstp), be32_to_cpu(rqstp->rq_xid));\n\t\treturn 0;\n\t}\n\targs->p = p;\n\targs->end = rqstp->rq_arg.head[0].iov_base + rqstp->rq_arg.head[0].iov_len;\n\targs->pagelist = rqstp->rq_arg.pages;\n\targs->pagelen = rqstp->rq_arg.page_len;\n\targs->tmpp = NULL;\n\targs->to_free = NULL;\n\targs->ops = args->iops;\n\targs->rqstp = rqstp;\n\n\treturn !nfsd4_decode_compound(args);\n}"
  },
  {
    "function_name": "nfsd4_release_compoundargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4370-4387",
    "snippet": "int nfsd4_release_compoundargs(void *rq, __be32 *p, void *resp)\n{\n\tstruct svc_rqst *rqstp = rq;\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\tif (args->ops != args->iops) {\n\t\tkfree(args->ops);\n\t\targs->ops = args->iops;\n\t}\n\tkfree(args->tmpp);\n\targs->tmpp = NULL;\n\twhile (args->to_free) {\n\t\tstruct svcxdr_tmpbuf *tb = args->to_free;\n\t\targs->to_free = tb->next;\n\t\tkfree(tb);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tb"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->tmpp"
          ],
          "line": 4379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->ops"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd4_release_compoundargs(void *rq, __be32 *p, void *resp)\n{\n\tstruct svc_rqst *rqstp = rq;\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\tif (args->ops != args->iops) {\n\t\tkfree(args->ops);\n\t\targs->ops = args->iops;\n\t}\n\tkfree(args->tmpp);\n\targs->tmpp = NULL;\n\twhile (args->to_free) {\n\t\tstruct svcxdr_tmpbuf *tb = args->to_free;\n\t\targs->to_free = tb->next;\n\t\tkfree(tb);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs4svc_encode_voidres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4364-4368",
    "snippet": "int\nnfs4svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n        return xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 4367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint\nnfs4svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n        return xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfsd4_encode_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4345-4362",
    "snippet": "void\nnfsd4_encode_replay(struct xdr_stream *xdr, struct nfsd4_op *op)\n{\n\t__be32 *p;\n\tstruct nfs4_replay *rp = op->replay;\n\n\tBUG_ON(!rp);\n\n\tp = xdr_reserve_space(xdr, 8 + rp->rp_buflen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\t*p++ = rp->rp_status;  /* already xdr'ed */\n\n\tp = xdr_encode_opaque_fixed(p, rp->rp_buf, rp->rp_buflen);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "rp->rp_buf",
            "rp->rp_buflen"
          ],
          "line": 4361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "op->opnum"
          ],
          "line": 4358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8 + rp->rp_buflen"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rp"
          ],
          "line": 4351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nvoid\nnfsd4_encode_replay(struct xdr_stream *xdr, struct nfsd4_op *op)\n{\n\t__be32 *p;\n\tstruct nfs4_replay *rp = op->replay;\n\n\tBUG_ON(!rp);\n\n\tp = xdr_reserve_space(xdr, 8 + rp->rp_buflen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\t*p++ = rp->rp_status;  /* already xdr'ed */\n\n\tp = xdr_encode_opaque_fixed(p, rp->rp_buf, rp->rp_buflen);\n}"
  },
  {
    "function_name": "nfsd4_encode_operation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4272-4337",
    "snippet": "void\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\txdr_commit_encode(xdr);\n\n\t/* nfsd4_check_resp_size guarantees enough room for error status */\n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t/*\n\t\t * The operation may have already been encoded or\n\t\t * partially encoded.  No op returns anything additional\n\t\t * in the case of one of these three errors, so we can\n\t\t * just truncate back to after the status.  But it's a\n\t\t * bug if we had to do this on a non-idempotent op:\n\t\t */\n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t/* Note that op->status is already in network byte order: */\n\twrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_enc)nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_enc)nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_enc)nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_enc)nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= (nfsd4_enc)nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_enc)nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= (nfsd4_enc)nfsd4_encode_link,\n\t[OP_LOCK]\t\t= (nfsd4_enc)nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_enc)nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_enc)nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= (nfsd4_enc)nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_enc)nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_enc)nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ]\t\t= (nfsd4_enc)nfsd4_encode_read,\n\t[OP_READDIR]\t\t= (nfsd4_enc)nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_enc)nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= (nfsd4_enc)nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_enc)nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_enc)nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_enc)nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_enc)nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= (nfsd4_enc)nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.1 operations */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_enc)nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_enc)nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_enc)nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_enc)nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= (nfsd4_enc)nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ_PLUS]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SEEK]\t\t= (nfsd4_enc)nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "post_err_offset - 4",
            "&op->status",
            "4"
          ],
          "line": 4336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_bytes_from_xdr_buf",
          "args": [
            "xdr->buf",
            "post_err_offset",
            "so->so_replay.rp_buf",
            "len"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "post_err_offset"
          ],
          "line": 4324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_on_nonidempotent_op",
          "args": [
            "op"
          ],
          "line": 4323
        },
        "resolved": true,
        "details": {
          "function_name": "warn_on_nonidempotent_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "2311-2318",
          "snippet": "void warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nvoid warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "&resp->cstate"
          ],
          "line": 4305
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_check_resp_size",
          "args": [
            "resp",
            "space_needed"
          ],
          "line": 4303
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_resp_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "4256-4270",
          "snippet": "__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_last_compound_op",
          "args": [
            "rqstp"
          ],
          "line": 4301
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_last_compound_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "617-623",
          "snippet": "static inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_commit_encode",
          "args": [
            "xdr"
          ],
          "line": 4296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoder",
          "args": [
            "resp",
            "op->status",
            "&op->u"
          ],
          "line": 4295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "nfsd4_enc_ops"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "op->opnum"
          ],
          "line": 4287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_enc)nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_enc)nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_enc)nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_enc)nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= (nfsd4_enc)nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_enc)nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= (nfsd4_enc)nfsd4_encode_link,\n\t[OP_LOCK]\t\t= (nfsd4_enc)nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_enc)nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_enc)nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= (nfsd4_enc)nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_enc)nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_enc)nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ]\t\t= (nfsd4_enc)nfsd4_encode_read,\n\t[OP_READDIR]\t\t= (nfsd4_enc)nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_enc)nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= (nfsd4_enc)nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_enc)nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_enc)nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_enc)nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_enc)nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= (nfsd4_enc)nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.1 operations */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_enc)nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_enc)nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_enc)nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_enc)nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= (nfsd4_enc)nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ_PLUS]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SEEK]\t\t= (nfsd4_enc)nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n};\n\nvoid\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\txdr_commit_encode(xdr);\n\n\t/* nfsd4_check_resp_size guarantees enough room for error status */\n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t/*\n\t\t * The operation may have already been encoded or\n\t\t * partially encoded.  No op returns anything additional\n\t\t * in the case of one of these three errors, so we can\n\t\t * just truncate back to after the status.  But it's a\n\t\t * bug if we had to do this on a non-idempotent op:\n\t\t */\n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t/* Note that op->status is already in network byte order: */\n\twrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\n}"
  },
  {
    "function_name": "nfsd4_check_resp_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4256-4270",
    "snippet": "__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "&resp->cstate"
          ],
          "line": 4263
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}"
  },
  {
    "function_name": "nfsd4_encode_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4147-4151",
    "snippet": "static __be32\nnfsd4_encode_noop(struct nfsd4_compoundres *resp, __be32 nfserr, void *p)\n{\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_noop(struct nfsd4_compoundres *resp, __be32 nfserr, void *p)\n{\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4131-4145",
    "snippet": "static __be32\nnfsd4_encode_seek(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  struct nfsd4_seek *seek)\n{\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(&resp->xdr, 4 + 8);\n\t*p++ = cpu_to_be32(seek->seek_eof);\n\tp = xdr_encode_hyper(p, seek->seek_pos);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "seek->seek_pos"
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seek->seek_eof"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "&resp->xdr",
            "4 + 8"
          ],
          "line": 4140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_seek(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  struct nfsd4_seek *seek)\n{\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(&resp->xdr, 4 + 8);\n\t*p++ = cpu_to_be32(seek->seek_eof);\n\tp = xdr_encode_hyper(p, seek->seek_pos);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_layoutreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4111-4128",
    "snippet": "static __be32\nnfsd4_encode_layoutreturn(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(lrp->lrs_present);\n\tif (lrp->lrs_present)\n\t\tnfsd4_encode_stateid(xdr, &lrp->lr_sid);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&lrp->lr_sid"
          ],
          "line": 4126
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2955-2967",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lrp->lrs_present"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 4121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_layoutreturn(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(lrp->lrs_present);\n\tif (lrp->lrs_present)\n\t\tnfsd4_encode_stateid(xdr, &lrp->lr_sid);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_encode_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4087-4109",
    "snippet": "static __be32\nnfsd4_encode_layoutcommit(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  struct nfsd4_layoutcommit *lcp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(lcp->lc_size_chg);\n\tif (lcp->lc_size_chg) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_hyper(p, lcp->lc_newsize);\n\t}\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "lcp->lc_newsize"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 4102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lcp->lc_size_chg"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_layoutcommit(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  struct nfsd4_layoutcommit *lcp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(lcp->lc_size_chg);\n\tif (lcp->lc_size_chg) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_hyper(p, lcp->lc_newsize);\n\t}\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_encode_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4052-4085",
    "snippet": "static __be32\nnfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(1);\t/* we always set return-on-close */\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t/* we always return a single layout */\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lgp->lg_content"
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->encode_layoutget",
          "args": [
            "xdr",
            "lgp"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lgp->lg_layout_type"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lgp->lg_seg.iomode"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "lgp->lg_seg.length"
          ],
          "line": 4077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "lgp->lg_seg.offset"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&lgp->lg_sid.si_opaque",
            "sizeof(stateid_opaque_t)"
          ],
          "line": 4072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lgp->lg_sid.si_generation"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 4070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "36 + sizeof(stateid_opaque_t)"
          ],
          "line": 4066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: err %d\\n\"",
            "__func__",
            "nfserr"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(1);\t/* we always set return-on-close */\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t/* we always return a single layout */\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_getdeviceinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3982-4050",
    "snippet": "static __be32\nnfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\n\t/* If maxcount is 0 then just update notifications */\n\tif (gdev->gd_maxcount != 0) {\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\t/*\n\t\t\t * We don't bother to burden the layout drivers with\n\t\t\t * enforcing gd_maxcount, just tell the client to\n\t\t\t * come back with a bigger buffer if it's not enough.\n\t\t\t */\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t/* bitmap length */\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"%s: done: %d\\n\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\n\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4 /* notifications */;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "needed_len"
          ],
          "line": 4046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 4042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "starting_len"
          ],
          "line": 4041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: maxcount too small\\n\"",
            "__func__"
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: done: %d\\n\"",
            "__func__",
            "be32_to_cpu(nfserr)"
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "nfserr"
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "gdev->gd_device"
          ],
          "line": 4034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 4026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "gdev->gd_notify_types"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + 4"
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->encode_getdeviceinfo",
          "args": [
            "xdr",
            "gdev"
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "gdev->gd_layout_type"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: err %d\\n\"",
            "__func__",
            "nfserr"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\n\t/* If maxcount is 0 then just update notifications */\n\tif (gdev->gd_maxcount != 0) {\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\t/*\n\t\t\t * We don't bother to burden the layout drivers with\n\t\t\t * enforcing gd_maxcount, just tell the client to\n\t\t\t * come back with a bigger buffer if it's not enough.\n\t\t\t */\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t/* bitmap length */\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"%s: done: %d\\n\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\n\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4 /* notifications */;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "nfsd4_encode_test_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3958-3979",
    "snippet": "static __be32\nnfsd4_encode_test_stateid(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  struct nfsd4_test_stateid *test_stateid)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfsd4_test_stateid_id *stateid, *next;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4 + (4 * test_stateid->ts_num_ids));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = htonl(test_stateid->ts_num_ids);\n\n\tlist_for_each_entry_safe(stateid, next, &test_stateid->ts_stateid_list, ts_id_list) {\n\t\t*p++ = stateid->ts_id_status;\n\t}\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "stateid",
            "next",
            "&test_stateid->ts_stateid_list",
            "ts_id_list"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "test_stateid->ts_num_ids"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + (4 * test_stateid->ts_num_ids)"
          ],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_test_stateid(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  struct nfsd4_test_stateid *test_stateid)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfsd4_test_stateid_id *stateid, *next;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4 + (4 * test_stateid->ts_num_ids));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = htonl(test_stateid->ts_num_ids);\n\n\tlist_for_each_entry_safe(stateid, next, &test_stateid->ts_stateid_list, ts_id_list) {\n\t\t*p++ = stateid->ts_id_status;\n\t}\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3932-3956",
    "snippet": "static __be32\nnfsd4_encode_sequence(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t      struct nfsd4_sequence *seq)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 20);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, seq->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(seq->seqid);\n\t*p++ = cpu_to_be32(seq->slotid);\n\t/* Note slotid's are numbered from zero: */\n\t*p++ = cpu_to_be32(seq->maxslots - 1); /* sr_highest_slotid */\n\t*p++ = cpu_to_be32(seq->maxslots - 1); /* sr_target_highest_slotid */\n\t*p++ = cpu_to_be32(seq->status_flags);\n\n\tresp->cstate.data_offset = xdr->buf->len; /* DRC cache data pointer */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seq->status_flags"
          ],
          "line": 3952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seq->maxslots - 1"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seq->maxslots - 1"
          ],
          "line": 3950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seq->slotid"
          ],
          "line": 3948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seq->seqid"
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "seq->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "NFS4_MAX_SESSIONID_LEN + 20"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_sequence(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t      struct nfsd4_sequence *seq)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 20);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, seq->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(seq->seqid);\n\t*p++ = cpu_to_be32(seq->slotid);\n\t/* Note slotid's are numbered from zero: */\n\t*p++ = cpu_to_be32(seq->maxslots - 1); /* sr_highest_slotid */\n\t*p++ = cpu_to_be32(seq->maxslots - 1); /* sr_target_highest_slotid */\n\t*p++ = cpu_to_be32(seq->status_flags);\n\n\tresp->cstate.data_offset = xdr->buf->len; /* DRC cache data pointer */\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_create_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3876-3930",
    "snippet": "static __be32\nnfsd4_encode_create_session(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t    struct nfsd4_create_session *sess)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 24);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, sess->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(sess->seqid);\n\t*p++ = cpu_to_be32(sess->flags);\n\n\tp = xdr_reserve_space(xdr, 28);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(0); /* headerpadsz */\n\t*p++ = cpu_to_be32(sess->fore_channel.maxreq_sz);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxresp_sz);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxresp_cached);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxops);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxreqs);\n\t*p++ = cpu_to_be32(sess->fore_channel.nr_rdma_attrs);\n\n\tif (sess->fore_channel.nr_rdma_attrs) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(sess->fore_channel.rdma_attrs);\n\t}\n\n\tp = xdr_reserve_space(xdr, 28);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(0); /* headerpadsz */\n\t*p++ = cpu_to_be32(sess->back_channel.maxreq_sz);\n\t*p++ = cpu_to_be32(sess->back_channel.maxresp_sz);\n\t*p++ = cpu_to_be32(sess->back_channel.maxresp_cached);\n\t*p++ = cpu_to_be32(sess->back_channel.maxops);\n\t*p++ = cpu_to_be32(sess->back_channel.maxreqs);\n\t*p++ = cpu_to_be32(sess->back_channel.nr_rdma_attrs);\n\n\tif (sess->back_channel.nr_rdma_attrs) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(sess->back_channel.rdma_attrs);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.rdma_attrs"
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.nr_rdma_attrs"
          ],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.maxreqs"
          ],
          "line": 3920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.maxops"
          ],
          "line": 3919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.maxresp_cached"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.maxresp_sz"
          ],
          "line": 3917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.maxreq_sz"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "28"
          ],
          "line": 3912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.rdma_attrs"
          ],
          "line": 3909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.nr_rdma_attrs"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.maxreqs"
          ],
          "line": 3902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.maxops"
          ],
          "line": 3901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.maxresp_cached"
          ],
          "line": 3900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.maxresp_sz"
          ],
          "line": 3899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.maxreq_sz"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "28"
          ],
          "line": 3894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->flags"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->seqid"
          ],
          "line": 3891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "sess->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 3889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "24"
          ],
          "line": 3886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_create_session(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t    struct nfsd4_create_session *sess)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 24);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, sess->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(sess->seqid);\n\t*p++ = cpu_to_be32(sess->flags);\n\n\tp = xdr_reserve_space(xdr, 28);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(0); /* headerpadsz */\n\t*p++ = cpu_to_be32(sess->fore_channel.maxreq_sz);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxresp_sz);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxresp_cached);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxops);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxreqs);\n\t*p++ = cpu_to_be32(sess->fore_channel.nr_rdma_attrs);\n\n\tif (sess->fore_channel.nr_rdma_attrs) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(sess->fore_channel.rdma_attrs);\n\t}\n\n\tp = xdr_reserve_space(xdr, 28);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(0); /* headerpadsz */\n\t*p++ = cpu_to_be32(sess->back_channel.maxreq_sz);\n\t*p++ = cpu_to_be32(sess->back_channel.maxresp_sz);\n\t*p++ = cpu_to_be32(sess->back_channel.maxresp_cached);\n\t*p++ = cpu_to_be32(sess->back_channel.maxops);\n\t*p++ = cpu_to_be32(sess->back_channel.maxreqs);\n\t*p++ = cpu_to_be32(sess->back_channel.nr_rdma_attrs);\n\n\tif (sess->back_channel.nr_rdma_attrs) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(sess->back_channel.rdma_attrs);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_exchange_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3798-3874",
    "snippet": "static __be32\nnfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t struct nfsd4_exchange_id *exid)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\tchar *major_id;\n\tchar *server_scope;\n\tint major_id_sz;\n\tint server_scope_sz;\n\tuint64_t minor_id = 0;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tmajor_id = utsname()->nodename;\n\tmajor_id_sz = strlen(major_id);\n\tserver_scope = utsname()->nodename;\n\tserver_scope_sz = strlen(server_scope);\n\n\tp = xdr_reserve_space(xdr,\n\t\t8 /* eir_clientid */ +\n\t\t4 /* eir_sequenceid */ +\n\t\t4 /* eir_flags */ +\n\t\t4 /* spr_how */);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tp = xdr_encode_opaque_fixed(p, &exid->clientid, 8);\n\t*p++ = cpu_to_be32(exid->seqid);\n\t*p++ = cpu_to_be32(exid->flags);\n\n\t*p++ = cpu_to_be32(exid->spa_how);\n\n\tswitch (exid->spa_how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\t/* spo_must_enforce, spo_must_allow */\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\n\t\t/* spo_must_enforce bitmap: */\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[0]);\n\t\t*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[1]);\n\t\t/* empty spo_must_allow bitmap: */\n\t\t*p++ = cpu_to_be32(0);\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\tp = xdr_reserve_space(xdr,\n\t\t8 /* so_minor_id */ +\n\t\t4 /* so_major_id.len */ +\n\t\t(XDR_QUADLEN(major_id_sz) * 4) +\n\t\t4 /* eir_server_scope.len */ +\n\t\t(XDR_QUADLEN(server_scope_sz) * 4) +\n\t\t4 /* eir_server_impl_id.count (0) */);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/* The server_owner struct */\n\tp = xdr_encode_hyper(p, minor_id);      /* Minor id */\n\t/* major id */\n\tp = xdr_encode_opaque(p, major_id, major_id_sz);\n\n\t/* Server scope */\n\tp = xdr_encode_opaque(p, server_scope, server_scope_sz);\n\n\t/* Implementation id */\n\t*p++ = cpu_to_be32(0);\t/* zero length nfs_impl_id4 array */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const u32 nfs4_minimal_spo_must_enforce[2] = {\n\t[1] = 1 << (OP_BIND_CONN_TO_SESSION - 32) |\n\t      1 << (OP_EXCHANGE_ID - 32) |\n\t      1 << (OP_CREATE_SESSION - 32) |\n\t      1 << (OP_DESTROY_SESSION - 32) |\n\t      1 << (OP_DESTROY_CLIENTID - 32)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "server_scope",
            "server_scope_sz"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "major_id",
            "major_id_sz"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "minor_id"
          ],
          "line": 3864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8 /* so_minor_id */ +\n\t\t4 /* so_major_id.len */ +\n\t\t(XDR_QUADLEN(major_id_sz) * 4) +\n\t\t4 /* eir_server_scope.len */ +\n\t\t(XDR_QUADLEN(server_scope_sz) * 4) +\n\t\t4/* eir_server_impl_id.count (0) */"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "server_scope_sz"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "major_id_sz"
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nfs4_minimal_spo_must_enforce[1]"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nfs4_minimal_spo_must_enforce[0]"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "2"
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 3837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "exid->spa_how"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "exid->flags"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "exid->seqid"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&exid->clientid",
            "8"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8 /* eir_clientid */ +\n\t\t4 /* eir_sequenceid */ +\n\t\t4 /* eir_flags */ +\n\t\t4/* spr_how */"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "server_scope"
          ],
          "line": 3816
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "utsname",
          "args": [],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utsname",
          "args": [],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic const u32 nfs4_minimal_spo_must_enforce[2] = {\n\t[1] = 1 << (OP_BIND_CONN_TO_SESSION - 32) |\n\t      1 << (OP_EXCHANGE_ID - 32) |\n\t      1 << (OP_CREATE_SESSION - 32) |\n\t      1 << (OP_DESTROY_SESSION - 32) |\n\t      1 << (OP_DESTROY_CLIENTID - 32)\n};\n\nstatic __be32\nnfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t struct nfsd4_exchange_id *exid)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\tchar *major_id;\n\tchar *server_scope;\n\tint major_id_sz;\n\tint server_scope_sz;\n\tuint64_t minor_id = 0;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tmajor_id = utsname()->nodename;\n\tmajor_id_sz = strlen(major_id);\n\tserver_scope = utsname()->nodename;\n\tserver_scope_sz = strlen(server_scope);\n\n\tp = xdr_reserve_space(xdr,\n\t\t8 /* eir_clientid */ +\n\t\t4 /* eir_sequenceid */ +\n\t\t4 /* eir_flags */ +\n\t\t4 /* spr_how */);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tp = xdr_encode_opaque_fixed(p, &exid->clientid, 8);\n\t*p++ = cpu_to_be32(exid->seqid);\n\t*p++ = cpu_to_be32(exid->flags);\n\n\t*p++ = cpu_to_be32(exid->spa_how);\n\n\tswitch (exid->spa_how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\t/* spo_must_enforce, spo_must_allow */\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\n\t\t/* spo_must_enforce bitmap: */\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[0]);\n\t\t*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[1]);\n\t\t/* empty spo_must_allow bitmap: */\n\t\t*p++ = cpu_to_be32(0);\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\tp = xdr_reserve_space(xdr,\n\t\t8 /* so_minor_id */ +\n\t\t4 /* so_major_id.len */ +\n\t\t(XDR_QUADLEN(major_id_sz) * 4) +\n\t\t4 /* eir_server_scope.len */ +\n\t\t(XDR_QUADLEN(server_scope_sz) * 4) +\n\t\t4 /* eir_server_impl_id.count (0) */);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/* The server_owner struct */\n\tp = xdr_encode_hyper(p, minor_id);      /* Minor id */\n\t/* major id */\n\tp = xdr_encode_opaque(p, major_id, major_id_sz);\n\n\t/* Server scope */\n\tp = xdr_encode_opaque(p, server_scope, server_scope_sz);\n\n\t/* Implementation id */\n\t*p++ = cpu_to_be32(0);\t/* zero length nfs_impl_id4 array */\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3772-3788",
    "snippet": "static __be32\nnfsd4_encode_write(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_write *write)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(write->wr_bytes_written);\n\t\t*p++ = cpu_to_be32(write->wr_how_written);\n\t\tp = xdr_encode_opaque_fixed(p, write->wr_verifier.data,\n\t\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "write->wr_verifier.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "write->wr_how_written"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "write->wr_bytes_written"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 3779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_write(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_write *write)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(write->wr_bytes_written);\n\t\t*p++ = cpu_to_be32(write->wr_how_written);\n\t\tp = xdr_encode_opaque_fixed(p, write->wr_verifier.data,\n\t\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_setclientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3748-3770",
    "snippet": "static __be32\nnfsd4_encode_setclientid(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setclientid *scd)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 8 + NFS4_VERIFIER_SIZE);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, &scd->se_clientid, 8);\n\t\tp = xdr_encode_opaque_fixed(p, &scd->se_confirm,\n\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\telse if (nfserr == nfserr_clid_inuse) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&scd->se_confirm",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&scd->se_clientid",
            "8"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8 + NFS4_VERIFIER_SIZE"
          ],
          "line": 3755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_setclientid(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setclientid *scd)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 8 + NFS4_VERIFIER_SIZE);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, &scd->se_clientid, 8);\n\t\tp = xdr_encode_opaque_fixed(p, &scd->se_confirm,\n\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\telse if (nfserr == nfserr_clid_inuse) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3724-3746",
    "snippet": "static __be32\nnfsd4_encode_setattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setattr *setattr)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 16);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tif (nfserr) {\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\telse {\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[0]);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[1]);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[2]);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "setattr->sa_bmval[2]"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "setattr->sa_bmval[1]"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "setattr->sa_bmval[0]"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "3"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "3"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_setattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setattr *setattr)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 16);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tif (nfserr) {\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\telse {\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[0]);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[1]);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[2]);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_secinfo_no_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3711-3718",
    "snippet": "static __be32\nnfsd4_encode_secinfo_no_name(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     struct nfsd4_secinfo_no_name *secinfo)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\treturn nfsd4_do_encode_secinfo(xdr, nfserr, secinfo->sin_exp);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_do_encode_secinfo",
          "args": [
            "xdr",
            "nfserr",
            "secinfo->sin_exp"
          ],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_do_encode_secinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3626-3700",
          "snippet": "static __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_secinfo_no_name(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     struct nfsd4_secinfo_no_name *secinfo)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\treturn nfsd4_do_encode_secinfo(xdr, nfserr, secinfo->sin_exp);\n}"
  },
  {
    "function_name": "nfsd4_encode_secinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3702-3709",
    "snippet": "static __be32\nnfsd4_encode_secinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     struct nfsd4_secinfo *secinfo)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\treturn nfsd4_do_encode_secinfo(xdr, nfserr, secinfo->si_exp);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_do_encode_secinfo",
          "args": [
            "xdr",
            "nfserr",
            "secinfo->si_exp"
          ],
          "line": 3708
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_do_encode_secinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3626-3700",
          "snippet": "static __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_secinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     struct nfsd4_secinfo *secinfo)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\treturn nfsd4_do_encode_secinfo(xdr, nfserr, secinfo->si_exp);\n}"
  },
  {
    "function_name": "nfsd4_do_encode_secinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3626-3700",
    "snippet": "static __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "supported"
          ],
          "line": 3694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\"",
            "pf"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "pf"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "info.service"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "info.qop"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "info.oid.data",
            "info.oid.len"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "RPC_AUTH_GSS"
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_LEN",
          "args": [
            "info.oid.len"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpcauth_get_gssinfo",
          "args": [
            "pf",
            "&info"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gss_flavor",
          "args": [
            "exp->ex_client"
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3610-3624",
    "snippet": "static __be32\nnfsd4_encode_rename(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_rename *rename)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 40);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &rename->rn_sinfo);\n\t\tp = encode_cinfo(p, &rename->rn_tinfo);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_cinfo",
          "args": [
            "p",
            "&rename->rn_tinfo"
          ],
          "line": 3621
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1889-1902",
          "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "40"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_rename(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_rename *rename)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 40);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &rename->rn_sinfo);\n\t\tp = encode_cinfo(p, &rename->rn_tinfo);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3595-3608",
    "snippet": "static __be32\nnfsd4_encode_remove(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_remove *remove)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &remove->rm_cinfo);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_cinfo",
          "args": [
            "p",
            "&remove->rm_cinfo"
          ],
          "line": 3605
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1889-1902",
          "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "20"
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_remove(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_remove *remove)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &remove->rm_cinfo);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3502-3593",
    "snippet": "static __be32\nnfsd4_encode_readdir(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readdir *readdir)\n{\n\tint maxcount;\n\tint bytes_left;\n\tloff_t offset;\n\t__be64 wire_offset;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tint starting_len = xdr->buf->len;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/* XXX: Following NFSv3, we ignore the READDIR verifier for now. */\n\t*p++ = cpu_to_be32(0);\n\t*p++ = cpu_to_be32(0);\n\tresp->xdr.buf->head[0].iov_len = ((char *)resp->xdr.p)\n\t\t\t\t- (char *)resp->xdr.buf->head[0].iov_base;\n\n\t/*\n\t * Number of bytes left for directory entries allowing for the\n\t * final 8 bytes of the readdir and a following failed op:\n\t */\n\tbytes_left = xdr->buf->buflen - xdr->buf->len\n\t\t\t- COMPOUND_ERR_SLACK_SPACE - 8;\n\tif (bytes_left < 0) {\n\t\tnfserr = nfserr_resource;\n\t\tgoto err_no_verf;\n\t}\n\tmaxcount = min_t(u32, readdir->rd_maxcount, INT_MAX);\n\t/*\n\t * Note the rfc defines rd_maxcount as the size of the\n\t * READDIR4resok structure, which includes the verifier above\n\t * and the 8 bytes encoded at the end of this function:\n\t */\n\tif (maxcount < 16) {\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto err_no_verf;\n\t}\n\tmaxcount = min_t(int, maxcount-16, bytes_left);\n\n\t/* RFC 3530 14.2.24 allows us to ignore dircount when it's 0: */\n\tif (!readdir->rd_dircount)\n\t\treaddir->rd_dircount = INT_MAX;\n\n\treaddir->xdr = xdr;\n\treaddir->rd_maxcount = maxcount;\n\treaddir->common.err = 0;\n\treaddir->cookie_offset = 0;\n\n\toffset = readdir->rd_cookie;\n\tnfserr = nfsd_readdir(readdir->rd_rqstp, readdir->rd_fhp,\n\t\t\t      &offset,\n\t\t\t      &readdir->common, nfsd4_encode_dirent);\n\tif (nfserr == nfs_ok &&\n\t    readdir->common.err == nfserr_toosmall &&\n\t    xdr->buf->len == starting_len + 8) {\n\t\t/* nothing encoded; which limit did we hit?: */\n\t\tif (maxcount - 16 < bytes_left)\n\t\t\t/* It was the fault of rd_maxcount: */\n\t\t\tnfserr = nfserr_toosmall;\n\t\telse\n\t\t\t/* We ran out of buffer space: */\n\t\t\tnfserr = nfserr_resource;\n\t}\n\tif (nfserr)\n\t\tgoto err_no_verf;\n\n\tif (readdir->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, readdir->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto err_no_verf;\n\t}\n\t*p++ = 0;\t/* no more entries */\n\t*p++ = htonl(readdir->common.err == nfserr_eof);\n\n\treturn 0;\nerr_no_verf:\n\txdr_truncate_encode(xdr, starting_len);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "starting_len"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "readdir->common.err == nfserr_eof"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "readdir->cookie_offset",
            "&wire_offset",
            "8"
          ],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "offset"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_readdir",
          "args": [
            "readdir->rd_rqstp",
            "readdir->rd_fhp",
            "&offset",
            "&readdir->common",
            "nfsd4_encode_dirent"
          ],
          "line": 3558
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1952-1983",
          "snippet": "__be32\nnfsd_readdir(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t *offsetp, \n\t     struct readdir_cd *cdp, nfsd_filldir_t func)\n{\n\t__be32\t\terr;\n\tstruct file\t*file;\n\tloff_t\t\toffset = *offsetp;\n\tint             may_flags = NFSD_MAY_READ;\n\n\t/* NFSv2 only supports 32 bit cookies */\n\tif (rqstp->rq_vers > 2)\n\t\tmay_flags |= NFSD_MAY_64BIT_COOKIE;\n\n\terr = nfsd_open(rqstp, fhp, S_IFDIR, may_flags, &file);\n\tif (err)\n\t\tgoto out;\n\n\toffset = vfs_llseek(file, offset, SEEK_SET);\n\tif (offset < 0) {\n\t\terr = nfserrno((int)offset);\n\t\tgoto out_close;\n\t}\n\n\terr = nfsd_buffered_readdir(file, func, cdp, offsetp);\n\n\tif (err == nfserr_eof || err == nfserr_toosmall)\n\t\terr = nfs_ok; /* can still be found in ->err */\nout_close:\n\tnfsd_close(file);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_readdir(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t *offsetp, \n\t     struct readdir_cd *cdp, nfsd_filldir_t func)\n{\n\t__be32\t\terr;\n\tstruct file\t*file;\n\tloff_t\t\toffset = *offsetp;\n\tint             may_flags = NFSD_MAY_READ;\n\n\t/* NFSv2 only supports 32 bit cookies */\n\tif (rqstp->rq_vers > 2)\n\t\tmay_flags |= NFSD_MAY_64BIT_COOKIE;\n\n\terr = nfsd_open(rqstp, fhp, S_IFDIR, may_flags, &file);\n\tif (err)\n\t\tgoto out;\n\n\toffset = vfs_llseek(file, offset, SEEK_SET);\n\tif (offset < 0) {\n\t\terr = nfserrno((int)offset);\n\t\tgoto out_close;\n\t}\n\n\terr = nfsd_buffered_readdir(file, func, cdp, offsetp);\n\n\tif (err == nfserr_eof || err == nfserr_toosmall)\n\t\terr = nfs_ok; /* can still be found in ->err */\nout_close:\n\tnfsd_close(file);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "maxcount-16",
            "bytes_left"
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "readdir->rd_maxcount",
            "INT_MAX"
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_readdir(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readdir *readdir)\n{\n\tint maxcount;\n\tint bytes_left;\n\tloff_t offset;\n\t__be64 wire_offset;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tint starting_len = xdr->buf->len;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/* XXX: Following NFSv3, we ignore the READDIR verifier for now. */\n\t*p++ = cpu_to_be32(0);\n\t*p++ = cpu_to_be32(0);\n\tresp->xdr.buf->head[0].iov_len = ((char *)resp->xdr.p)\n\t\t\t\t- (char *)resp->xdr.buf->head[0].iov_base;\n\n\t/*\n\t * Number of bytes left for directory entries allowing for the\n\t * final 8 bytes of the readdir and a following failed op:\n\t */\n\tbytes_left = xdr->buf->buflen - xdr->buf->len\n\t\t\t- COMPOUND_ERR_SLACK_SPACE - 8;\n\tif (bytes_left < 0) {\n\t\tnfserr = nfserr_resource;\n\t\tgoto err_no_verf;\n\t}\n\tmaxcount = min_t(u32, readdir->rd_maxcount, INT_MAX);\n\t/*\n\t * Note the rfc defines rd_maxcount as the size of the\n\t * READDIR4resok structure, which includes the verifier above\n\t * and the 8 bytes encoded at the end of this function:\n\t */\n\tif (maxcount < 16) {\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto err_no_verf;\n\t}\n\tmaxcount = min_t(int, maxcount-16, bytes_left);\n\n\t/* RFC 3530 14.2.24 allows us to ignore dircount when it's 0: */\n\tif (!readdir->rd_dircount)\n\t\treaddir->rd_dircount = INT_MAX;\n\n\treaddir->xdr = xdr;\n\treaddir->rd_maxcount = maxcount;\n\treaddir->common.err = 0;\n\treaddir->cookie_offset = 0;\n\n\toffset = readdir->rd_cookie;\n\tnfserr = nfsd_readdir(readdir->rd_rqstp, readdir->rd_fhp,\n\t\t\t      &offset,\n\t\t\t      &readdir->common, nfsd4_encode_dirent);\n\tif (nfserr == nfs_ok &&\n\t    readdir->common.err == nfserr_toosmall &&\n\t    xdr->buf->len == starting_len + 8) {\n\t\t/* nothing encoded; which limit did we hit?: */\n\t\tif (maxcount - 16 < bytes_left)\n\t\t\t/* It was the fault of rd_maxcount: */\n\t\t\tnfserr = nfserr_toosmall;\n\t\telse\n\t\t\t/* We ran out of buffer space: */\n\t\t\tnfserr = nfserr_resource;\n\t}\n\tif (nfserr)\n\t\tgoto err_no_verf;\n\n\tif (readdir->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, readdir->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto err_no_verf;\n\t}\n\t*p++ = 0;\t/* no more entries */\n\t*p++ = htonl(readdir->common.err == nfserr_eof);\n\n\treturn 0;\nerr_no_verf:\n\txdr_truncate_encode(xdr, starting_len);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3457-3500",
    "snippet": "static __be32\nnfsd4_encode_readlink(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readlink *readlink)\n{\n\tint maxcount;\n\t__be32 wire_count;\n\tint zero = 0;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tint length_offset = xdr->buf->len;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tmaxcount = PAGE_SIZE;\n\n\tp = xdr_reserve_space(xdr, maxcount);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t/*\n\t * XXX: By default, the ->readlink() VFS op will truncate symlinks\n\t * if they would overflow the buffer.  Is this kosher in NFSv4?  If\n\t * not, one easy fix is: if ->readlink() precisely fills the buffer,\n\t * assume that truncation occurred, and return NFS4ERR_RESOURCE.\n\t */\n\tnfserr = nfsd_readlink(readlink->rl_rqstp, readlink->rl_fhp,\n\t\t\t\t\t\t(char *)p, &maxcount);\n\tif (nfserr == nfserr_isdir)\n\t\tnfserr = nfserr_inval;\n\tif (nfserr) {\n\t\txdr_truncate_encode(xdr, length_offset);\n\t\treturn nfserr;\n\t}\n\n\twire_count = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, length_offset, &wire_count, 4);\n\txdr_truncate_encode(xdr, length_offset + 4 + ALIGN(maxcount, 4));\n\tif (maxcount & 3)\n\t\twrite_bytes_to_xdr_buf(xdr->buf, length_offset + 4 + maxcount,\n\t\t\t\t\t\t&zero, 4 - (maxcount&3));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "length_offset + 4 + maxcount",
            "&zero",
            "4 - (maxcount&3)"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "length_offset + 4 + ALIGN(maxcount, 4)"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "maxcount",
            "4"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "length_offset",
            "&wire_count",
            "4"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "maxcount"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "length_offset"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_readlink",
          "args": [
            "readlink->rl_rqstp",
            "readlink->rl_fhp",
            "(char *)p",
            "&maxcount"
          ],
          "line": 3484
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1501-1541",
          "snippet": "__be32\nnfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)\n{\n\tstruct inode\t*inode;\n\tmm_segment_t\toldfs;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tstruct path path;\n\n\terr = fh_verify(rqstp, fhp, S_IFLNK, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = path.dentry->d_inode;\n\n\terr = nfserr_inval;\n\tif (!inode->i_op->readlink)\n\t\tgoto out;\n\n\ttouch_atime(&path);\n\t/* N.B. Why does this call need a get_fs()??\n\t * Remove the set_fs and watch the fireworks:-) --okir\n\t */\n\n\toldfs = get_fs(); set_fs(KERNEL_DS);\n\thost_err = inode->i_op->readlink(path.dentry, (char __user *)buf, *lenp);\n\tset_fs(oldfs);\n\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\t*lenp = host_err;\n\terr = 0;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)\n{\n\tstruct inode\t*inode;\n\tmm_segment_t\toldfs;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tstruct path path;\n\n\terr = fh_verify(rqstp, fhp, S_IFLNK, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = path.dentry->d_inode;\n\n\terr = nfserr_inval;\n\tif (!inode->i_op->readlink)\n\t\tgoto out;\n\n\ttouch_atime(&path);\n\t/* N.B. Why does this call need a get_fs()??\n\t * Remove the set_fs and watch the fireworks:-) --okir\n\t */\n\n\toldfs = get_fs(); set_fs(KERNEL_DS);\n\thost_err = inode->i_op->readlink(path.dentry, (char __user *)buf, *lenp);\n\tset_fs(oldfs);\n\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\t*lenp = host_err;\n\terr = 0;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "maxcount"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_readlink(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readlink *readlink)\n{\n\tint maxcount;\n\t__be32 wire_count;\n\tint zero = 0;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tint length_offset = xdr->buf->len;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tmaxcount = PAGE_SIZE;\n\n\tp = xdr_reserve_space(xdr, maxcount);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t/*\n\t * XXX: By default, the ->readlink() VFS op will truncate symlinks\n\t * if they would overflow the buffer.  Is this kosher in NFSv4?  If\n\t * not, one easy fix is: if ->readlink() precisely fills the buffer,\n\t * assume that truncation occurred, and return NFS4ERR_RESOURCE.\n\t */\n\tnfserr = nfsd_readlink(readlink->rl_rqstp, readlink->rl_fhp,\n\t\t\t\t\t\t(char *)p, &maxcount);\n\tif (nfserr == nfserr_isdir)\n\t\tnfserr = nfserr_inval;\n\tif (nfserr) {\n\t\txdr_truncate_encode(xdr, length_offset);\n\t\treturn nfserr;\n\t}\n\n\twire_count = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, length_offset, &wire_count, 4);\n\txdr_truncate_encode(xdr, length_offset + 4 + ALIGN(maxcount, 4));\n\tif (maxcount & 3)\n\t\twrite_bytes_to_xdr_buf(xdr->buf, length_offset + 4 + maxcount,\n\t\t\t\t\t\t&zero, 4 - (maxcount&3));\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3406-3455",
    "snippet": "static __be32\nnfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  struct nfsd4_read *read)\n{\n\tunsigned long maxcount;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct file *file = read->rd_filp;\n\tint starting_len = xdr->buf->len;\n\tstruct raparms *ra;\n\t__be32 *p;\n\t__be32 err;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 8); /* eof flag and byte count */\n\tif (!p) {\n\t\tWARN_ON_ONCE(test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags));\n\t\treturn nfserr_resource;\n\t}\n\tif (resp->xdr.buf->page_len && test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_resource;\n\t}\n\txdr_commit_encode(xdr);\n\n\tmaxcount = svc_max_payload(resp->rqstp);\n\tmaxcount = min_t(unsigned long, maxcount, (xdr->buf->buflen - xdr->buf->len));\n\tmaxcount = min_t(unsigned long, maxcount, read->rd_length);\n\n\tif (!read->rd_filp) {\n\t\terr = nfsd_get_tmp_read_open(resp->rqstp, read->rd_fhp,\n\t\t\t\t\t\t&file, &ra);\n\t\tif (err)\n\t\t\tgoto err_truncate;\n\t}\n\n\tif (file->f_op->splice_read && test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags))\n\t\terr = nfsd4_encode_splice_read(resp, read, file, maxcount);\n\telse\n\t\terr = nfsd4_encode_readv(resp, read, file, maxcount);\n\n\tif (!read->rd_filp)\n\t\tnfsd_put_tmp_read_open(file, ra);\n\nerr_truncate:\n\tif (err)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn err;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "starting_len"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_put_tmp_read_open",
          "args": [
            "file",
            "ra"
          ],
          "line": 3449
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_put_tmp_read_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1032-1044",
          "snippet": "void nfsd_put_tmp_read_open(struct file *file, struct raparms *ra)\n{\n\t/* Write back readahead params */\n\tif (ra) {\n\t\tstruct raparm_hbucket *rab = &raparm_hash[ra->p_hindex];\n\t\tspin_lock(&rab->pb_lock);\n\t\tra->p_ra = file->f_ra;\n\t\tra->p_set = 1;\n\t\tra->p_count--;\n\t\tspin_unlock(&rab->pb_lock);\n\t}\n\tnfsd_close(file);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];\n\nvoid nfsd_put_tmp_read_open(struct file *file, struct raparms *ra)\n{\n\t/* Write back readahead params */\n\tif (ra) {\n\t\tstruct raparm_hbucket *rab = &raparm_hash[ra->p_hindex];\n\t\tspin_lock(&rab->pb_lock);\n\t\tra->p_ra = file->f_ra;\n\t\tra->p_set = 1;\n\t\tra->p_count--;\n\t\tspin_unlock(&rab->pb_lock);\n\t}\n\tnfsd_close(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_readv",
          "args": [
            "resp",
            "read",
            "file",
            "maxcount"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3347-3404",
          "snippet": "static __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,\n\t\t\t\t struct nfsd4_read *read,\n\t\t\t\t struct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tu32 eof;\n\tint v;\n\tint starting_len = xdr->buf->len - 8;\n\tlong len;\n\tint thislen;\n\t__be32 nfserr;\n\t__be32 tmp;\n\t__be32 *p;\n\tu32 zzz = 0;\n\tint pad;\n\n\tlen = maxcount;\n\tv = 0;\n\n\tthislen = min_t(long, len, ((void *)xdr->end - (void *)xdr->p));\n\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\tWARN_ON_ONCE(!p);\n\tresp->rqstp->rq_vec[v].iov_base = p;\n\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\tv++;\n\tlen -= thislen;\n\n\twhile (len) {\n\t\tthislen = min_t(long, len, PAGE_SIZE);\n\t\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\t\tWARN_ON_ONCE(!p);\n\t\tresp->rqstp->rq_vec[v].iov_base = p;\n\t\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\t\tv++;\n\t\tlen -= thislen;\n\t}\n\tread->rd_vlen = v;\n\n\tnfserr = nfsd_readv(file, read->rd_offset, resp->rqstp->rq_vec,\n\t\t\tread->rd_vlen, &maxcount);\n\tif (nfserr)\n\t\treturn nfserr;\n\txdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));\n\n\teof = (read->rd_offset + maxcount >=\n\t       read->rd_fhp->fh_dentry->d_inode->i_size);\n\n\ttmp = htonl(eof);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len    , &tmp, 4);\n\ttmp = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 4, &tmp, 4);\n\n\tpad = (maxcount&3) ? 4 - (maxcount&3) : 0;\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 8 + maxcount,\n\t\t\t\t\t\t\t\t&zzz, pad);\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,\n\t\t\t\t struct nfsd4_read *read,\n\t\t\t\t struct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tu32 eof;\n\tint v;\n\tint starting_len = xdr->buf->len - 8;\n\tlong len;\n\tint thislen;\n\t__be32 nfserr;\n\t__be32 tmp;\n\t__be32 *p;\n\tu32 zzz = 0;\n\tint pad;\n\n\tlen = maxcount;\n\tv = 0;\n\n\tthislen = min_t(long, len, ((void *)xdr->end - (void *)xdr->p));\n\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\tWARN_ON_ONCE(!p);\n\tresp->rqstp->rq_vec[v].iov_base = p;\n\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\tv++;\n\tlen -= thislen;\n\n\twhile (len) {\n\t\tthislen = min_t(long, len, PAGE_SIZE);\n\t\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\t\tWARN_ON_ONCE(!p);\n\t\tresp->rqstp->rq_vec[v].iov_base = p;\n\t\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\t\tv++;\n\t\tlen -= thislen;\n\t}\n\tread->rd_vlen = v;\n\n\tnfserr = nfsd_readv(file, read->rd_offset, resp->rqstp->rq_vec,\n\t\t\tread->rd_vlen, &maxcount);\n\tif (nfserr)\n\t\treturn nfserr;\n\txdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));\n\n\teof = (read->rd_offset + maxcount >=\n\t       read->rd_fhp->fh_dentry->d_inode->i_size);\n\n\ttmp = htonl(eof);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len    , &tmp, 4);\n\ttmp = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 4, &tmp, 4);\n\n\tpad = (maxcount&3) ? 4 - (maxcount&3) : 0;\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 8 + maxcount,\n\t\t\t\t\t\t\t\t&zzz, pad);\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_splice_read",
          "args": [
            "resp",
            "read",
            "file",
            "maxcount"
          ],
          "line": 3444
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3286-3345",
          "snippet": "static __be32 nfsd4_encode_splice_read(\n\t\t\t\tstruct nfsd4_compoundres *resp,\n\t\t\t\tstruct nfsd4_read *read,\n\t\t\t\tstruct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = xdr->buf;\n\tu32 eof;\n\tint space_left;\n\t__be32 nfserr;\n\t__be32 *p = xdr->p - 2;\n\n\t/* Make sure there will be room for padding if needed */\n\tif (xdr->end - xdr->p < 1)\n\t\treturn nfserr_resource;\n\n\tnfserr = nfsd_splice_read(read->rd_rqstp, file,\n\t\t\t\t  read->rd_offset, &maxcount);\n\tif (nfserr) {\n\t\t/*\n\t\t * nfsd_splice_actor may have already messed with the\n\t\t * page length; reset it so as not to confuse\n\t\t * xdr_truncate_encode:\n\t\t */\n\t\tbuf->page_len = 0;\n\t\treturn nfserr;\n\t}\n\n\teof = (read->rd_offset + maxcount >=\n\t       read->rd_fhp->fh_dentry->d_inode->i_size);\n\n\t*(p++) = htonl(eof);\n\t*(p++) = htonl(maxcount);\n\n\tbuf->page_len = maxcount;\n\tbuf->len += maxcount;\n\txdr->page_ptr += (buf->page_base + maxcount + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t/ PAGE_SIZE;\n\n\t/* Use rest of head for padding and remaining ops: */\n\tbuf->tail[0].iov_base = xdr->p;\n\tbuf->tail[0].iov_len = 0;\n\txdr->iov = buf->tail;\n\tif (maxcount&3) {\n\t\tint pad = 4 - (maxcount&3);\n\n\t\t*(xdr->p++) = 0;\n\n\t\tbuf->tail[0].iov_base += maxcount&3;\n\t\tbuf->tail[0].iov_len = pad;\n\t\tbuf->len += pad;\n\t}\n\n\tspace_left = min_t(int, (void *)xdr->end - (void *)xdr->p,\n\t\t\t\tbuf->buflen - buf->len);\n\tbuf->buflen = buf->len + space_left;\n\txdr->end = (__be32 *)((void *)xdr->end + space_left);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_splice_read(\n\t\t\t\tstruct nfsd4_compoundres *resp,\n\t\t\t\tstruct nfsd4_read *read,\n\t\t\t\tstruct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = xdr->buf;\n\tu32 eof;\n\tint space_left;\n\t__be32 nfserr;\n\t__be32 *p = xdr->p - 2;\n\n\t/* Make sure there will be room for padding if needed */\n\tif (xdr->end - xdr->p < 1)\n\t\treturn nfserr_resource;\n\n\tnfserr = nfsd_splice_read(read->rd_rqstp, file,\n\t\t\t\t  read->rd_offset, &maxcount);\n\tif (nfserr) {\n\t\t/*\n\t\t * nfsd_splice_actor may have already messed with the\n\t\t * page length; reset it so as not to confuse\n\t\t * xdr_truncate_encode:\n\t\t */\n\t\tbuf->page_len = 0;\n\t\treturn nfserr;\n\t}\n\n\teof = (read->rd_offset + maxcount >=\n\t       read->rd_fhp->fh_dentry->d_inode->i_size);\n\n\t*(p++) = htonl(eof);\n\t*(p++) = htonl(maxcount);\n\n\tbuf->page_len = maxcount;\n\tbuf->len += maxcount;\n\txdr->page_ptr += (buf->page_base + maxcount + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t/ PAGE_SIZE;\n\n\t/* Use rest of head for padding and remaining ops: */\n\tbuf->tail[0].iov_base = xdr->p;\n\tbuf->tail[0].iov_len = 0;\n\txdr->iov = buf->tail;\n\tif (maxcount&3) {\n\t\tint pad = 4 - (maxcount&3);\n\n\t\t*(xdr->p++) = 0;\n\n\t\tbuf->tail[0].iov_base += maxcount&3;\n\t\tbuf->tail[0].iov_len = pad;\n\t\tbuf->len += pad;\n\t}\n\n\tspace_left = min_t(int, (void *)xdr->end - (void *)xdr->p,\n\t\t\t\tbuf->buflen - buf->len);\n\tbuf->buflen = buf->len + space_left;\n\txdr->end = (__be32 *)((void *)xdr->end + space_left);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_SPLICE_OK",
            "&resp->rqstp->rq_flags"
          ],
          "line": 3443
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_get_tmp_read_open",
          "args": [
            "resp->rqstp",
            "read->rd_fhp",
            "&file",
            "&ra"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_get_tmp_read_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1012-1030",
          "snippet": "__be32 nfsd_get_tmp_read_open(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct file **file, struct raparms **ra)\n{\n\tstruct inode *inode;\n\t__be32 err;\n\n\terr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, file);\n\tif (err)\n\t\treturn err;\n\n\tinode = file_inode(*file);\n\n\t/* Get readahead parameters */\n\t*ra = nfsd_get_raparms(inode->i_sb->s_dev, inode->i_ino);\n\n\tif (*ra && (*ra)->p_set)\n\t\t(*file)->f_ra = (*ra)->p_ra;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32 nfsd_get_tmp_read_open(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct file **file, struct raparms **ra)\n{\n\tstruct inode *inode;\n\t__be32 err;\n\n\terr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, file);\n\tif (err)\n\t\treturn err;\n\n\tinode = file_inode(*file);\n\n\t/* Get readahead parameters */\n\t*ra = nfsd_get_raparms(inode->i_sb->s_dev, inode->i_ino);\n\n\tif (*ra && (*ra)->p_set)\n\t\t(*file)->f_ra = (*ra)->p_ra;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "maxcount",
            "read->rd_length"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "maxcount",
            "(xdr->buf->buflen - xdr->buf->len)"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "resp->rqstp"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_commit_encode",
          "args": [
            "xdr"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags)"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  struct nfsd4_read *read)\n{\n\tunsigned long maxcount;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct file *file = read->rd_filp;\n\tint starting_len = xdr->buf->len;\n\tstruct raparms *ra;\n\t__be32 *p;\n\t__be32 err;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 8); /* eof flag and byte count */\n\tif (!p) {\n\t\tWARN_ON_ONCE(test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags));\n\t\treturn nfserr_resource;\n\t}\n\tif (resp->xdr.buf->page_len && test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_resource;\n\t}\n\txdr_commit_encode(xdr);\n\n\tmaxcount = svc_max_payload(resp->rqstp);\n\tmaxcount = min_t(unsigned long, maxcount, (xdr->buf->buflen - xdr->buf->len));\n\tmaxcount = min_t(unsigned long, maxcount, read->rd_length);\n\n\tif (!read->rd_filp) {\n\t\terr = nfsd_get_tmp_read_open(resp->rqstp, read->rd_fhp,\n\t\t\t\t\t\t&file, &ra);\n\t\tif (err)\n\t\t\tgoto err_truncate;\n\t}\n\n\tif (file->f_op->splice_read && test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags))\n\t\terr = nfsd4_encode_splice_read(resp, read, file, maxcount);\n\telse\n\t\terr = nfsd4_encode_readv(resp, read, file, maxcount);\n\n\tif (!read->rd_filp)\n\t\tnfsd_put_tmp_read_open(file, ra);\n\nerr_truncate:\n\tif (err)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn err;\n}"
  },
  {
    "function_name": "nfsd4_encode_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3347-3404",
    "snippet": "static __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,\n\t\t\t\t struct nfsd4_read *read,\n\t\t\t\t struct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tu32 eof;\n\tint v;\n\tint starting_len = xdr->buf->len - 8;\n\tlong len;\n\tint thislen;\n\t__be32 nfserr;\n\t__be32 tmp;\n\t__be32 *p;\n\tu32 zzz = 0;\n\tint pad;\n\n\tlen = maxcount;\n\tv = 0;\n\n\tthislen = min_t(long, len, ((void *)xdr->end - (void *)xdr->p));\n\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\tWARN_ON_ONCE(!p);\n\tresp->rqstp->rq_vec[v].iov_base = p;\n\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\tv++;\n\tlen -= thislen;\n\n\twhile (len) {\n\t\tthislen = min_t(long, len, PAGE_SIZE);\n\t\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\t\tWARN_ON_ONCE(!p);\n\t\tresp->rqstp->rq_vec[v].iov_base = p;\n\t\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\t\tv++;\n\t\tlen -= thislen;\n\t}\n\tread->rd_vlen = v;\n\n\tnfserr = nfsd_readv(file, read->rd_offset, resp->rqstp->rq_vec,\n\t\t\tread->rd_vlen, &maxcount);\n\tif (nfserr)\n\t\treturn nfserr;\n\txdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));\n\n\teof = (read->rd_offset + maxcount >=\n\t       read->rd_fhp->fh_dentry->d_inode->i_size);\n\n\ttmp = htonl(eof);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len    , &tmp, 4);\n\ttmp = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 4, &tmp, 4);\n\n\tpad = (maxcount&3) ? 4 - (maxcount&3) : 0;\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 8 + maxcount,\n\t\t\t\t\t\t\t\t&zzz, pad);\n\treturn 0;\n\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "starting_len + 8 + maxcount",
            "&zzz",
            "pad"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "starting_len + 4",
            "&tmp",
            "4"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "maxcount"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "starting_len",
            "&tmp",
            "4"
          ],
          "line": 3395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "eof"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "starting_len + 8 + ((maxcount+3)&~3)"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_readv",
          "args": [
            "file",
            "read->rd_offset",
            "resp->rqstp->rq_vec",
            "read->rd_vlen",
            "&maxcount"
          ],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "888-899",
          "snippet": "__be32 nfsd_readv(struct file *file, loff_t offset, struct kvec *vec, int vlen,\n\t\tunsigned long *count)\n{\n\tmm_segment_t oldfs;\n\tint host_err;\n\n\toldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\thost_err = vfs_readv(file, (struct iovec __user *)vec, vlen, &offset);\n\tset_fs(oldfs);\n\treturn nfsd_finish_read(file, count, host_err);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32 nfsd_readv(struct file *file, loff_t offset, struct kvec *vec, int vlen,\n\t\tunsigned long *count)\n{\n\tmm_segment_t oldfs;\n\tint host_err;\n\n\toldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\thost_err = vfs_readv(file, (struct iovec __user *)vec, vlen, &offset);\n\tset_fs(oldfs);\n\treturn nfsd_finish_read(file, count, host_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!p"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "(thislen+3)&~3"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "long",
            "len",
            "PAGE_SIZE"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!p"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "(thislen+3)&~3"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "long",
            "len",
            "((void *)xdr->end - (void *)xdr->p)"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,\n\t\t\t\t struct nfsd4_read *read,\n\t\t\t\t struct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tu32 eof;\n\tint v;\n\tint starting_len = xdr->buf->len - 8;\n\tlong len;\n\tint thislen;\n\t__be32 nfserr;\n\t__be32 tmp;\n\t__be32 *p;\n\tu32 zzz = 0;\n\tint pad;\n\n\tlen = maxcount;\n\tv = 0;\n\n\tthislen = min_t(long, len, ((void *)xdr->end - (void *)xdr->p));\n\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\tWARN_ON_ONCE(!p);\n\tresp->rqstp->rq_vec[v].iov_base = p;\n\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\tv++;\n\tlen -= thislen;\n\n\twhile (len) {\n\t\tthislen = min_t(long, len, PAGE_SIZE);\n\t\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\t\tWARN_ON_ONCE(!p);\n\t\tresp->rqstp->rq_vec[v].iov_base = p;\n\t\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\t\tv++;\n\t\tlen -= thislen;\n\t}\n\tread->rd_vlen = v;\n\n\tnfserr = nfsd_readv(file, read->rd_offset, resp->rqstp->rq_vec,\n\t\t\tread->rd_vlen, &maxcount);\n\tif (nfserr)\n\t\treturn nfserr;\n\txdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));\n\n\teof = (read->rd_offset + maxcount >=\n\t       read->rd_fhp->fh_dentry->d_inode->i_size);\n\n\ttmp = htonl(eof);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len    , &tmp, 4);\n\ttmp = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 4, &tmp, 4);\n\n\tpad = (maxcount&3) ? 4 - (maxcount&3) : 0;\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 8 + maxcount,\n\t\t\t\t\t\t\t\t&zzz, pad);\n\treturn 0;\n\n}"
  },
  {
    "function_name": "nfsd4_encode_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3286-3345",
    "snippet": "static __be32 nfsd4_encode_splice_read(\n\t\t\t\tstruct nfsd4_compoundres *resp,\n\t\t\t\tstruct nfsd4_read *read,\n\t\t\t\tstruct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = xdr->buf;\n\tu32 eof;\n\tint space_left;\n\t__be32 nfserr;\n\t__be32 *p = xdr->p - 2;\n\n\t/* Make sure there will be room for padding if needed */\n\tif (xdr->end - xdr->p < 1)\n\t\treturn nfserr_resource;\n\n\tnfserr = nfsd_splice_read(read->rd_rqstp, file,\n\t\t\t\t  read->rd_offset, &maxcount);\n\tif (nfserr) {\n\t\t/*\n\t\t * nfsd_splice_actor may have already messed with the\n\t\t * page length; reset it so as not to confuse\n\t\t * xdr_truncate_encode:\n\t\t */\n\t\tbuf->page_len = 0;\n\t\treturn nfserr;\n\t}\n\n\teof = (read->rd_offset + maxcount >=\n\t       read->rd_fhp->fh_dentry->d_inode->i_size);\n\n\t*(p++) = htonl(eof);\n\t*(p++) = htonl(maxcount);\n\n\tbuf->page_len = maxcount;\n\tbuf->len += maxcount;\n\txdr->page_ptr += (buf->page_base + maxcount + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t/ PAGE_SIZE;\n\n\t/* Use rest of head for padding and remaining ops: */\n\tbuf->tail[0].iov_base = xdr->p;\n\tbuf->tail[0].iov_len = 0;\n\txdr->iov = buf->tail;\n\tif (maxcount&3) {\n\t\tint pad = 4 - (maxcount&3);\n\n\t\t*(xdr->p++) = 0;\n\n\t\tbuf->tail[0].iov_base += maxcount&3;\n\t\tbuf->tail[0].iov_len = pad;\n\t\tbuf->len += pad;\n\t}\n\n\tspace_left = min_t(int, (void *)xdr->end - (void *)xdr->p,\n\t\t\t\tbuf->buflen - buf->len);\n\tbuf->buflen = buf->len + space_left;\n\txdr->end = (__be32 *)((void *)xdr->end + space_left);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "(void *)xdr->end - (void *)xdr->p",
            "buf->buflen - buf->len"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "maxcount"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "eof"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_splice_read",
          "args": [
            "read->rd_rqstp",
            "file",
            "read->rd_offset",
            "&maxcount"
          ],
          "line": 3302
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "872-886",
          "snippet": "__be32 nfsd_splice_read(struct svc_rqst *rqstp,\n\t\t     struct file *file, loff_t offset, unsigned long *count)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= 0,\n\t\t.total_len\t= *count,\n\t\t.pos\t\t= offset,\n\t\t.u.data\t\t= rqstp,\n\t};\n\tint host_err;\n\n\trqstp->rq_next_page = rqstp->rq_respages + 1;\n\thost_err = splice_direct_to_actor(file, &sd, nfsd_direct_splice_actor);\n\treturn nfsd_finish_read(file, count, host_err);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32 nfsd_splice_read(struct svc_rqst *rqstp,\n\t\t     struct file *file, loff_t offset, unsigned long *count)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= 0,\n\t\t.total_len\t= *count,\n\t\t.pos\t\t= offset,\n\t\t.u.data\t\t= rqstp,\n\t};\n\tint host_err;\n\n\trqstp->rq_next_page = rqstp->rq_respages + 1;\n\thost_err = splice_direct_to_actor(file, &sd, nfsd_direct_splice_actor);\n\treturn nfsd_finish_read(file, count, host_err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_splice_read(\n\t\t\t\tstruct nfsd4_compoundres *resp,\n\t\t\t\tstruct nfsd4_read *read,\n\t\t\t\tstruct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = xdr->buf;\n\tu32 eof;\n\tint space_left;\n\t__be32 nfserr;\n\t__be32 *p = xdr->p - 2;\n\n\t/* Make sure there will be room for padding if needed */\n\tif (xdr->end - xdr->p < 1)\n\t\treturn nfserr_resource;\n\n\tnfserr = nfsd_splice_read(read->rd_rqstp, file,\n\t\t\t\t  read->rd_offset, &maxcount);\n\tif (nfserr) {\n\t\t/*\n\t\t * nfsd_splice_actor may have already messed with the\n\t\t * page length; reset it so as not to confuse\n\t\t * xdr_truncate_encode:\n\t\t */\n\t\tbuf->page_len = 0;\n\t\treturn nfserr;\n\t}\n\n\teof = (read->rd_offset + maxcount >=\n\t       read->rd_fhp->fh_dentry->d_inode->i_size);\n\n\t*(p++) = htonl(eof);\n\t*(p++) = htonl(maxcount);\n\n\tbuf->page_len = maxcount;\n\tbuf->len += maxcount;\n\txdr->page_ptr += (buf->page_base + maxcount + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t/ PAGE_SIZE;\n\n\t/* Use rest of head for padding and remaining ops: */\n\tbuf->tail[0].iov_base = xdr->p;\n\tbuf->tail[0].iov_len = 0;\n\txdr->iov = buf->tail;\n\tif (maxcount&3) {\n\t\tint pad = 4 - (maxcount&3);\n\n\t\t*(xdr->p++) = 0;\n\n\t\tbuf->tail[0].iov_base += maxcount&3;\n\t\tbuf->tail[0].iov_len = pad;\n\t\tbuf->len += pad;\n\t}\n\n\tspace_left = min_t(int, (void *)xdr->end - (void *)xdr->p,\n\t\t\t\tbuf->buflen - buf->len);\n\tbuf->buflen = buf->len + space_left;\n\txdr->end = (__be32 *)((void *)xdr->end + space_left);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_open_downgrade",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3275-3284",
    "snippet": "static __be32\nnfsd4_encode_open_downgrade(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_downgrade *od)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &od->od_stateid);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&od->od_stateid"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2955-2967",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_open_downgrade(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_downgrade *od)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &od->od_stateid);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_open_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3264-3273",
    "snippet": "static __be32\nnfsd4_encode_open_confirm(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_confirm *oc)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &oc->oc_resp_stateid);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&oc->oc_resp_stateid"
          ],
          "line": 3270
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2955-2967",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_open_confirm(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_confirm *oc)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &oc->oc_resp_stateid);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3172-3262",
    "snippet": "static __be32\nnfsd4_encode_open(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open *open)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfsd4_encode_stateid(xdr, &open->op_stateid);\n\tif (nfserr)\n\t\tgoto out;\n\tp = xdr_reserve_space(xdr, 40);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = encode_cinfo(p, &open->op_cinfo);\n\t*p++ = cpu_to_be32(open->op_rflags);\n\t*p++ = cpu_to_be32(2);\n\t*p++ = cpu_to_be32(open->op_bmval[0]);\n\t*p++ = cpu_to_be32(open->op_bmval[1]);\n\t*p++ = cpu_to_be32(open->op_delegate_type);\n\n\tswitch (open->op_delegate_type) {\n\tcase NFS4_OPEN_DELEGATE_NONE:\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_READ:\n\t\tnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(open->op_recall);\n\n\t\t/*\n\t\t * TODO: ACE's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);   /* XXX: is NULL principal ok? */\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\tnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\tp = xdr_reserve_space(xdr, 32);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\n\t\t/*\n\t\t * TODO: space_limit's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_LIMIT_SIZE);\n\t\t*p++ = cpu_to_be32(~(u32)0);\n\t\t*p++ = cpu_to_be32(~(u32)0);\n\n\t\t/*\n\t\t * TODO: ACE's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);   /* XXX: is NULL principal ok? */\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_NONE_EXT: /* 4.1 */\n\t\tswitch (open->op_why_no_deleg) {\n\t\tcase WND4_CONTENTION:\n\t\tcase WND4_RESOURCE:\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(open->op_why_no_deleg);\n\t\t\t/* deleg signaling not supported yet: */\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(open->op_why_no_deleg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t/* XXX save filehandle here */\nout:\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_why_no_deleg"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_why_no_deleg"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "~(u32)0"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "~(u32)0"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_LIMIT_SIZE"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "32"
          ],
          "line": 3218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&open->op_delegate_stateid"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2955-2967",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_recall"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "20"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_delegate_type"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_bmval[1]"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_bmval[0]"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "2"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_rflags"
          ],
          "line": 3188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_cinfo",
          "args": [
            "p",
            "&open->op_cinfo"
          ],
          "line": 3187
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1889-1902",
          "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "40"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_open(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open *open)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfsd4_encode_stateid(xdr, &open->op_stateid);\n\tif (nfserr)\n\t\tgoto out;\n\tp = xdr_reserve_space(xdr, 40);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = encode_cinfo(p, &open->op_cinfo);\n\t*p++ = cpu_to_be32(open->op_rflags);\n\t*p++ = cpu_to_be32(2);\n\t*p++ = cpu_to_be32(open->op_bmval[0]);\n\t*p++ = cpu_to_be32(open->op_bmval[1]);\n\t*p++ = cpu_to_be32(open->op_delegate_type);\n\n\tswitch (open->op_delegate_type) {\n\tcase NFS4_OPEN_DELEGATE_NONE:\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_READ:\n\t\tnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(open->op_recall);\n\n\t\t/*\n\t\t * TODO: ACE's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);   /* XXX: is NULL principal ok? */\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\tnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\tp = xdr_reserve_space(xdr, 32);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\n\t\t/*\n\t\t * TODO: space_limit's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_LIMIT_SIZE);\n\t\t*p++ = cpu_to_be32(~(u32)0);\n\t\t*p++ = cpu_to_be32(~(u32)0);\n\n\t\t/*\n\t\t * TODO: ACE's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);   /* XXX: is NULL principal ok? */\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_NONE_EXT: /* 4.1 */\n\t\tswitch (open->op_why_no_deleg) {\n\t\tcase WND4_CONTENTION:\n\t\tcase WND4_RESOURCE:\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(open->op_why_no_deleg);\n\t\t\t/* deleg signaling not supported yet: */\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(open->op_why_no_deleg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t/* XXX save filehandle here */\nout:\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3156-3169",
    "snippet": "static __be32\nnfsd4_encode_link(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_link *link)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &link->li_cinfo);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_cinfo",
          "args": [
            "p",
            "&link->li_cinfo"
          ],
          "line": 3166
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1889-1902",
          "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "20"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_link(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_link *link)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &link->li_cinfo);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_locku",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3144-3153",
    "snippet": "static __be32\nnfsd4_encode_locku(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_locku *locku)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &locku->lu_stateid);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&locku->lu_stateid"
          ],
          "line": 3150
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2955-2967",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_locku(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_locku *locku)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &locku->lu_stateid);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_lockt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3134-3142",
    "snippet": "static __be32\nnfsd4_encode_lockt(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lockt *lockt)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (nfserr == nfserr_denied)\n\t\tnfsd4_encode_lock_denied(xdr, &lockt->lt_denied);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_lock_denied",
          "args": [
            "xdr",
            "&lockt->lt_denied"
          ],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_lock_denied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3086-3119",
          "snippet": "static __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_lockt(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lockt *lockt)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (nfserr == nfserr_denied)\n\t\tnfsd4_encode_lock_denied(xdr, &lockt->lt_denied);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3121-3132",
    "snippet": "static __be32\nnfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lock *lock)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &lock->lk_resp_stateid);\n\telse if (nfserr == nfserr_denied)\n\t\tnfserr = nfsd4_encode_lock_denied(xdr, &lock->lk_denied);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_lock_denied",
          "args": [
            "xdr",
            "&lock->lk_denied"
          ],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_lock_denied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3086-3119",
          "snippet": "static __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&lock->lk_resp_stateid"
          ],
          "line": 3127
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2955-2967",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lock *lock)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &lock->lk_resp_stateid);\n\telse if (nfserr == nfserr_denied)\n\t\tnfserr = nfsd4_encode_lock_denied(xdr, &lock->lk_denied);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_lock_denied",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3086-3119",
    "snippet": "static __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64)0"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "conf->data"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "conf->data",
            "conf->len"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&ld->ld_clientid",
            "8"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ld->ld_type"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "ld->ld_length"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "ld->ld_start"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "conf->data"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "32 + XDR_LEN(conf->len)"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_LEN",
          "args": [
            "conf->len"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}"
  },
  {
    "function_name": "nfsd4_encode_getfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3064-3080",
    "snippet": "static __be32\nnfsd4_encode_getfh(struct nfsd4_compoundres *resp, __be32 nfserr, struct svc_fh **fhpp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct svc_fh *fhp = *fhpp;\n\tunsigned int len;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tlen = fhp->fh_handle.fh_size;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base, len);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "&fhp->fh_handle.fh_base",
            "len"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "len + 4"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_getfh(struct nfsd4_compoundres *resp, __be32 nfserr, struct svc_fh **fhpp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct svc_fh *fhp = *fhpp;\n\tunsigned int len;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tlen = fhp->fh_handle.fh_size;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base, len);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3049-3062",
    "snippet": "static __be32\nnfsd4_encode_getattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_getattr *getattr)\n{\n\tstruct svc_fh *fhp = getattr->ga_fhp;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tnfserr = nfsd4_encode_fattr(xdr, fhp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\t    getattr->ga_bmval,\n\t\t\t\t    resp->rqstp, 0);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_fattr",
          "args": [
            "xdr",
            "fhp",
            "fhp->fh_export",
            "fhp->fh_dentry",
            "getattr->ga_bmval",
            "resp->rqstp",
            "0"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2197-2744",
          "snippet": "static __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tint aclsupport = 0;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tBUG_ON(bmval[2]);\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & (FATTR4_WORD0_ACL | FATTR4_WORD0_ACLSUPPORT\n\t\t\t| FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\taclsupport = (err == 0);\n\t\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\t\telse if (err == -EINVAL) {\n\t\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\t\tgoto out;\n\t\t\t} else if (err != 0)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) ||\n\t\t\tbmval[0] & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(dentry->d_inode,\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!aclsupport)\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, dentry->d_inode);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(aclsupport ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root)\n\t\t\tget_parent_attributes(exp, &stat);\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif ((bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) ||\n\t    (bmval2 & FATTR4_WORD2_LAYOUT_TYPES)) {\n\t\tif (exp->ex_layout_type) {\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(1);\n\t\t\t*p++ = cpu_to_be32(exp->ex_layout_type);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t}\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD0);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD1);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL",
            "#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL\n#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL\n\nstatic __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tint aclsupport = 0;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tBUG_ON(bmval[2]);\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & (FATTR4_WORD0_ACL | FATTR4_WORD0_ACLSUPPORT\n\t\t\t| FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\taclsupport = (err == 0);\n\t\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\t\telse if (err == -EINVAL) {\n\t\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\t\tgoto out;\n\t\t\t} else if (err != 0)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) ||\n\t\t\tbmval[0] & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(dentry->d_inode,\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!aclsupport)\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, dentry->d_inode);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(aclsupport ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root)\n\t\t\tget_parent_attributes(exp, &stat);\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif ((bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) ||\n\t    (bmval2 & FATTR4_WORD2_LAYOUT_TYPES)) {\n\t\tif (exp->ex_layout_type) {\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(1);\n\t\t\t*p++ = cpu_to_be32(exp->ex_layout_type);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t}\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD0);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD1);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_getattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_getattr *getattr)\n{\n\tstruct svc_fh *fhp = getattr->ga_fhp;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tnfserr = nfsd4_encode_fattr(xdr, fhp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\t    getattr->ga_bmval,\n\t\t\t\t    resp->rqstp, 0);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3031-3047",
    "snippet": "static __be32\nnfsd4_encode_create(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_create *create)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 32);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &create->cr_cinfo);\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(create->cr_bmval[0]);\n\t\t*p++ = cpu_to_be32(create->cr_bmval[1]);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "create->cr_bmval[1]"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "create->cr_bmval[0]"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "2"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_cinfo",
          "args": [
            "p",
            "&create->cr_cinfo"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1889-1902",
          "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "32"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_create(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_create *create)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 32);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &create->cr_cinfo);\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(create->cr_bmval[0]);\n\t\t*p++ = cpu_to_be32(create->cr_bmval[1]);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3015-3029",
    "snippet": "static __be32\nnfsd4_encode_commit(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_commit *commit)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, commit->co_verf.data,\n\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "commit->co_verf.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_commit(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_commit *commit)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, commit->co_verf.data,\n\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3003-3012",
    "snippet": "static __be32\nnfsd4_encode_close(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_close *close)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &close->cl_stateid);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&close->cl_stateid"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2955-2967",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_close(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_close *close)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &close->cl_stateid);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_bind_conn_to_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2985-3001",
    "snippet": "static __be32 nfsd4_encode_bind_conn_to_session(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_bind_conn_to_session *bcts)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, bcts->sessionid.data,\n\t\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t\t*p++ = cpu_to_be32(bcts->dir);\n\t\t/* Sorry, we do not yet support RDMA over 4.1: */\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bcts->dir"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "bcts->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "NFS4_MAX_SESSIONID_LEN + 8"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_bind_conn_to_session(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_bind_conn_to_session *bcts)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, bcts->sessionid.data,\n\t\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t\t*p++ = cpu_to_be32(bcts->dir);\n\t\t/* Sorry, we do not yet support RDMA over 4.1: */\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2969-2983",
    "snippet": "static __be32\nnfsd4_encode_access(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_access *access)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(access->ac_supported);\n\t\t*p++ = cpu_to_be32(access->ac_resp_access);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "access->ac_resp_access"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "access->ac_supported"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_access(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_access *access)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(access->ac_supported);\n\t\t*p++ = cpu_to_be32(access->ac_resp_access);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2955-2967",
    "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&sid->si_opaque",
            "sizeof(stateid_opaque_t)"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sid->si_generation"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "sizeof(stateid_t)"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2865-2953",
    "snippet": "static int\nnfsd4_encode_dirent(void *ccdv, const char *name, int namlen,\n\t\t    loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd4_readdir *cd = container_of(ccd, struct nfsd4_readdir, common);\n\tstruct xdr_stream *xdr = cd->xdr;\n\tint start_offset = xdr->buf->len;\n\tint cookie_offset;\n\tu32 name_and_cookie;\n\tint entry_bytes;\n\t__be32 nfserr = nfserr_toosmall;\n\t__be64 wire_offset;\n\t__be32 *p;\n\n\t/* In nfsv4, \".\" and \"..\" never make it onto the wire.. */\n\tif (name && isdotent(name, namlen)) {\n\t\tcd->common.err = nfs_ok;\n\t\treturn 0;\n\t}\n\n\tif (cd->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, cd->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto fail;\n\t*p++ = xdr_one;                             /* mark entry present */\n\tcookie_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 3*4 + namlen);\n\tif (!p)\n\t\tgoto fail;\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);    /* offset of next entry */\n\tp = xdr_encode_array(p, name, namlen);      /* name length & name */\n\n\tnfserr = nfsd4_encode_dirent_fattr(xdr, cd, name, namlen);\n\tswitch (nfserr) {\n\tcase nfs_ok:\n\t\tbreak;\n\tcase nfserr_resource:\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto fail;\n\tcase nfserr_noent:\n\t\txdr_truncate_encode(xdr, start_offset);\n\t\tgoto skip_entry;\n\tdefault:\n\t\t/*\n\t\t * If the client requested the RDATTR_ERROR attribute,\n\t\t * we stuff the error code into this attribute\n\t\t * and continue.  If this attribute was not requested,\n\t\t * then in accordance with the spec, we fail the\n\t\t * entire READDIR operation(!)\n\t\t */\n\t\tif (!(cd->rd_bmval[0] & FATTR4_WORD0_RDATTR_ERROR))\n\t\t\tgoto fail;\n\t\tp = nfsd4_encode_rdattr_error(xdr, nfserr);\n\t\tif (p == NULL) {\n\t\t\tnfserr = nfserr_toosmall;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tnfserr = nfserr_toosmall;\n\tentry_bytes = xdr->buf->len - start_offset;\n\tif (entry_bytes > cd->rd_maxcount)\n\t\tgoto fail;\n\tcd->rd_maxcount -= entry_bytes;\n\t/*\n\t * RFC 3530 14.2.24 describes rd_dircount as only a \"hint\", so\n\t * let's always let through the first entry, at least:\n\t */\n\tif (!cd->rd_dircount)\n\t\tgoto fail;\n\tname_and_cookie = 4 + 4 * XDR_QUADLEN(namlen) + 8;\n\tif (name_and_cookie > cd->rd_dircount && cd->cookie_offset)\n\t\tgoto fail;\n\tcd->rd_dircount -= min(cd->rd_dircount, name_and_cookie);\n\n\tcd->cookie_offset = cookie_offset;\nskip_entry:\n\tcd->common.err = nfs_ok;\n\treturn 0;\nfail:\n\txdr_truncate_encode(xdr, start_offset);\n\tcd->common.err = nfserr;\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "start_offset"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "cd->rd_dircount",
            "name_and_cookie"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "namlen"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_rdattr_error",
          "args": [
            "xdr",
            "nfserr"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_rdattr_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2848-2863",
          "snippet": "static __be32 *\nnfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 20);\n\tif (!p)\n\t\treturn NULL;\n\t*p++ = htonl(2);\n\t*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR); /* bmval0 */\n\t*p++ = htonl(0);\t\t\t /* bmval1 */\n\n\t*p++ = htonl(4);     /* attribute length */\n\t*p++ = nfserr;       /* no htonl */\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *\nnfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 20);\n\tif (!p)\n\t\treturn NULL;\n\t*p++ = htonl(2);\n\t*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR); /* bmval0 */\n\t*p++ = htonl(0);\t\t\t /* bmval1 */\n\n\t*p++ = htonl(4);     /* attribute length */\n\t*p++ = nfserr;       /* no htonl */\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "start_offset"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_dirent_fattr",
          "args": [
            "xdr",
            "cd",
            "name",
            "namlen"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_dirent_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2786-2846",
          "snippet": "static __be32\nnfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,\n\t\t\tconst char *name, int namlen)\n{\n\tstruct svc_export *exp = cd->rd_fhp->fh_export;\n\tstruct dentry *dentry;\n\t__be32 nfserr;\n\tint ignore_crossmnt = 0;\n\n\tdentry = lookup_one_len(name, cd->rd_fhp->fh_dentry, namlen);\n\tif (IS_ERR(dentry))\n\t\treturn nfserrno(PTR_ERR(dentry));\n\tif (!dentry->d_inode) {\n\t\t/*\n\t\t * nfsd_buffered_readdir drops the i_mutex between\n\t\t * readdir and calling this callback, leaving a window\n\t\t * where this directory entry could have gone away.\n\t\t */\n\t\tdput(dentry);\n\t\treturn nfserr_noent;\n\t}\n\n\texp_get(exp);\n\t/*\n\t * In the case of a mountpoint, the client may be asking for\n\t * attributes that are only properties of the underlying filesystem\n\t * as opposed to the cross-mounted file system. In such a case,\n\t * we will not follow the cross mount and will fill the attribtutes\n\t * directly from the mountpoint dentry.\n\t */\n\tif (nfsd_mountpoint(dentry, exp)) {\n\t\tint err;\n\n\t\tif (!(exp->ex_flags & NFSEXP_V4ROOT)\n\t\t\t\t&& !attributes_need_mount(cd->rd_bmval)) {\n\t\t\tignore_crossmnt = 1;\n\t\t\tgoto out_encode;\n\t\t}\n\t\t/*\n\t\t * Why the heck aren't we just using nfsd_lookup??\n\t\t * Different \".\"/\"..\" handling?  Something else?\n\t\t * At least, add a comment here to explain....\n\t\t */\n\t\terr = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);\n\t\tif (err) {\n\t\t\tnfserr = nfserrno(err);\n\t\t\tgoto out_put;\n\t\t}\n\t\tnfserr = check_nfsd_access(exp, cd->rd_rqstp);\n\t\tif (nfserr)\n\t\t\tgoto out_put;\n\n\t}\nout_encode:\n\tnfserr = nfsd4_encode_fattr(xdr, NULL, exp, dentry, cd->rd_bmval,\n\t\t\t\t\tcd->rd_rqstp, ignore_crossmnt);\nout_put:\n\tdput(dentry);\n\texp_put(exp);\n\treturn nfserr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,\n\t\t\tconst char *name, int namlen)\n{\n\tstruct svc_export *exp = cd->rd_fhp->fh_export;\n\tstruct dentry *dentry;\n\t__be32 nfserr;\n\tint ignore_crossmnt = 0;\n\n\tdentry = lookup_one_len(name, cd->rd_fhp->fh_dentry, namlen);\n\tif (IS_ERR(dentry))\n\t\treturn nfserrno(PTR_ERR(dentry));\n\tif (!dentry->d_inode) {\n\t\t/*\n\t\t * nfsd_buffered_readdir drops the i_mutex between\n\t\t * readdir and calling this callback, leaving a window\n\t\t * where this directory entry could have gone away.\n\t\t */\n\t\tdput(dentry);\n\t\treturn nfserr_noent;\n\t}\n\n\texp_get(exp);\n\t/*\n\t * In the case of a mountpoint, the client may be asking for\n\t * attributes that are only properties of the underlying filesystem\n\t * as opposed to the cross-mounted file system. In such a case,\n\t * we will not follow the cross mount and will fill the attribtutes\n\t * directly from the mountpoint dentry.\n\t */\n\tif (nfsd_mountpoint(dentry, exp)) {\n\t\tint err;\n\n\t\tif (!(exp->ex_flags & NFSEXP_V4ROOT)\n\t\t\t\t&& !attributes_need_mount(cd->rd_bmval)) {\n\t\t\tignore_crossmnt = 1;\n\t\t\tgoto out_encode;\n\t\t}\n\t\t/*\n\t\t * Why the heck aren't we just using nfsd_lookup??\n\t\t * Different \".\"/\"..\" handling?  Something else?\n\t\t * At least, add a comment here to explain....\n\t\t */\n\t\terr = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);\n\t\tif (err) {\n\t\t\tnfserr = nfserrno(err);\n\t\t\tgoto out_put;\n\t\t}\n\t\tnfserr = check_nfsd_access(exp, cd->rd_rqstp);\n\t\tif (nfserr)\n\t\t\tgoto out_put;\n\n\t}\nout_encode:\n\tnfserr = nfsd4_encode_fattr(xdr, NULL, exp, dentry, cd->rd_bmval,\n\t\t\t\t\tcd->rd_rqstp, ignore_crossmnt);\nout_put:\n\tdput(dentry);\n\texp_put(exp);\n\treturn nfserr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_array",
          "args": [
            "p",
            "name",
            "namlen"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "NFS_OFFSET_MAX"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "3*4 + namlen"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "cd->cookie_offset",
            "&wire_offset",
            "8"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "offset"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdotent",
          "args": [
            "name",
            "namlen"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ccd",
            "structnfsd4_readdir",
            "common"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int\nnfsd4_encode_dirent(void *ccdv, const char *name, int namlen,\n\t\t    loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd4_readdir *cd = container_of(ccd, struct nfsd4_readdir, common);\n\tstruct xdr_stream *xdr = cd->xdr;\n\tint start_offset = xdr->buf->len;\n\tint cookie_offset;\n\tu32 name_and_cookie;\n\tint entry_bytes;\n\t__be32 nfserr = nfserr_toosmall;\n\t__be64 wire_offset;\n\t__be32 *p;\n\n\t/* In nfsv4, \".\" and \"..\" never make it onto the wire.. */\n\tif (name && isdotent(name, namlen)) {\n\t\tcd->common.err = nfs_ok;\n\t\treturn 0;\n\t}\n\n\tif (cd->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, cd->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto fail;\n\t*p++ = xdr_one;                             /* mark entry present */\n\tcookie_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 3*4 + namlen);\n\tif (!p)\n\t\tgoto fail;\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);    /* offset of next entry */\n\tp = xdr_encode_array(p, name, namlen);      /* name length & name */\n\n\tnfserr = nfsd4_encode_dirent_fattr(xdr, cd, name, namlen);\n\tswitch (nfserr) {\n\tcase nfs_ok:\n\t\tbreak;\n\tcase nfserr_resource:\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto fail;\n\tcase nfserr_noent:\n\t\txdr_truncate_encode(xdr, start_offset);\n\t\tgoto skip_entry;\n\tdefault:\n\t\t/*\n\t\t * If the client requested the RDATTR_ERROR attribute,\n\t\t * we stuff the error code into this attribute\n\t\t * and continue.  If this attribute was not requested,\n\t\t * then in accordance with the spec, we fail the\n\t\t * entire READDIR operation(!)\n\t\t */\n\t\tif (!(cd->rd_bmval[0] & FATTR4_WORD0_RDATTR_ERROR))\n\t\t\tgoto fail;\n\t\tp = nfsd4_encode_rdattr_error(xdr, nfserr);\n\t\tif (p == NULL) {\n\t\t\tnfserr = nfserr_toosmall;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tnfserr = nfserr_toosmall;\n\tentry_bytes = xdr->buf->len - start_offset;\n\tif (entry_bytes > cd->rd_maxcount)\n\t\tgoto fail;\n\tcd->rd_maxcount -= entry_bytes;\n\t/*\n\t * RFC 3530 14.2.24 describes rd_dircount as only a \"hint\", so\n\t * let's always let through the first entry, at least:\n\t */\n\tif (!cd->rd_dircount)\n\t\tgoto fail;\n\tname_and_cookie = 4 + 4 * XDR_QUADLEN(namlen) + 8;\n\tif (name_and_cookie > cd->rd_dircount && cd->cookie_offset)\n\t\tgoto fail;\n\tcd->rd_dircount -= min(cd->rd_dircount, name_and_cookie);\n\n\tcd->cookie_offset = cookie_offset;\nskip_entry:\n\tcd->common.err = nfs_ok;\n\treturn 0;\nfail:\n\txdr_truncate_encode(xdr, start_offset);\n\tcd->common.err = nfserr;\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "nfsd4_encode_rdattr_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2848-2863",
    "snippet": "static __be32 *\nnfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 20);\n\tif (!p)\n\t\treturn NULL;\n\t*p++ = htonl(2);\n\t*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR); /* bmval0 */\n\t*p++ = htonl(0);\t\t\t /* bmval1 */\n\n\t*p++ = htonl(4);     /* attribute length */\n\t*p++ = nfserr;       /* no htonl */\n\treturn p;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "4"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FATTR4_WORD0_RDATTR_ERROR"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "2"
          ],
          "line": 2856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "20"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *\nnfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 20);\n\tif (!p)\n\t\treturn NULL;\n\t*p++ = htonl(2);\n\t*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR); /* bmval0 */\n\t*p++ = htonl(0);\t\t\t /* bmval1 */\n\n\t*p++ = htonl(4);     /* attribute length */\n\t*p++ = nfserr;       /* no htonl */\n\treturn p;\n}"
  },
  {
    "function_name": "nfsd4_encode_dirent_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2786-2846",
    "snippet": "static __be32\nnfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,\n\t\t\tconst char *name, int namlen)\n{\n\tstruct svc_export *exp = cd->rd_fhp->fh_export;\n\tstruct dentry *dentry;\n\t__be32 nfserr;\n\tint ignore_crossmnt = 0;\n\n\tdentry = lookup_one_len(name, cd->rd_fhp->fh_dentry, namlen);\n\tif (IS_ERR(dentry))\n\t\treturn nfserrno(PTR_ERR(dentry));\n\tif (!dentry->d_inode) {\n\t\t/*\n\t\t * nfsd_buffered_readdir drops the i_mutex between\n\t\t * readdir and calling this callback, leaving a window\n\t\t * where this directory entry could have gone away.\n\t\t */\n\t\tdput(dentry);\n\t\treturn nfserr_noent;\n\t}\n\n\texp_get(exp);\n\t/*\n\t * In the case of a mountpoint, the client may be asking for\n\t * attributes that are only properties of the underlying filesystem\n\t * as opposed to the cross-mounted file system. In such a case,\n\t * we will not follow the cross mount and will fill the attribtutes\n\t * directly from the mountpoint dentry.\n\t */\n\tif (nfsd_mountpoint(dentry, exp)) {\n\t\tint err;\n\n\t\tif (!(exp->ex_flags & NFSEXP_V4ROOT)\n\t\t\t\t&& !attributes_need_mount(cd->rd_bmval)) {\n\t\t\tignore_crossmnt = 1;\n\t\t\tgoto out_encode;\n\t\t}\n\t\t/*\n\t\t * Why the heck aren't we just using nfsd_lookup??\n\t\t * Different \".\"/\"..\" handling?  Something else?\n\t\t * At least, add a comment here to explain....\n\t\t */\n\t\terr = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);\n\t\tif (err) {\n\t\t\tnfserr = nfserrno(err);\n\t\t\tgoto out_put;\n\t\t}\n\t\tnfserr = check_nfsd_access(exp, cd->rd_rqstp);\n\t\tif (nfserr)\n\t\t\tgoto out_put;\n\n\t}\nout_encode:\n\tnfserr = nfsd4_encode_fattr(xdr, NULL, exp, dentry, cd->rd_bmval,\n\t\t\t\t\tcd->rd_rqstp, ignore_crossmnt);\nout_put:\n\tdput(dentry);\n\texp_put(exp);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 2844
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_fattr",
          "args": [
            "xdr",
            "NULL",
            "exp",
            "dentry",
            "cd->rd_bmval",
            "cd->rd_rqstp",
            "ignore_crossmnt"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2197-2744",
          "snippet": "static __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tint aclsupport = 0;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tBUG_ON(bmval[2]);\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & (FATTR4_WORD0_ACL | FATTR4_WORD0_ACLSUPPORT\n\t\t\t| FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\taclsupport = (err == 0);\n\t\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\t\telse if (err == -EINVAL) {\n\t\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\t\tgoto out;\n\t\t\t} else if (err != 0)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) ||\n\t\t\tbmval[0] & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(dentry->d_inode,\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!aclsupport)\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, dentry->d_inode);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(aclsupport ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root)\n\t\t\tget_parent_attributes(exp, &stat);\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif ((bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) ||\n\t    (bmval2 & FATTR4_WORD2_LAYOUT_TYPES)) {\n\t\tif (exp->ex_layout_type) {\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(1);\n\t\t\t*p++ = cpu_to_be32(exp->ex_layout_type);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t}\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD0);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD1);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL",
            "#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL\n#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL\n\nstatic __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tint aclsupport = 0;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tBUG_ON(bmval[2]);\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & (FATTR4_WORD0_ACL | FATTR4_WORD0_ACLSUPPORT\n\t\t\t| FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\taclsupport = (err == 0);\n\t\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\t\telse if (err == -EINVAL) {\n\t\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\t\tgoto out;\n\t\t\t} else if (err != 0)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) ||\n\t\t\tbmval[0] & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(dentry->d_inode,\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!aclsupport)\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, dentry->d_inode);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(aclsupport ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root)\n\t\t\tget_parent_attributes(exp, &stat);\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif ((bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) ||\n\t    (bmval2 & FATTR4_WORD2_LAYOUT_TYPES)) {\n\t\tif (exp->ex_layout_type) {\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(1);\n\t\t\t*p++ = cpu_to_be32(exp->ex_layout_type);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t}\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD0);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD1);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_nfsd_access",
          "args": [
            "exp",
            "cd->rd_rqstp"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "check_nfsd_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "939-959",
          "snippet": "__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "err"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_cross_mnt",
          "args": [
            "cd->rd_rqstp",
            "&dentry",
            "&exp"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cross_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "82-129",
          "snippet": "int\nnfsd_cross_mnt(struct svc_rqst *rqstp, struct dentry **dpp, \n\t\t        struct svc_export **expp)\n{\n\tstruct svc_export *exp = *expp, *exp2 = NULL;\n\tstruct dentry *dentry = *dpp;\n\tstruct path path = {.mnt = mntget(exp->ex_path.mnt),\n\t\t\t    .dentry = dget(dentry)};\n\tint err = 0;\n\n\terr = follow_down(&path);\n\tif (err < 0)\n\t\tgoto out;\n\n\texp2 = rqst_exp_get_by_name(rqstp, &path);\n\tif (IS_ERR(exp2)) {\n\t\terr = PTR_ERR(exp2);\n\t\t/*\n\t\t * We normally allow NFS clients to continue\n\t\t * \"underneath\" a mountpoint that is not exported.\n\t\t * The exception is V4ROOT, where no traversal is ever\n\t\t * allowed without an explicit export of the new\n\t\t * directory.\n\t\t */\n\t\tif (err == -ENOENT && !(exp->ex_flags & NFSEXP_V4ROOT))\n\t\t\terr = 0;\n\t\tpath_put(&path);\n\t\tgoto out;\n\t}\n\tif (nfsd_v4client(rqstp) ||\n\t\t(exp->ex_flags & NFSEXP_CROSSMOUNT) || EX_NOHIDE(exp2)) {\n\t\t/* successfully crossed mount point */\n\t\t/*\n\t\t * This is subtle: path.dentry is *not* on path.mnt\n\t\t * at this point.  The only reason we are safe is that\n\t\t * original mnt is pinned down by exp, so we should\n\t\t * put path *before* putting exp\n\t\t */\n\t\t*dpp = path.dentry;\n\t\tpath.dentry = dentry;\n\t\t*expp = exp2;\n\t\texp2 = exp;\n\t}\n\tpath_put(&path);\n\texp_put(exp2);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nint\nnfsd_cross_mnt(struct svc_rqst *rqstp, struct dentry **dpp, \n\t\t        struct svc_export **expp)\n{\n\tstruct svc_export *exp = *expp, *exp2 = NULL;\n\tstruct dentry *dentry = *dpp;\n\tstruct path path = {.mnt = mntget(exp->ex_path.mnt),\n\t\t\t    .dentry = dget(dentry)};\n\tint err = 0;\n\n\terr = follow_down(&path);\n\tif (err < 0)\n\t\tgoto out;\n\n\texp2 = rqst_exp_get_by_name(rqstp, &path);\n\tif (IS_ERR(exp2)) {\n\t\terr = PTR_ERR(exp2);\n\t\t/*\n\t\t * We normally allow NFS clients to continue\n\t\t * \"underneath\" a mountpoint that is not exported.\n\t\t * The exception is V4ROOT, where no traversal is ever\n\t\t * allowed without an explicit export of the new\n\t\t * directory.\n\t\t */\n\t\tif (err == -ENOENT && !(exp->ex_flags & NFSEXP_V4ROOT))\n\t\t\terr = 0;\n\t\tpath_put(&path);\n\t\tgoto out;\n\t}\n\tif (nfsd_v4client(rqstp) ||\n\t\t(exp->ex_flags & NFSEXP_CROSSMOUNT) || EX_NOHIDE(exp2)) {\n\t\t/* successfully crossed mount point */\n\t\t/*\n\t\t * This is subtle: path.dentry is *not* on path.mnt\n\t\t * at this point.  The only reason we are safe is that\n\t\t * original mnt is pinned down by exp, so we should\n\t\t * put path *before* putting exp\n\t\t */\n\t\t*dpp = path.dentry;\n\t\tpath.dentry = dentry;\n\t\t*expp = exp2;\n\t\texp2 = exp;\n\t}\n\tpath_put(&path);\n\texp_put(exp2);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attributes_need_mount",
          "args": [
            "cd->rd_bmval"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "attributes_need_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2777-2784",
          "snippet": "static inline int attributes_need_mount(u32 *bmval)\n{\n\tif (bmval[0] & ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))\n\t\treturn 1;\n\tif (bmval[1] & ~FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline int attributes_need_mount(u32 *bmval)\n{\n\tif (bmval[0] & ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))\n\t\treturn 1;\n\tif (bmval[1] & ~FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_mountpoint",
          "args": [
            "dentry",
            "exp"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "169-178",
          "snippet": "int nfsd_mountpoint(struct dentry *dentry, struct svc_export *exp)\n{\n\tif (d_mountpoint(dentry))\n\t\treturn 1;\n\tif (nfsd4_is_junction(dentry))\n\t\treturn 1;\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn 0;\n\treturn dentry->d_inode != NULL;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nint nfsd_mountpoint(struct dentry *dentry, struct svc_export *exp)\n{\n\tif (d_mountpoint(dentry))\n\t\treturn 1;\n\tif (nfsd4_is_junction(dentry))\n\t\treturn 1;\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn 0;\n\treturn dentry->d_inode != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_get",
          "args": [
            "exp"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "106-110",
          "snippet": "static inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "cd->rd_fhp->fh_dentry",
            "namlen"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,\n\t\t\tconst char *name, int namlen)\n{\n\tstruct svc_export *exp = cd->rd_fhp->fh_export;\n\tstruct dentry *dentry;\n\t__be32 nfserr;\n\tint ignore_crossmnt = 0;\n\n\tdentry = lookup_one_len(name, cd->rd_fhp->fh_dentry, namlen);\n\tif (IS_ERR(dentry))\n\t\treturn nfserrno(PTR_ERR(dentry));\n\tif (!dentry->d_inode) {\n\t\t/*\n\t\t * nfsd_buffered_readdir drops the i_mutex between\n\t\t * readdir and calling this callback, leaving a window\n\t\t * where this directory entry could have gone away.\n\t\t */\n\t\tdput(dentry);\n\t\treturn nfserr_noent;\n\t}\n\n\texp_get(exp);\n\t/*\n\t * In the case of a mountpoint, the client may be asking for\n\t * attributes that are only properties of the underlying filesystem\n\t * as opposed to the cross-mounted file system. In such a case,\n\t * we will not follow the cross mount and will fill the attribtutes\n\t * directly from the mountpoint dentry.\n\t */\n\tif (nfsd_mountpoint(dentry, exp)) {\n\t\tint err;\n\n\t\tif (!(exp->ex_flags & NFSEXP_V4ROOT)\n\t\t\t\t&& !attributes_need_mount(cd->rd_bmval)) {\n\t\t\tignore_crossmnt = 1;\n\t\t\tgoto out_encode;\n\t\t}\n\t\t/*\n\t\t * Why the heck aren't we just using nfsd_lookup??\n\t\t * Different \".\"/\"..\" handling?  Something else?\n\t\t * At least, add a comment here to explain....\n\t\t */\n\t\terr = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);\n\t\tif (err) {\n\t\t\tnfserr = nfserrno(err);\n\t\t\tgoto out_put;\n\t\t}\n\t\tnfserr = check_nfsd_access(exp, cd->rd_rqstp);\n\t\tif (nfserr)\n\t\t\tgoto out_put;\n\n\t}\nout_encode:\n\tnfserr = nfsd4_encode_fattr(xdr, NULL, exp, dentry, cd->rd_bmval,\n\t\t\t\t\tcd->rd_rqstp, ignore_crossmnt);\nout_put:\n\tdput(dentry);\n\texp_put(exp);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "attributes_need_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2777-2784",
    "snippet": "static inline int attributes_need_mount(u32 *bmval)\n{\n\tif (bmval[0] & ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))\n\t\treturn 1;\n\tif (bmval[1] & ~FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline int attributes_need_mount(u32 *bmval)\n{\n\tif (bmval[0] & ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))\n\t\treturn 1;\n\tif (bmval[1] & ~FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_fattr_to_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2761-2775",
    "snippet": "__be32 nfsd4_encode_fattr_to_buf(__be32 **p, int words,\n\t\t\tstruct svc_fh *fhp, struct svc_export *exp,\n\t\t\tstruct dentry *dentry, u32 *bmval,\n\t\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tstruct xdr_buf dummy;\n\tstruct xdr_stream xdr;\n\t__be32 ret;\n\n\tsvcxdr_init_encode_from_buffer(&xdr, &dummy, *p, words << 2);\n\tret = nfsd4_encode_fattr(&xdr, fhp, exp, dentry, bmval, rqstp,\n\t\t\t\t\t\t\tignore_crossmnt);\n\t*p = xdr.p;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_fattr",
          "args": [
            "&xdr",
            "fhp",
            "exp",
            "dentry",
            "bmval",
            "rqstp",
            "ignore_crossmnt"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2197-2744",
          "snippet": "static __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tint aclsupport = 0;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tBUG_ON(bmval[2]);\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & (FATTR4_WORD0_ACL | FATTR4_WORD0_ACLSUPPORT\n\t\t\t| FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\taclsupport = (err == 0);\n\t\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\t\telse if (err == -EINVAL) {\n\t\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\t\tgoto out;\n\t\t\t} else if (err != 0)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) ||\n\t\t\tbmval[0] & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(dentry->d_inode,\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!aclsupport)\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, dentry->d_inode);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(aclsupport ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root)\n\t\t\tget_parent_attributes(exp, &stat);\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif ((bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) ||\n\t    (bmval2 & FATTR4_WORD2_LAYOUT_TYPES)) {\n\t\tif (exp->ex_layout_type) {\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(1);\n\t\t\t*p++ = cpu_to_be32(exp->ex_layout_type);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t}\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD0);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD1);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL",
            "#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL\n#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL\n\nstatic __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tint aclsupport = 0;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tBUG_ON(bmval[2]);\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & (FATTR4_WORD0_ACL | FATTR4_WORD0_ACLSUPPORT\n\t\t\t| FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\taclsupport = (err == 0);\n\t\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\t\telse if (err == -EINVAL) {\n\t\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\t\tgoto out;\n\t\t\t} else if (err != 0)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) ||\n\t\t\tbmval[0] & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(dentry->d_inode,\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!aclsupport)\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, dentry->d_inode);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(aclsupport ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root)\n\t\t\tget_parent_attributes(exp, &stat);\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif ((bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) ||\n\t    (bmval2 & FATTR4_WORD2_LAYOUT_TYPES)) {\n\t\tif (exp->ex_layout_type) {\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(1);\n\t\t\t*p++ = cpu_to_be32(exp->ex_layout_type);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t}\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD0);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD1);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svcxdr_init_encode_from_buffer",
          "args": [
            "&xdr",
            "&dummy",
            "*p",
            "words << 2"
          ],
          "line": 2770
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_init_encode_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2746-2759",
          "snippet": "static void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\n\t\t\t\tstruct xdr_buf *buf, __be32 *p, int bytes)\n{\n\txdr->scratch.iov_len = 0;\n\tmemset(buf, 0, sizeof(struct xdr_buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = 0;\n\tbuf->len = 0;\n\txdr->buf = buf;\n\txdr->iov = buf->head;\n\txdr->p = p;\n\txdr->end = (void *)p + bytes;\n\tbuf->buflen = bytes;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\n\t\t\t\tstruct xdr_buf *buf, __be32 *p, int bytes)\n{\n\txdr->scratch.iov_len = 0;\n\tmemset(buf, 0, sizeof(struct xdr_buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = 0;\n\tbuf->len = 0;\n\txdr->buf = buf;\n\txdr->iov = buf->head;\n\txdr->p = p;\n\txdr->end = (void *)p + bytes;\n\tbuf->buflen = bytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n__be32 nfsd4_encode_fattr_to_buf(__be32 **p, int words,\n\t\t\tstruct svc_fh *fhp, struct svc_export *exp,\n\t\t\tstruct dentry *dentry, u32 *bmval,\n\t\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tstruct xdr_buf dummy;\n\tstruct xdr_stream xdr;\n\t__be32 ret;\n\n\tsvcxdr_init_encode_from_buffer(&xdr, &dummy, *p, words << 2);\n\tret = nfsd4_encode_fattr(&xdr, fhp, exp, dentry, bmval, rqstp,\n\t\t\t\t\t\t\tignore_crossmnt);\n\t*p = xdr.p;\n\treturn ret;\n}"
  },
  {
    "function_name": "svcxdr_init_encode_from_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2746-2759",
    "snippet": "static void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\n\t\t\t\tstruct xdr_buf *buf, __be32 *p, int bytes)\n{\n\txdr->scratch.iov_len = 0;\n\tmemset(buf, 0, sizeof(struct xdr_buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = 0;\n\tbuf->len = 0;\n\txdr->buf = buf;\n\txdr->iov = buf->head;\n\txdr->p = p;\n\txdr->end = (void *)p + bytes;\n\tbuf->buflen = bytes;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(struct xdr_buf)"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\n\t\t\t\tstruct xdr_buf *buf, __be32 *p, int bytes)\n{\n\txdr->scratch.iov_len = 0;\n\tmemset(buf, 0, sizeof(struct xdr_buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = 0;\n\tbuf->len = 0;\n\txdr->buf = buf;\n\txdr->iov = buf->head;\n\txdr->p = p;\n\txdr->end = (void *)p + bytes;\n\tbuf->buflen = bytes;\n}"
  },
  {
    "function_name": "nfsd4_encode_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2197-2744",
    "snippet": "static __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tint aclsupport = 0;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tBUG_ON(bmval[2]);\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & (FATTR4_WORD0_ACL | FATTR4_WORD0_ACLSUPPORT\n\t\t\t| FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\taclsupport = (err == 0);\n\t\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\t\telse if (err == -EINVAL) {\n\t\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\t\tgoto out;\n\t\t\t} else if (err != 0)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) ||\n\t\t\tbmval[0] & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(dentry->d_inode,\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!aclsupport)\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, dentry->d_inode);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(aclsupport ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root)\n\t\t\tget_parent_attributes(exp, &stat);\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif ((bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) ||\n\t    (bmval2 & FATTR4_WORD2_LAYOUT_TYPES)) {\n\t\tif (exp->ex_layout_type) {\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(1);\n\t\t\t*p++ = cpu_to_be32(exp->ex_layout_type);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t}\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD0);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD1);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL",
      "#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "err"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "starting_len"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tempfh"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "tempfh"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "acl"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "context",
            "contextlen"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "attrlen_offset",
            "&attrlen",
            "4"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "xdr->buf->len - attrlen_offset - 4"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFSD_SUPPATTR_EXCLCREAT_WORD2"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFSD_SUPPATTR_EXCLCREAT_WORD1"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFSD_SUPPATTR_EXCLCREAT_WORD0"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "3"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_security_label",
          "args": [
            "xdr",
            "rqstp",
            "context",
            "contextlen"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_security_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2155-2158",
          "snippet": "static inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{ return 0; }",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.blksize"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "exp->ex_layout_type"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "stat.ino"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_parent_attributes",
          "args": [
            "exp",
            "&stat"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "get_parent_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2178-2191",
          "snippet": "static int get_parent_attributes(struct svc_export *exp, struct kstat *stat)\n{\n\tstruct path path = exp->ex_path;\n\tint err;\n\n\tpath_get(&path);\n\twhile (follow_up(&path)) {\n\t\tif (path.dentry != path.mnt->mnt_root)\n\t\t\tbreak;\n\t}\n\terr = vfs_getattr(&path, stat);\n\tpath_put(&path);\n\treturn err;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int get_parent_attributes(struct svc_export *exp, struct kstat *stat)\n{\n\tstruct path path = exp->ex_path;\n\tint err;\n\n\tpath_get(&path);\n\twhile (follow_up(&path)) {\n\t\tif (path.dentry != path.mnt->mnt_root)\n\t\t\tbreak;\n\t}\n\terr = vfs_getattr(&path, stat);\n\tpath_put(&path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.mtime.tv_nsec"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(s64)stat.mtime.tv_sec"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.ctime.tv_nsec"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(s64)stat.ctime.tv_sec"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.atime.tv_nsec"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(s64)stat.atime.tv_sec"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "dummy64"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "dummy64"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "dummy64"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "dummy64"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "(u32) MINOR(stat.rdev)"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "stat.rdev"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "(u32) MAJOR(stat.rdev)"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "stat.rdev"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_group",
          "args": [
            "xdr",
            "rqstp",
            "stat.gid"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4idmap.c",
          "lines": "661-666",
          "snippet": "__be32 nfsd4_encode_group(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t  kgid_t gid)\n{\n\tu32 id = from_kgid(&init_user_ns, gid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_GROUP, id);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IDMAP_TYPE_GROUP 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n#define IDMAP_TYPE_GROUP 1\n\n__be32 nfsd4_encode_group(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t  kgid_t gid)\n{\n\tu32 id = from_kgid(&init_user_ns, gid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_GROUP, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_user",
          "args": [
            "xdr",
            "rqstp",
            "stat.uid"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4idmap.c",
          "lines": "654-659",
          "snippet": "__be32 nfsd4_encode_user(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t kuid_t uid)\n{\n\tu32 id = from_kuid(&init_user_ns, uid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_USER, id);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IDMAP_TYPE_USER  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n#define IDMAP_TYPE_USER  0\n\n__be32 nfsd4_encode_user(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t kuid_t uid)\n{\n\tu32 id = from_kuid(&init_user_ns, uid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_USER, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.nlink"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.mode & S_IALLUGO"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) svc_max_payload(rqstp)"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) svc_max_payload(rqstp)"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "statfs.f_namelen"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "255"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "exp->ex_path.mnt->mnt_sb->s_maxbytes"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_fs_locations",
          "args": [
            "xdr",
            "rqstp",
            "exp"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fs_locations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2081-2102",
          "snippet": "static __be32 nfsd4_encode_fs_locations(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, struct svc_export *exp)\n{\n\t__be32 status;\n\tint i;\n\t__be32 *p;\n\tstruct nfsd4_fs_locations *fslocs = &exp->ex_fslocs;\n\n\tstatus = nfsd4_encode_fsloc_fsroot(xdr, rqstp, &exp->ex_path);\n\tif (status)\n\t\treturn status;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(fslocs->locations_count);\n\tfor (i=0; i<fslocs->locations_count; i++) {\n\t\tstatus = nfsd4_encode_fs_location4(xdr, &fslocs->locations[i]);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_fs_locations(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, struct svc_export *exp)\n{\n\t__be32 status;\n\tint i;\n\t__be32 *p;\n\tstruct nfsd4_fs_locations *fslocs = &exp->ex_fslocs;\n\n\tstatus = nfsd4_encode_fsloc_fsroot(xdr, rqstp, &exp->ex_path);\n\tif (status)\n\t\treturn status;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(fslocs->locations_count);\n\tfor (i=0; i<fslocs->locations_count; i++) {\n\t\tstatus = nfsd4_encode_fs_location4(xdr, &fslocs->locations[i]);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) statfs.f_files"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) statfs.f_ffree"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) statfs.f_ffree"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "stat.ino"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "&fhp->fh_handle.fh_base",
            "fhp->fh_handle.fh_size"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "fhp->fh_handle.fh_size + 4"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "aclsupport ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_aclname",
          "args": [
            "xdr",
            "rqstp",
            "ace"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_aclname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2118-2128",
          "snippet": "static inline __be32\nnfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t     struct nfs4_ace *ace)\n{\n\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\treturn nfs4_acl_write_who(xdr, ace->whotype);\n\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\treturn nfsd4_encode_group(xdr, rqstp, ace->who_gid);\n\telse\n\t\treturn nfsd4_encode_user(xdr, rqstp, ace->who_uid);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline __be32\nnfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t     struct nfs4_ace *ace)\n{\n\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\treturn nfs4_acl_write_who(xdr, ace->whotype);\n\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\treturn nfsd4_encode_group(xdr, rqstp, ace->who_gid);\n\telse\n\t\treturn nfsd4_encode_user(xdr, rqstp, ace->who_uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ace->flag"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ace->type"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4*3"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "acl->naces"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "rdattr_err"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nn->nfsd4_lease"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "exp->ex_uuid",
            "EX_UUID_LEN"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "MINOR(stat.dev)"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "stat.dev"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "MAJOR(stat.dev)"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "stat.dev"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64)0"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64)exp->ex_fsid"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsid_source",
          "args": [
            "fhp"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "fsid_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "666-692",
          "snippet": "enum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nenum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "NFS4_REFERRAL_FSID_MINOR"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "NFS4_REFERRAL_FSID_MAJOR"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "stat.size"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_change",
          "args": [
            "p",
            "&stat",
            "dentry->d_inode"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "encode_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1878-1887",
          "snippet": "static __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode)\n{\n\tif (IS_I_VERSION(inode)) {\n\t\tp = xdr_encode_hyper(p, inode->i_version);\n\t} else {\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode)\n{\n\tif (IS_I_VERSION(inode)) {\n\t\tp = xdr_encode_hyper(p, inode->i_version);\n\t} else {\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_FH_PERSISTENT"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dummy"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_file_type",
          "args": [
            "stat.mode"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2104-2116",
          "snippet": "static u32 nfs4_file_type(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\treturn NF4FIFO;\n\tcase S_IFCHR:\treturn NF4CHR;\n\tcase S_IFDIR:\treturn NF4DIR;\n\tcase S_IFBLK:\treturn NF4BLK;\n\tcase S_IFLNK:\treturn NF4LNK;\n\tcase S_IFREG:\treturn NF4REG;\n\tcase S_IFSOCK:\treturn NF4SOCK;\n\tdefault:\treturn NF4BAD;\n\t};\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic u32 nfs4_file_type(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\treturn NF4FIFO;\n\tcase S_IFCHR:\treturn NF4CHR;\n\tcase S_IFDIR:\treturn NF4DIR;\n\tcase S_IFBLK:\treturn NF4BLK;\n\tcase S_IFLNK:\treturn NF4LNK;\n\tcase S_IFREG:\treturn NF4REG;\n\tcase S_IFSOCK:\treturn NF4SOCK;\n\tdefault:\treturn NF4BAD;\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "word2"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "word1"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "word0"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "3"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "word1"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "word0"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "2"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs2",
          "args": [
            "minorversion"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "371-378",
          "snippet": "static inline u32 nfsd_suppattrs2(u32 minorversion)\n{\n\tswitch (minorversion) {\n\tdefault: return NFSD4_2_SUPPORTED_ATTRS_WORD2;\n\tcase 1:  return NFSD4_1_SUPPORTED_ATTRS_WORD2;\n\tcase 0:  return NFSD4_SUPPORTED_ATTRS_WORD2;\n\t}\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tNFSD4_2_SECURITY_ATTRS)",
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)",
            "#define NFSD4_SUPPORTED_ATTRS_WORD2 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tNFSD4_2_SECURITY_ATTRS)\n#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)\n#define NFSD4_SUPPORTED_ATTRS_WORD2 0\n\nstatic inline u32 nfsd_suppattrs2(u32 minorversion)\n{\n\tswitch (minorversion) {\n\tdefault: return NFSD4_2_SUPPORTED_ATTRS_WORD2;\n\tcase 1:  return NFSD4_1_SUPPORTED_ATTRS_WORD2;\n\tcase 0:  return NFSD4_SUPPORTED_ATTRS_WORD2;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs1",
          "args": [
            "minorversion"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "365-369",
          "snippet": "static inline u32 nfsd_suppattrs1(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD1\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD1;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)",
            "#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)\n#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)\n\nstatic inline u32 nfsd_suppattrs1(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD1\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs0",
          "args": [
            "minorversion"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "359-363",
          "snippet": "static inline u32 nfsd_suppattrs0(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD0\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD0;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0",
            "#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0\n#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)\n\nstatic inline u32 nfsd_suppattrs0(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD0\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval0"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval1"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval0"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "2"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval2"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval1"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval0"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "3"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_getsecctx",
          "args": [
            "dentry->d_inode",
            "&context",
            "&contextlen"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_get_nfs4_acl",
          "args": [
            "rqstp",
            "dentry",
            "&acl"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_get_nfs4_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "138-187",
          "snippet": "int\nnfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry,\n\t\tstruct nfs4_acl **acl)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = 0;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\tint size = 0;\n\n\tpacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (!pacl)\n\t\tpacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\n\tif (IS_ERR(pacl))\n\t\treturn PTR_ERR(pacl);\n\n\t/* allocate for worst case: one (deny, allow) pair each: */\n\tsize += 2 * pacl->a_count;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tflags = NFS4_ACL_DIR;\n\t\tdpacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(dpacl)) {\n\t\t\terror = PTR_ERR(dpacl);\n\t\t\tgoto rel_pacl;\n\t\t}\n\n\t\tif (dpacl)\n\t\t\tsize += 2 * dpacl->a_count;\n\t}\n\n\t*acl = kmalloc(nfs4_acl_bytes(size), GFP_KERNEL);\n\tif (*acl == NULL) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*acl)->naces = 0;\n\n\t_posix_to_nfsv4_one(pacl, *acl, flags & ~NFS4_ACL_TYPE_DEFAULT);\n\n\tif (dpacl)\n\t\t_posix_to_nfsv4_one(dpacl, *acl, flags | NFS4_ACL_TYPE_DEFAULT);\n\nout:\n\tposix_acl_release(dpacl);\nrel_pacl:\n\tposix_acl_release(pacl);\n\treturn error;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_ACL_DIR\t\t0x02",
            "#define NFS4_ACL_TYPE_DEFAULT\t0x01"
          ],
          "globals_used": [
            "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_ACL_DIR\t\t0x02\n#define NFS4_ACL_TYPE_DEFAULT\t0x01\n\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nint\nnfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry,\n\t\tstruct nfs4_acl **acl)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = 0;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\tint size = 0;\n\n\tpacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (!pacl)\n\t\tpacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\n\tif (IS_ERR(pacl))\n\t\treturn PTR_ERR(pacl);\n\n\t/* allocate for worst case: one (deny, allow) pair each: */\n\tsize += 2 * pacl->a_count;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tflags = NFS4_ACL_DIR;\n\t\tdpacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(dpacl)) {\n\t\t\terror = PTR_ERR(dpacl);\n\t\t\tgoto rel_pacl;\n\t\t}\n\n\t\tif (dpacl)\n\t\t\tsize += 2 * dpacl->a_count;\n\t}\n\n\t*acl = kmalloc(nfs4_acl_bytes(size), GFP_KERNEL);\n\tif (*acl == NULL) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*acl)->naces = 0;\n\n\t_posix_to_nfsv4_one(pacl, *acl, flags & ~NFS4_ACL_TYPE_DEFAULT);\n\n\tif (dpacl)\n\t\t_posix_to_nfsv4_one(dpacl, *acl, flags | NFS4_ACL_TYPE_DEFAULT);\n\nout:\n\tposix_acl_release(dpacl);\nrel_pacl:\n\tposix_acl_release(pacl);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_compose",
          "args": [
            "tempfh",
            "exp",
            "dentry",
            "NULL"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "fh_compose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "511-585",
          "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = dentry->d_inode;\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) exp->ex_path.dentry->d_inode->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\texp->ex_path.dentry->d_inode->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = dentry->d_inode;\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) exp->ex_path.dentry->d_inode->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\texp->ex_path.dentry->d_inode->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "tempfh",
            "NFS4_FHSIZE"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct svc_fh)",
            "GFP_KERNEL"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_statfs",
          "args": [
            "&path",
            "&statfs"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/statfs.c",
          "lines": "66-74",
          "snippet": "int vfs_statfs(struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint vfs_statfs(struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&path",
            "&stat"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "65-73",
          "snippet": "int vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fattr_handle_absent_fs",
          "args": [
            "&bmval0",
            "&bmval1",
            "&rdattr_err"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "fattr_handle_absent_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2161-2175",
          "snippet": "static __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *rdattr_err)\n{\n\t/* As per referral draft:  */\n\tif (*bmval0 & ~WORD0_ABSENT_FS_ATTRS ||\n\t    *bmval1 & ~WORD1_ABSENT_FS_ATTRS) {\n\t\tif (*bmval0 & FATTR4_WORD0_RDATTR_ERROR ||\n\t            *bmval0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\t\t*rdattr_err = NFSERR_MOVED;\n\t\telse\n\t\t\treturn nfserr_moved;\n\t}\n\t*bmval0 &= WORD0_ABSENT_FS_ATTRS;\n\t*bmval1 &= WORD1_ABSENT_FS_ATTRS;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID",
            "#define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \\\n\t\t\t      FATTR4_WORD0_RDATTR_ERROR)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID\n#define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \\\n\t\t\t      FATTR4_WORD0_RDATTR_ERROR)\n\nstatic __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *rdattr_err)\n{\n\t/* As per referral draft:  */\n\tif (*bmval0 & ~WORD0_ABSENT_FS_ATTRS ||\n\t    *bmval1 & ~WORD1_ABSENT_FS_ATTRS) {\n\t\tif (*bmval0 & FATTR4_WORD0_RDATTR_ERROR ||\n\t            *bmval0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\t\t*rdattr_err = NFSERR_MOVED;\n\t\telse\n\t\t\treturn nfserr_moved;\n\t}\n\t*bmval0 &= WORD0_ABSENT_FS_ATTRS;\n\t*bmval1 &= WORD1_ABSENT_FS_ATTRS;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bmval[2]"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bmval2 & ~nfsd_suppattrs2(minorversion)"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bmval1 & ~nfsd_suppattrs1(minorversion)"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bmval0 & ~nfsd_suppattrs0(minorversion)"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bmval1 & NFSD_WRITEONLY_ATTRS_WORD1"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL\n#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL\n\nstatic __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tint aclsupport = 0;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tBUG_ON(bmval[2]);\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & (FATTR4_WORD0_ACL | FATTR4_WORD0_ACLSUPPORT\n\t\t\t| FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\taclsupport = (err == 0);\n\t\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\t\telse if (err == -EINVAL) {\n\t\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\t\tgoto out;\n\t\t\t} else if (err != 0)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) ||\n\t\t\tbmval[0] & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(dentry->d_inode,\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!aclsupport)\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, dentry->d_inode);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(aclsupport ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root)\n\t\t\tget_parent_attributes(exp, &stat);\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif ((bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) ||\n\t    (bmval2 & FATTR4_WORD2_LAYOUT_TYPES)) {\n\t\tif (exp->ex_layout_type) {\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(1);\n\t\t\t*p++ = cpu_to_be32(exp->ex_layout_type);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t}\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD0);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD1);\n\t\t*p++ = cpu_to_be32(NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}"
  },
  {
    "function_name": "get_parent_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2178-2191",
    "snippet": "static int get_parent_attributes(struct svc_export *exp, struct kstat *stat)\n{\n\tstruct path path = exp->ex_path;\n\tint err;\n\n\tpath_get(&path);\n\twhile (follow_up(&path)) {\n\t\tif (path.dentry != path.mnt->mnt_root)\n\t\t\tbreak;\n\t}\n\terr = vfs_getattr(&path, stat);\n\tpath_put(&path);\n\treturn err;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&path",
            "stat"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "65-73",
          "snippet": "int vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "follow_up",
          "args": [
            "&path"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "follow_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "941-961",
          "snippet": "int follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&path"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int get_parent_attributes(struct svc_export *exp, struct kstat *stat)\n{\n\tstruct path path = exp->ex_path;\n\tint err;\n\n\tpath_get(&path);\n\twhile (follow_up(&path)) {\n\t\tif (path.dentry != path.mnt->mnt_root)\n\t\t\tbreak;\n\t}\n\terr = vfs_getattr(&path, stat);\n\tpath_put(&path);\n\treturn err;\n}"
  },
  {
    "function_name": "fattr_handle_absent_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2161-2175",
    "snippet": "static __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *rdattr_err)\n{\n\t/* As per referral draft:  */\n\tif (*bmval0 & ~WORD0_ABSENT_FS_ATTRS ||\n\t    *bmval1 & ~WORD1_ABSENT_FS_ATTRS) {\n\t\tif (*bmval0 & FATTR4_WORD0_RDATTR_ERROR ||\n\t            *bmval0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\t\t*rdattr_err = NFSERR_MOVED;\n\t\telse\n\t\t\treturn nfserr_moved;\n\t}\n\t*bmval0 &= WORD0_ABSENT_FS_ATTRS;\n\t*bmval1 &= WORD1_ABSENT_FS_ATTRS;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID",
      "#define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \\\n\t\t\t      FATTR4_WORD0_RDATTR_ERROR)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID\n#define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \\\n\t\t\t      FATTR4_WORD0_RDATTR_ERROR)\n\nstatic __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *rdattr_err)\n{\n\t/* As per referral draft:  */\n\tif (*bmval0 & ~WORD0_ABSENT_FS_ATTRS ||\n\t    *bmval1 & ~WORD1_ABSENT_FS_ATTRS) {\n\t\tif (*bmval0 & FATTR4_WORD0_RDATTR_ERROR ||\n\t            *bmval0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\t\t*rdattr_err = NFSERR_MOVED;\n\t\telse\n\t\t\treturn nfserr_moved;\n\t}\n\t*bmval0 &= WORD0_ABSENT_FS_ATTRS;\n\t*bmval1 &= WORD1_ABSENT_FS_ATTRS;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_security_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2155-2158",
    "snippet": "static inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{ return 0; }",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{ return 0; }"
  },
  {
    "function_name": "nfsd4_encode_security_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2135-2153",
    "snippet": "static inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, len + 4 + 4 + 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/*\n\t * For now we use a 0 here to indicate the null translation; in\n\t * the future we may place a call to translation code here.\n\t */\n\t*p++ = cpu_to_be32(0); /* lfs */\n\t*p++ = cpu_to_be32(0); /* pi */\n\tp = xdr_encode_opaque(p, context, len);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "context",
            "len"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "len + 4 + 4 + 4"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, len + 4 + 4 + 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/*\n\t * For now we use a 0 here to indicate the null translation; in\n\t * the future we may place a call to translation code here.\n\t */\n\t*p++ = cpu_to_be32(0); /* lfs */\n\t*p++ = cpu_to_be32(0); /* pi */\n\tp = xdr_encode_opaque(p, context, len);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_aclname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2118-2128",
    "snippet": "static inline __be32\nnfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t     struct nfs4_ace *ace)\n{\n\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\treturn nfs4_acl_write_who(xdr, ace->whotype);\n\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\treturn nfsd4_encode_group(xdr, rqstp, ace->who_gid);\n\telse\n\t\treturn nfsd4_encode_user(xdr, rqstp, ace->who_uid);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_user",
          "args": [
            "xdr",
            "rqstp",
            "ace->who_uid"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4idmap.c",
          "lines": "654-659",
          "snippet": "__be32 nfsd4_encode_user(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t kuid_t uid)\n{\n\tu32 id = from_kuid(&init_user_ns, uid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_USER, id);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IDMAP_TYPE_USER  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n#define IDMAP_TYPE_USER  0\n\n__be32 nfsd4_encode_user(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t kuid_t uid)\n{\n\tu32 id = from_kuid(&init_user_ns, uid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_USER, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_group",
          "args": [
            "xdr",
            "rqstp",
            "ace->who_gid"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4idmap.c",
          "lines": "661-666",
          "snippet": "__be32 nfsd4_encode_group(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t  kgid_t gid)\n{\n\tu32 id = from_kgid(&init_user_ns, gid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_GROUP, id);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IDMAP_TYPE_GROUP 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n#define IDMAP_TYPE_GROUP 1\n\n__be32 nfsd4_encode_group(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t  kgid_t gid)\n{\n\tu32 id = from_kgid(&init_user_ns, gid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_GROUP, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_acl_write_who",
          "args": [
            "xdr",
            "ace->whotype"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_acl_write_who",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "927-944",
          "snippet": "__be32 nfs4_acl_write_who(struct xdr_stream *xdr, int who)\n{\n\t__be32 *p;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].type != who)\n\t\t\tcontinue;\n\t\tp = xdr_reserve_space(xdr, s2t_map[i].stringlen + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, s2t_map[i].string,\n\t\t\t\t\ts2t_map[i].stringlen);\n\t\treturn 0;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn nfserr_serverfault;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};\n\n__be32 nfs4_acl_write_who(struct xdr_stream *xdr, int who)\n{\n\t__be32 *p;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].type != who)\n\t\t\tcontinue;\n\t\tp = xdr_reserve_space(xdr, s2t_map[i].stringlen + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, s2t_map[i].string,\n\t\t\t\t\ts2t_map[i].stringlen);\n\t\treturn 0;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn nfserr_serverfault;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline __be32\nnfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t     struct nfs4_ace *ace)\n{\n\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\treturn nfs4_acl_write_who(xdr, ace->whotype);\n\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\treturn nfsd4_encode_group(xdr, rqstp, ace->who_gid);\n\telse\n\t\treturn nfsd4_encode_user(xdr, rqstp, ace->who_uid);\n}"
  },
  {
    "function_name": "nfs4_file_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2104-2116",
    "snippet": "static u32 nfs4_file_type(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\treturn NF4FIFO;\n\tcase S_IFCHR:\treturn NF4CHR;\n\tcase S_IFDIR:\treturn NF4DIR;\n\tcase S_IFBLK:\treturn NF4BLK;\n\tcase S_IFLNK:\treturn NF4LNK;\n\tcase S_IFREG:\treturn NF4REG;\n\tcase S_IFSOCK:\treturn NF4SOCK;\n\tdefault:\treturn NF4BAD;\n\t};\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic u32 nfs4_file_type(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\treturn NF4FIFO;\n\tcase S_IFCHR:\treturn NF4CHR;\n\tcase S_IFDIR:\treturn NF4DIR;\n\tcase S_IFBLK:\treturn NF4BLK;\n\tcase S_IFLNK:\treturn NF4LNK;\n\tcase S_IFREG:\treturn NF4REG;\n\tcase S_IFSOCK:\treturn NF4SOCK;\n\tdefault:\treturn NF4BAD;\n\t};\n}"
  },
  {
    "function_name": "nfsd4_encode_fs_locations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2081-2102",
    "snippet": "static __be32 nfsd4_encode_fs_locations(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, struct svc_export *exp)\n{\n\t__be32 status;\n\tint i;\n\t__be32 *p;\n\tstruct nfsd4_fs_locations *fslocs = &exp->ex_fslocs;\n\n\tstatus = nfsd4_encode_fsloc_fsroot(xdr, rqstp, &exp->ex_path);\n\tif (status)\n\t\treturn status;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(fslocs->locations_count);\n\tfor (i=0; i<fslocs->locations_count; i++) {\n\t\tstatus = nfsd4_encode_fs_location4(xdr, &fslocs->locations[i]);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_fs_location4",
          "args": [
            "xdr",
            "&fslocs->locations[i]"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fs_location4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1976-1989",
          "snippet": "static __be32 nfsd4_encode_fs_location4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfsd4_fs_location *location)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_encode_components_esc(xdr, ':', location->hosts,\n\t\t\t\t\t\t'[', ']');\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_encode_components(xdr, '/', location->path);\n\tif (status)\n\t\treturn status;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_fs_location4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfsd4_fs_location *location)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_encode_components_esc(xdr, ':', location->hosts,\n\t\t\t\t\t\t'[', ']');\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_encode_components(xdr, '/', location->path);\n\tif (status)\n\t\treturn status;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "fslocs->locations_count"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_fsloc_fsroot",
          "args": [
            "xdr",
            "rqstp",
            "&exp->ex_path"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fsloc_fsroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2064-2076",
          "snippet": "static __be32 nfsd4_encode_fsloc_fsroot(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, const struct path *path)\n{\n\tstruct svc_export *exp_ps;\n\t__be32 res;\n\n\texp_ps = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp_ps))\n\t\treturn nfserrno(PTR_ERR(exp_ps));\n\tres = nfsd4_encode_path(xdr, &exp_ps->ex_path, path);\n\texp_put(exp_ps);\n\treturn res;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_fsloc_fsroot(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, const struct path *path)\n{\n\tstruct svc_export *exp_ps;\n\t__be32 res;\n\n\texp_ps = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp_ps))\n\t\treturn nfserrno(PTR_ERR(exp_ps));\n\tres = nfsd4_encode_path(xdr, &exp_ps->ex_path, path);\n\texp_put(exp_ps);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_fs_locations(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, struct svc_export *exp)\n{\n\t__be32 status;\n\tint i;\n\t__be32 *p;\n\tstruct nfsd4_fs_locations *fslocs = &exp->ex_fslocs;\n\n\tstatus = nfsd4_encode_fsloc_fsroot(xdr, rqstp, &exp->ex_path);\n\tif (status)\n\t\treturn status;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(fslocs->locations_count);\n\tfor (i=0; i<fslocs->locations_count; i++) {\n\t\tstatus = nfsd4_encode_fs_location4(xdr, &fslocs->locations[i]);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_fsloc_fsroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2064-2076",
    "snippet": "static __be32 nfsd4_encode_fsloc_fsroot(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, const struct path *path)\n{\n\tstruct svc_export *exp_ps;\n\t__be32 res;\n\n\texp_ps = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp_ps))\n\t\treturn nfserrno(PTR_ERR(exp_ps));\n\tres = nfsd4_encode_path(xdr, &exp_ps->ex_path, path);\n\texp_put(exp_ps);\n\treturn res;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp_ps"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_path",
          "args": [
            "xdr",
            "&exp_ps->ex_path",
            "path"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1994-2062",
          "snippet": "static __be32 nfsd4_encode_path(struct xdr_stream *xdr,\n\t\t\t\tconst struct path *root,\n\t\t\t\tconst struct path *path)\n{\n\tstruct path cur = *path;\n\t__be32 *p;\n\tstruct dentry **components = NULL;\n\tunsigned int ncomponents = 0;\n\t__be32 err = nfserr_jukebox;\n\n\tdprintk(\"nfsd4_encode_components(\");\n\n\tpath_get(&cur);\n\t/* First walk the path up to the nfsd root, and store the\n\t * dentries/path components in an array.\n\t */\n\tfor (;;) {\n\t\tif (cur.dentry == root->dentry && cur.mnt == root->mnt)\n\t\t\tbreak;\n\t\tif (cur.dentry == cur.mnt->mnt_root) {\n\t\t\tif (follow_up(&cur))\n\t\t\t\tcontinue;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif ((ncomponents & 15) == 0) {\n\t\t\tstruct dentry **new;\n\t\t\tnew = krealloc(components,\n\t\t\t\t\tsizeof(*new) * (ncomponents + 16),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tgoto out_free;\n\t\t\tcomponents = new;\n\t\t}\n\t\tcomponents[ncomponents++] = cur.dentry;\n\t\tcur.dentry = dget_parent(cur.dentry);\n\t}\n\terr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_free;\n\t*p++ = cpu_to_be32(ncomponents);\n\n\twhile (ncomponents) {\n\t\tstruct dentry *dentry = components[ncomponents - 1];\n\t\tunsigned int len;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tlen = dentry->d_name.len;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_free;\n\t\t}\n\t\tp = xdr_encode_opaque(p, dentry->d_name.name, len);\n\t\tdprintk(\"/%pd\", dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(dentry);\n\t\tncomponents--;\n\t}\n\n\terr = 0;\nout_free:\n\tdprintk(\")\\n\");\n\twhile (ncomponents)\n\t\tdput(components[--ncomponents]);\n\tkfree(components);\n\tpath_put(&cur);\n\treturn err;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_path(struct xdr_stream *xdr,\n\t\t\t\tconst struct path *root,\n\t\t\t\tconst struct path *path)\n{\n\tstruct path cur = *path;\n\t__be32 *p;\n\tstruct dentry **components = NULL;\n\tunsigned int ncomponents = 0;\n\t__be32 err = nfserr_jukebox;\n\n\tdprintk(\"nfsd4_encode_components(\");\n\n\tpath_get(&cur);\n\t/* First walk the path up to the nfsd root, and store the\n\t * dentries/path components in an array.\n\t */\n\tfor (;;) {\n\t\tif (cur.dentry == root->dentry && cur.mnt == root->mnt)\n\t\t\tbreak;\n\t\tif (cur.dentry == cur.mnt->mnt_root) {\n\t\t\tif (follow_up(&cur))\n\t\t\t\tcontinue;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif ((ncomponents & 15) == 0) {\n\t\t\tstruct dentry **new;\n\t\t\tnew = krealloc(components,\n\t\t\t\t\tsizeof(*new) * (ncomponents + 16),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tgoto out_free;\n\t\t\tcomponents = new;\n\t\t}\n\t\tcomponents[ncomponents++] = cur.dentry;\n\t\tcur.dentry = dget_parent(cur.dentry);\n\t}\n\terr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_free;\n\t*p++ = cpu_to_be32(ncomponents);\n\n\twhile (ncomponents) {\n\t\tstruct dentry *dentry = components[ncomponents - 1];\n\t\tunsigned int len;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tlen = dentry->d_name.len;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_free;\n\t\t}\n\t\tp = xdr_encode_opaque(p, dentry->d_name.name, len);\n\t\tdprintk(\"/%pd\", dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(dentry);\n\t\tncomponents--;\n\t}\n\n\terr = 0;\nout_free:\n\tdprintk(\")\\n\");\n\twhile (ncomponents)\n\t\tdput(components[--ncomponents]);\n\tkfree(components);\n\tpath_put(&cur);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "PTR_ERR(exp_ps)"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp_ps"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp_ps"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rqst_find_fsidzero_export",
          "args": [
            "rqstp"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_find_fsidzero_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1051-1058",
          "snippet": "struct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstruct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_fsloc_fsroot(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, const struct path *path)\n{\n\tstruct svc_export *exp_ps;\n\t__be32 res;\n\n\texp_ps = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp_ps))\n\t\treturn nfserrno(PTR_ERR(exp_ps));\n\tres = nfsd4_encode_path(xdr, &exp_ps->ex_path, path);\n\texp_put(exp_ps);\n\treturn res;\n}"
  },
  {
    "function_name": "nfsd4_encode_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1994-2062",
    "snippet": "static __be32 nfsd4_encode_path(struct xdr_stream *xdr,\n\t\t\t\tconst struct path *root,\n\t\t\t\tconst struct path *path)\n{\n\tstruct path cur = *path;\n\t__be32 *p;\n\tstruct dentry **components = NULL;\n\tunsigned int ncomponents = 0;\n\t__be32 err = nfserr_jukebox;\n\n\tdprintk(\"nfsd4_encode_components(\");\n\n\tpath_get(&cur);\n\t/* First walk the path up to the nfsd root, and store the\n\t * dentries/path components in an array.\n\t */\n\tfor (;;) {\n\t\tif (cur.dentry == root->dentry && cur.mnt == root->mnt)\n\t\t\tbreak;\n\t\tif (cur.dentry == cur.mnt->mnt_root) {\n\t\t\tif (follow_up(&cur))\n\t\t\t\tcontinue;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif ((ncomponents & 15) == 0) {\n\t\t\tstruct dentry **new;\n\t\t\tnew = krealloc(components,\n\t\t\t\t\tsizeof(*new) * (ncomponents + 16),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tgoto out_free;\n\t\t\tcomponents = new;\n\t\t}\n\t\tcomponents[ncomponents++] = cur.dentry;\n\t\tcur.dentry = dget_parent(cur.dentry);\n\t}\n\terr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_free;\n\t*p++ = cpu_to_be32(ncomponents);\n\n\twhile (ncomponents) {\n\t\tstruct dentry *dentry = components[ncomponents - 1];\n\t\tunsigned int len;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tlen = dentry->d_name.len;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_free;\n\t\t}\n\t\tp = xdr_encode_opaque(p, dentry->d_name.name, len);\n\t\tdprintk(\"/%pd\", dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(dentry);\n\t\tncomponents--;\n\t}\n\n\terr = 0;\nout_free:\n\tdprintk(\")\\n\");\n\twhile (ncomponents)\n\t\tdput(components[--ncomponents]);\n\tkfree(components);\n\tpath_put(&cur);\n\treturn err;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&cur"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "components"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "components[--ncomponents]"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\")\\n\""
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"/%pd\"",
            "dentry"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "dentry->d_name.name",
            "len"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "len + 4"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ncomponents"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "cur.dentry"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "components",
            "sizeof(*new) * (ncomponents + 16)",
            "GFP_KERNEL"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_up",
          "args": [
            "&cur"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "follow_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "941-961",
          "snippet": "int follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&cur"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4_encode_components(\""
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_path(struct xdr_stream *xdr,\n\t\t\t\tconst struct path *root,\n\t\t\t\tconst struct path *path)\n{\n\tstruct path cur = *path;\n\t__be32 *p;\n\tstruct dentry **components = NULL;\n\tunsigned int ncomponents = 0;\n\t__be32 err = nfserr_jukebox;\n\n\tdprintk(\"nfsd4_encode_components(\");\n\n\tpath_get(&cur);\n\t/* First walk the path up to the nfsd root, and store the\n\t * dentries/path components in an array.\n\t */\n\tfor (;;) {\n\t\tif (cur.dentry == root->dentry && cur.mnt == root->mnt)\n\t\t\tbreak;\n\t\tif (cur.dentry == cur.mnt->mnt_root) {\n\t\t\tif (follow_up(&cur))\n\t\t\t\tcontinue;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif ((ncomponents & 15) == 0) {\n\t\t\tstruct dentry **new;\n\t\t\tnew = krealloc(components,\n\t\t\t\t\tsizeof(*new) * (ncomponents + 16),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tgoto out_free;\n\t\t\tcomponents = new;\n\t\t}\n\t\tcomponents[ncomponents++] = cur.dentry;\n\t\tcur.dentry = dget_parent(cur.dentry);\n\t}\n\terr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_free;\n\t*p++ = cpu_to_be32(ncomponents);\n\n\twhile (ncomponents) {\n\t\tstruct dentry *dentry = components[ncomponents - 1];\n\t\tunsigned int len;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tlen = dentry->d_name.len;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_free;\n\t\t}\n\t\tp = xdr_encode_opaque(p, dentry->d_name.name, len);\n\t\tdprintk(\"/%pd\", dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(dentry);\n\t\tncomponents--;\n\t}\n\n\terr = 0;\nout_free:\n\tdprintk(\")\\n\");\n\twhile (ncomponents)\n\t\tdput(components[--ncomponents]);\n\tkfree(components);\n\tpath_put(&cur);\n\treturn err;\n}"
  },
  {
    "function_name": "nfsd4_encode_fs_location4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1976-1989",
    "snippet": "static __be32 nfsd4_encode_fs_location4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfsd4_fs_location *location)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_encode_components_esc(xdr, ':', location->hosts,\n\t\t\t\t\t\t'[', ']');\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_encode_components(xdr, '/', location->path);\n\tif (status)\n\t\treturn status;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_components",
          "args": [
            "xdr",
            "'/'",
            "location->path"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_components",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1967-1971",
          "snippet": "static __be32 nfsd4_encode_components(struct xdr_stream *xdr, char sep,\n\t\t\t\t      char *components)\n{\n\treturn nfsd4_encode_components_esc(xdr, sep, components, 0, 0);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_components(struct xdr_stream *xdr, char sep,\n\t\t\t\t      char *components)\n{\n\treturn nfsd4_encode_components_esc(xdr, sep, components, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_components_esc",
          "args": [
            "xdr",
            "':'",
            "location->hosts",
            "'['",
            "']'"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_components_esc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1907-1962",
          "snippet": "static __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_fs_location4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfsd4_fs_location *location)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_encode_components_esc(xdr, ':', location->hosts,\n\t\t\t\t\t\t'[', ']');\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_encode_components(xdr, '/', location->path);\n\tif (status)\n\t\treturn status;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_components",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1967-1971",
    "snippet": "static __be32 nfsd4_encode_components(struct xdr_stream *xdr, char sep,\n\t\t\t\t      char *components)\n{\n\treturn nfsd4_encode_components_esc(xdr, sep, components, 0, 0);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_components_esc",
          "args": [
            "xdr",
            "sep",
            "components",
            "0",
            "0"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_components_esc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1907-1962",
          "snippet": "static __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_components(struct xdr_stream *xdr, char sep,\n\t\t\t\t      char *components)\n{\n\treturn nfsd4_encode_components_esc(xdr, sep, components, 0, 0);\n}"
  },
  {
    "function_name": "nfsd4_encode_components_esc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1907-1962",
    "snippet": "static __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "pathlen_offset",
            "&pathlen",
            "4"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "count"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "str",
            "strlen"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "strlen + 4"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4_encode_components(%s)\\n\"",
            "components"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}"
  },
  {
    "function_name": "encode_cinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1889-1902",
    "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c->after_ctime_nsec"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c->after_ctime_sec"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c->before_ctime_nsec"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c->before_ctime_sec"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "c->after_change"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "c->before_change"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c->atomic"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "encode_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1878-1887",
    "snippet": "static __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode)\n{\n\tif (IS_I_VERSION(inode)) {\n\t\tp = xdr_encode_hyper(p, inode->i_version);\n\t} else {\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_nsec);\n\t}\n\treturn p;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat->ctime.tv_nsec"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat->ctime.tv_sec"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "inode->i_version"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_I_VERSION",
          "args": [
            "inode"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode)\n{\n\tif (IS_I_VERSION(inode)) {\n\t\tp = xdr_encode_hyper(p, inode->i_version);\n\t} else {\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_nsec);\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "nfsd4_decode_compound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1791-1876",
    "snippet": "static __be32\nnfsd4_decode_compound(struct nfsd4_compoundargs *argp)\n{\n\tDECODE_HEAD;\n\tstruct nfsd4_op *op;\n\tbool cachethis = false;\n\tint auth_slack= argp->rqstp->rq_auth_slack;\n\tint max_reply = auth_slack + 8; /* opcnt, status */\n\tint readcount = 0;\n\tint readbytes = 0;\n\tint i;\n\n\tREAD_BUF(4);\n\targp->taglen = be32_to_cpup(p++);\n\tREAD_BUF(argp->taglen + 8);\n\tSAVEMEM(argp->tag, argp->taglen);\n\targp->minorversion = be32_to_cpup(p++);\n\targp->opcnt = be32_to_cpup(p++);\n\tmax_reply += 4 + (XDR_QUADLEN(argp->taglen) << 2);\n\n\tif (argp->taglen > NFSD4_MAX_TAGLEN)\n\t\tgoto xdr_error;\n\tif (argp->opcnt > 100)\n\t\tgoto xdr_error;\n\n\tif (argp->opcnt > ARRAY_SIZE(argp->iops)) {\n\t\targp->ops = kzalloc(argp->opcnt * sizeof(*argp->ops), GFP_KERNEL);\n\t\tif (!argp->ops) {\n\t\t\targp->ops = argp->iops;\n\t\t\tdprintk(\"nfsd: couldn't allocate room for COMPOUND\\n\");\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tif (argp->minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\targp->opcnt = 0;\n\n\tfor (i = 0; i < argp->opcnt; i++) {\n\t\top = &argp->ops[i];\n\t\top->replay = NULL;\n\n\t\tREAD_BUF(4);\n\t\top->opnum = be32_to_cpup(p++);\n\n\t\tif (nfsd4_opnum_in_range(argp, op))\n\t\t\top->status = nfsd4_dec_ops[op->opnum](argp, &op->u);\n\t\telse {\n\t\t\top->opnum = OP_ILLEGAL;\n\t\t\top->status = nfserr_op_illegal;\n\t\t}\n\t\t/*\n\t\t * We'll try to cache the result in the DRC if any one\n\t\t * op in the compound wants to be cached:\n\t\t */\n\t\tcachethis |= nfsd4_cache_this_op(op);\n\n\t\tif (op->opnum == OP_READ) {\n\t\t\treadcount++;\n\t\t\treadbytes += nfsd4_max_reply(argp->rqstp, op);\n\t\t} else\n\t\t\tmax_reply += nfsd4_max_reply(argp->rqstp, op);\n\t\t/*\n\t\t * OP_LOCK may return a conflicting lock.  (Special case\n\t\t * because it will just skip encoding this if it runs\n\t\t * out of xdr buffer space, and it is the only operation\n\t\t * that behaves this way.)\n\t\t */\n\t\tif (op->opnum == OP_LOCK)\n\t\t\tmax_reply += NFS4_OPAQUE_LIMIT;\n\n\t\tif (op->status) {\n\t\t\targp->opcnt = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Sessions make the DRC unnecessary: */\n\tif (argp->minorversion)\n\t\tcachethis = false;\n\tsvc_reserve(argp->rqstp, max_reply + readbytes);\n\targp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;\n\n\tif (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)\n\t\tclear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [
      "static nfsd4_dec nfsd4_dec_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_dec)nfsd4_decode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_dec)nfsd4_decode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_dec)nfsd4_decode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_dec)nfsd4_decode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DELEGRETURN]\t= (nfsd4_dec)nfsd4_decode_delegreturn,\n\t[OP_GETATTR]\t\t= (nfsd4_dec)nfsd4_decode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_LINK]\t\t= (nfsd4_dec)nfsd4_decode_link,\n\t[OP_LOCK]\t\t= (nfsd4_dec)nfsd4_decode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_dec)nfsd4_decode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_dec)nfsd4_decode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_dec)nfsd4_decode_lookup,\n\t[OP_LOOKUPP]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_OPEN]\t\t= (nfsd4_dec)nfsd4_decode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_dec)nfsd4_decode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_dec)nfsd4_decode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_dec)nfsd4_decode_putfh,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_dec)nfsd4_decode_putpubfh,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_READ]\t\t= (nfsd4_dec)nfsd4_decode_read,\n\t[OP_READDIR]\t\t= (nfsd4_dec)nfsd4_decode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_REMOVE]\t\t= (nfsd4_dec)nfsd4_decode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_dec)nfsd4_decode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_dec)nfsd4_decode_renew,\n\t[OP_RESTOREFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_dec)nfsd4_decode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_dec)nfsd4_decode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_dec)nfsd4_decode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_dec)nfsd4_decode_setclientid_confirm,\n\t[OP_VERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_WRITE]\t\t= (nfsd4_dec)nfsd4_decode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_dec)nfsd4_decode_release_lockowner,\n\n\t/* new operations for NFSv4.1 */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_dec)nfsd4_decode_backchannel_ctl,\n\t[OP_BIND_CONN_TO_SESSION]= (nfsd4_dec)nfsd4_decode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_dec)nfsd4_decode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_dec)nfsd4_decode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_dec)nfsd4_decode_destroy_session,\n\t[OP_FREE_STATEID]\t= (nfsd4_dec)nfsd4_decode_free_stateid,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_dec)nfsd4_decode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_dec)nfsd4_decode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_TEST_STATEID]\t= (nfsd4_dec)nfsd4_decode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_dec)nfsd4_decode_destroy_clientid,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_dec)nfsd4_decode_reclaim_complete,\n\n\t/* new operations for NFSv4.2 */\n\t[OP_ALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_COPY]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTERROR]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_READ_PLUS]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_SEEK]\t\t= (nfsd4_dec)nfsd4_decode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "RQ_SPLICE_OK",
            "&argp->rqstp->rq_flags"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_reserve",
          "args": [
            "argp->rqstp",
            "max_reply + readbytes"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_max_reply",
          "args": [
            "argp->rqstp",
            "op"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_max_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "2299-2309",
          "snippet": "int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define op_encode_hdr_size\t\t(2)"
          ],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cache_this_op",
          "args": [
            "op"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cache_this_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1539-1544",
          "snippet": "bool nfsd4_cache_this_op(struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn false;\n\treturn OPDESC(op)->op_flags & OP_CACHEME;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nbool nfsd4_cache_this_op(struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn false;\n\treturn OPDESC(op)->op_flags & OP_CACHEME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_dec_ops[op->opnum]",
          "args": [
            "argp",
            "&op->u"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_opnum_in_range",
          "args": [
            "argp",
            "op"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_opnum_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1777-1789",
          "snippet": "static inline bool\nnfsd4_opnum_in_range(struct nfsd4_compoundargs *argp, struct nfsd4_op *op)\n{\n\tif (op->opnum < FIRST_NFS4_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 0 && op->opnum > LAST_NFS40_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 1 && op->opnum > LAST_NFS41_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 2 && op->opnum > LAST_NFS42_OP)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline bool\nnfsd4_opnum_in_range(struct nfsd4_compoundargs *argp, struct nfsd4_op *op)\n{\n\tif (op->opnum < FIRST_NFS4_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 0 && op->opnum > LAST_NFS40_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 1 && op->opnum > LAST_NFS41_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 2 && op->opnum > LAST_NFS42_OP)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: couldn't allocate room for COMPOUND\\n\""
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "argp->opcnt * sizeof(*argp->ops)",
            "GFP_KERNEL"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "argp->iops"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "argp->taglen"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "argp->tag",
            "argp->taglen"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "argp->taglen + 8"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic nfsd4_dec nfsd4_dec_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_dec)nfsd4_decode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_dec)nfsd4_decode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_dec)nfsd4_decode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_dec)nfsd4_decode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DELEGRETURN]\t= (nfsd4_dec)nfsd4_decode_delegreturn,\n\t[OP_GETATTR]\t\t= (nfsd4_dec)nfsd4_decode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_LINK]\t\t= (nfsd4_dec)nfsd4_decode_link,\n\t[OP_LOCK]\t\t= (nfsd4_dec)nfsd4_decode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_dec)nfsd4_decode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_dec)nfsd4_decode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_dec)nfsd4_decode_lookup,\n\t[OP_LOOKUPP]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_OPEN]\t\t= (nfsd4_dec)nfsd4_decode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_dec)nfsd4_decode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_dec)nfsd4_decode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_dec)nfsd4_decode_putfh,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_dec)nfsd4_decode_putpubfh,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_READ]\t\t= (nfsd4_dec)nfsd4_decode_read,\n\t[OP_READDIR]\t\t= (nfsd4_dec)nfsd4_decode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_REMOVE]\t\t= (nfsd4_dec)nfsd4_decode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_dec)nfsd4_decode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_dec)nfsd4_decode_renew,\n\t[OP_RESTOREFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_dec)nfsd4_decode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_dec)nfsd4_decode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_dec)nfsd4_decode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_dec)nfsd4_decode_setclientid_confirm,\n\t[OP_VERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_WRITE]\t\t= (nfsd4_dec)nfsd4_decode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_dec)nfsd4_decode_release_lockowner,\n\n\t/* new operations for NFSv4.1 */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_dec)nfsd4_decode_backchannel_ctl,\n\t[OP_BIND_CONN_TO_SESSION]= (nfsd4_dec)nfsd4_decode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_dec)nfsd4_decode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_dec)nfsd4_decode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_dec)nfsd4_decode_destroy_session,\n\t[OP_FREE_STATEID]\t= (nfsd4_dec)nfsd4_decode_free_stateid,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_dec)nfsd4_decode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_dec)nfsd4_decode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_TEST_STATEID]\t= (nfsd4_dec)nfsd4_decode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_dec)nfsd4_decode_destroy_clientid,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_dec)nfsd4_decode_reclaim_complete,\n\n\t/* new operations for NFSv4.2 */\n\t[OP_ALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_COPY]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTERROR]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_READ_PLUS]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_SEEK]\t\t= (nfsd4_dec)nfsd4_decode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n};\n\nstatic __be32\nnfsd4_decode_compound(struct nfsd4_compoundargs *argp)\n{\n\tDECODE_HEAD;\n\tstruct nfsd4_op *op;\n\tbool cachethis = false;\n\tint auth_slack= argp->rqstp->rq_auth_slack;\n\tint max_reply = auth_slack + 8; /* opcnt, status */\n\tint readcount = 0;\n\tint readbytes = 0;\n\tint i;\n\n\tREAD_BUF(4);\n\targp->taglen = be32_to_cpup(p++);\n\tREAD_BUF(argp->taglen + 8);\n\tSAVEMEM(argp->tag, argp->taglen);\n\targp->minorversion = be32_to_cpup(p++);\n\targp->opcnt = be32_to_cpup(p++);\n\tmax_reply += 4 + (XDR_QUADLEN(argp->taglen) << 2);\n\n\tif (argp->taglen > NFSD4_MAX_TAGLEN)\n\t\tgoto xdr_error;\n\tif (argp->opcnt > 100)\n\t\tgoto xdr_error;\n\n\tif (argp->opcnt > ARRAY_SIZE(argp->iops)) {\n\t\targp->ops = kzalloc(argp->opcnt * sizeof(*argp->ops), GFP_KERNEL);\n\t\tif (!argp->ops) {\n\t\t\targp->ops = argp->iops;\n\t\t\tdprintk(\"nfsd: couldn't allocate room for COMPOUND\\n\");\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tif (argp->minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\targp->opcnt = 0;\n\n\tfor (i = 0; i < argp->opcnt; i++) {\n\t\top = &argp->ops[i];\n\t\top->replay = NULL;\n\n\t\tREAD_BUF(4);\n\t\top->opnum = be32_to_cpup(p++);\n\n\t\tif (nfsd4_opnum_in_range(argp, op))\n\t\t\top->status = nfsd4_dec_ops[op->opnum](argp, &op->u);\n\t\telse {\n\t\t\top->opnum = OP_ILLEGAL;\n\t\t\top->status = nfserr_op_illegal;\n\t\t}\n\t\t/*\n\t\t * We'll try to cache the result in the DRC if any one\n\t\t * op in the compound wants to be cached:\n\t\t */\n\t\tcachethis |= nfsd4_cache_this_op(op);\n\n\t\tif (op->opnum == OP_READ) {\n\t\t\treadcount++;\n\t\t\treadbytes += nfsd4_max_reply(argp->rqstp, op);\n\t\t} else\n\t\t\tmax_reply += nfsd4_max_reply(argp->rqstp, op);\n\t\t/*\n\t\t * OP_LOCK may return a conflicting lock.  (Special case\n\t\t * because it will just skip encoding this if it runs\n\t\t * out of xdr buffer space, and it is the only operation\n\t\t * that behaves this way.)\n\t\t */\n\t\tif (op->opnum == OP_LOCK)\n\t\t\tmax_reply += NFS4_OPAQUE_LIMIT;\n\n\t\tif (op->status) {\n\t\t\targp->opcnt = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Sessions make the DRC unnecessary: */\n\tif (argp->minorversion)\n\t\tcachethis = false;\n\tsvc_reserve(argp->rqstp, max_reply + readbytes);\n\targp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;\n\n\tif (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)\n\t\tclear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_opnum_in_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1777-1789",
    "snippet": "static inline bool\nnfsd4_opnum_in_range(struct nfsd4_compoundargs *argp, struct nfsd4_op *op)\n{\n\tif (op->opnum < FIRST_NFS4_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 0 && op->opnum > LAST_NFS40_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 1 && op->opnum > LAST_NFS41_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 2 && op->opnum > LAST_NFS42_OP)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline bool\nnfsd4_opnum_in_range(struct nfsd4_compoundargs *argp, struct nfsd4_op *op)\n{\n\tif (op->opnum < FIRST_NFS4_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 0 && op->opnum > LAST_NFS40_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 1 && op->opnum > LAST_NFS41_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 2 && op->opnum > LAST_NFS42_OP)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "nfsd4_decode_notsupp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1686-1690",
    "snippet": "static __be32\nnfsd4_decode_notsupp(struct nfsd4_compoundargs *argp, void *p)\n{\n\treturn nfserr_notsupp;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_decode_notsupp(struct nfsd4_compoundargs *argp, void *p)\n{\n\treturn nfserr_notsupp;\n}"
  },
  {
    "function_name": "nfsd4_decode_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1680-1684",
    "snippet": "static __be32\nnfsd4_decode_noop(struct nfsd4_compoundargs *argp, void *p)\n{\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_decode_noop(struct nfsd4_compoundargs *argp, void *p)\n{\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_decode_seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1664-1678",
    "snippet": "static __be32\nnfsd4_decode_seek(struct nfsd4_compoundargs *argp, struct nfsd4_seek *seek)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &seek->seek_stateid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(8 + 4);\n\tp = xdr_decode_hyper(p, &seek->seek_offset);\n\tseek->seek_whence = be32_to_cpup(p);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&seek->seek_offset"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8 + 4"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&seek->seek_stateid"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_seek(struct nfsd4_compoundargs *argp, struct nfsd4_seek *seek)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &seek->seek_stateid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(8 + 4);\n\tp = xdr_decode_hyper(p, &seek->seek_offset);\n\tseek->seek_whence = be32_to_cpup(p);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1647-1662",
    "snippet": "static __be32\nnfsd4_decode_fallocate(struct nfsd4_compoundargs *argp,\n\t\t       struct nfsd4_fallocate *fallocate)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &fallocate->falloc_stateid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &fallocate->falloc_offset);\n\txdr_decode_hyper(p, &fallocate->falloc_length);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&fallocate->falloc_length"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&fallocate->falloc_offset"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&fallocate->falloc_stateid"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_fallocate(struct nfsd4_compoundargs *argp,\n\t\t       struct nfsd4_fallocate *fallocate)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &fallocate->falloc_stateid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &fallocate->falloc_offset);\n\txdr_decode_hyper(p, &fallocate->falloc_length);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_layoutreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1616-1644",
    "snippet": "static __be32\nnfsd4_decode_layoutreturn(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(16);\n\tlrp->lr_reclaim = be32_to_cpup(p++);\n\tlrp->lr_layout_type = be32_to_cpup(p++);\n\tlrp->lr_seg.iomode = be32_to_cpup(p++);\n\tlrp->lr_return_type = be32_to_cpup(p++);\n\tif (lrp->lr_return_type == RETURN_FILE) {\n\t\tREAD_BUF(16);\n\t\tp = xdr_decode_hyper(p, &lrp->lr_seg.offset);\n\t\tp = xdr_decode_hyper(p, &lrp->lr_seg.length);\n\t\tnfsd4_decode_stateid(argp, &lrp->lr_sid);\n\t\tREAD_BUF(4);\n\t\tlrp->lrf_body_len = be32_to_cpup(p++);\n\t\tif (lrp->lrf_body_len > 0) {\n\t\t\tREAD_BUF(lrp->lrf_body_len);\n\t\t\tREADMEM(lrp->lrf_body, lrp->lrf_body_len);\n\t\t}\n\t} else {\n\t\tlrp->lr_seg.offset = 0;\n\t\tlrp->lr_seg.length = NFS4_MAX_UINT64;\n\t}\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "lrp->lrf_body",
            "lrp->lrf_body_len"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "lrp->lrf_body_len"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&lrp->lr_sid"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lrp->lr_seg.length"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lrp->lr_seg.offset"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_layoutreturn(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(16);\n\tlrp->lr_reclaim = be32_to_cpup(p++);\n\tlrp->lr_layout_type = be32_to_cpup(p++);\n\tlrp->lr_seg.iomode = be32_to_cpup(p++);\n\tlrp->lr_return_type = be32_to_cpup(p++);\n\tif (lrp->lr_return_type == RETURN_FILE) {\n\t\tREAD_BUF(16);\n\t\tp = xdr_decode_hyper(p, &lrp->lr_seg.offset);\n\t\tp = xdr_decode_hyper(p, &lrp->lr_seg.length);\n\t\tnfsd4_decode_stateid(argp, &lrp->lr_sid);\n\t\tREAD_BUF(4);\n\t\tlrp->lrf_body_len = be32_to_cpup(p++);\n\t\tif (lrp->lrf_body_len > 0) {\n\t\t\tREAD_BUF(lrp->lrf_body_len);\n\t\t\tREADMEM(lrp->lrf_body, lrp->lrf_body_len);\n\t\t}\n\t} else {\n\t\tlrp->lr_seg.offset = 0;\n\t\tlrp->lr_seg.length = NFS4_MAX_UINT64;\n\t}\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1572-1614",
    "snippet": "static __be32\nnfsd4_decode_layoutcommit(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tDECODE_HEAD;\n\tu32 timechange;\n\n\tREAD_BUF(20);\n\tp = xdr_decode_hyper(p, &lcp->lc_seg.offset);\n\tp = xdr_decode_hyper(p, &lcp->lc_seg.length);\n\tlcp->lc_reclaim = be32_to_cpup(p++);\n\tnfsd4_decode_stateid(argp, &lcp->lc_sid);\n\tREAD_BUF(4);\n\tlcp->lc_newoffset = be32_to_cpup(p++);\n\tif (lcp->lc_newoffset) {\n\t\tREAD_BUF(8);\n\t\tp = xdr_decode_hyper(p, &lcp->lc_last_wr);\n\t} else\n\t\tlcp->lc_last_wr = 0;\n\tREAD_BUF(4);\n\ttimechange = be32_to_cpup(p++);\n\tif (timechange) {\n\t\tstatus = nfsd4_decode_time(argp, &lcp->lc_mtime);\n\t\tif (status)\n\t\t\treturn status;\n\t} else {\n\t\tlcp->lc_mtime.tv_nsec = UTIME_NOW;\n\t}\n\tREAD_BUF(8);\n\tlcp->lc_layout_type = be32_to_cpup(p++);\n\n\t/*\n\t * Save the layout update in XDR format and let the layout driver deal\n\t * with it later.\n\t */\n\tlcp->lc_up_len = be32_to_cpup(p++);\n\tif (lcp->lc_up_len > 0) {\n\t\tREAD_BUF(lcp->lc_up_len);\n\t\tREADMEM(lcp->lc_up_layout, lcp->lc_up_len);\n\t}\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "lcp->lc_up_layout",
            "lcp->lc_up_len"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "lcp->lc_up_len"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_time",
          "args": [
            "argp",
            "&lcp->lc_mtime"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "242-256",
          "snippet": "static __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lcp->lc_last_wr"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&lcp->lc_sid"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lcp->lc_seg.length"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lcp->lc_seg.offset"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "20"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_layoutcommit(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tDECODE_HEAD;\n\tu32 timechange;\n\n\tREAD_BUF(20);\n\tp = xdr_decode_hyper(p, &lcp->lc_seg.offset);\n\tp = xdr_decode_hyper(p, &lcp->lc_seg.length);\n\tlcp->lc_reclaim = be32_to_cpup(p++);\n\tnfsd4_decode_stateid(argp, &lcp->lc_sid);\n\tREAD_BUF(4);\n\tlcp->lc_newoffset = be32_to_cpup(p++);\n\tif (lcp->lc_newoffset) {\n\t\tREAD_BUF(8);\n\t\tp = xdr_decode_hyper(p, &lcp->lc_last_wr);\n\t} else\n\t\tlcp->lc_last_wr = 0;\n\tREAD_BUF(4);\n\ttimechange = be32_to_cpup(p++);\n\tif (timechange) {\n\t\tstatus = nfsd4_decode_time(argp, &lcp->lc_mtime);\n\t\tif (status)\n\t\t\treturn status;\n\t} else {\n\t\tlcp->lc_mtime.tv_nsec = UTIME_NOW;\n\t}\n\tREAD_BUF(8);\n\tlcp->lc_layout_type = be32_to_cpup(p++);\n\n\t/*\n\t * Save the layout update in XDR format and let the layout driver deal\n\t * with it later.\n\t */\n\tlcp->lc_up_len = be32_to_cpup(p++);\n\tif (lcp->lc_up_len > 0) {\n\t\tREAD_BUF(lcp->lc_up_len);\n\t\tREADMEM(lcp->lc_up_layout, lcp->lc_up_len);\n\t}\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1552-1570",
    "snippet": "static __be32\nnfsd4_decode_layoutget(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(36);\n\tlgp->lg_signal = be32_to_cpup(p++);\n\tlgp->lg_layout_type = be32_to_cpup(p++);\n\tlgp->lg_seg.iomode = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &lgp->lg_seg.offset);\n\tp = xdr_decode_hyper(p, &lgp->lg_seg.length);\n\tp = xdr_decode_hyper(p, &lgp->lg_minlength);\n\tnfsd4_decode_stateid(argp, &lgp->lg_sid);\n\tREAD_BUF(4);\n\tlgp->lg_maxcount = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&lgp->lg_sid"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lgp->lg_minlength"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lgp->lg_seg.length"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lgp->lg_seg.offset"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "36"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_layoutget(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(36);\n\tlgp->lg_signal = be32_to_cpup(p++);\n\tlgp->lg_layout_type = be32_to_cpup(p++);\n\tlgp->lg_seg.iomode = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &lgp->lg_seg.offset);\n\tp = xdr_decode_hyper(p, &lgp->lg_seg.length);\n\tp = xdr_decode_hyper(p, &lgp->lg_minlength);\n\tnfsd4_decode_stateid(argp, &lgp->lg_sid);\n\tREAD_BUF(4);\n\tlgp->lg_maxcount = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_getdeviceinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1527-1550",
    "snippet": "static __be32\nnfsd4_decode_getdeviceinfo(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tDECODE_HEAD;\n\tu32 num, i;\n\n\tREAD_BUF(sizeof(struct nfsd4_deviceid) + 3 * 4);\n\tCOPYMEM(&gdev->gd_devid, sizeof(struct nfsd4_deviceid));\n\tgdev->gd_layout_type = be32_to_cpup(p++);\n\tgdev->gd_maxcount = be32_to_cpup(p++);\n\tnum = be32_to_cpup(p++);\n\tif (num) {\n\t\tREAD_BUF(4 * num);\n\t\tgdev->gd_notify_types = be32_to_cpup(p++);\n\t\tfor (i = 1; i < num; i++) {\n\t\t\tif (be32_to_cpup(p++)) {\n\t\t\t\tstatus = nfserr_inval;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4 * num"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&gdev->gd_devid",
            "sizeof(struct nfsd4_deviceid)"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "sizeof(struct nfsd4_deviceid) + 3 * 4"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_getdeviceinfo(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tDECODE_HEAD;\n\tu32 num, i;\n\n\tREAD_BUF(sizeof(struct nfsd4_deviceid) + 3 * 4);\n\tCOPYMEM(&gdev->gd_devid, sizeof(struct nfsd4_deviceid));\n\tgdev->gd_layout_type = be32_to_cpup(p++);\n\tgdev->gd_maxcount = be32_to_cpup(p++);\n\tnum = be32_to_cpup(p++);\n\tif (num) {\n\t\tREAD_BUF(4 * num);\n\t\tgdev->gd_notify_types = be32_to_cpup(p++);\n\t\tfor (i = 1; i < num; i++) {\n\t\t\tif (be32_to_cpup(p++)) {\n\t\t\t\tstatus = nfserr_inval;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_reclaim_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1516-1524",
    "snippet": "static __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp, struct nfsd4_reclaim_complete *rc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\trc->rca_one_fs = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp, struct nfsd4_reclaim_complete *rc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\trc->rca_one_fs = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_destroy_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1506-1514",
    "snippet": "static __be32 nfsd4_decode_destroy_clientid(struct nfsd4_compoundargs *argp, struct nfsd4_destroy_clientid *dc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(8);\n\tCOPYMEM(&dc->clientid, 8);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&dc->clientid",
            "8"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_destroy_clientid(struct nfsd4_compoundargs *argp, struct nfsd4_destroy_clientid *dc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(8);\n\tCOPYMEM(&dc->clientid, 8);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_test_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1470-1504",
    "snippet": "static __be32\nnfsd4_decode_test_stateid(struct nfsd4_compoundargs *argp, struct nfsd4_test_stateid *test_stateid)\n{\n\tint i;\n\t__be32 *p, status;\n\tstruct nfsd4_test_stateid_id *stateid;\n\n\tREAD_BUF(4);\n\ttest_stateid->ts_num_ids = ntohl(*p++);\n\n\tINIT_LIST_HEAD(&test_stateid->ts_stateid_list);\n\n\tfor (i = 0; i < test_stateid->ts_num_ids; i++) {\n\t\tstateid = svcxdr_tmpalloc(argp, sizeof(*stateid));\n\t\tif (!stateid) {\n\t\t\tstatus = nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&stateid->ts_id_list);\n\t\tlist_add_tail(&stateid->ts_id_list, &test_stateid->ts_stateid_list);\n\n\t\tstatus = nfsd4_decode_stateid(argp, &stateid->ts_id_stateid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = 0;\nout:\n\treturn status;\nxdr_error:\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\", __FILE__, __LINE__);\n\tstatus = nfserr_bad_xdr;\n\tgoto out;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: xdr error (%s:%d)\\n\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&stateid->ts_id_stateid"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&stateid->ts_id_list",
            "&test_stateid->ts_stateid_list"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&stateid->ts_id_list"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "-ENOMEM"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svcxdr_tmpalloc",
          "args": [
            "argp",
            "sizeof(*stateid)"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_tmpalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "185-196",
          "snippet": "static void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&test_stateid->ts_stateid_list"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_decode_test_stateid(struct nfsd4_compoundargs *argp, struct nfsd4_test_stateid *test_stateid)\n{\n\tint i;\n\t__be32 *p, status;\n\tstruct nfsd4_test_stateid_id *stateid;\n\n\tREAD_BUF(4);\n\ttest_stateid->ts_num_ids = ntohl(*p++);\n\n\tINIT_LIST_HEAD(&test_stateid->ts_stateid_list);\n\n\tfor (i = 0; i < test_stateid->ts_num_ids; i++) {\n\t\tstateid = svcxdr_tmpalloc(argp, sizeof(*stateid));\n\t\tif (!stateid) {\n\t\t\tstatus = nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&stateid->ts_id_list);\n\t\tlist_add_tail(&stateid->ts_id_list, &test_stateid->ts_stateid_list);\n\n\t\tstatus = nfsd4_decode_stateid(argp, &stateid->ts_id_stateid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = 0;\nout:\n\treturn status;\nxdr_error:\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\", __FILE__, __LINE__);\n\tstatus = nfserr_bad_xdr;\n\tgoto out;\n}"
  },
  {
    "function_name": "nfsd4_decode_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1454-1468",
    "snippet": "static __be32\nnfsd4_decode_sequence(struct nfsd4_compoundargs *argp,\n\t\t      struct nfsd4_sequence *seq)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN + 16);\n\tCOPYMEM(seq->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\tseq->seqid = be32_to_cpup(p++);\n\tseq->slotid = be32_to_cpup(p++);\n\tseq->maxslots = be32_to_cpup(p++);\n\tseq->cachethis = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "seq->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_MAX_SESSIONID_LEN + 16"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_sequence(struct nfsd4_compoundargs *argp,\n\t\t      struct nfsd4_sequence *seq)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN + 16);\n\tCOPYMEM(seq->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\tseq->seqid = be32_to_cpup(p++);\n\tseq->slotid = be32_to_cpup(p++);\n\tseq->maxslots = be32_to_cpup(p++);\n\tseq->cachethis = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_free_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1441-1452",
    "snippet": "static __be32\nnfsd4_decode_free_stateid(struct nfsd4_compoundargs *argp,\n\t\t\t  struct nfsd4_free_stateid *free_stateid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tfree_stateid->fr_stateid.si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&free_stateid->fr_stateid.si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&free_stateid->fr_stateid.si_opaque",
            "sizeof(stateid_opaque_t)"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "sizeof(stateid_t)"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_free_stateid(struct nfsd4_compoundargs *argp,\n\t\t\t  struct nfsd4_free_stateid *free_stateid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tfree_stateid->fr_stateid.si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&free_stateid->fr_stateid.si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_destroy_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1430-1439",
    "snippet": "static __be32\nnfsd4_decode_destroy_session(struct nfsd4_compoundargs *argp,\n\t\t\t     struct nfsd4_destroy_session *destroy_session)\n{\n\tDECODE_HEAD;\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN);\n\tCOPYMEM(destroy_session->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "destroy_session->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_destroy_session(struct nfsd4_compoundargs *argp,\n\t\t\t     struct nfsd4_destroy_session *destroy_session)\n{\n\tDECODE_HEAD;\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN);\n\tCOPYMEM(destroy_session->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_create_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1378-1428",
    "snippet": "static __be32\nnfsd4_decode_create_session(struct nfsd4_compoundargs *argp,\n\t\t\t    struct nfsd4_create_session *sess)\n{\n\tDECODE_HEAD;\n\tu32 dummy;\n\n\tREAD_BUF(16);\n\tCOPYMEM(&sess->clientid, 8);\n\tsess->seqid = be32_to_cpup(p++);\n\tsess->flags = be32_to_cpup(p++);\n\n\t/* Fore channel attrs */\n\tREAD_BUF(28);\n\tdummy = be32_to_cpup(p++); /* headerpadsz is always 0 */\n\tsess->fore_channel.maxreq_sz = be32_to_cpup(p++);\n\tsess->fore_channel.maxresp_sz = be32_to_cpup(p++);\n\tsess->fore_channel.maxresp_cached = be32_to_cpup(p++);\n\tsess->fore_channel.maxops = be32_to_cpup(p++);\n\tsess->fore_channel.maxreqs = be32_to_cpup(p++);\n\tsess->fore_channel.nr_rdma_attrs = be32_to_cpup(p++);\n\tif (sess->fore_channel.nr_rdma_attrs == 1) {\n\t\tREAD_BUF(4);\n\t\tsess->fore_channel.rdma_attrs = be32_to_cpup(p++);\n\t} else if (sess->fore_channel.nr_rdma_attrs > 1) {\n\t\tdprintk(\"Too many fore channel attr bitmaps!\\n\");\n\t\tgoto xdr_error;\n\t}\n\n\t/* Back channel attrs */\n\tREAD_BUF(28);\n\tdummy = be32_to_cpup(p++); /* headerpadsz is always 0 */\n\tsess->back_channel.maxreq_sz = be32_to_cpup(p++);\n\tsess->back_channel.maxresp_sz = be32_to_cpup(p++);\n\tsess->back_channel.maxresp_cached = be32_to_cpup(p++);\n\tsess->back_channel.maxops = be32_to_cpup(p++);\n\tsess->back_channel.maxreqs = be32_to_cpup(p++);\n\tsess->back_channel.nr_rdma_attrs = be32_to_cpup(p++);\n\tif (sess->back_channel.nr_rdma_attrs == 1) {\n\t\tREAD_BUF(4);\n\t\tsess->back_channel.rdma_attrs = be32_to_cpup(p++);\n\t} else if (sess->back_channel.nr_rdma_attrs > 1) {\n\t\tdprintk(\"Too many back channel attr bitmaps!\\n\");\n\t\tgoto xdr_error;\n\t}\n\n\tREAD_BUF(4);\n\tsess->callback_prog = be32_to_cpup(p++);\n\tnfsd4_decode_cb_sec(argp, &sess->cb_sec);\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_cb_sec",
          "args": [
            "argp",
            "&sess->cb_sec"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_cb_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "471-549",
          "snippet": "static __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Too many back channel attr bitmaps!\\n\""
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "28"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Too many fore channel attr bitmaps!\\n\""
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "28"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&sess->clientid",
            "8"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_create_session(struct nfsd4_compoundargs *argp,\n\t\t\t    struct nfsd4_create_session *sess)\n{\n\tDECODE_HEAD;\n\tu32 dummy;\n\n\tREAD_BUF(16);\n\tCOPYMEM(&sess->clientid, 8);\n\tsess->seqid = be32_to_cpup(p++);\n\tsess->flags = be32_to_cpup(p++);\n\n\t/* Fore channel attrs */\n\tREAD_BUF(28);\n\tdummy = be32_to_cpup(p++); /* headerpadsz is always 0 */\n\tsess->fore_channel.maxreq_sz = be32_to_cpup(p++);\n\tsess->fore_channel.maxresp_sz = be32_to_cpup(p++);\n\tsess->fore_channel.maxresp_cached = be32_to_cpup(p++);\n\tsess->fore_channel.maxops = be32_to_cpup(p++);\n\tsess->fore_channel.maxreqs = be32_to_cpup(p++);\n\tsess->fore_channel.nr_rdma_attrs = be32_to_cpup(p++);\n\tif (sess->fore_channel.nr_rdma_attrs == 1) {\n\t\tREAD_BUF(4);\n\t\tsess->fore_channel.rdma_attrs = be32_to_cpup(p++);\n\t} else if (sess->fore_channel.nr_rdma_attrs > 1) {\n\t\tdprintk(\"Too many fore channel attr bitmaps!\\n\");\n\t\tgoto xdr_error;\n\t}\n\n\t/* Back channel attrs */\n\tREAD_BUF(28);\n\tdummy = be32_to_cpup(p++); /* headerpadsz is always 0 */\n\tsess->back_channel.maxreq_sz = be32_to_cpup(p++);\n\tsess->back_channel.maxresp_sz = be32_to_cpup(p++);\n\tsess->back_channel.maxresp_cached = be32_to_cpup(p++);\n\tsess->back_channel.maxops = be32_to_cpup(p++);\n\tsess->back_channel.maxreqs = be32_to_cpup(p++);\n\tsess->back_channel.nr_rdma_attrs = be32_to_cpup(p++);\n\tif (sess->back_channel.nr_rdma_attrs == 1) {\n\t\tREAD_BUF(4);\n\t\tsess->back_channel.rdma_attrs = be32_to_cpup(p++);\n\t} else if (sess->back_channel.nr_rdma_attrs > 1) {\n\t\tdprintk(\"Too many back channel attr bitmaps!\\n\");\n\t\tgoto xdr_error;\n\t}\n\n\tREAD_BUF(4);\n\tsess->callback_prog = be32_to_cpup(p++);\n\tnfsd4_decode_cb_sec(argp, &sess->cb_sec);\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_exchange_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1274-1376",
    "snippet": "static __be32\nnfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,\n\t\t\t struct nfsd4_exchange_id *exid)\n{\n\tint dummy, tmp;\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\tCOPYMEM(exid->verifier.data, NFS4_VERIFIER_SIZE);\n\n\tstatus = nfsd4_decode_opaque(argp, &exid->clname);\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(4);\n\texid->flags = be32_to_cpup(p++);\n\n\t/* Ignore state_protect4_a */\n\tREAD_BUF(4);\n\texid->spa_how = be32_to_cpup(p++);\n\tswitch (exid->spa_how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\t/* spo_must_enforce */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\t/* spo_must_allow */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\t\tbreak;\n\tcase SP4_SSV:\n\t\t/* ssp_ops */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\t/* ssp_hash_algs<> */\n\t\tREAD_BUF(4);\n\t\ttmp = be32_to_cpup(p++);\n\t\twhile (tmp--) {\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t}\n\n\t\t/* ssp_encr_algs<> */\n\t\tREAD_BUF(4);\n\t\ttmp = be32_to_cpup(p++);\n\t\twhile (tmp--) {\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t}\n\n\t\t/* ssp_window and ssp_num_gss_handles */\n\t\tREAD_BUF(8);\n\t\tdummy = be32_to_cpup(p++);\n\t\tdummy = be32_to_cpup(p++);\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\t/* Ignore Implementation ID */\n\tREAD_BUF(4);    /* nfs_impl_id4 array length */\n\tdummy = be32_to_cpup(p++);\n\n\tif (dummy > 1)\n\t\tgoto xdr_error;\n\n\tif (dummy == 1) {\n\t\t/* nii_domain */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy);\n\t\tp += XDR_QUADLEN(dummy);\n\n\t\t/* nii_name */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy);\n\t\tp += XDR_QUADLEN(dummy);\n\n\t\t/* nii_date */\n\t\tREAD_BUF(12);\n\t\tp += 3;\n\t}\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "12"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy * 4"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy * 4"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy * 4"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy * 4"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_opaque",
          "args": [
            "argp",
            "&exid->clname"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "831-846",
          "snippet": "static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "exid->verifier.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,\n\t\t\t struct nfsd4_exchange_id *exid)\n{\n\tint dummy, tmp;\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\tCOPYMEM(exid->verifier.data, NFS4_VERIFIER_SIZE);\n\n\tstatus = nfsd4_decode_opaque(argp, &exid->clname);\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(4);\n\texid->flags = be32_to_cpup(p++);\n\n\t/* Ignore state_protect4_a */\n\tREAD_BUF(4);\n\texid->spa_how = be32_to_cpup(p++);\n\tswitch (exid->spa_how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\t/* spo_must_enforce */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\t/* spo_must_allow */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\t\tbreak;\n\tcase SP4_SSV:\n\t\t/* ssp_ops */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\t/* ssp_hash_algs<> */\n\t\tREAD_BUF(4);\n\t\ttmp = be32_to_cpup(p++);\n\t\twhile (tmp--) {\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t}\n\n\t\t/* ssp_encr_algs<> */\n\t\tREAD_BUF(4);\n\t\ttmp = be32_to_cpup(p++);\n\t\twhile (tmp--) {\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t}\n\n\t\t/* ssp_window and ssp_num_gss_handles */\n\t\tREAD_BUF(8);\n\t\tdummy = be32_to_cpup(p++);\n\t\tdummy = be32_to_cpup(p++);\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\t/* Ignore Implementation ID */\n\tREAD_BUF(4);    /* nfs_impl_id4 array length */\n\tdummy = be32_to_cpup(p++);\n\n\tif (dummy > 1)\n\t\tgoto xdr_error;\n\n\tif (dummy == 1) {\n\t\t/* nii_domain */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy);\n\t\tp += XDR_QUADLEN(dummy);\n\n\t\t/* nii_name */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy);\n\t\tp += XDR_QUADLEN(dummy);\n\n\t\t/* nii_date */\n\t\tREAD_BUF(12);\n\t\tp += 3;\n\t}\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_release_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1255-1272",
    "snippet": "static __be32\nnfsd4_decode_release_lockowner(struct nfsd4_compoundargs *argp, struct nfsd4_release_lockowner *rlockowner)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(12);\n\tCOPYMEM(&rlockowner->rl_clientid, sizeof(clientid_t));\n\trlockowner->rl_owner.len = be32_to_cpup(p++);\n\tREAD_BUF(rlockowner->rl_owner.len);\n\tREADMEM(rlockowner->rl_owner.data, rlockowner->rl_owner.len);\n\n\tif (argp->minorversion && !zero_clientid(&rlockowner->rl_clientid))\n\t\treturn nfserr_inval;\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_clientid",
          "args": [
            "&rlockowner->rl_clientid"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "zero_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "172-175",
          "snippet": "static int zero_clientid(clientid_t *clid)\n{\n\treturn (clid->cl_boot == 0) && (clid->cl_id == 0);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int zero_clientid(clientid_t *clid)\n{\n\treturn (clid->cl_boot == 0) && (clid->cl_id == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "rlockowner->rl_owner.data",
            "rlockowner->rl_owner.len"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "rlockowner->rl_owner.len"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&rlockowner->rl_clientid",
            "sizeof(clientid_t)"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "12"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_release_lockowner(struct nfsd4_compoundargs *argp, struct nfsd4_release_lockowner *rlockowner)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(12);\n\tCOPYMEM(&rlockowner->rl_clientid, sizeof(clientid_t));\n\trlockowner->rl_owner.len = be32_to_cpup(p++);\n\tREAD_BUF(rlockowner->rl_owner.len);\n\tREADMEM(rlockowner->rl_owner.data, rlockowner->rl_owner.len);\n\n\tif (argp->minorversion && !zero_clientid(&rlockowner->rl_clientid))\n\t\treturn nfserr_inval;\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1204-1253",
    "snippet": "static __be32\nnfsd4_decode_write(struct nfsd4_compoundargs *argp, struct nfsd4_write *write)\n{\n\tint avail;\n\tint len;\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &write->wr_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &write->wr_offset);\n\twrite->wr_stable_how = be32_to_cpup(p++);\n\tif (write->wr_stable_how > 2)\n\t\tgoto xdr_error;\n\twrite->wr_buflen = be32_to_cpup(p++);\n\n\t/* Sorry .. no magic macros for this.. *\n\t * READ_BUF(write->wr_buflen);\n\t * SAVEMEM(write->wr_buf, write->wr_buflen);\n\t */\n\tavail = (char*)argp->end - (char*)argp->p;\n\tif (avail + argp->pagelen < write->wr_buflen) {\n\t\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\n\t\t\t\t__FILE__, __LINE__);\n\t\tgoto xdr_error;\n\t}\n\twrite->wr_head.iov_base = p;\n\twrite->wr_head.iov_len = avail;\n\twrite->wr_pagelist = argp->pagelist;\n\n\tlen = XDR_QUADLEN(write->wr_buflen) << 2;\n\tif (len >= avail) {\n\t\tint pages;\n\n\t\tlen -= avail;\n\n\t\tpages = len >> PAGE_SHIFT;\n\t\targp->pagelist += pages;\n\t\targp->pagelen -= pages * PAGE_SIZE;\n\t\tlen -= pages * PAGE_SIZE;\n\n\t\targp->p = (__be32 *)page_address(argp->pagelist[0]);\n\t\targp->pagelist++;\n\t\targp->end = argp->p + XDR_QUADLEN(PAGE_SIZE);\n\t}\n\targp->p += XDR_QUADLEN(len);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "len"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "argp->pagelist[0]"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "write->wr_buflen"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: xdr error (%s:%d)\\n\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&write->wr_offset"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&write->wr_stateid"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_write(struct nfsd4_compoundargs *argp, struct nfsd4_write *write)\n{\n\tint avail;\n\tint len;\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &write->wr_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &write->wr_offset);\n\twrite->wr_stable_how = be32_to_cpup(p++);\n\tif (write->wr_stable_how > 2)\n\t\tgoto xdr_error;\n\twrite->wr_buflen = be32_to_cpup(p++);\n\n\t/* Sorry .. no magic macros for this.. *\n\t * READ_BUF(write->wr_buflen);\n\t * SAVEMEM(write->wr_buf, write->wr_buflen);\n\t */\n\tavail = (char*)argp->end - (char*)argp->p;\n\tif (avail + argp->pagelen < write->wr_buflen) {\n\t\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\n\t\t\t\t__FILE__, __LINE__);\n\t\tgoto xdr_error;\n\t}\n\twrite->wr_head.iov_base = p;\n\twrite->wr_head.iov_len = avail;\n\twrite->wr_pagelist = argp->pagelist;\n\n\tlen = XDR_QUADLEN(write->wr_buflen) << 2;\n\tif (len >= avail) {\n\t\tint pages;\n\n\t\tlen -= avail;\n\n\t\tpages = len >> PAGE_SHIFT;\n\t\targp->pagelist += pages;\n\t\targp->pagelen -= pages * PAGE_SIZE;\n\t\tlen -= pages * PAGE_SIZE;\n\n\t\targp->p = (__be32 *)page_address(argp->pagelist[0]);\n\t\targp->pagelist++;\n\t\targp->end = argp->p + XDR_QUADLEN(PAGE_SIZE);\n\t}\n\targp->p += XDR_QUADLEN(len);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1185-1202",
    "snippet": "static __be32\nnfsd4_decode_verify(struct nfsd4_compoundargs *argp, struct nfsd4_verify *verify)\n{\n\tDECODE_HEAD;\n\n\tif ((status = nfsd4_decode_bitmap(argp, verify->ve_bmval)))\n\t\tgoto out;\n\n\t/* For convenience's sake, we compare raw xdr'd attributes in\n\t * nfsd4_proc_verify */\n\n\tREAD_BUF(4);\n\tverify->ve_attrlen = be32_to_cpup(p++);\n\tREAD_BUF(verify->ve_attrlen);\n\tSAVEMEM(verify->ve_attrval, verify->ve_attrlen);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "verify->ve_attrval",
            "verify->ve_attrlen"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "verify->ve_attrlen"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_bitmap",
          "args": [
            "argp",
            "verify->ve_bmval"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "258-282",
          "snippet": "static __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_verify(struct nfsd4_compoundargs *argp, struct nfsd4_verify *verify)\n{\n\tDECODE_HEAD;\n\n\tif ((status = nfsd4_decode_bitmap(argp, verify->ve_bmval)))\n\t\tgoto out;\n\n\t/* For convenience's sake, we compare raw xdr'd attributes in\n\t * nfsd4_proc_verify */\n\n\tREAD_BUF(4);\n\tverify->ve_attrlen = be32_to_cpup(p++);\n\tREAD_BUF(verify->ve_attrlen);\n\tSAVEMEM(verify->ve_attrval, verify->ve_attrlen);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_setclientid_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1169-1182",
    "snippet": "static __be32\nnfsd4_decode_setclientid_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid_confirm *scd_c)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(8 + NFS4_VERIFIER_SIZE);\n\tCOPYMEM(&scd_c->sc_clientid, 8);\n\tCOPYMEM(&scd_c->sc_confirm, NFS4_VERIFIER_SIZE);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&scd_c->sc_confirm",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&scd_c->sc_clientid",
            "8"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8 + NFS4_VERIFIER_SIZE"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_setclientid_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid_confirm *scd_c)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(8 + NFS4_VERIFIER_SIZE);\n\tCOPYMEM(&scd_c->sc_clientid, 8);\n\tCOPYMEM(&scd_c->sc_confirm, NFS4_VERIFIER_SIZE);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_setclientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1140-1167",
    "snippet": "static __be32\nnfsd4_decode_setclientid(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid *setclientid)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\tCOPYMEM(setclientid->se_verf.data, NFS4_VERIFIER_SIZE);\n\n\tstatus = nfsd4_decode_opaque(argp, &setclientid->se_name);\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\tREAD_BUF(8);\n\tsetclientid->se_callback_prog = be32_to_cpup(p++);\n\tsetclientid->se_callback_netid_len = be32_to_cpup(p++);\n\n\tREAD_BUF(setclientid->se_callback_netid_len + 4);\n\tSAVEMEM(setclientid->se_callback_netid_val, setclientid->se_callback_netid_len);\n\tsetclientid->se_callback_addr_len = be32_to_cpup(p++);\n\n\tREAD_BUF(setclientid->se_callback_addr_len + 4);\n\tSAVEMEM(setclientid->se_callback_addr_val, setclientid->se_callback_addr_len);\n\tsetclientid->se_callback_ident = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "setclientid->se_callback_addr_val",
            "setclientid->se_callback_addr_len"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "setclientid->se_callback_addr_len + 4"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "setclientid->se_callback_netid_val",
            "setclientid->se_callback_netid_len"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "setclientid->se_callback_netid_len + 4"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_opaque",
          "args": [
            "argp",
            "&setclientid->se_name"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "831-846",
          "snippet": "static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "setclientid->se_verf.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_setclientid(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid *setclientid)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\tCOPYMEM(setclientid->se_verf.data, NFS4_VERIFIER_SIZE);\n\n\tstatus = nfsd4_decode_opaque(argp, &setclientid->se_name);\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\tREAD_BUF(8);\n\tsetclientid->se_callback_prog = be32_to_cpup(p++);\n\tsetclientid->se_callback_netid_len = be32_to_cpup(p++);\n\n\tREAD_BUF(setclientid->se_callback_netid_len + 4);\n\tSAVEMEM(setclientid->se_callback_netid_val, setclientid->se_callback_netid_len);\n\tsetclientid->se_callback_addr_len = be32_to_cpup(p++);\n\n\tREAD_BUF(setclientid->se_callback_addr_len + 4);\n\tSAVEMEM(setclientid->se_callback_addr_val, setclientid->se_callback_addr_len);\n\tsetclientid->se_callback_ident = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1128-1138",
    "snippet": "static __be32\nnfsd4_decode_setattr(struct nfsd4_compoundargs *argp, struct nfsd4_setattr *setattr)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_decode_stateid(argp, &setattr->sa_stateid);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_fattr(argp, setattr->sa_bmval, &setattr->sa_iattr,\n\t\t\t\t  &setattr->sa_acl, &setattr->sa_label);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_fattr",
          "args": [
            "argp",
            "setattr->sa_bmval",
            "&setattr->sa_iattr",
            "&setattr->sa_acl",
            "&setattr->sa_label"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "284-446",
          "snippet": "static __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFSD4_MAX_SEC_LABEL_LEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFSD4_MAX_SEC_LABEL_LEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&setattr->sa_stateid"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_decode_setattr(struct nfsd4_compoundargs *argp, struct nfsd4_setattr *setattr)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_decode_stateid(argp, &setattr->sa_stateid);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_fattr(argp, setattr->sa_bmval, &setattr->sa_iattr,\n\t\t\t\t  &setattr->sa_acl, &setattr->sa_label);\n}"
  },
  {
    "function_name": "nfsd4_decode_secinfo_no_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1117-1126",
    "snippet": "static __be32\nnfsd4_decode_secinfo_no_name(struct nfsd4_compoundargs *argp,\n\t\t     struct nfsd4_secinfo_no_name *sin)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tsin->sin_style = be32_to_cpup(p++);\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_secinfo_no_name(struct nfsd4_compoundargs *argp,\n\t\t     struct nfsd4_secinfo_no_name *sin)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tsin->sin_style = be32_to_cpup(p++);\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_secinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1101-1115",
    "snippet": "static __be32\nnfsd4_decode_secinfo(struct nfsd4_compoundargs *argp,\n\t\t     struct nfsd4_secinfo *secinfo)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tsecinfo->si_namelen = be32_to_cpup(p++);\n\tREAD_BUF(secinfo->si_namelen);\n\tSAVEMEM(secinfo->si_name, secinfo->si_namelen);\n\tstatus = check_filename(secinfo->si_name, secinfo->si_namelen);\n\tif (status)\n\t\treturn status;\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "secinfo->si_name",
            "secinfo->si_namelen"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "67-80",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "secinfo->si_name",
            "secinfo->si_namelen"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "secinfo->si_namelen"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_secinfo(struct nfsd4_compoundargs *argp,\n\t\t     struct nfsd4_secinfo *secinfo)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tsecinfo->si_namelen = be32_to_cpup(p++);\n\tREAD_BUF(secinfo->si_namelen);\n\tSAVEMEM(secinfo->si_name, secinfo->si_namelen);\n\tstatus = check_filename(secinfo->si_name, secinfo->si_namelen);\n\tif (status)\n\t\treturn status;\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_renew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1087-1099",
    "snippet": "static __be32\nnfsd4_decode_renew(struct nfsd4_compoundargs *argp, clientid_t *clientid)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(sizeof(clientid_t));\n\tCOPYMEM(clientid, sizeof(clientid_t));\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "clientid",
            "sizeof(clientid_t)"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "sizeof(clientid_t)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_renew(struct nfsd4_compoundargs *argp, clientid_t *clientid)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(sizeof(clientid_t));\n\tCOPYMEM(clientid, sizeof(clientid_t));\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1067-1085",
    "snippet": "static __be32\nnfsd4_decode_rename(struct nfsd4_compoundargs *argp, struct nfsd4_rename *rename)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\trename->rn_snamelen = be32_to_cpup(p++);\n\tREAD_BUF(rename->rn_snamelen + 4);\n\tSAVEMEM(rename->rn_sname, rename->rn_snamelen);\n\trename->rn_tnamelen = be32_to_cpup(p++);\n\tREAD_BUF(rename->rn_tnamelen);\n\tSAVEMEM(rename->rn_tname, rename->rn_tnamelen);\n\tif ((status = check_filename(rename->rn_sname, rename->rn_snamelen)))\n\t\treturn status;\n\tif ((status = check_filename(rename->rn_tname, rename->rn_tnamelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "rename->rn_tname",
            "rename->rn_tnamelen"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "67-80",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "rename->rn_tname",
            "rename->rn_tnamelen"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "rename->rn_tnamelen"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "rename->rn_sname",
            "rename->rn_snamelen"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "rename->rn_snamelen + 4"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_rename(struct nfsd4_compoundargs *argp, struct nfsd4_rename *rename)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\trename->rn_snamelen = be32_to_cpup(p++);\n\tREAD_BUF(rename->rn_snamelen + 4);\n\tSAVEMEM(rename->rn_sname, rename->rn_snamelen);\n\trename->rn_tnamelen = be32_to_cpup(p++);\n\tREAD_BUF(rename->rn_tnamelen);\n\tSAVEMEM(rename->rn_tname, rename->rn_tnamelen);\n\tif ((status = check_filename(rename->rn_sname, rename->rn_snamelen)))\n\t\treturn status;\n\tif ((status = check_filename(rename->rn_tname, rename->rn_tnamelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1052-1065",
    "snippet": "static __be32\nnfsd4_decode_remove(struct nfsd4_compoundargs *argp, struct nfsd4_remove *remove)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tremove->rm_namelen = be32_to_cpup(p++);\n\tREAD_BUF(remove->rm_namelen);\n\tSAVEMEM(remove->rm_name, remove->rm_namelen);\n\tif ((status = check_filename(remove->rm_name, remove->rm_namelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "remove->rm_name",
            "remove->rm_namelen"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "67-80",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "remove->rm_name",
            "remove->rm_namelen"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "remove->rm_namelen"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_remove(struct nfsd4_compoundargs *argp, struct nfsd4_remove *remove)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tremove->rm_namelen = be32_to_cpup(p++);\n\tREAD_BUF(remove->rm_namelen);\n\tSAVEMEM(remove->rm_name, remove->rm_namelen);\n\tif ((status = check_filename(remove->rm_name, remove->rm_namelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1036-1050",
    "snippet": "static __be32\nnfsd4_decode_readdir(struct nfsd4_compoundargs *argp, struct nfsd4_readdir *readdir)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(24);\n\tp = xdr_decode_hyper(p, &readdir->rd_cookie);\n\tCOPYMEM(readdir->rd_verf.data, sizeof(readdir->rd_verf.data));\n\treaddir->rd_dircount = be32_to_cpup(p++);\n\treaddir->rd_maxcount = be32_to_cpup(p++);\n\tif ((status = nfsd4_decode_bitmap(argp, readdir->rd_bmval)))\n\t\tgoto out;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_bitmap",
          "args": [
            "argp",
            "readdir->rd_bmval"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "258-282",
          "snippet": "static __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "readdir->rd_verf.data",
            "sizeof(readdir->rd_verf.data)"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&readdir->rd_cookie"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "24"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_readdir(struct nfsd4_compoundargs *argp, struct nfsd4_readdir *readdir)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(24);\n\tp = xdr_decode_hyper(p, &readdir->rd_cookie);\n\tCOPYMEM(readdir->rd_verf.data, sizeof(readdir->rd_verf.data));\n\treaddir->rd_dircount = be32_to_cpup(p++);\n\treaddir->rd_maxcount = be32_to_cpup(p++);\n\tif ((status = nfsd4_decode_bitmap(argp, readdir->rd_bmval)))\n\t\tgoto out;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1021-1034",
    "snippet": "static __be32\nnfsd4_decode_read(struct nfsd4_compoundargs *argp, struct nfsd4_read *read)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &read->rd_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &read->rd_offset);\n\tread->rd_length = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&read->rd_offset"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "12"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&read->rd_stateid"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_read(struct nfsd4_compoundargs *argp, struct nfsd4_read *read)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &read->rd_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &read->rd_offset);\n\tread->rd_length = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_putpubfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1013-1019",
    "snippet": "static __be32\nnfsd4_decode_putpubfh(struct nfsd4_compoundargs *argp, void *p)\n{\n\tif (argp->minorversion == 0)\n\t\treturn nfs_ok;\n\treturn nfserr_notsupp;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\nnfsd4_decode_putpubfh(struct nfsd4_compoundargs *argp, void *p)\n{\n\tif (argp->minorversion == 0)\n\t\treturn nfs_ok;\n\treturn nfserr_notsupp;\n}"
  },
  {
    "function_name": "nfsd4_decode_putfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "998-1011",
    "snippet": "static __be32\nnfsd4_decode_putfh(struct nfsd4_compoundargs *argp, struct nfsd4_putfh *putfh)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tputfh->pf_fhlen = be32_to_cpup(p++);\n\tif (putfh->pf_fhlen > NFS4_FHSIZE)\n\t\tgoto xdr_error;\n\tREAD_BUF(putfh->pf_fhlen);\n\tSAVEMEM(putfh->pf_fhval, putfh->pf_fhlen);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "putfh->pf_fhval",
            "putfh->pf_fhlen"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "putfh->pf_fhlen"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_putfh(struct nfsd4_compoundargs *argp, struct nfsd4_putfh *putfh)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tputfh->pf_fhlen = be32_to_cpup(p++);\n\tif (putfh->pf_fhlen > NFS4_FHSIZE)\n\t\tgoto xdr_error;\n\tREAD_BUF(putfh->pf_fhlen);\n\tSAVEMEM(putfh->pf_fhval, putfh->pf_fhlen);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_open_downgrade",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "978-996",
    "snippet": "static __be32\nnfsd4_decode_open_downgrade(struct nfsd4_compoundargs *argp, struct nfsd4_open_downgrade *open_down)\n{\n\tDECODE_HEAD;\n\t\t    \n\tstatus = nfsd4_decode_stateid(argp, &open_down->od_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(4);\n\topen_down->od_seqid = be32_to_cpup(p++);\n\tstatus = nfsd4_decode_share_access(argp, &open_down->od_share_access,\n\t\t\t\t\t   &open_down->od_deleg_want, NULL);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_share_deny(argp, &open_down->od_share_deny);\n\tif (status)\n\t\treturn status;\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_share_deny",
          "args": [
            "argp",
            "&open_down->od_share_deny"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_share_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "817-829",
          "snippet": "static __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_share_access",
          "args": [
            "argp",
            "&open_down->od_share_access",
            "&open_down->od_deleg_want",
            "NULL"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_share_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "764-815",
          "snippet": "static __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&open_down->od_stateid"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_open_downgrade(struct nfsd4_compoundargs *argp, struct nfsd4_open_downgrade *open_down)\n{\n\tDECODE_HEAD;\n\t\t    \n\tstatus = nfsd4_decode_stateid(argp, &open_down->od_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(4);\n\topen_down->od_seqid = be32_to_cpup(p++);\n\tstatus = nfsd4_decode_share_access(argp, &open_down->od_share_access,\n\t\t\t\t\t   &open_down->od_deleg_want, NULL);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_share_deny(argp, &open_down->od_share_deny);\n\tif (status)\n\t\treturn status;\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_open_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "961-976",
    "snippet": "static __be32\nnfsd4_decode_open_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_open_confirm *open_conf)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tstatus = nfsd4_decode_stateid(argp, &open_conf->oc_req_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(4);\n\topen_conf->oc_seqid = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&open_conf->oc_req_stateid"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_open_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_open_confirm *open_conf)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tstatus = nfsd4_decode_stateid(argp, &open_conf->oc_req_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(4);\n\topen_conf->oc_seqid = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "848-959",
    "snippet": "static __be32\nnfsd4_decode_open(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)\n{\n\tDECODE_HEAD;\n\tu32 dummy;\n\n\tmemset(open->op_bmval, 0, sizeof(open->op_bmval));\n\topen->op_iattr.ia_valid = 0;\n\topen->op_openowner = NULL;\n\n\topen->op_xdr_error = 0;\n\t/* seqid, share_access, share_deny, clientid, ownerlen */\n\tREAD_BUF(4);\n\topen->op_seqid = be32_to_cpup(p++);\n\t/* decode, yet ignore deleg_when until supported */\n\tstatus = nfsd4_decode_share_access(argp, &open->op_share_access,\n\t\t\t\t\t   &open->op_deleg_want, &dummy);\n\tif (status)\n\t\tgoto xdr_error;\n\tstatus = nfsd4_decode_share_deny(argp, &open->op_share_deny);\n\tif (status)\n\t\tgoto xdr_error;\n\tREAD_BUF(sizeof(clientid_t));\n\tCOPYMEM(&open->op_clientid, sizeof(clientid_t));\n\tstatus = nfsd4_decode_opaque(argp, &open->op_owner);\n\tif (status)\n\t\tgoto xdr_error;\n\tREAD_BUF(4);\n\topen->op_create = be32_to_cpup(p++);\n\tswitch (open->op_create) {\n\tcase NFS4_OPEN_NOCREATE:\n\t\tbreak;\n\tcase NFS4_OPEN_CREATE:\n\t\tREAD_BUF(4);\n\t\topen->op_createmode = be32_to_cpup(p++);\n\t\tswitch (open->op_createmode) {\n\t\tcase NFS4_CREATE_UNCHECKED:\n\t\tcase NFS4_CREATE_GUARDED:\n\t\t\tstatus = nfsd4_decode_fattr(argp, open->op_bmval,\n\t\t\t\t&open->op_iattr, &open->op_acl, &open->op_label);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_EXCLUSIVE:\n\t\t\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\t\t\tCOPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t\tif (argp->minorversion < 1)\n\t\t\t\tgoto xdr_error;\n\t\t\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\t\t\tCOPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);\n\t\t\tstatus = nfsd4_decode_fattr(argp, open->op_bmval,\n\t\t\t\t&open->op_iattr, &open->op_acl, &open->op_label);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\t/* open_claim */\n\tREAD_BUF(4);\n\topen->op_claim_type = be32_to_cpup(p++);\n\tswitch (open->op_claim_type) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tREAD_BUF(4);\n\t\topen->op_fname.len = be32_to_cpup(p++);\n\t\tREAD_BUF(open->op_fname.len);\n\t\tSAVEMEM(open->op_fname.data, open->op_fname.len);\n\t\tif ((status = check_filename(open->op_fname.data, open->op_fname.len)))\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tREAD_BUF(4);\n\t\topen->op_delegate_type = be32_to_cpup(p++);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tstatus = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(4);\n\t\topen->op_fname.len = be32_to_cpup(p++);\n\t\tREAD_BUF(open->op_fname.len);\n\t\tSAVEMEM(open->op_fname.data, open->op_fname.len);\n\t\tif ((status = check_filename(open->op_fname.data, open->op_fname.len)))\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\tif (argp->minorversion < 1)\n\t\t\tgoto xdr_error;\n\t\t/* void */\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\tif (argp->minorversion < 1)\n\t\t\tgoto xdr_error;\n\t\tstatus = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&open->op_delegate_stateid"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "open->op_fname.data",
            "open->op_fname.len"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "67-80",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "open->op_fname.data",
            "open->op_fname.len"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "open->op_fname.len"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "open->op_fname.data",
            "open->op_fname.len"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "open->op_fname.len"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_fattr",
          "args": [
            "argp",
            "open->op_bmval",
            "&open->op_iattr",
            "&open->op_acl",
            "&open->op_label"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "284-446",
          "snippet": "static __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFSD4_MAX_SEC_LABEL_LEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFSD4_MAX_SEC_LABEL_LEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "open->op_verf.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "open->op_verf.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_opaque",
          "args": [
            "argp",
            "&open->op_owner"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "831-846",
          "snippet": "static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&open->op_clientid",
            "sizeof(clientid_t)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "sizeof(clientid_t)"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_share_deny",
          "args": [
            "argp",
            "&open->op_share_deny"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_share_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "817-829",
          "snippet": "static __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_share_access",
          "args": [
            "argp",
            "&open->op_share_access",
            "&open->op_deleg_want",
            "&dummy"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_share_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "764-815",
          "snippet": "static __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "open->op_bmval",
            "0",
            "sizeof(open->op_bmval)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_open(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)\n{\n\tDECODE_HEAD;\n\tu32 dummy;\n\n\tmemset(open->op_bmval, 0, sizeof(open->op_bmval));\n\topen->op_iattr.ia_valid = 0;\n\topen->op_openowner = NULL;\n\n\topen->op_xdr_error = 0;\n\t/* seqid, share_access, share_deny, clientid, ownerlen */\n\tREAD_BUF(4);\n\topen->op_seqid = be32_to_cpup(p++);\n\t/* decode, yet ignore deleg_when until supported */\n\tstatus = nfsd4_decode_share_access(argp, &open->op_share_access,\n\t\t\t\t\t   &open->op_deleg_want, &dummy);\n\tif (status)\n\t\tgoto xdr_error;\n\tstatus = nfsd4_decode_share_deny(argp, &open->op_share_deny);\n\tif (status)\n\t\tgoto xdr_error;\n\tREAD_BUF(sizeof(clientid_t));\n\tCOPYMEM(&open->op_clientid, sizeof(clientid_t));\n\tstatus = nfsd4_decode_opaque(argp, &open->op_owner);\n\tif (status)\n\t\tgoto xdr_error;\n\tREAD_BUF(4);\n\topen->op_create = be32_to_cpup(p++);\n\tswitch (open->op_create) {\n\tcase NFS4_OPEN_NOCREATE:\n\t\tbreak;\n\tcase NFS4_OPEN_CREATE:\n\t\tREAD_BUF(4);\n\t\topen->op_createmode = be32_to_cpup(p++);\n\t\tswitch (open->op_createmode) {\n\t\tcase NFS4_CREATE_UNCHECKED:\n\t\tcase NFS4_CREATE_GUARDED:\n\t\t\tstatus = nfsd4_decode_fattr(argp, open->op_bmval,\n\t\t\t\t&open->op_iattr, &open->op_acl, &open->op_label);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_EXCLUSIVE:\n\t\t\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\t\t\tCOPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t\tif (argp->minorversion < 1)\n\t\t\t\tgoto xdr_error;\n\t\t\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\t\t\tCOPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);\n\t\t\tstatus = nfsd4_decode_fattr(argp, open->op_bmval,\n\t\t\t\t&open->op_iattr, &open->op_acl, &open->op_label);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\t/* open_claim */\n\tREAD_BUF(4);\n\topen->op_claim_type = be32_to_cpup(p++);\n\tswitch (open->op_claim_type) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tREAD_BUF(4);\n\t\topen->op_fname.len = be32_to_cpup(p++);\n\t\tREAD_BUF(open->op_fname.len);\n\t\tSAVEMEM(open->op_fname.data, open->op_fname.len);\n\t\tif ((status = check_filename(open->op_fname.data, open->op_fname.len)))\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tREAD_BUF(4);\n\t\topen->op_delegate_type = be32_to_cpup(p++);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tstatus = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(4);\n\t\topen->op_fname.len = be32_to_cpup(p++);\n\t\tREAD_BUF(open->op_fname.len);\n\t\tSAVEMEM(open->op_fname.data, open->op_fname.len);\n\t\tif ((status = check_filename(open->op_fname.data, open->op_fname.len)))\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\tif (argp->minorversion < 1)\n\t\t\tgoto xdr_error;\n\t\t/* void */\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\tif (argp->minorversion < 1)\n\t\t\tgoto xdr_error;\n\t\tstatus = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_opaque",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "831-846",
    "snippet": "static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "o->data",
            "o->len"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "o->len"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
  },
  {
    "function_name": "nfsd4_decode_share_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "817-829",
    "snippet": "static __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
  },
  {
    "function_name": "nfsd4_decode_share_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "764-815",
    "snippet": "static __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
  },
  {
    "function_name": "nfsd4_decode_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "749-762",
    "snippet": "static __be32\nnfsd4_decode_lookup(struct nfsd4_compoundargs *argp, struct nfsd4_lookup *lookup)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tlookup->lo_len = be32_to_cpup(p++);\n\tREAD_BUF(lookup->lo_len);\n\tSAVEMEM(lookup->lo_name, lookup->lo_len);\n\tif ((status = check_filename(lookup->lo_name, lookup->lo_len)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "lookup->lo_name",
            "lookup->lo_len"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "67-80",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "lookup->lo_name",
            "lookup->lo_len"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "lookup->lo_len"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_lookup(struct nfsd4_compoundargs *argp, struct nfsd4_lookup *lookup)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tlookup->lo_len = be32_to_cpup(p++);\n\tREAD_BUF(lookup->lo_len);\n\tSAVEMEM(lookup->lo_name, lookup->lo_len);\n\tif ((status = check_filename(lookup->lo_name, lookup->lo_len)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_locku",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "729-747",
    "snippet": "static __be32\nnfsd4_decode_locku(struct nfsd4_compoundargs *argp, struct nfsd4_locku *locku)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(8);\n\tlocku->lu_type = be32_to_cpup(p++);\n\tif ((locku->lu_type < NFS4_READ_LT) || (locku->lu_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tlocku->lu_seqid = be32_to_cpup(p++);\n\tstatus = nfsd4_decode_stateid(argp, &locku->lu_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &locku->lu_offset);\n\tp = xdr_decode_hyper(p, &locku->lu_length);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&locku->lu_length"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&locku->lu_offset"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&locku->lu_stateid"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_locku(struct nfsd4_compoundargs *argp, struct nfsd4_locku *locku)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(8);\n\tlocku->lu_type = be32_to_cpup(p++);\n\tif ((locku->lu_type < NFS4_READ_LT) || (locku->lu_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tlocku->lu_seqid = be32_to_cpup(p++);\n\tstatus = nfsd4_decode_stateid(argp, &locku->lu_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &locku->lu_offset);\n\tp = xdr_decode_hyper(p, &locku->lu_length);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_lockt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "710-727",
    "snippet": "static __be32\nnfsd4_decode_lockt(struct nfsd4_compoundargs *argp, struct nfsd4_lockt *lockt)\n{\n\tDECODE_HEAD;\n\t\t        \n\tREAD_BUF(32);\n\tlockt->lt_type = be32_to_cpup(p++);\n\tif((lockt->lt_type < NFS4_READ_LT) || (lockt->lt_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tp = xdr_decode_hyper(p, &lockt->lt_offset);\n\tp = xdr_decode_hyper(p, &lockt->lt_length);\n\tCOPYMEM(&lockt->lt_clientid, 8);\n\tlockt->lt_owner.len = be32_to_cpup(p++);\n\tREAD_BUF(lockt->lt_owner.len);\n\tREADMEM(lockt->lt_owner.data, lockt->lt_owner.len);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "lockt->lt_owner.data",
            "lockt->lt_owner.len"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "lockt->lt_owner.len"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&lockt->lt_clientid",
            "8"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lockt->lt_length"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lockt->lt_offset"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "32"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_lockt(struct nfsd4_compoundargs *argp, struct nfsd4_lockt *lockt)\n{\n\tDECODE_HEAD;\n\t\t        \n\tREAD_BUF(32);\n\tlockt->lt_type = be32_to_cpup(p++);\n\tif((lockt->lt_type < NFS4_READ_LT) || (lockt->lt_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tp = xdr_decode_hyper(p, &lockt->lt_offset);\n\tp = xdr_decode_hyper(p, &lockt->lt_length);\n\tCOPYMEM(&lockt->lt_clientid, 8);\n\tlockt->lt_owner.len = be32_to_cpup(p++);\n\tREAD_BUF(lockt->lt_owner.len);\n\tREADMEM(lockt->lt_owner.data, lockt->lt_owner.len);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "670-708",
    "snippet": "static __be32\nnfsd4_decode_lock(struct nfsd4_compoundargs *argp, struct nfsd4_lock *lock)\n{\n\tDECODE_HEAD;\n\n\t/*\n\t* type, reclaim(boolean), offset, length, new_lock_owner(boolean)\n\t*/\n\tREAD_BUF(28);\n\tlock->lk_type = be32_to_cpup(p++);\n\tif ((lock->lk_type < NFS4_READ_LT) || (lock->lk_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tlock->lk_reclaim = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &lock->lk_offset);\n\tp = xdr_decode_hyper(p, &lock->lk_length);\n\tlock->lk_is_new = be32_to_cpup(p++);\n\n\tif (lock->lk_is_new) {\n\t\tREAD_BUF(4);\n\t\tlock->lk_new_open_seqid = be32_to_cpup(p++);\n\t\tstatus = nfsd4_decode_stateid(argp, &lock->lk_new_open_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(8 + sizeof(clientid_t));\n\t\tlock->lk_new_lock_seqid = be32_to_cpup(p++);\n\t\tCOPYMEM(&lock->lk_new_clientid, sizeof(clientid_t));\n\t\tlock->lk_new_owner.len = be32_to_cpup(p++);\n\t\tREAD_BUF(lock->lk_new_owner.len);\n\t\tREADMEM(lock->lk_new_owner.data, lock->lk_new_owner.len);\n\t} else {\n\t\tstatus = nfsd4_decode_stateid(argp, &lock->lk_old_lock_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(4);\n\t\tlock->lk_old_lock_seqid = be32_to_cpup(p++);\n\t}\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&lock->lk_old_lock_stateid"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "lock->lk_new_owner.data",
            "lock->lk_new_owner.len"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "lock->lk_new_owner.len"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&lock->lk_new_clientid",
            "sizeof(clientid_t)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8 + sizeof(clientid_t)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lock->lk_length"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lock->lk_offset"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "28"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_lock(struct nfsd4_compoundargs *argp, struct nfsd4_lock *lock)\n{\n\tDECODE_HEAD;\n\n\t/*\n\t* type, reclaim(boolean), offset, length, new_lock_owner(boolean)\n\t*/\n\tREAD_BUF(28);\n\tlock->lk_type = be32_to_cpup(p++);\n\tif ((lock->lk_type < NFS4_READ_LT) || (lock->lk_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tlock->lk_reclaim = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &lock->lk_offset);\n\tp = xdr_decode_hyper(p, &lock->lk_length);\n\tlock->lk_is_new = be32_to_cpup(p++);\n\n\tif (lock->lk_is_new) {\n\t\tREAD_BUF(4);\n\t\tlock->lk_new_open_seqid = be32_to_cpup(p++);\n\t\tstatus = nfsd4_decode_stateid(argp, &lock->lk_new_open_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(8 + sizeof(clientid_t));\n\t\tlock->lk_new_lock_seqid = be32_to_cpup(p++);\n\t\tCOPYMEM(&lock->lk_new_clientid, sizeof(clientid_t));\n\t\tlock->lk_new_owner.len = be32_to_cpup(p++);\n\t\tREAD_BUF(lock->lk_new_owner.len);\n\t\tREADMEM(lock->lk_new_owner.data, lock->lk_new_owner.len);\n\t} else {\n\t\tstatus = nfsd4_decode_stateid(argp, &lock->lk_old_lock_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(4);\n\t\tlock->lk_old_lock_seqid = be32_to_cpup(p++);\n\t}\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "655-668",
    "snippet": "static __be32\nnfsd4_decode_link(struct nfsd4_compoundargs *argp, struct nfsd4_link *link)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tlink->li_namelen = be32_to_cpup(p++);\n\tREAD_BUF(link->li_namelen);\n\tSAVEMEM(link->li_name, link->li_namelen);\n\tif ((status = check_filename(link->li_name, link->li_namelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "link->li_name",
            "link->li_namelen"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "67-80",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "link->li_name",
            "link->li_namelen"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "link->li_namelen"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_link(struct nfsd4_compoundargs *argp, struct nfsd4_link *link)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tlink->li_namelen = be32_to_cpup(p++);\n\tREAD_BUF(link->li_namelen);\n\tSAVEMEM(link->li_name, link->li_namelen);\n\tif ((status = check_filename(link->li_name, link->li_namelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "649-653",
    "snippet": "static inline __be32\nnfsd4_decode_getattr(struct nfsd4_compoundargs *argp, struct nfsd4_getattr *getattr)\n{\n\treturn nfsd4_decode_bitmap(argp, getattr->ga_bmval);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_bitmap",
          "args": [
            "argp",
            "getattr->ga_bmval"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "258-282",
          "snippet": "static __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline __be32\nnfsd4_decode_getattr(struct nfsd4_compoundargs *argp, struct nfsd4_getattr *getattr)\n{\n\treturn nfsd4_decode_bitmap(argp, getattr->ga_bmval);\n}"
  },
  {
    "function_name": "nfsd4_decode_delegreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "643-647",
    "snippet": "static inline __be32\nnfsd4_decode_delegreturn(struct nfsd4_compoundargs *argp, struct nfsd4_delegreturn *dr)\n{\n\treturn nfsd4_decode_stateid(argp, &dr->dr_stateid);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&dr->dr_stateid"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline __be32\nnfsd4_decode_delegreturn(struct nfsd4_compoundargs *argp, struct nfsd4_delegreturn *dr)\n{\n\treturn nfsd4_decode_stateid(argp, &dr->dr_stateid);\n}"
  },
  {
    "function_name": "nfsd4_decode_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "599-641",
    "snippet": "static __be32\nnfsd4_decode_create(struct nfsd4_compoundargs *argp, struct nfsd4_create *create)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tcreate->cr_type = be32_to_cpup(p++);\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tREAD_BUF(4);\n\t\tcreate->cr_datalen = be32_to_cpup(p++);\n\t\tREAD_BUF(create->cr_datalen);\n\t\tcreate->cr_data = svcxdr_dupstr(argp, p, create->cr_datalen);\n\t\tif (!create->cr_data)\n\t\t\treturn nfserr_jukebox;\n\t\tbreak;\n\tcase NF4BLK:\n\tcase NF4CHR:\n\t\tREAD_BUF(8);\n\t\tcreate->cr_specdata1 = be32_to_cpup(p++);\n\t\tcreate->cr_specdata2 = be32_to_cpup(p++);\n\t\tbreak;\n\tcase NF4SOCK:\n\tcase NF4FIFO:\n\tcase NF4DIR:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tREAD_BUF(4);\n\tcreate->cr_namelen = be32_to_cpup(p++);\n\tREAD_BUF(create->cr_namelen);\n\tSAVEMEM(create->cr_name, create->cr_namelen);\n\tif ((status = check_filename(create->cr_name, create->cr_namelen)))\n\t\treturn status;\n\n\tstatus = nfsd4_decode_fattr(argp, create->cr_bmval, &create->cr_iattr,\n\t\t\t\t    &create->cr_acl, &create->cr_label);\n\tif (status)\n\t\tgoto out;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_fattr",
          "args": [
            "argp",
            "create->cr_bmval",
            "&create->cr_iattr",
            "&create->cr_acl",
            "&create->cr_label"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "284-446",
          "snippet": "static __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFSD4_MAX_SEC_LABEL_LEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFSD4_MAX_SEC_LABEL_LEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "create->cr_name",
            "create->cr_namelen"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "67-80",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "create->cr_name",
            "create->cr_namelen"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "create->cr_namelen"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_dupstr",
          "args": [
            "argp",
            "p",
            "create->cr_datalen"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_dupstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "205-215",
          "snippet": "static char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "create->cr_datalen"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_create(struct nfsd4_compoundargs *argp, struct nfsd4_create *create)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tcreate->cr_type = be32_to_cpup(p++);\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tREAD_BUF(4);\n\t\tcreate->cr_datalen = be32_to_cpup(p++);\n\t\tREAD_BUF(create->cr_datalen);\n\t\tcreate->cr_data = svcxdr_dupstr(argp, p, create->cr_datalen);\n\t\tif (!create->cr_data)\n\t\t\treturn nfserr_jukebox;\n\t\tbreak;\n\tcase NF4BLK:\n\tcase NF4CHR:\n\t\tREAD_BUF(8);\n\t\tcreate->cr_specdata1 = be32_to_cpup(p++);\n\t\tcreate->cr_specdata2 = be32_to_cpup(p++);\n\t\tbreak;\n\tcase NF4SOCK:\n\tcase NF4FIFO:\n\tcase NF4DIR:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tREAD_BUF(4);\n\tcreate->cr_namelen = be32_to_cpup(p++);\n\tREAD_BUF(create->cr_namelen);\n\tSAVEMEM(create->cr_name, create->cr_namelen);\n\tif ((status = check_filename(create->cr_name, create->cr_namelen)))\n\t\treturn status;\n\n\tstatus = nfsd4_decode_fattr(argp, create->cr_bmval, &create->cr_iattr,\n\t\t\t\t    &create->cr_acl, &create->cr_label);\n\tif (status)\n\t\tgoto out;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "587-597",
    "snippet": "static __be32\nnfsd4_decode_commit(struct nfsd4_compoundargs *argp, struct nfsd4_commit *commit)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &commit->co_offset);\n\tcommit->co_count = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&commit->co_offset"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "12"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_commit(struct nfsd4_compoundargs *argp, struct nfsd4_commit *commit)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &commit->co_offset);\n\tcommit->co_count = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "574-584",
    "snippet": "static __be32\nnfsd4_decode_close(struct nfsd4_compoundargs *argp, struct nfsd4_close *close)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tclose->cl_seqid = be32_to_cpup(p++);\n\treturn nfsd4_decode_stateid(argp, &close->cl_stateid);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&close->cl_stateid"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "448-458",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_close(struct nfsd4_compoundargs *argp, struct nfsd4_close *close)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tclose->cl_seqid = be32_to_cpup(p++);\n\treturn nfsd4_decode_stateid(argp, &close->cl_stateid);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_bind_conn_to_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "562-572",
    "snippet": "static __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp, struct nfsd4_bind_conn_to_session *bcts)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN + 8);\n\tCOPYMEM(bcts->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\tbcts->dir = be32_to_cpup(p++);\n\t/* XXX: skipping ctsa_use_conn_in_rdma_mode.  Perhaps Tom Tucker\n\t * could help us figure out we should be using it. */\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "bcts->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_MAX_SESSIONID_LEN + 8"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp, struct nfsd4_bind_conn_to_session *bcts)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN + 8);\n\tCOPYMEM(bcts->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\tbcts->dir = be32_to_cpup(p++);\n\t/* XXX: skipping ctsa_use_conn_in_rdma_mode.  Perhaps Tom Tucker\n\t * could help us figure out we should be using it. */\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_backchannel_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "551-560",
    "snippet": "static __be32 nfsd4_decode_backchannel_ctl(struct nfsd4_compoundargs *argp, struct nfsd4_backchannel_ctl *bc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tbc->bc_cb_program = be32_to_cpup(p++);\n\tnfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_cb_sec",
          "args": [
            "argp",
            "&bc->bc_cb_sec"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_cb_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "471-549",
          "snippet": "static __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_backchannel_ctl(struct nfsd4_compoundargs *argp, struct nfsd4_backchannel_ctl *bc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tbc->bc_cb_program = be32_to_cpup(p++);\n\tnfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_cb_sec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "471-549",
    "snippet": "static __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Illegal callback secflavor\\n\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\""
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "kgid"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "kuid"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "gid"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy * 4"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "machine_name",
            "dummy"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "460-469",
    "snippet": "static __be32\nnfsd4_decode_access(struct nfsd4_compoundargs *argp, struct nfsd4_access *access)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\taccess->ac_req_access = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_access(struct nfsd4_compoundargs *argp, struct nfsd4_access *access)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\taccess->ac_req_access = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "448-458",
    "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&sid->si_opaque",
            "sizeof(stateid_opaque_t)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "sizeof(stateid_t)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "284-446",
    "snippet": "static __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFSD4_MAX_SEC_LABEL_LEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "expected_len - len"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_dupstr",
          "args": [
            "argp",
            "buf",
            "dummy32"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_dupstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "205-215",
          "snippet": "static char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "buf",
            "dummy32"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy32"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy32"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_time",
          "args": [
            "argp",
            "&iattr->ia_mtime"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "242-256",
          "snippet": "static __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_map_name_to_gid",
          "args": [
            "argp->rqstp",
            "buf",
            "dummy32",
            "&iattr->ia_gid"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_map_name_to_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4idmap.c",
          "lines": "641-652",
          "snippet": "__be32\nnfsd_map_name_to_gid(struct svc_rqst *rqstp, const char *name, size_t namelen,\n\t\tkgid_t *gid)\n{\n\t__be32 status;\n\tu32 id = -1;\n\tstatus = do_name_to_id(rqstp, IDMAP_TYPE_GROUP, name, namelen, &id);\n\t*gid = make_kgid(&init_user_ns, id);\n\tif (!gid_valid(*gid))\n\t\tstatus = nfserr_badowner;\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IDMAP_TYPE_GROUP 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n#define IDMAP_TYPE_GROUP 1\n\n__be32\nnfsd_map_name_to_gid(struct svc_rqst *rqstp, const char *name, size_t namelen,\n\t\tkgid_t *gid)\n{\n\t__be32 status;\n\tu32 id = -1;\n\tstatus = do_name_to_id(rqstp, IDMAP_TYPE_GROUP, name, namelen, &id);\n\t*gid = make_kgid(&init_user_ns, id);\n\tif (!gid_valid(*gid))\n\t\tstatus = nfserr_badowner;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "buf",
            "dummy32"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy32"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy32"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_map_name_to_uid",
          "args": [
            "argp->rqstp",
            "buf",
            "dummy32",
            "&iattr->ia_uid"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_map_name_to_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4idmap.c",
          "lines": "628-639",
          "snippet": "__be32\nnfsd_map_name_to_uid(struct svc_rqst *rqstp, const char *name, size_t namelen,\n\t\tkuid_t *uid)\n{\n\t__be32 status;\n\tu32 id = -1;\n\tstatus = do_name_to_id(rqstp, IDMAP_TYPE_USER, name, namelen, &id);\n\t*uid = make_kuid(&init_user_ns, id);\n\tif (!uid_valid(*uid))\n\t\tstatus = nfserr_badowner;\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IDMAP_TYPE_USER  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n#define IDMAP_TYPE_USER  0\n\n__be32\nnfsd_map_name_to_uid(struct svc_rqst *rqstp, const char *name, size_t namelen,\n\t\tkuid_t *uid)\n{\n\t__be32 status;\n\tu32 id = -1;\n\tstatus = do_name_to_id(rqstp, IDMAP_TYPE_USER, name, namelen, &id);\n\t*uid = make_kuid(&init_user_ns, id);\n\tif (!uid_valid(*uid))\n\t\tstatus = nfserr_badowner;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "buf",
            "dummy32"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy32"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy32"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_acl_get_whotype",
          "args": [
            "buf",
            "dummy32"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_acl_get_whotype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "914-925",
          "snippet": "int\nnfs4_acl_get_whotype(char *p, u32 len)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].stringlen == len &&\n\t\t\t\t0 == memcmp(s2t_map[i].string, p, len))\n\t\t\treturn s2t_map[i].type;\n\t}\n\treturn NFS4_ACL_WHO_NAMED;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};\n\nint\nnfs4_acl_get_whotype(char *p, u32 len)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].stringlen == len &&\n\t\t\t\t0 == memcmp(s2t_map[i].string, p, len))\n\t\t\treturn s2t_map[i].type;\n\t}\n\treturn NFS4_ACL_WHO_NAMED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "buf",
            "dummy32"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy32"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy32"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_tmpalloc",
          "args": [
            "argp",
            "nfs4_acl_bytes(nace)"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_tmpalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "185-196",
          "snippet": "static void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_acl_bytes",
          "args": [
            "nace"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_acl_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "887-890",
          "snippet": "int nfs4_acl_bytes(int entries)\n{\n\treturn sizeof(struct nfs4_acl) + entries * sizeof(struct nfs4_ace);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static short ace2type(struct nfs4_ace *);",
            "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic short ace2type(struct nfs4_ace *);\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nint nfs4_acl_bytes(int entries)\n{\n\treturn sizeof(struct nfs4_acl) + entries * sizeof(struct nfs4_ace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&iattr->ia_size"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_bitmap",
          "args": [
            "argp",
            "bmval"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "258-282",
          "snippet": "static __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFSD4_MAX_SEC_LABEL_LEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "258-282",
    "snippet": "static __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "bmlen << 2"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "242-256",
    "snippet": "static __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&sec"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "12"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "savemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "227-236",
    "snippet": "static char *savemem(struct nfsd4_compoundargs *argp, __be32 *p, int nbytes)\n{\n\tvoid *ret;\n\n\tret = svcxdr_tmpalloc(argp, nbytes);\n\tif (!ret)\n\t\treturn NULL;\n\tmemcpy(ret, p, nbytes);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ret",
            "p",
            "nbytes"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_tmpalloc",
          "args": [
            "argp",
            "nbytes"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_tmpalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "185-196",
          "snippet": "static void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic char *savemem(struct nfsd4_compoundargs *argp, __be32 *p, int nbytes)\n{\n\tvoid *ret;\n\n\tret = svcxdr_tmpalloc(argp, nbytes);\n\tif (!ret)\n\t\treturn NULL;\n\tmemcpy(ret, p, nbytes);\n\treturn ret;\n}"
  },
  {
    "function_name": "svcxdr_dupstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "205-215",
    "snippet": "static char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "buf",
            "len"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_tmpalloc",
          "args": [
            "argp",
            "len + 1"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_tmpalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "185-196",
          "snippet": "static void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}"
  },
  {
    "function_name": "svcxdr_tmpalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "185-196",
    "snippet": "static void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*tb) + len",
            "GFP_KERNEL"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}"
  },
  {
    "function_name": "zero_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "172-175",
    "snippet": "static int zero_clientid(clientid_t *clid)\n{\n\treturn (clid->cl_boot == 0) && (clid->cl_id == 0);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int zero_clientid(clientid_t *clid)\n{\n\treturn (clid->cl_boot == 0) && (clid->cl_id == 0);\n}"
  },
  {
    "function_name": "read_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "139-170",
    "snippet": "static __be32 *read_buf(struct nfsd4_compoundargs *argp, u32 nbytes)\n{\n\t/* We want more bytes than seem to be available.\n\t * Maybe we need a new page, maybe we have just run out\n\t */\n\tunsigned int avail = (char *)argp->end - (char *)argp->p;\n\t__be32 *p;\n\tif (avail + argp->pagelen < nbytes)\n\t\treturn NULL;\n\tif (avail + PAGE_SIZE < nbytes) /* need more than a page !! */\n\t\treturn NULL;\n\t/* ok, we can do it with the current plus the next page */\n\tif (nbytes <= sizeof(argp->tmp))\n\t\tp = argp->tmp;\n\telse {\n\t\tkfree(argp->tmpp);\n\t\tp = argp->tmpp = kmalloc(nbytes, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\t\n\t}\n\t/*\n\t * The following memcpy is safe because read_buf is always\n\t * called with nbytes > avail, and the two cases above both\n\t * guarantee p points to at least nbytes bytes.\n\t */\n\tmemcpy(p, argp->p, avail);\n\tnext_decode_page(argp);\n\tmemcpy(((char*)p)+avail, argp->p, (nbytes - avail));\n\targp->p += XDR_QUADLEN(nbytes - avail);\n\treturn p;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "nbytes - avail"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "((char*)p)+avail",
            "argp->p",
            "(nbytes - avail)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_decode_page",
          "args": [
            "argp"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "next_decode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "126-137",
          "snippet": "static void next_decode_page(struct nfsd4_compoundargs *argp)\n{\n\targp->p = page_address(argp->pagelist[0]);\n\targp->pagelist++;\n\tif (argp->pagelen < PAGE_SIZE) {\n\t\targp->end = argp->p + (argp->pagelen>>2);\n\t\targp->pagelen = 0;\n\t} else {\n\t\targp->end = argp->p + (PAGE_SIZE>>2);\n\t\targp->pagelen -= PAGE_SIZE;\n\t}\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void next_decode_page(struct nfsd4_compoundargs *argp)\n{\n\targp->p = page_address(argp->pagelist[0]);\n\targp->pagelist++;\n\tif (argp->pagelen < PAGE_SIZE) {\n\t\targp->end = argp->p + (argp->pagelen>>2);\n\t\targp->pagelen = 0;\n\t} else {\n\t\targp->end = argp->p + (PAGE_SIZE>>2);\n\t\targp->pagelen -= PAGE_SIZE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "argp->p",
            "avail"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "nbytes",
            "GFP_KERNEL"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "argp->tmpp"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32 *read_buf(struct nfsd4_compoundargs *argp, u32 nbytes)\n{\n\t/* We want more bytes than seem to be available.\n\t * Maybe we need a new page, maybe we have just run out\n\t */\n\tunsigned int avail = (char *)argp->end - (char *)argp->p;\n\t__be32 *p;\n\tif (avail + argp->pagelen < nbytes)\n\t\treturn NULL;\n\tif (avail + PAGE_SIZE < nbytes) /* need more than a page !! */\n\t\treturn NULL;\n\t/* ok, we can do it with the current plus the next page */\n\tif (nbytes <= sizeof(argp->tmp))\n\t\tp = argp->tmp;\n\telse {\n\t\tkfree(argp->tmpp);\n\t\tp = argp->tmpp = kmalloc(nbytes, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\t\n\t}\n\t/*\n\t * The following memcpy is safe because read_buf is always\n\t * called with nbytes > avail, and the two cases above both\n\t * guarantee p points to at least nbytes bytes.\n\t */\n\tmemcpy(p, argp->p, avail);\n\tnext_decode_page(argp);\n\tmemcpy(((char*)p)+avail, argp->p, (nbytes - avail));\n\targp->p += XDR_QUADLEN(nbytes - avail);\n\treturn p;\n}"
  },
  {
    "function_name": "next_decode_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "126-137",
    "snippet": "static void next_decode_page(struct nfsd4_compoundargs *argp)\n{\n\targp->p = page_address(argp->pagelist[0]);\n\targp->pagelist++;\n\tif (argp->pagelen < PAGE_SIZE) {\n\t\targp->end = argp->p + (argp->pagelen>>2);\n\t\targp->pagelen = 0;\n\t} else {\n\t\targp->end = argp->p + (PAGE_SIZE>>2);\n\t\targp->pagelen -= PAGE_SIZE;\n\t}\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "argp->pagelist[0]"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void next_decode_page(struct nfsd4_compoundargs *argp)\n{\n\targp->p = page_address(argp->pagelist[0]);\n\targp->pagelist++;\n\tif (argp->pagelen < PAGE_SIZE) {\n\t\targp->end = argp->p + (argp->pagelen>>2);\n\t\targp->pagelen = 0;\n\t} else {\n\t\targp->end = argp->p + (PAGE_SIZE>>2);\n\t\targp->pagelen -= PAGE_SIZE;\n\t}\n}"
  },
  {
    "function_name": "check_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
    "lines": "67-80",
    "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdotent",
          "args": [
            "str",
            "len"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
  }
]