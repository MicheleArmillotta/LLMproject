[
  {
    "function_name": "(struct vfsmo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "1132-1169",
    "snippet": "attr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t  struct kstat *stat)\n{\n\tloff_t size;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tmutex_lock(&ui->ui_mutex);\n\tgeneric_fillattr(inode, stat);\n\tstat->blksize = UBIFS_BLOCK_SIZE;\n\tstat->size = ui->ui_size;\n\n\t/*\n\t * Unfortunately, the 'stat()' system call was designed for block\n\t * device based file systems, and it is not appropriate for UBIFS,\n\t * because UBIFS does not have notion of \"block\". For example, it is\n\t * difficult to tell how many block a directory takes - it actually\n\t * takes less than 300 bytes, but we have to round it to block size,\n\t * which introduces large mistake. This makes utilities like 'du' to\n\t * report completely senseless numbers. This is the reason why UBIFS\n\t * goes the same way as JFFS2 - it reports zero blocks for everything\n\t * but regular files, which makes more sense than reporting completely\n\t * wrong sizes.\n\t */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tsize = ui->xattr_size;\n\t\tsize += stat->size;\n\t\tsize = ALIGN(size, UBIFS_BLOCK_SIZE);\n\t\t/*\n\t\t * Note, user-space expects 512-byte blocks count irrespectively\n\t\t * of what was reported in @stat->size.\n\t\t */\n\t\tstat->blocks = size >> 9;\n\t} else\n\t\tstat->blocks = 0;\n\tmutex_unlock(&ui->ui_mutex);\n\treturn 0;\n}\n\nconst struc",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\treturn 0;"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_",
          "args": [
            "LOCK",
            "IZE);\n\t\t/*\n\t\t *"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->i_mod",
          "args": [
            ")) {\n\t\tsize ="
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttr(inode, stat)",
          "args": [
            "sta",
            ">blk"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\tgeneric_f"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tmu",
          "args": [
            "ex_lo"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t  struct kstat *stat)\n{\n\tloff_t size;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tmutex_lock(&ui->ui_mutex);\n\tgeneric_fillattr(inode, stat);\n\tstat->blksize = UBIFS_BLOCK_SIZE;\n\tstat->size = ui->ui_size;\n\n\t/*\n\t * Unfortunately, the 'stat()' system call was designed for block\n\t * device based file systems, and it is not appropriate for UBIFS,\n\t * because UBIFS does not have notion of \"block\". For example, it is\n\t * difficult to tell how many block a directory takes - it actually\n\t * takes less than 300 bytes, but we have to round it to block size,\n\t * which introduces large mistake. This makes utilities like 'du' to\n\t * report completely senseless numbers. This is the reason why UBIFS\n\t * goes the same way as JFFS2 - it reports zero blocks for everything\n\t * but regular files, which makes more sense than reporting completely\n\t * wrong sizes.\n\t */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tsize = ui->xattr_size;\n\t\tsize += stat->size;\n\t\tsize = ALIGN(size, UBIFS_BLOCK_SIZE);\n\t\t/*\n\t\t * Note, user-space expects 512-byte blocks count irrespectively\n\t\t * of what was reported in @stat->size.\n\t\t */\n\t\tstat->blocks = size >> 9;\n\t} else\n\t\tstat->blocks = 0;\n\tmutex_unlock(&ui->ui_mutex);\n\treturn 0;\n}\n\nconst struc"
  },
  {
    "function_name": "struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "966-1130",
    "snippet": "ifs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct ubifs_info *c = old_dir->i_sb->s_fs_info;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct ubifs_inode *old_inode_ui = ubifs_inode(old_inode);\n\tint err, release, sync = 0, move = (new_dir != old_dir);\n\tint is_dir = S_ISDIR(old_inode->i_mode);\n\tint unlink = !!new_inode;\n\tint new_sz = CALC_DENT_SIZE(new_dentry->d_name.len);\n\tint old_sz = CALC_DENT_SIZE(old_dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_dent = 1, .mod_dent = 1,\n\t\t\t\t\t.dirtied_ino = 3 };\n\tstruct ubifs_budget_req ino_req = { .dirtied_ino = 1,\n\t\t\t.dirtied_ino_d = ALIGN(old_inode_ui->data_len, 8) };\n\tstruct timespec time;\n\tunsigned int uninitialized_var(saved_nlink);\n\n\t/*\n\t * Budget request settings: deletion direntry, new direntry, removing\n\t * the old inode, and changing old and new parent directory inodes.\n\t *\n\t * However, this operation also marks the target inode as dirty and\n\t * does not write it, so we allocate budget for the target inode\n\t * separately.\n\t */\n\n\tdbg_gen(\"dent '%pd' ino %lu in dir ino %lu to dent '%pd' in dir ino %lu\",\n\t\told_dentry, old_inode->i_ino, old_dir->i_ino,\n\t\tnew_dentry, new_dir->i_ino);\n\tubifs_assert(mutex_is_locked(&old_dir->i_mutex));\n\tubifs_assert(mutex_is_locked(&new_dir->i_mutex));\n\tif (unlink)\n\t\tubifs_assert(mutex_is_locked(&new_inode->i_mutex));\n\n\n\tif (unlink && is_dir) {\n\t\terr = check_dir_empty(c, new_inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\terr = ubifs_budget_space(c, &ino_req);\n\tif (err) {\n\t\tubifs_release_budget(c, &req);\n\t\treturn err;\n\t}\n\n\tlock_3_inodes(old_dir, new_dir, new_inode);\n\n\t/*\n\t * Like most other Unix systems, set the @i_ctime for inodes on a\n\t * rename.\n\t */\n\ttime = ubifs_current_time(old_dir);\n\told_inode->i_ctime = time;\n\n\t/* We must adjust parent link count when renaming directories */\n\tif (is_dir) {\n\t\tif (move) {\n\t\t\t/*\n\t\t\t * @old_dir loses a link because we are moving\n\t\t\t * @old_inode to a different directory.\n\t\t\t */\n\t\t\tdrop_nlink(old_dir);\n\t\t\t/*\n\t\t\t * @new_dir only gains a link if we are not also\n\t\t\t * overwriting an existing directory.\n\t\t\t */\n\t\t\tif (!unlink)\n\t\t\t\tinc_nlink(new_dir);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @old_inode is not moving to a different directory,\n\t\t\t * but @old_dir still loses a link if we are\n\t\t\t * overwriting an existing directory.\n\t\t\t */\n\t\t\tif (unlink)\n\t\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t}\n\n\told_dir->i_size -= old_sz;\n\tubifs_inode(old_dir)->ui_size = old_dir->i_size;\n\told_dir->i_mtime = old_dir->i_ctime = time;\n\tnew_dir->i_mtime = new_dir->i_ctime = time;\n\n\t/*\n\t * And finally, if we unlinked a direntry which happened to have the\n\t * same name as the moved direntry, we have to decrement @i_nlink of\n\t * the unlinked inode and change its ctime.\n\t */\n\tif (unlink) {\n\t\t/*\n\t\t * Directories cannot have hard-links, so if this is a\n\t\t * directory, just clear @i_nlink.\n\t\t */\n\t\tsaved_nlink = new_inode->i_nlink;\n\t\tif (is_dir)\n\t\t\tclear_nlink(new_inode);\n\t\telse\n\t\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = time;\n\t} else {\n\t\tnew_dir->i_size += new_sz;\n\t\tubifs_inode(new_dir)->ui_size = new_dir->i_size;\n\t}\n\n\t/*\n\t * Do not ask 'ubifs_jnl_rename()' to flush write-buffer if @old_inode\n\t * is dirty, because this will be done later on at the end of\n\t * 'ubifs_rename()'.\n\t */\n\tif (IS_SYNC(old_inode)) {\n\t\tsync = IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir);\n\t\tif (unlink && IS_SYNC(new_inode))\n\t\t\tsync = 1;\n\t}\n\terr = ubifs_jnl_rename(c, old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t       sync);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tunlock_3_inodes(old_dir, new_dir, new_inode);\n\tubifs_release_budget(c, &req);\n\n\tmutex_lock(&old_inode_ui->ui_mutex);\n\trelease = old_inode_ui->dirty;\n\tmark_inode_dirty_sync(old_inode);\n\tmutex_unlock(&old_inode_ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &ino_req);\n\tif (IS_SYNC(old_inode))\n\t\terr = old_inode->i_sb->s_op->write_inode(old_inode, NULL);\n\treturn err;\n\nout_cancel:\n\tif (unlink) {\n\t\tset_nlink(new_inode, saved_nlink);\n\t} else {\n\t\tnew_dir->i_size -= new_sz;\n\t\tubifs_inode(new_dir)->ui_size = new_dir->i_size;\n\t}\n\told_dir->i_size += old_sz;\n\tubifs_inode(old_dir)->ui_size = old_dir->i_size;\n\tif (is_dir) {\n\t\tif (move) {\n\t\t\tinc_nlink(old_dir);\n\t\t\tif (!unlink)\n\t\t\t\tdrop_nlink(new_dir);\n\t\t} else {\n\t\t\tif (unlink)\n\t\t\t\tinc_nlink(old_dir);\n\t\t}\n\t}\n\tunlock_3_inodes(old_dir, new_dir, new_inode);\n\tubifs_release_budget(c, &ino_req);\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nint ubifs_g",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n er"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &ino_req)",
          "args": [
            "bifs_rel"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(old_dir, new",
          "args": [
            "dir, ne",
            "inode);",
            "ubifs_rel"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dir);",
          "args": [
            "}\n\tun"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w_dir);",
          "args": [
            "else {"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dir);",
          "args": [
            "if (!un"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_dir)->ui",
          "args": [
            "size ="
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_dir)->ui",
          "args": [
            "size ="
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_inode, s",
          "args": [
            "ved_nlink",
            "} else {"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->write_inode",
          "args": [
            "LL);\n\tret",
            "n er"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "340-351",
          "snippet": "static int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node))",
          "args": [
            "err = ol"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &ino_req)",
          "args": [
            "f (IS_SY"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&old_inode_u",
          "args": [
            "->ui_mutex);\n\n\tif (rele"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_sync(old_inode);",
          "args": [
            "mutex_unl"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_inode_u",
          "args": [
            "->ui_mutex);\n\trelease ="
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);",
          "args": [
            "u",
            "x_lo"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(old_dir, new",
          "args": [
            "dir, ne",
            "inode);",
            "ubifs_rel"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame(c, old_dir,",
          "args": [
            "l",
            "dentry,",
            "ew_dir, ne",
            "dentry,",
            "s",
            "rr)"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node))",
          "args": [
            "sync ="
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w_dir);",
          "args": [
            "f (unli"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_dir) ||",
          "args": [
            "S_DIRSY"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node))",
          "args": [
            "sync ="
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_dir)->ui",
          "args": [
            "size ="
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w_inode);",
          "args": [
            "new_inod"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_inode);",
          "args": [
            "else"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_dir)->ui",
          "args": [
            "size ="
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_dir);",
          "args": [
            "}\n\n\to"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dir);",
          "args": [
            "else {"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_dir);",
          "args": [
            "/*"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(old_dir);\n\to",
          "args": [
            "d_inode"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(old_dir, new",
          "args": [
            "dir, ne",
            "inode);",
            "/*\n\t * L"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);",
          "args": [
            "e",
            "rn e"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &ino_req)",
          "args": [
            "f (err)"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty(c, new_inode",
          "args": [
            ";",
            "if (err)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&new_inode->i_mutex));\n\n\n\tif (unl"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&new_inode->",
          "args": [
            "_mutex));\n\n\n\tif (un"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&new_dir->i_mutex));\n\tif (unlin"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&new_dir->i_",
          "args": [
            "utex));\n\tif (unli"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&old_dir->i_mutex));\n\tubifs_ass"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&old_dir->i_",
          "args": [
            "utex));\n\tubifs_as"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'%pd'",
          "args": [
            "no %lu in dir ino %lu to dent '%pd' in dir ino %lu\",\n\t\told_dentr",
            "ld_inode->",
            "ino, old_dir->i_",
            "o,\n\t\tnew_dentr",
            "ew_dir->i_",
            "o);\n\tubifs_ass"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_ui",
          "args": [
            ">data_len, 8) };\n\tstru"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(old_dentry->",
          "args": [
            "_name.len);\n\tstruct ub"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(new_dentry->",
          "args": [
            "_name.len);\n\tint old_s"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i",
          "args": [
            "mode);\n\tint unlin"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_inode);",
          "args": [
            "int err,"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct ubifs_info *c = old_dir->i_sb->s_fs_info;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct ubifs_inode *old_inode_ui = ubifs_inode(old_inode);\n\tint err, release, sync = 0, move = (new_dir != old_dir);\n\tint is_dir = S_ISDIR(old_inode->i_mode);\n\tint unlink = !!new_inode;\n\tint new_sz = CALC_DENT_SIZE(new_dentry->d_name.len);\n\tint old_sz = CALC_DENT_SIZE(old_dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_dent = 1, .mod_dent = 1,\n\t\t\t\t\t.dirtied_ino = 3 };\n\tstruct ubifs_budget_req ino_req = { .dirtied_ino = 1,\n\t\t\t.dirtied_ino_d = ALIGN(old_inode_ui->data_len, 8) };\n\tstruct timespec time;\n\tunsigned int uninitialized_var(saved_nlink);\n\n\t/*\n\t * Budget request settings: deletion direntry, new direntry, removing\n\t * the old inode, and changing old and new parent directory inodes.\n\t *\n\t * However, this operation also marks the target inode as dirty and\n\t * does not write it, so we allocate budget for the target inode\n\t * separately.\n\t */\n\n\tdbg_gen(\"dent '%pd' ino %lu in dir ino %lu to dent '%pd' in dir ino %lu\",\n\t\told_dentry, old_inode->i_ino, old_dir->i_ino,\n\t\tnew_dentry, new_dir->i_ino);\n\tubifs_assert(mutex_is_locked(&old_dir->i_mutex));\n\tubifs_assert(mutex_is_locked(&new_dir->i_mutex));\n\tif (unlink)\n\t\tubifs_assert(mutex_is_locked(&new_inode->i_mutex));\n\n\n\tif (unlink && is_dir) {\n\t\terr = check_dir_empty(c, new_inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\terr = ubifs_budget_space(c, &ino_req);\n\tif (err) {\n\t\tubifs_release_budget(c, &req);\n\t\treturn err;\n\t}\n\n\tlock_3_inodes(old_dir, new_dir, new_inode);\n\n\t/*\n\t * Like most other Unix systems, set the @i_ctime for inodes on a\n\t * rename.\n\t */\n\ttime = ubifs_current_time(old_dir);\n\told_inode->i_ctime = time;\n\n\t/* We must adjust parent link count when renaming directories */\n\tif (is_dir) {\n\t\tif (move) {\n\t\t\t/*\n\t\t\t * @old_dir loses a link because we are moving\n\t\t\t * @old_inode to a different directory.\n\t\t\t */\n\t\t\tdrop_nlink(old_dir);\n\t\t\t/*\n\t\t\t * @new_dir only gains a link if we are not also\n\t\t\t * overwriting an existing directory.\n\t\t\t */\n\t\t\tif (!unlink)\n\t\t\t\tinc_nlink(new_dir);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @old_inode is not moving to a different directory,\n\t\t\t * but @old_dir still loses a link if we are\n\t\t\t * overwriting an existing directory.\n\t\t\t */\n\t\t\tif (unlink)\n\t\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t}\n\n\told_dir->i_size -= old_sz;\n\tubifs_inode(old_dir)->ui_size = old_dir->i_size;\n\told_dir->i_mtime = old_dir->i_ctime = time;\n\tnew_dir->i_mtime = new_dir->i_ctime = time;\n\n\t/*\n\t * And finally, if we unlinked a direntry which happened to have the\n\t * same name as the moved direntry, we have to decrement @i_nlink of\n\t * the unlinked inode and change its ctime.\n\t */\n\tif (unlink) {\n\t\t/*\n\t\t * Directories cannot have hard-links, so if this is a\n\t\t * directory, just clear @i_nlink.\n\t\t */\n\t\tsaved_nlink = new_inode->i_nlink;\n\t\tif (is_dir)\n\t\t\tclear_nlink(new_inode);\n\t\telse\n\t\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = time;\n\t} else {\n\t\tnew_dir->i_size += new_sz;\n\t\tubifs_inode(new_dir)->ui_size = new_dir->i_size;\n\t}\n\n\t/*\n\t * Do not ask 'ubifs_jnl_rename()' to flush write-buffer if @old_inode\n\t * is dirty, because this will be done later on at the end of\n\t * 'ubifs_rename()'.\n\t */\n\tif (IS_SYNC(old_inode)) {\n\t\tsync = IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir);\n\t\tif (unlink && IS_SYNC(new_inode))\n\t\t\tsync = 1;\n\t}\n\terr = ubifs_jnl_rename(c, old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t       sync);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tunlock_3_inodes(old_dir, new_dir, new_inode);\n\tubifs_release_budget(c, &req);\n\n\tmutex_lock(&old_inode_ui->ui_mutex);\n\trelease = old_inode_ui->dirty;\n\tmark_inode_dirty_sync(old_inode);\n\tmutex_unlock(&old_inode_ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &ino_req);\n\tif (IS_SYNC(old_inode))\n\t\terr = old_inode->i_sb->s_op->write_inode(old_inode, NULL);\n\treturn err;\n\nout_cancel:\n\tif (unlink) {\n\t\tset_nlink(new_inode, saved_nlink);\n\t} else {\n\t\tnew_dir->i_size -= new_sz;\n\t\tubifs_inode(new_dir)->ui_size = new_dir->i_size;\n\t}\n\told_dir->i_size += old_sz;\n\tubifs_inode(old_dir)->ui_size = old_dir->i_size;\n\tif (is_dir) {\n\t\tif (move) {\n\t\t\tinc_nlink(old_dir);\n\t\t\tif (!unlink)\n\t\t\t\tdrop_nlink(new_dir);\n\t\t} else {\n\t\t\tif (unlink)\n\t\t\t\tinc_nlink(old_dir);\n\t\t}\n\t}\n\tunlock_3_inodes(old_dir, new_dir, new_inode);\n\tubifs_release_budget(c, &ino_req);\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nint ubifs_g"
  },
  {
    "function_name": "es(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "956-964",
    "snippet": "nlock_3_inodes(struct inode *inode1, struct inode *inode2,\n\t\t\t    struct inode *inode3)\n{\n\tif (inode3)\n\t\tmutex_unlock(&ubifs_inode(inode3)->ui_mutex);\n\tif (inode1 != inode2)\n\t\tmutex_unlock(&ubifs_inode(inode2)->ui_mutex);\n\tmutex_unlock(&ubifs_inode(inode1)->ui_mutex);\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&ubifs_inode",
          "args": [
            "inode1)->ui_mutex);\n}\n\nstatic"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node1)->ui_",
          "args": [
            "utex);"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ubifs_inode",
          "args": [
            "inode2)->ui_mutex);\n\tmutex_unl"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node2)->ui_",
          "args": [
            "utex);"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ubifs_inode",
          "args": [
            "inode3)->ui_mutex);\n\tif (inode"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node3)->ui_",
          "args": [
            "utex);"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nnlock_3_inodes(struct inode *inode1, struct inode *inode2,\n\t\t\t    struct inode *inode3)\n{\n\tif (inode3)\n\t\tmutex_unlock(&ubifs_inode(inode3)->ui_mutex);\n\tif (inode1 != inode2)\n\t\tmutex_unlock(&ubifs_inode(inode2)->ui_mutex);\n\tmutex_unlock(&ubifs_inode(inode1)->ui_mutex);\n}\n\nstatic int"
  },
  {
    "function_name": "(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "940-948",
    "snippet": "ock_3_inodes(struct inode *inode1, struct inode *inode2,\n\t\t\t  struct inode *inode3)\n{\n\tmutex_lock_nested(&ubifs_inode(inode1)->ui_mutex, WB_MUTEX_1);\n\tif (inode2 != inode1)\n\t\tmutex_lock_nested(&ubifs_inode(inode2)->ui_mutex, WB_MUTEX_2);\n\tif (inode3)\n\t\tmutex_lock_nested(&ubifs_inode(inode3)->ui_mutex, WB_MUTEX_3);\n}\n\n/**\n * unlo",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sted(&ubifs_inode",
          "args": [
            "inode3)->ui_mutex, WB_MUTEX_3)",
            "}\n\n/**\n *"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node3)->ui_",
          "args": [
            "utex,"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&ubifs_inode",
          "args": [
            "inode2)->ui_mutex, WB_MUTEX_2)",
            "if (inode"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node2)->ui_",
          "args": [
            "utex,"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&ubifs_inode",
          "args": [
            "inode1)->ui_mutex, WB_MUTEX_1)",
            "if (inode"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node1)->ui_",
          "args": [
            "utex,"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nock_3_inodes(struct inode *inode1, struct inode *inode2,\n\t\t\t  struct inode *inode3)\n{\n\tmutex_lock_nested(&ubifs_inode(inode1)->ui_mutex, WB_MUTEX_1);\n\tif (inode2 != inode1)\n\t\tmutex_lock_nested(&ubifs_inode(inode2)->ui_mutex, WB_MUTEX_2);\n\tif (inode3)\n\t\tmutex_lock_nested(&ubifs_inode(inode3)->ui_mutex, WB_MUTEX_3);\n}\n\n/**\n * unlo"
  },
  {
    "function_name": "(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "846-925",
    "snippet": "ifs_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t const char *symname)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tint err, len = strlen(symname);\n\tint sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.new_ino_d = ALIGN(len, 8),\n\t\t\t\t\t.dirtied_ino = 1 };\n\n\t/*\n\t * Budget request settings: new inode, new direntry and changing parent\n\t * directory inode.\n\t */\n\n\tdbg_gen(\"dent '%pd', target '%s' in dir ino %lu\", dentry,\n\t\tsymname, dir->i_ino);\n\n\tif (len > UBIFS_MAX_INO_DATA)\n\t\treturn -ENAMETOOLONG;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tinode = ubifs_new_inode(c, dir, S_IFLNK | S_IRWXUGO);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\tui = ubifs_inode(inode);\n\tui->data = kmalloc(len + 1, GFP_NOFS);\n\tif (!ui->data) {\n\t\terr = -ENOMEM;\n\t\tgoto out_inode;\n\t}\n\n\tmemcpy(ui->data, symname, len);\n\t((char *)ui->data)[len] = '\\0';\n\t/*\n\t * The terminating zero byte is not written to the flash media and it\n\t * is put just to make later in-memory string processing simpler. Thus,\n\t * data length is @len, not @len + %1.\n\t */\n\tui->data_len = len;\n\tinode->i_size = ubifs_inode(inode)->ui_size = len;\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tmutex_unlock(&dir_ui->ui_mutex);\nout_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\n/**\n * lock",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n er"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_",
          "args": [
            "udg:"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "load_aout_library",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_aout.c",
          "lines": "337-408",
          "snippet": "static int load_aout_library(struct file *file)\n{\n\tstruct inode * inode;\n\tunsigned long bss, start_addr, len;\n\tunsigned long error;\n\tint retval;\n\tstruct exec ex;\n\n\tinode = file_inode(file);\n\n\tretval = -ENOEXEC;\n\terror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\n\tif (error != sizeof(ex))\n\t\tgoto out;\n\n\t/* We come in here for the regular a.out style of shared libraries */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\n\t    N_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\n\t    i_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!file->f_op->mmap)\n\t\tgoto out;\n\n\tif (N_FLAGS(ex))\n\t\tgoto out;\n\n\t/* For  QMAGIC, the starting address is 0x20 into the page.  We mask\n\t   this off to get the starting address for the page */\n\n\tstart_addr =  ex.a_entry & 0xfffff000;\n\n\tif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\n\t\tif (printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\",\n\t\t\t       file);\n\t\t}\n\t\tvm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\n\t\t\n\t\tread_code(file, start_addr, N_TXTOFF(ex),\n\t\t\t  ex.a_text + ex.a_data);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\tN_TXTOFF(ex));\n\tretval = error;\n\tif (error != start_addr)\n\t\tgoto out;\n\n\tlen = PAGE_ALIGN(ex.a_text + ex.a_data);\n\tbss = ex.a_text + ex.a_data + ex.a_bss;\n\tif (bss > len) {\n\t\terror = vm_brk(start_addr + len, bss - len);\n\t\tretval = error;\n\t\tif (error != start_addr + len)\n\t\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <asm/a.out-core.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/coredump.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/a.out.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int load_aout_library(struct file*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_aout_library(struct file*);\n\nstatic int load_aout_library(struct file *file)\n{\n\tstruct inode * inode;\n\tunsigned long bss, start_addr, len;\n\tunsigned long error;\n\tint retval;\n\tstruct exec ex;\n\n\tinode = file_inode(file);\n\n\tretval = -ENOEXEC;\n\terror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\n\tif (error != sizeof(ex))\n\t\tgoto out;\n\n\t/* We come in here for the regular a.out style of shared libraries */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\n\t    N_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\n\t    i_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!file->f_op->mmap)\n\t\tgoto out;\n\n\tif (N_FLAGS(ex))\n\t\tgoto out;\n\n\t/* For  QMAGIC, the starting address is 0x20 into the page.  We mask\n\t   this off to get the starting address for the page */\n\n\tstart_addr =  ex.a_entry & 0xfffff000;\n\n\tif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\n\t\tif (printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\",\n\t\t\t       file);\n\t\t}\n\t\tvm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\n\t\t\n\t\tread_code(file, start_addr, N_TXTOFF(ex),\n\t\t\t  ex.a_text + ex.a_data);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\tN_TXTOFF(ex));\n\tretval = error;\n\tif (error != start_addr)\n\t\tgoto out;\n\n\tlen = PAGE_ALIGN(ex.a_text + ex.a_data);\n\tbss = ex.a_text + ex.a_data + ex.a_bss;\n\tif (bss > len) {\n\t\terror = vm_brk(start_addr + len, bss - len);\n\t\tretval = error;\n\t\tif (error != start_addr + len)\n\t\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e(inode);\n\tipu",
          "args": [
            "(inod"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&dir_ui->ui_",
          "args": [
            "utex);\nout_inode:"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dentry, inod",
          "args": [
            ");\n\tre",
            "rn 0;"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash(inode);\n\td_i",
          "args": [
            "stant"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\ti",
          "args": [
            "s",
            "t_in"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&dir_ui->ui_",
          "args": [
            "utex);\n\n\tubifs_re"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(c, dir, &den",
          "args": [
            "r",
            ">d_",
            "me, inode, 0, 0",
            "if",
            "r"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir_ui->ui_",
          "args": [
            "utex);\n\tdir->i_si"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curity(dir, inode,",
          "args": [
            "den",
            "y->d_",
            "me);\n\tif (err)"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node)->ui_s",
          "args": [
            "ze ="
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ta, sy",
          "args": [
            "name, le",
            ";\n\t((ch",
            "*)"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1, GFP",
          "args": [
            "NOFS);",
            "f (!ui->"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tui-",
          "args": [
            "data"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "rr ="
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, dir, S_IF",
          "args": [
            "N",
            "| S",
            "RWXUGO);\n\tif (IS_ER"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'%pd',",
          "args": [
            "target '%s' in dir ino %lu\", dentry,\n\t\ts",
            "name,",
            ">i_ino)",
            "if (len"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ",",
          "args": [
            ".d",
            "t"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "void *buf, i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
          "lines": "81-90",
          "snippet": "rst_non_ff(void *buf, int len)\n{\n\tuint8_t *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (*p++ != 0xff)\n\t\t\treturn i;\n\treturn -1;\n}\n\n/**\n * get_",
          "includes": [
            "fs.h\"\n\n/**\n * is_em",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nrst_non_ff(void *buf, int len)\n{\n\tuint8_t *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (*p++ != 0xff)\n\t\t\treturn i;\n\treturn -1;\n}\n\n/**\n * get_"
        }
      },
      {
        "call_info": {
          "callee": "E(dentry->d_na",
          "args": [
            "e.len);\n\tstruct ub"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);\n\ti",
          "args": [
            "t sz_ch"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir);\n\tstruc",
          "args": [
            "ub"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t const char *symname)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tint err, len = strlen(symname);\n\tint sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.new_ino_d = ALIGN(len, 8),\n\t\t\t\t\t.dirtied_ino = 1 };\n\n\t/*\n\t * Budget request settings: new inode, new direntry and changing parent\n\t * directory inode.\n\t */\n\n\tdbg_gen(\"dent '%pd', target '%s' in dir ino %lu\", dentry,\n\t\tsymname, dir->i_ino);\n\n\tif (len > UBIFS_MAX_INO_DATA)\n\t\treturn -ENAMETOOLONG;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tinode = ubifs_new_inode(c, dir, S_IFLNK | S_IRWXUGO);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\tui = ubifs_inode(inode);\n\tui->data = kmalloc(len + 1, GFP_NOFS);\n\tif (!ui->data) {\n\t\terr = -ENOMEM;\n\t\tgoto out_inode;\n\t}\n\n\tmemcpy(ui->data, symname, len);\n\t((char *)ui->data)[len] = '\\0';\n\t/*\n\t * The terminating zero byte is not written to the flash media and it\n\t * is put just to make later in-memory string processing simpler. Thus,\n\t * data length is @len, not @len + %1.\n\t */\n\tui->data_len = len;\n\tinode->i_size = ubifs_inode(inode)->ui_size = len;\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tmutex_unlock(&dir_ui->ui_mutex);\nout_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\n/**\n * lock"
  },
  {
    "function_name": "truct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "767-844",
    "snippet": "ifs_mknod(struct inode *dir, struct dentry *dentry,\n\t\t       umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tunion ubifs_dev_desc *dev = NULL;\n\tint sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tint err, devlen = 0;\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.new_ino_d = ALIGN(devlen, 8),\n\t\t\t\t\t.dirtied_ino = 1 };\n\n\t/*\n\t * Budget request settings: new inode, new direntry and changing parent\n\t * directory inode.\n\t */\n\n\tdbg_gen(\"dent '%pd' in dir ino %lu\", dentry, dir->i_ino);\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\tdev = kmalloc(sizeof(union ubifs_dev_desc), GFP_NOFS);\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\t\tdevlen = ubifs_encode_dev(dev, rdev);\n\t}\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tkfree(dev);\n\t\treturn err;\n\t}\n\n\tinode = ubifs_new_inode(c, dir, mode);\n\tif (IS_ERR(inode)) {\n\t\tkfree(dev);\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\tinode->i_size = ubifs_inode(inode)->ui_size = devlen;\n\tui = ubifs_inode(inode);\n\tui->data = dev;\n\tui->data_len = devlen;\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n er"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_",
          "args": [
            "udg:"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "load_aout_library",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_aout.c",
          "lines": "337-408",
          "snippet": "static int load_aout_library(struct file *file)\n{\n\tstruct inode * inode;\n\tunsigned long bss, start_addr, len;\n\tunsigned long error;\n\tint retval;\n\tstruct exec ex;\n\n\tinode = file_inode(file);\n\n\tretval = -ENOEXEC;\n\terror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\n\tif (error != sizeof(ex))\n\t\tgoto out;\n\n\t/* We come in here for the regular a.out style of shared libraries */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\n\t    N_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\n\t    i_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!file->f_op->mmap)\n\t\tgoto out;\n\n\tif (N_FLAGS(ex))\n\t\tgoto out;\n\n\t/* For  QMAGIC, the starting address is 0x20 into the page.  We mask\n\t   this off to get the starting address for the page */\n\n\tstart_addr =  ex.a_entry & 0xfffff000;\n\n\tif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\n\t\tif (printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\",\n\t\t\t       file);\n\t\t}\n\t\tvm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\n\t\t\n\t\tread_code(file, start_addr, N_TXTOFF(ex),\n\t\t\t  ex.a_text + ex.a_data);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\tN_TXTOFF(ex));\n\tretval = error;\n\tif (error != start_addr)\n\t\tgoto out;\n\n\tlen = PAGE_ALIGN(ex.a_text + ex.a_data);\n\tbss = ex.a_text + ex.a_data + ex.a_bss;\n\tif (bss > len) {\n\t\terror = vm_brk(start_addr + len, bss - len);\n\t\tretval = error;\n\t\tif (error != start_addr + len)\n\t\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <asm/a.out-core.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/coredump.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/a.out.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int load_aout_library(struct file*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_aout_library(struct file*);\n\nstatic int load_aout_library(struct file *file)\n{\n\tstruct inode * inode;\n\tunsigned long bss, start_addr, len;\n\tunsigned long error;\n\tint retval;\n\tstruct exec ex;\n\n\tinode = file_inode(file);\n\n\tretval = -ENOEXEC;\n\terror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\n\tif (error != sizeof(ex))\n\t\tgoto out;\n\n\t/* We come in here for the regular a.out style of shared libraries */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\n\t    N_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\n\t    i_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!file->f_op->mmap)\n\t\tgoto out;\n\n\tif (N_FLAGS(ex))\n\t\tgoto out;\n\n\t/* For  QMAGIC, the starting address is 0x20 into the page.  We mask\n\t   this off to get the starting address for the page */\n\n\tstart_addr =  ex.a_entry & 0xfffff000;\n\n\tif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\n\t\tif (printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\",\n\t\t\t       file);\n\t\t}\n\t\tvm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\n\t\t\n\t\tread_code(file, start_addr, N_TXTOFF(ex),\n\t\t\t  ex.a_text + ex.a_data);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\tN_TXTOFF(ex));\n\tretval = error;\n\tif (error != start_addr)\n\t\tgoto out;\n\n\tlen = PAGE_ALIGN(ex.a_text + ex.a_data);\n\tbss = ex.a_text + ex.a_data + ex.a_bss;\n\tif (bss > len) {\n\t\terror = vm_brk(start_addr + len, bss - len);\n\t\tretval = error;\n\t\tif (error != start_addr + len)\n\t\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e(inode);\n\tipu",
          "args": [
            "(inod"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&dir_ui->ui_",
          "args": [
            "utex);\n\tmake_bad_"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dentry, inod",
          "args": [
            ");\n\tre",
            "rn 0;"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash(inode);\n\td_i",
          "args": [
            "stant"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\ti",
          "args": [
            "s",
            "t_in"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&dir_ui->ui_",
          "args": [
            "utex);\n\n\tubifs_re"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(c, dir, &den",
          "args": [
            "r",
            ">d_",
            "me, inode, 0, 0",
            "if",
            "r"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir_ui->ui_",
          "args": [
            "utex);\n\tdir->i_si"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curity(dir, inode,",
          "args": [
            "den",
            "y->d_",
            "me);\n\tif (err)"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tui-",
          "args": [
            "data"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node)->ui_s",
          "args": [
            "ze ="
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode(inode, inode",
          "args": [
            ">i_mo",
            ", rdev);\n\tino",
            "->i_"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "PT"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "free("
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, dir, mode",
          "args": [
            ";",
            "if",
            "S_ER"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n e"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev(dev, rdev);",
          "args": [
            "}",
            "rr ="
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(union",
          "args": [
            "ubifs_dev_desc), GFP_NOFS);",
            "if (!dev"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {\n\t\td",
          "args": [
            "v ="
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "|| S_I",
          "args": [
            "CHR("
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(rdev))\n\t\tret",
          "args": [
            "rn -"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'%pd'",
          "args": [
            "n dir ino %lu\", dentry, dir",
            "i_ino)",
            "if (!new"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "8),",
          "args": [
            ".d",
            "t"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(dentry->d_na",
          "args": [
            "e.len);\n\tint err,"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir);\n\tstruc",
          "args": [
            "ub"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_mknod(struct inode *dir, struct dentry *dentry,\n\t\t       umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tunion ubifs_dev_desc *dev = NULL;\n\tint sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tint err, devlen = 0;\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.new_ino_d = ALIGN(devlen, 8),\n\t\t\t\t\t.dirtied_ino = 1 };\n\n\t/*\n\t * Budget request settings: new inode, new direntry and changing parent\n\t * directory inode.\n\t */\n\n\tdbg_gen(\"dent '%pd' in dir ino %lu\", dentry, dir->i_ino);\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\tdev = kmalloc(sizeof(union ubifs_dev_desc), GFP_NOFS);\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\t\tdevlen = ubifs_encode_dev(dev, rdev);\n\t}\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tkfree(dev);\n\t\treturn err;\n\t}\n\n\tinode = ubifs_new_inode(c, dir, mode);\n\tif (IS_ERR(inode)) {\n\t\tkfree(dev);\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\tinode->i_size = ubifs_inode(inode)->ui_size = devlen;\n\tui = ubifs_inode(inode);\n\tui->data = dev;\n\tui->data_len = devlen;\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic int"
  },
  {
    "function_name": "truct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "707-765",
    "snippet": "ifs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tint err, sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1 };\n\n\t/*\n\t * Budget request settings: new inode, new direntry and changing parent\n\t * directory inode.\n\t */\n\n\tdbg_gen(\"dent '%pd', mode %#hx in dir ino %lu\",\n\t\tdentry, mode, dir->i_ino);\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tinode = ubifs_new_inode(c, dir, S_IFDIR | mode);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tinsert_inode_hash(inode);\n\tinc_nlink(inode);\n\tinc_nlink(dir);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 0, 0);\n\tif (err) {\n\t\tubifs_err(\"cannot create directory, error %d\", err);\n\t\tgoto out_cancel;\n\t}\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdrop_nlink(dir);\n\tmutex_unlock(&dir_ui->ui_mutex);\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n er"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_",
          "args": [
            "udg:"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "load_aout_library",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_aout.c",
          "lines": "337-408",
          "snippet": "static int load_aout_library(struct file *file)\n{\n\tstruct inode * inode;\n\tunsigned long bss, start_addr, len;\n\tunsigned long error;\n\tint retval;\n\tstruct exec ex;\n\n\tinode = file_inode(file);\n\n\tretval = -ENOEXEC;\n\terror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\n\tif (error != sizeof(ex))\n\t\tgoto out;\n\n\t/* We come in here for the regular a.out style of shared libraries */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\n\t    N_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\n\t    i_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!file->f_op->mmap)\n\t\tgoto out;\n\n\tif (N_FLAGS(ex))\n\t\tgoto out;\n\n\t/* For  QMAGIC, the starting address is 0x20 into the page.  We mask\n\t   this off to get the starting address for the page */\n\n\tstart_addr =  ex.a_entry & 0xfffff000;\n\n\tif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\n\t\tif (printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\",\n\t\t\t       file);\n\t\t}\n\t\tvm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\n\t\t\n\t\tread_code(file, start_addr, N_TXTOFF(ex),\n\t\t\t  ex.a_text + ex.a_data);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\tN_TXTOFF(ex));\n\tretval = error;\n\tif (error != start_addr)\n\t\tgoto out;\n\n\tlen = PAGE_ALIGN(ex.a_text + ex.a_data);\n\tbss = ex.a_text + ex.a_data + ex.a_bss;\n\tif (bss > len) {\n\t\terror = vm_brk(start_addr + len, bss - len);\n\t\tretval = error;\n\t\tif (error != start_addr + len)\n\t\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <asm/a.out-core.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/coredump.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/a.out.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int load_aout_library(struct file*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_aout_library(struct file*);\n\nstatic int load_aout_library(struct file *file)\n{\n\tstruct inode * inode;\n\tunsigned long bss, start_addr, len;\n\tunsigned long error;\n\tint retval;\n\tstruct exec ex;\n\n\tinode = file_inode(file);\n\n\tretval = -ENOEXEC;\n\terror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\n\tif (error != sizeof(ex))\n\t\tgoto out;\n\n\t/* We come in here for the regular a.out style of shared libraries */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\n\t    N_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\n\t    i_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!file->f_op->mmap)\n\t\tgoto out;\n\n\tif (N_FLAGS(ex))\n\t\tgoto out;\n\n\t/* For  QMAGIC, the starting address is 0x20 into the page.  We mask\n\t   this off to get the starting address for the page */\n\n\tstart_addr =  ex.a_entry & 0xfffff000;\n\n\tif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\n\t\tif (printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\",\n\t\t\t       file);\n\t\t}\n\t\tvm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\n\t\t\n\t\tread_code(file, start_addr, N_TXTOFF(ex),\n\t\t\t  ex.a_text + ex.a_data);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\tN_TXTOFF(ex));\n\tretval = error;\n\tif (error != start_addr)\n\t\tgoto out;\n\n\tlen = PAGE_ALIGN(ex.a_text + ex.a_data);\n\tbss = ex.a_text + ex.a_data + ex.a_bss;\n\tif (bss > len) {\n\t\terror = vm_brk(start_addr + len, bss - len);\n\t\tretval = error;\n\t\tif (error != start_addr + len)\n\t\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e(inode);\n\tipu",
          "args": [
            "(inod"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&dir_ui->ui_",
          "args": [
            "utex);\n\tmake_bad_"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r);\n\tmutex",
          "args": [
            "unl"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dentry, inod",
          "args": [
            ");\n\tre",
            "rn 0;"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\td",
          "args": [
            "i",
            "tant"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&dir_ui->ui_",
          "args": [
            "utex);\n\n\tubifs_re"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot crea",
          "args": [
            "e directory, error %d\", err);\n\t\tgot",
            "out"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(c, dir, &den",
          "args": [
            "r",
            ">d_",
            "me, inode, 0, 0",
            "if",
            "r"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tdir->",
          "args": [
            "_si"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de);\n\tinc",
          "args": [
            "nlink"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash(inode);\n\tinc",
          "args": [
            "nlink"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir_ui->ui_",
          "args": [
            "utex);\n\tinsert_in"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curity(dir, inode,",
          "args": [
            "den",
            "y->d_",
            "me);\n\tif (err)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "rr ="
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, dir, S_IF",
          "args": [
            "I",
            "| m",
            "e);\n\tif (IS_ER"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'%pd',",
          "args": [
            "mode %#hx in dir ino %lu\",\n\t\tdentry, m",
            "dir->",
            "ino)",
            "err = ub"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(dentry->d_na",
          "args": [
            "e.len);\n\tstruct ub"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir);\n\tstruc",
          "args": [
            "ub"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tint err, sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1 };\n\n\t/*\n\t * Budget request settings: new inode, new direntry and changing parent\n\t * directory inode.\n\t */\n\n\tdbg_gen(\"dent '%pd', mode %#hx in dir ino %lu\",\n\t\tdentry, mode, dir->i_ino);\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tinode = ubifs_new_inode(c, dir, S_IFDIR | mode);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tinsert_inode_hash(inode);\n\tinc_nlink(inode);\n\tinc_nlink(dir);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 0, 0);\n\tif (err) {\n\t\tubifs_err(\"cannot create directory, error %d\", err);\n\t\tgoto out_cancel;\n\t}\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdrop_nlink(dir);\n\tmutex_unlock(&dir_ui->ui_mutex);\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic int"
  },
  {
    "function_name": "truct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "645-705",
    "snippet": "ifs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = dentry->d_inode;\n\tint sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tint err, budgeted = 1;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_budget_req req = { .mod_dent = 1, .dirtied_ino = 2 };\n\n\t/*\n\t * Budget request settings: deletion direntry, deletion inode and\n\t * changing the parent inode. If budgeting fails, go ahead anyway\n\t * because we have extra space reserved for deletions.\n\t */\n\n\tdbg_gen(\"directory '%pd', ino %lu in dir ino %lu\", dentry,\n\t\tinode->i_ino, dir->i_ino);\n\tubifs_assert(mutex_is_locked(&dir->i_mutex));\n\tubifs_assert(mutex_is_locked(&inode->i_mutex));\n\terr = check_dir_empty(c, dentry->d_inode);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\t\tbudgeted = 0;\n\t}\n\n\tlock_2_inodes(dir, inode);\n\tinode->i_ctime = ubifs_current_time(dir);\n\tclear_nlink(inode);\n\tdrop_nlink(dir);\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 1, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\t/* We've deleted something - clean the \"no space\" flags */\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\treturn 0;\n\nout_cancel:\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tinc_nlink(dir);\n\tset_nlink(inode, 2);\n\tunlock_2_inodes(dir, inode);\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n er"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(dir, inode);",
          "args": [
            "if",
            "budge"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de, 2);",
          "args": [
            "nlock",
            "_"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tset_n",
          "args": [
            "ink"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retur",
          "args": [],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "coda_return_EIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "32-35",
          "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\te",
          "args": [
            "s",
            "{"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(dir, inode);",
          "args": [
            "i",
            "(budg"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(c, dir, &den",
          "args": [
            "r",
            ">d_",
            "me, inode, 1, 0",
            "if",
            "r"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r);\n\tdir->",
          "args": [
            "_si"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tdro",
          "args": [
            "_nlin"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(dir);\n\tclear",
          "args": [
            "nli"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dir, inode);",
          "args": [
            "in",
            "e->i_"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty(c, dentry->d",
          "args": [
            "i",
            "de);\n\tif (err)"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&inode->i_mutex));\n\terr = che"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&inode->i_mu",
          "args": [
            "ex));\n\terr = ch"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&dir->i_mutex));\n\tubifs_ass"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&dir->i_mute",
          "args": [
            "));\n\tubifs_as"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctory '",
          "args": [
            "pd', ino %lu in dir ino %lu\", dentry,\n\t\ti",
            "de->i_",
            "dir->i_ino)",
            "ubifs_ass"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir);\n\tstruc",
          "args": [
            "ub"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(dentry->d_na",
          "args": [
            "e.len);\n\tint err,"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = dentry->d_inode;\n\tint sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tint err, budgeted = 1;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_budget_req req = { .mod_dent = 1, .dirtied_ino = 2 };\n\n\t/*\n\t * Budget request settings: deletion direntry, deletion inode and\n\t * changing the parent inode. If budgeting fails, go ahead anyway\n\t * because we have extra space reserved for deletions.\n\t */\n\n\tdbg_gen(\"directory '%pd', ino %lu in dir ino %lu\", dentry,\n\t\tinode->i_ino, dir->i_ino);\n\tubifs_assert(mutex_is_locked(&dir->i_mutex));\n\tubifs_assert(mutex_is_locked(&inode->i_mutex));\n\terr = check_dir_empty(c, dentry->d_inode);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\t\tbudgeted = 0;\n\t}\n\n\tlock_2_inodes(dir, inode);\n\tinode->i_ctime = ubifs_current_time(dir);\n\tclear_nlink(inode);\n\tdrop_nlink(dir);\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 1, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\t/* We've deleted something - clean the \"no space\" flags */\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\treturn 0;\n\nout_cancel:\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tinc_nlink(dir);\n\tset_nlink(inode, 2);\n\tunlock_2_inodes(dir, inode);\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic int"
  },
  {
    "function_name": "ty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "625-643",
    "snippet": "eck_dir_empty(struct ubifs_info *c, struct inode *dir)\n{\n\tstruct qstr nm = { .name = NULL };\n\tstruct ubifs_dent_node *dent;\n\tunion ubifs_key key;\n\tint err;\n\n\tlowest_dent_key(c, &key, dir->i_ino);\n\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\tif (IS_ERR(dent)) {\n\t\terr = PTR_ERR(dent);\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t} else {\n\t\tkfree(dent);\n\t\terr = -ENOTEMPTY;\n\t}\n\treturn err;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err",
          "args": [
            "= -E"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": ";\n\t\tif",
          "args": [
            "err"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\t\te",
          "args": [
            "r ="
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_ent(c, &key, &nm",
          "args": [
            ";",
            "if (",
            "_ER"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey(c, &key, dir",
          "args": [
            ">",
            "ino)",
            "dent = ub"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\neck_dir_empty(struct ubifs_info *c, struct inode *dir)\n{\n\tstruct qstr nm = { .name = NULL };\n\tstruct ubifs_dent_node *dent;\n\tunion ubifs_key key;\n\tint err;\n\n\tlowest_dent_key(c, &key, dir->i_ino);\n\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\tif (IS_ERR(dent)) {\n\t\terr = PTR_ERR(dent);\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t} else {\n\t\tkfree(dent);\n\t\terr = -ENOTEMPTY;\n\t}\n\treturn err;\n}\n\nstatic int"
  },
  {
    "function_name": "struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "553-614",
    "snippet": "ifs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tint sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tint err, budgeted = 1;\n\tstruct ubifs_budget_req req = { .mod_dent = 1, .dirtied_ino = 2 };\n\tunsigned int saved_nlink = inode->i_nlink;\n\n\t/*\n\t * Budget request settings: deletion direntry, deletion inode (+1 for\n\t * @dirtied_ino), changing the parent directory inode. If budgeting\n\t * fails, go ahead anyway because we have extra space reserved for\n\t * deletions.\n\t */\n\n\tdbg_gen(\"dent '%pd' from ino %lu (nlink %d) in dir ino %lu\",\n\t\tdentry, inode->i_ino,\n\t\tinode->i_nlink, dir->i_ino);\n\tubifs_assert(mutex_is_locked(&dir->i_mutex));\n\tubifs_assert(mutex_is_locked(&inode->i_mutex));\n\terr = dbg_check_synced_i_size(c, inode);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\t\tbudgeted = 0;\n\t}\n\n\tlock_2_inodes(dir, inode);\n\tinode->i_ctime = ubifs_current_time(dir);\n\tdrop_nlink(inode);\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 1, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\t/* We've deleted something - clean the \"no space\" flags */\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\treturn 0;\n\nout_cancel:\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tset_nlink(inode, saved_nlink);\n\tunlock_2_inodes(dir, inode);\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\n/**\n * chec",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n er"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(dir, inode);",
          "args": [
            "if",
            "budge"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de, saved",
          "args": [
            "nlink",
            "unlock_2_"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retur",
          "args": [],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "coda_return_EIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "32-35",
          "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\te",
          "args": [
            "s",
            "{"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(dir, inode);",
          "args": [
            "i",
            "(budg"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(c, dir, &den",
          "args": [
            "r",
            ">d_",
            "me, inode, 1, 0",
            "if",
            "r"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode);\n\tdir",
          "args": [
            ">i_si"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(dir);\n\tdrop_",
          "args": [
            "lin"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dir, inode);",
          "args": [
            "in",
            "e->i_"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ced_i_size(c, inode);",
          "args": [
            "f",
            "err)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&inode->i_mutex));\n\terr = dbg"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&inode->i_mu",
          "args": [
            "ex));\n\terr = db"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&dir->i_mutex));\n\tubifs_ass"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&dir->i_mute",
          "args": [
            "));\n\tubifs_as"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'%pd'",
          "args": [
            "rom ino %lu (nlink %d) in dir ino %lu\",\n\t\tdentry, i",
            "->i_in",
            "inode->i_",
            "k, dir->i_ino)",
            "ubifs_ass"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(dentry->d_na",
          "args": [
            "e.len);\n\tint err,"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir);\n\tint s",
          "args": [
            "_ch"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tint sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tint err, budgeted = 1;\n\tstruct ubifs_budget_req req = { .mod_dent = 1, .dirtied_ino = 2 };\n\tunsigned int saved_nlink = inode->i_nlink;\n\n\t/*\n\t * Budget request settings: deletion direntry, deletion inode (+1 for\n\t * @dirtied_ino), changing the parent directory inode. If budgeting\n\t * fails, go ahead anyway because we have extra space reserved for\n\t * deletions.\n\t */\n\n\tdbg_gen(\"dent '%pd' from ino %lu (nlink %d) in dir ino %lu\",\n\t\tdentry, inode->i_ino,\n\t\tinode->i_nlink, dir->i_ino);\n\tubifs_assert(mutex_is_locked(&dir->i_mutex));\n\tubifs_assert(mutex_is_locked(&inode->i_mutex));\n\terr = dbg_check_synced_i_size(c, inode);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\t\tbudgeted = 0;\n\t}\n\n\tlock_2_inodes(dir, inode);\n\tinode->i_ctime = ubifs_current_time(dir);\n\tdrop_nlink(inode);\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 1, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\t/* We've deleted something - clean the \"no space\" flags */\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\treturn 0;\n\nout_cancel:\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tset_nlink(inode, saved_nlink);\n\tunlock_2_inodes(dir, inode);\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\n/**\n * chec"
  },
  {
    "function_name": "ruct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "497-551",
    "snippet": "ifs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t      struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tint err, sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_dent = 1, .dirtied_ino = 2,\n\t\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\n\t/*\n\t * Budget request settings: new direntry, changing the target inode,\n\t * changing the parent inode.\n\t */\n\n\tdbg_gen(\"dent '%pd' to ino %lu (nlink %d) in dir ino %lu\",\n\t\tdentry, inode->i_ino,\n\t\tinode->i_nlink, dir->i_ino);\n\tubifs_assert(mutex_is_locked(&dir->i_mutex));\n\tubifs_assert(mutex_is_locked(&inode->i_mutex));\n\n\terr = dbg_check_synced_i_size(c, inode);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tlock_2_inodes(dir, inode);\n\tinc_nlink(inode);\n\tihold(inode);\n\tinode->i_ctime = ubifs_current_time(inode);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tubifs_release_budget(c, &req);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdrop_nlink(inode);\n\tunlock_2_inodes(dir, inode);\n\tubifs_release_budget(c, &req);\n\tiput(inode);\n\treturn err;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn er"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\ti",
          "args": [
            "u",
            "inod"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(dir, inode);",
          "args": [
            "ub",
            "s_rel"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode);\n\tunl",
          "args": [
            "ck_2_"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dentry, inod",
          "args": [
            ");\n\tre",
            "rn 0;"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\td",
          "args": [
            "i",
            "tant"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(dir, inode);",
          "args": [
            "u",
            "fs_re"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(c, dir, &den",
          "args": [
            "r",
            ">d_",
            "me, inode, 0, 0",
            "if",
            "r"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(inode);\n\tdir",
          "args": [
            ">i_si"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino",
          "args": [
            "e->i_"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_parent_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "376-389",
          "snippet": "ino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de);\n\tiho",
          "args": [
            "d(ino"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dir, inode);",
          "args": [
            "in",
            "nlink"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ced_i_size(c, inode);",
          "args": [
            "f",
            "err)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&inode->i_mutex));\n\n\terr = db"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&inode->i_mu",
          "args": [
            "ex));\n\n\terr = d"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&dir->i_mutex));\n\tubifs_ass"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&dir->i_mute",
          "args": [
            "));\n\tubifs_as"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'%pd'",
          "args": [
            "o ino %lu (nlink %d) in dir ino %lu\",\n\t\tdentry, i",
            "->i_in",
            "inode->i_",
            "k, dir->i_ino)",
            "ubifs_ass"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_len",
          "args": [
            "8) };\n\n\t/*",
            "*"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(dentry->d_na",
          "args": [
            "e.len);\n\tstruct ub"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir);\n\tint e",
          "args": [
            "r,"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t      struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tint err, sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_dent = 1, .dirtied_ino = 2,\n\t\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\n\t/*\n\t * Budget request settings: new direntry, changing the target inode,\n\t * changing the parent inode.\n\t */\n\n\tdbg_gen(\"dent '%pd' to ino %lu (nlink %d) in dir ino %lu\",\n\t\tdentry, inode->i_ino,\n\t\tinode->i_nlink, dir->i_ino);\n\tubifs_assert(mutex_is_locked(&dir->i_mutex));\n\tubifs_assert(mutex_is_locked(&inode->i_mutex));\n\n\terr = dbg_check_synced_i_size(c, inode);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tlock_2_inodes(dir, inode);\n\tinc_nlink(inode);\n\tihold(inode);\n\tinode->i_ctime = ubifs_current_time(inode);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tubifs_release_budget(c, &req);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdrop_nlink(inode);\n\tunlock_2_inodes(dir, inode);\n\tubifs_release_budget(c, &req);\n\tiput(inode);\n\treturn err;\n}\n\nstatic int"
  },
  {
    "function_name": "es(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "491-495",
    "snippet": "nlock_2_inodes(struct inode *inode1, struct inode *inode2)\n{\n\tmutex_unlock(&ubifs_inode(inode2)->ui_mutex);\n\tmutex_unlock(&ubifs_inode(inode1)->ui_mutex);\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&ubifs_inode",
          "args": [
            "inode1)->ui_mutex);\n}\n\nstatic"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node1)->ui_",
          "args": [
            "utex);"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ubifs_inode",
          "args": [
            "inode2)->ui_mutex);\n\tmutex_unl"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node2)->ui_",
          "args": [
            "utex);"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nnlock_2_inodes(struct inode *inode1, struct inode *inode2)\n{\n\tmutex_unlock(&ubifs_inode(inode2)->ui_mutex);\n\tmutex_unlock(&ubifs_inode(inode1)->ui_mutex);\n}\n\nstatic int"
  },
  {
    "function_name": "(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "480-484",
    "snippet": "ock_2_inodes(struct inode *inode1, struct inode *inode2)\n{\n\tmutex_lock_nested(&ubifs_inode(inode1)->ui_mutex, WB_MUTEX_1);\n\tmutex_lock_nested(&ubifs_inode(inode2)->ui_mutex, WB_MUTEX_2);\n}\n\n/**\n * unlo",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sted(&ubifs_inode",
          "args": [
            "inode2)->ui_mutex, WB_MUTEX_2)",
            "}\n\n/**\n *"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node2)->ui_",
          "args": [
            "utex,"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&ubifs_inode",
          "args": [
            "inode1)->ui_mutex, WB_MUTEX_1)",
            "mutex_loc"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node1)->ui_",
          "args": [
            "utex,"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nock_2_inodes(struct inode *inode1, struct inode *inode2)\n{\n\tmutex_lock_nested(&ubifs_inode(inode1)->ui_mutex, WB_MUTEX_1);\n\tmutex_lock_nested(&ubifs_inode(inode2)->ui_mutex, WB_MUTEX_2);\n}\n\n/**\n * unlo"
  },
  {
    "function_name": "ease(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "464-469",
    "snippet": "ifs_dir_release(struct inode *dir, struct file *file)\n{\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}\n\n/**\n * lock",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rivat",
          "args": [
            "_data);\n\tfile->pri"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "locks_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "270-283",
          "snippet": "void locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_dir_release(struct inode *dir, struct file *file)\n{\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}\n\n/**\n * lock"
  },
  {
    "function_name": "(struct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "350-461",
    "snippet": "ifs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint err;\n\tstruct qstr nm;\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent;\n\tstruct inode *dir = file_inode(file);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\n\tdbg_gen(\"dir ino %lu, f_pos %#llx\", dir->i_ino, ctx->pos);\n\n\tif (ctx->pos > UBIFS_S_KEY_HASH_MASK || ctx->pos == 2)\n\t\t/*\n\t\t * The directory was seek'ed to a senseless position or there\n\t\t * are no more entries.\n\t\t */\n\t\treturn 0;\n\n\tif (file->f_version == 0) {\n\t\t/*\n\t\t * The file was seek'ed, which means that @file->private_data\n\t\t * is now invalid. This may also be just the first\n\t\t * 'ubifs_readdir()' invocation, in which case\n\t\t * @file->private_data is NULL, and the below code is\n\t\t * basically a no-op.\n\t\t */\n\t\tkfree(file->private_data);\n\t\tfile->private_data = NULL;\n\t}\n\n\t/*\n\t * 'generic_file_llseek()' unconditionally sets @file->f_version to\n\t * zero, and we use this for detecting whether the file was seek'ed.\n\t */\n\tfile->f_version = 1;\n\n\t/* File positions 0 and 1 correspond to \".\" and \"..\" */\n\tif (ctx->pos < 2) {\n\t\tubifs_assert(!file->private_data);\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\treturn 0;\n\n\t\t/* Find the first entry in TNC and save it */\n\t\tlowest_dent_key(c, &key, dir->i_ino);\n\t\tnm.name = NULL;\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\n\t\tctx->pos = key_hash_flash(c, &dent->key);\n\t\tfile->private_data = dent;\n\t}\n\n\tdent = file->private_data;\n\tif (!dent) {\n\t\t/*\n\t\t * The directory was seek'ed to and is now readdir'ed.\n\t\t * Find the entry corresponding to @ctx->pos or the closest one.\n\t\t */\n\t\tdent_key_init_hash(c, &key, dir->i_ino, ctx->pos);\n\t\tnm.name = NULL;\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\t\tctx->pos = key_hash_flash(c, &dent->key);\n\t\tfile->private_data = dent;\n\t}\n\n\twhile (1) {\n\t\tdbg_gen(\"feed '%s', ino %llu, new f_pos %#x\",\n\t\t\tdent->name, (unsigned long long)le64_to_cpu(dent->inum),\n\t\t\tkey_hash_flash(c, &dent->key));\n\t\tubifs_assert(le64_to_cpu(dent->ch.sqnum) >\n\t\t\t     ubifs_inode(dir)->creat_sqnum);\n\n\t\tnm.len = le16_to_cpu(dent->nlen);\n\t\tif (!dir_emit(ctx, dent->name, nm.len,\n\t\t\t       le64_to_cpu(dent->inum),\n\t\t\t       vfs_dent_type(dent->type)))\n\t\t\treturn 0;\n\n\t\t/* Switch to the next entry */\n\t\tkey_read(c, &dent->key, &key);\n\t\tnm.name = dent->name;\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\n\t\tkfree(file->private_data);\n\t\tctx->pos = key_hash_flash(c, &dent->key);\n\t\tfile->private_data = dent;\n\t\tcond_resched();\n\t}\n\nout:\n\tif (err != -ENOENT) {\n\t\tubifs_err(\"cannot find next direntry, error %d\", err);\n\t\treturn err;\n\t}\n\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\t/* 2 is a special value indicating that there are no more direntries */\n\tctx->pos = 2;\n\treturn 0;\n}\n\n/* Free sav",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rivat",
          "args": [
            "_data);\n\tfile->pri"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "locks_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "270-283",
          "snippet": "void locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nnot find",
          "args": [
            "next direntry, error %d\", err);\n\t\tret",
            "n e"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}\n\nout:",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(c, &dent->ke",
          "args": [
            ")",
            "file->pr"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tgo",
          "args": [
            "o ou"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{",
          "args": [
            "rr ="
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": "t_ent(c, &key, &nm",
          "args": [
            ";",
            "if",
            "S_E"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dent->ke",
          "args": [
            ",",
            "key);\n\t\tnm",
            "ame"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dent->n",
          "args": [
            "me,",
            "m.len,",
            "l",
            "ent->inum),\n\t\t\t       v",
            "(dent->type)))\n\t\t\treturn"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dent->type))",
          "args": [
            "return"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->inum),",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "if (!dir"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu(",
          "args": [
            "ent->ch.sqnum) >\n\t\t\t     ubifs_inode(dir)->creat_sqnum);\n\n\t\tnm.len"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir)->creat_",
          "args": [
            "qnu"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->ch.sqn",
          "args": [
            "m) >\n\t\t\t     u"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'%s',",
          "args": [
            "no %llu, new f_pos %#x\",\n\t\t\tdent->na",
            "unsigned l",
            "g long)le64_to_cpu(dent->inum),\n\t\t\tkey_hash",
            "h(c, &dent->key));\n\t\tubifs_as"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(c, &dent->ke",
          "args": [
            ")",
            "ubifs_a"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->inum),",
          "args": [
            "key_has"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(c, &dent->ke",
          "args": [
            ")",
            "file->pr"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tgo",
          "args": [
            "o ou"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_ent(c, &key, &nm",
          "args": [
            ";",
            "if",
            "S_E"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_hash(c, &key, dir",
          "args": [
            ">",
            "ino,",
            "tx->pos);",
            "nm.name"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(c, &dent->ke",
          "args": [
            ")",
            "file->pr"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tgo",
          "args": [
            "o ou"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_ent(c, &key, &nm",
          "args": [
            ";",
            "if",
            "S_E"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey(c, &key, dir",
          "args": [
            ">",
            "ino)",
            "nm.name"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(file, ctx))",
          "args": [
            "re",
            "rn"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!file->priva",
          "args": [
            "e_data);\n\t\tif (!dir"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino %lu",
          "args": [
            "f_pos %#llx\", dir->i_ino,",
            "tx->pos);",
            "if (ctx-"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le);\n\tstru",
          "args": [
            "t ub"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint err;\n\tstruct qstr nm;\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent;\n\tstruct inode *dir = file_inode(file);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\n\tdbg_gen(\"dir ino %lu, f_pos %#llx\", dir->i_ino, ctx->pos);\n\n\tif (ctx->pos > UBIFS_S_KEY_HASH_MASK || ctx->pos == 2)\n\t\t/*\n\t\t * The directory was seek'ed to a senseless position or there\n\t\t * are no more entries.\n\t\t */\n\t\treturn 0;\n\n\tif (file->f_version == 0) {\n\t\t/*\n\t\t * The file was seek'ed, which means that @file->private_data\n\t\t * is now invalid. This may also be just the first\n\t\t * 'ubifs_readdir()' invocation, in which case\n\t\t * @file->private_data is NULL, and the below code is\n\t\t * basically a no-op.\n\t\t */\n\t\tkfree(file->private_data);\n\t\tfile->private_data = NULL;\n\t}\n\n\t/*\n\t * 'generic_file_llseek()' unconditionally sets @file->f_version to\n\t * zero, and we use this for detecting whether the file was seek'ed.\n\t */\n\tfile->f_version = 1;\n\n\t/* File positions 0 and 1 correspond to \".\" and \"..\" */\n\tif (ctx->pos < 2) {\n\t\tubifs_assert(!file->private_data);\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\treturn 0;\n\n\t\t/* Find the first entry in TNC and save it */\n\t\tlowest_dent_key(c, &key, dir->i_ino);\n\t\tnm.name = NULL;\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\n\t\tctx->pos = key_hash_flash(c, &dent->key);\n\t\tfile->private_data = dent;\n\t}\n\n\tdent = file->private_data;\n\tif (!dent) {\n\t\t/*\n\t\t * The directory was seek'ed to and is now readdir'ed.\n\t\t * Find the entry corresponding to @ctx->pos or the closest one.\n\t\t */\n\t\tdent_key_init_hash(c, &key, dir->i_ino, ctx->pos);\n\t\tnm.name = NULL;\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\t\tctx->pos = key_hash_flash(c, &dent->key);\n\t\tfile->private_data = dent;\n\t}\n\n\twhile (1) {\n\t\tdbg_gen(\"feed '%s', ino %llu, new f_pos %#x\",\n\t\t\tdent->name, (unsigned long long)le64_to_cpu(dent->inum),\n\t\t\tkey_hash_flash(c, &dent->key));\n\t\tubifs_assert(le64_to_cpu(dent->ch.sqnum) >\n\t\t\t     ubifs_inode(dir)->creat_sqnum);\n\n\t\tnm.len = le16_to_cpu(dent->nlen);\n\t\tif (!dir_emit(ctx, dent->name, nm.len,\n\t\t\t       le64_to_cpu(dent->inum),\n\t\t\t       vfs_dent_type(dent->type)))\n\t\t\treturn 0;\n\n\t\t/* Switch to the next entry */\n\t\tkey_read(c, &dent->key, &key);\n\t\tnm.name = dent->name;\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\n\t\tkfree(file->private_data);\n\t\tctx->pos = key_hash_flash(c, &dent->key);\n\t\tfile->private_data = dent;\n\t\tcond_resched();\n\t}\n\nout:\n\tif (err != -ENOENT) {\n\t\tubifs_err(\"cannot find next direntry, error %d\", err);\n\t\treturn err;\n\t}\n\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\t/* 2 is a special value indicating that there are no more direntries */\n\tctx->pos = 2;\n\treturn 0;\n}\n\n/* Free sav"
  },
  {
    "function_name": "(uint8_t type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "310-331",
    "snippet": "ed int vfs_dent_type(uint8_t type)\n{\n\tswitch (type) {\n\tcase UBIFS_ITYPE_REG:\n\t\treturn DT_REG;\n\tcase UBIFS_ITYPE_DIR:\n\t\treturn DT_DIR;\n\tcase UBIFS_ITYPE_LNK:\n\t\treturn DT_LNK;\n\tcase UBIFS_ITYPE_BLK:\n\t\treturn DT_BLK;\n\tcase UBIFS_ITYPE_CHR:\n\t\treturn DT_CHR;\n\tcase UBIFS_ITYPE_FIFO:\n\t\treturn DT_FIFO;\n\tcase UBIFS_ITYPE_SOCK:\n\t\treturn DT_SOCK;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\n/*\n * The c",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tur",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "coda_return_EIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "32-35",
          "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\ned int vfs_dent_type(uint8_t type)\n{\n\tswitch (type) {\n\tcase UBIFS_ITYPE_REG:\n\t\treturn DT_REG;\n\tcase UBIFS_ITYPE_DIR:\n\t\treturn DT_DIR;\n\tcase UBIFS_ITYPE_LNK:\n\t\treturn DT_LNK;\n\tcase UBIFS_ITYPE_BLK:\n\t\treturn DT_BLK;\n\tcase UBIFS_ITYPE_CHR:\n\t\treturn DT_CHR;\n\tcase UBIFS_ITYPE_FIFO:\n\t\treturn DT_FIFO;\n\tcase UBIFS_ITYPE_SOCK:\n\t\treturn DT_SOCK;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\n/*\n * The c"
  },
  {
    "function_name": "struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "245-301",
    "snippet": "ifs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\tbool excl)\n{\n\tstruct inode *inode;\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tint err, sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.dirtied_ino = 1 };\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\n\t/*\n\t * Budget request settings: new inode, new direntry, changing the\n\t * parent directory inode.\n\t */\n\n\tdbg_gen(\"dent '%pd', mode %#hx in dir ino %lu\",\n\t\tdentry, mode, dir->i_ino);\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tinode = ubifs_new_inode(c, dir, mode);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\tubifs_err(\"cannot create regular file, error %d\", err);\n\treturn err;\n}\n\n/**\n * vfs_",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nnot crea",
          "args": [
            "e regular file, error %d\", err);\n\tretu",
            "er"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tu",
          "args": [
            "i",
            "_err"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_",
          "args": [
            "udg:"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "load_aout_library",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_aout.c",
          "lines": "337-408",
          "snippet": "static int load_aout_library(struct file *file)\n{\n\tstruct inode * inode;\n\tunsigned long bss, start_addr, len;\n\tunsigned long error;\n\tint retval;\n\tstruct exec ex;\n\n\tinode = file_inode(file);\n\n\tretval = -ENOEXEC;\n\terror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\n\tif (error != sizeof(ex))\n\t\tgoto out;\n\n\t/* We come in here for the regular a.out style of shared libraries */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\n\t    N_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\n\t    i_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!file->f_op->mmap)\n\t\tgoto out;\n\n\tif (N_FLAGS(ex))\n\t\tgoto out;\n\n\t/* For  QMAGIC, the starting address is 0x20 into the page.  We mask\n\t   this off to get the starting address for the page */\n\n\tstart_addr =  ex.a_entry & 0xfffff000;\n\n\tif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\n\t\tif (printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\",\n\t\t\t       file);\n\t\t}\n\t\tvm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\n\t\t\n\t\tread_code(file, start_addr, N_TXTOFF(ex),\n\t\t\t  ex.a_text + ex.a_data);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\tN_TXTOFF(ex));\n\tretval = error;\n\tif (error != start_addr)\n\t\tgoto out;\n\n\tlen = PAGE_ALIGN(ex.a_text + ex.a_data);\n\tbss = ex.a_text + ex.a_data + ex.a_bss;\n\tif (bss > len) {\n\t\terror = vm_brk(start_addr + len, bss - len);\n\t\tretval = error;\n\t\tif (error != start_addr + len)\n\t\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <asm/a.out-core.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/coredump.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/a.out.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int load_aout_library(struct file*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_aout_library(struct file*);\n\nstatic int load_aout_library(struct file *file)\n{\n\tstruct inode * inode;\n\tunsigned long bss, start_addr, len;\n\tunsigned long error;\n\tint retval;\n\tstruct exec ex;\n\n\tinode = file_inode(file);\n\n\tretval = -ENOEXEC;\n\terror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\n\tif (error != sizeof(ex))\n\t\tgoto out;\n\n\t/* We come in here for the regular a.out style of shared libraries */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\n\t    N_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\n\t    i_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!file->f_op->mmap)\n\t\tgoto out;\n\n\tif (N_FLAGS(ex))\n\t\tgoto out;\n\n\t/* For  QMAGIC, the starting address is 0x20 into the page.  We mask\n\t   this off to get the starting address for the page */\n\n\tstart_addr =  ex.a_entry & 0xfffff000;\n\n\tif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\n\t\tif (printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\",\n\t\t\t       file);\n\t\t}\n\t\tvm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\n\t\t\n\t\tread_code(file, start_addr, N_TXTOFF(ex),\n\t\t\t  ex.a_text + ex.a_data);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\tN_TXTOFF(ex));\n\tretval = error;\n\tif (error != start_addr)\n\t\tgoto out;\n\n\tlen = PAGE_ALIGN(ex.a_text + ex.a_data);\n\tbss = ex.a_text + ex.a_data + ex.a_bss;\n\tif (bss > len) {\n\t\terror = vm_brk(start_addr + len, bss - len);\n\t\tretval = error;\n\t\tif (error != start_addr + len)\n\t\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e(inode);\n\tipu",
          "args": [
            "(inod"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&dir_ui->ui_",
          "args": [
            "utex);\n\tmake_bad_"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dentry, inod",
          "args": [
            ");\n\tre",
            "rn 0;"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash(inode);\n\td_i",
          "args": [
            "stant"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\ti",
          "args": [
            "s",
            "t_in"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&dir_ui->ui_",
          "args": [
            "utex);\n\n\tubifs_re"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(c, dir, &den",
          "args": [
            "r",
            ">d_",
            "me, inode, 0, 0",
            "if",
            "r"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir_ui->ui_",
          "args": [
            "utex);\n\tdir->i_si"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curity(dir, inode,",
          "args": [
            "den",
            "y->d_",
            "me);\n\tif (err)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "rr ="
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, dir, mode",
          "args": [
            ";",
            "if",
            "S_ER"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'%pd',",
          "args": [
            "mode %#hx in dir ino %lu\",\n\t\tdentry, m",
            "dir->",
            "ino)",
            "err = ub"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir);\n\n\t/*",
          "args": [
            "* B"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(dentry->d_na",
          "args": [
            "e.len);\n\tstruct ub"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\tbool excl)\n{\n\tstruct inode *inode;\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tint err, sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.dirtied_ino = 1 };\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\n\t/*\n\t * Budget request settings: new inode, new direntry, changing the\n\t * parent directory inode.\n\t */\n\n\tdbg_gen(\"dent '%pd', mode %#hx in dir ino %lu\",\n\t\tdentry, mode, dir->i_ino);\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tinode = ubifs_new_inode(c, dir, mode);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\tubifs_err(\"cannot create regular file, error %d\", err);\n\treturn err;\n}\n\n/**\n * vfs_"
  },
  {
    "function_name": "struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "184-243",
    "snippet": "dentry *ubifs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tint err;\n\tunion ubifs_key key;\n\tstruct inode *inode = NULL;\n\tstruct ubifs_dent_node *dent;\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\n\tdbg_gen(\"'%pd' in dir ino %lu\", dentry, dir->i_ino);\n\n\tif (dentry->d_name.len > UBIFS_MAX_NLEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tdent = kmalloc(UBIFS_MAX_DENT_NODE_SZ, GFP_NOFS);\n\tif (!dent)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdent_key_init(c, &key, dir->i_ino, &dentry->d_name);\n\n\terr = ubifs_tnc_lookup_nm(c, &key, dent, &dentry->d_name);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tdbg_gen(\"not found\");\n\t\t\tgoto done;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (dbg_check_name(c, dent, &dentry->d_name)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinode = ubifs_iget(dir->i_sb, le64_to_cpu(dent->inum));\n\tif (IS_ERR(inode)) {\n\t\t/*\n\t\t * This should not happen. Probably the file-system needs\n\t\t * checking.\n\t\t */\n\t\terr = PTR_ERR(inode);\n\t\tubifs_err(\"dead directory entry '%pd', error %d\",\n\t\t\t  dentry, err);\n\t\tubifs_ro_mode(c, err);\n\t\tgoto out;\n\t}\n\ndone:\n\tkfree(dent);\n\t/*\n\t * Note, d_splice_alias() would be required instead if we supported\n\t * NFS.\n\t */\n\td_add(dentry, inode);\n\treturn NULL;\n\nout:\n\tkfree(dent);\n\treturn ERR_PTR(err);\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\nsta",
          "args": [
            "ic"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n ER"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inod",
          "args": [
            ");\n\tre",
            "rn NU"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "truct inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
          "lines": "645-705",
          "snippet": "ifs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = dentry->d_inode;\n\tint sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tint err, budgeted = 1;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_budget_req req = { .mod_dent = 1, .dirtied_ino = 2 };\n\n\t/*\n\t * Budget request settings: deletion direntry, deletion inode and\n\t * changing the parent inode. If budgeting fails, go ahead anyway\n\t * because we have extra space reserved for deletions.\n\t */\n\n\tdbg_gen(\"directory '%pd', ino %lu in dir ino %lu\", dentry,\n\t\tinode->i_ino, dir->i_ino);\n\tubifs_assert(mutex_is_locked(&dir->i_mutex));\n\tubifs_assert(mutex_is_locked(&inode->i_mutex));\n\terr = check_dir_empty(c, dentry->d_inode);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\t\tbudgeted = 0;\n\t}\n\n\tlock_2_inodes(dir, inode);\n\tinode->i_ctime = ubifs_current_time(dir);\n\tclear_nlink(inode);\n\tdrop_nlink(dir);\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 1, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\t/* We've deleted something - clean the \"no space\" flags */\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\treturn 0;\n\nout_cancel:\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tinc_nlink(dir);\n\tset_nlink(inode, 2);\n\tunlock_2_inodes(dir, inode);\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic int",
          "includes": [
            "fs.h\"\n\n/**\n * inher"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nifs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = dentry->d_inode;\n\tint sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tint err, budgeted = 1;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_budget_req req = { .mod_dent = 1, .dirtied_ino = 2 };\n\n\t/*\n\t * Budget request settings: deletion direntry, deletion inode and\n\t * changing the parent inode. If budgeting fails, go ahead anyway\n\t * because we have extra space reserved for deletions.\n\t */\n\n\tdbg_gen(\"directory '%pd', ino %lu in dir ino %lu\", dentry,\n\t\tinode->i_ino, dir->i_ino);\n\tubifs_assert(mutex_is_locked(&dir->i_mutex));\n\tubifs_assert(mutex_is_locked(&inode->i_mutex));\n\terr = check_dir_empty(c, dentry->d_inode);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\t\tbudgeted = 0;\n\t}\n\n\tlock_2_inodes(dir, inode);\n\tinode->i_ctime = ubifs_current_time(dir);\n\tclear_nlink(inode);\n\tdrop_nlink(dir);\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = dir->i_ctime = inode->i_ctime;\n\terr = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 1, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\t/* We've deleted something - clean the \"no space\" flags */\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\treturn 0;\n\nout_cancel:\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tinc_nlink(dir);\n\tset_nlink(inode, 2);\n\tunlock_2_inodes(dir, inode);\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "/*",
          "args": [
            "* No"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\t\tg",
          "args": [
            "t",
            "out"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad direct",
          "args": [
            "ry entry '%pd', error %d\",\n\t\t\t  dentry",
            "ubi",
            "_ro"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tub",
          "args": [
            "fs_er"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "*"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->i_sb, l",
          "args": [
            "64_to_cpu",
            "ent->inum));\n\tif (IS_ER"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->inum))",
          "args": [
            "if (IS_E"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, dent, &de",
          "args": [
            "t",
            "->d_",
            "me)) {\n\t\terr ="
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "found\")",
          "args": [
            "goto do"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_nm(c, &key, den",
          "args": [
            ",",
            "dent",
            "->d_",
            "me);\n\tif (err)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, dir",
          "args": [
            ">",
            "ino,",
            "dentry->d_",
            "me);\n\n\terr = ub"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "ent_key"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MAX_DE",
          "args": [
            "T_NODE_SZ, GFP_NOFS);",
            "f (!dent"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETOOLON",
          "args": [
            ");\n\n\tdent = k"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "' in di",
          "args": [
            "ino %lu\", dentry, dir",
            "i_ino)",
            "if (dent"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\ndentry *ubifs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tint err;\n\tunion ubifs_key key;\n\tstruct inode *inode = NULL;\n\tstruct ubifs_dent_node *dent;\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\n\tdbg_gen(\"'%pd' in dir ino %lu\", dentry, dir->i_ino);\n\n\tif (dentry->d_name.len > UBIFS_MAX_NLEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tdent = kmalloc(UBIFS_MAX_DENT_NODE_SZ, GFP_NOFS);\n\tif (!dent)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdent_key_init(c, &key, dir->i_ino, &dentry->d_name);\n\n\terr = ubifs_tnc_lookup_nm(c, &key, dent, &dentry->d_name);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tdbg_gen(\"not found\");\n\t\t\tgoto done;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (dbg_check_name(c, dent, &dentry->d_name)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinode = ubifs_iget(dir->i_sb, le64_to_cpu(dent->inum));\n\tif (IS_ERR(inode)) {\n\t\t/*\n\t\t * This should not happen. Probably the file-system needs\n\t\t * checking.\n\t\t */\n\t\terr = PTR_ERR(inode);\n\t\tubifs_err(\"dead directory entry '%pd', error %d\",\n\t\t\t  dentry, err);\n\t\tubifs_ro_mode(c, err);\n\t\tgoto out;\n\t}\n\ndone:\n\tkfree(dent);\n\t/*\n\t * Note, d_splice_alias() would be required instead if we supported\n\t * NFS.\n\t */\n\td_add(dentry, inode);\n\treturn NULL;\n\nout:\n\tkfree(dent);\n\treturn ERR_PTR(err);\n}\n\nstatic int"
  },
  {
    "function_name": "e(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "171-182",
    "snippet": "g_check_name(const struct ubifs_info *c,\n\t\t\t  const struct ubifs_dent_node *dent,\n\t\t\t  const struct qstr *nm)\n{\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (le16_to_cpu(dent->nlen) != nm->len)\n\t\treturn -EINVAL;\n\tif (memcmp(dent->name, nm->name, nm->len))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic stru",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "name,",
          "args": [
            "m->name, n",
            ">len))",
            "eturn -"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen)",
          "args": [
            "= nm->len)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\ng_check_name(const struct ubifs_info *c,\n\t\t\t  const struct ubifs_dent_node *dent,\n\t\t\t  const struct qstr *nm)\n{\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (le16_to_cpu(dent->nlen) != nm->len)\n\t\treturn -EINVAL;\n\tif (memcmp(dent->name, nm->name, nm->len))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic stru"
  },
  {
    "function_name": "de(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "88-169",
    "snippet": "*ubifs_new_inode(struct ubifs_info *c, const struct inode *dir,\n\t\t\t      umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\n\tinode = new_inode(c->vfs_sb);\n\tui = ubifs_inode(inode);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Set 'S_NOCMTIME' to prevent VFS form updating [mc]time of inodes and\n\t * marking them dirty in file write path (see 'file_update_time()').\n\t * UBIFS has to fully control \"clean <-> dirty\" transitions of inodes\n\t * to make budgeting work.\n\t */\n\tinode->i_flags |= S_NOCMTIME;\n\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\t\t ubifs_current_time(inode);\n\tinode->i_mapping->nrpages = 0;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_mapping->a_ops = &ubifs_file_address_operations;\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinode->i_fop = &ubifs_file_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op  = &ubifs_dir_inode_operations;\n\t\tinode->i_fop = &ubifs_dir_operations;\n\t\tinode->i_size = ui->ui_size = UBIFS_INO_NODE_SZ;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ubifs_symlink_inode_operations;\n\t\tbreak;\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tinode->i_op  = &ubifs_file_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tui->flags = inherit_flags(dir, mode);\n\tubifs_set_inode_flags(inode);\n\tif (S_ISREG(mode))\n\t\tui->compr_type = c->default_compr;\n\telse\n\t\tui->compr_type = UBIFS_COMPR_NONE;\n\tui->synced_i_size = 0;\n\n\tspin_lock(&c->cnt_lock);\n\t/* Inode number overflow is currently not supported */\n\tif (c->highest_inum >= INUM_WARN_WATERMARK) {\n\t\tif (c->highest_inum >= INUM_WATERMARK) {\n\t\t\tspin_unlock(&c->cnt_lock);\n\t\t\tubifs_err(\"out of inode numbers\");\n\t\t\tmake_bad_inode(inode);\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tubifs_warn(\"running out of inode numbers (current %lu, max %d)\",\n\t\t\t   (unsigned long)c->highest_inum, INUM_WATERMARK);\n\t}\n\n\tinode->i_ino = ++c->highest_inum;\n\t/*\n\t * The creation sequence number remains with this inode for its\n\t * lifetime. All nodes for this inode have a greater sequence number,\n\t * and so it is possible to distinguish obsolete nodes belonging to a\n\t * previous incarnation of the same inode number - for example, for the\n\t * purpose of rebuilding the index.\n\t */\n\tui->creat_sqnum = ++c->max_sqnum;\n\tspin_unlock(&c->cnt_lock);\n\treturn inode;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [
      "inode_operations ubifs_dir_inode_operations = {\n\t.lookup      = ubifs_lookup,\n\t.create      = ubifs_create,\n\t.link        = ubifs_link,\n\t.symlink     = ubifs_symlink,\n\t.unlink      = ubifs_unlink,\n\t.mkdir       = ubifs_mkdir,\n\t.rmdir       = ubifs_rmdir,\n\t.mknod       = ubifs_mknod,\n\t.rename      = ubifs_rename,\n\t.setattr     = ubifs_setattr,\n\t.getattr     = ubifs_getattr,\n\t.setxattr    = ubifs_setxattr,\n\t.getxattr    = ubifs_getxattr,\n\t.listxattr   = ubifs_listxattr,\n\t.removexattr = ubifs_removexattr,\n};\n\nconst struc",
      "file_operations ubifs_dir_operations = {\n\t.llseek         = generic_file_llseek,\n\t.release        = ubifs_dir_release,\n\t.read           = generic_read_dir,\n\t.iterate        = ubifs_readdir,\n\t.fsync          = ubifs_fsync,\n\t.unlocked_ioctl = ubifs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = ubifs_compat_ioctl,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->cnt_lock",
          "args": [
            ";\n\treturn in"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unning out",
          "args": [
            "of inode numbers (current %lu, max %d)\",\n\t\t\t   (unsi",
            "g)c->highest_inum, INUM_WATERM",
            "K);\n\t}\n\n\tinode"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AL);",
          "args": [
            "ubif"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "turn"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_leaf_same_major",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "3558-3570",
          "snippet": "static int ocfs2_dx_leaf_same_major(struct ocfs2_dx_leaf *dx_leaf)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num = le16_to_cpu(dl_list->de_num_used);\n\n\tfor (i = 0; i < (num - 1); i++) {\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) !=\n\t\t    le32_to_cpu(dl_list->de_entries[i + 1].dx_major_hash))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dx_leaf_same_major(struct ocfs2_dx_leaf *dx_leaf)\n{\n\tstruct ocfs2_dx_entry_list *dl_list = &dx_leaf->dl_list;\n\tint i, num = le16_to_cpu(dl_list->de_num_used);\n\n\tfor (i = 0; i < (num - 1); i++) {\n\t\tif (le32_to_cpu(dl_list->de_entries[i].dx_major_hash) !=\n\t\t    le32_to_cpu(dl_list->de_entries[i + 1].dx_major_hash))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e(inode);\n\t\t\ti",
          "args": [
            "ut(in"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t of inod",
          "args": [
            "numbers\");\n\t\t\tmake_ba"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cnt_lock",
          "args": [
            ";\n\t\t\tubifs_e"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cnt_lock",
          "args": [
            ";\n\t/* Inode"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tui-",
          "args": [
            "comp"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_flags(inode);\n\tif",
          "args": [
            "S_ISR"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dir, mode);",
          "args": [
            "ubi",
            "_set"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "is_32bit_api",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "208-215",
          "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "_time(inode);\n\tino",
          "args": [
            "e->i_"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ner(inode, dir,",
          "args": [
            "ode);",
            "ino",
            "->i_"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "*\n\t * S"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tif",
          "args": [
            "!inod"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_sb);",
          "args": [
            "ui = ubif"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\ninode_operations ubifs_dir_inode_operations = {\n\t.lookup      = ubifs_lookup,\n\t.create      = ubifs_create,\n\t.link        = ubifs_link,\n\t.symlink     = ubifs_symlink,\n\t.unlink      = ubifs_unlink,\n\t.mkdir       = ubifs_mkdir,\n\t.rmdir       = ubifs_rmdir,\n\t.mknod       = ubifs_mknod,\n\t.rename      = ubifs_rename,\n\t.setattr     = ubifs_setattr,\n\t.getattr     = ubifs_getattr,\n\t.setxattr    = ubifs_setxattr,\n\t.getxattr    = ubifs_getxattr,\n\t.listxattr   = ubifs_listxattr,\n\t.removexattr = ubifs_removexattr,\n};\n\nconst struc;\nfile_operations ubifs_dir_operations = {\n\t.llseek         = generic_file_llseek,\n\t.release        = ubifs_dir_release,\n\t.read           = generic_read_dir,\n\t.iterate        = ubifs_readdir,\n\t.fsync          = ubifs_fsync,\n\t.unlocked_ioctl = ubifs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = ubifs_compat_ioctl,\n#endif\n};\n\n*ubifs_new_inode(struct ubifs_info *c, const struct inode *dir,\n\t\t\t      umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\n\tinode = new_inode(c->vfs_sb);\n\tui = ubifs_inode(inode);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Set 'S_NOCMTIME' to prevent VFS form updating [mc]time of inodes and\n\t * marking them dirty in file write path (see 'file_update_time()').\n\t * UBIFS has to fully control \"clean <-> dirty\" transitions of inodes\n\t * to make budgeting work.\n\t */\n\tinode->i_flags |= S_NOCMTIME;\n\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\t\t ubifs_current_time(inode);\n\tinode->i_mapping->nrpages = 0;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_mapping->a_ops = &ubifs_file_address_operations;\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinode->i_fop = &ubifs_file_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op  = &ubifs_dir_inode_operations;\n\t\tinode->i_fop = &ubifs_dir_operations;\n\t\tinode->i_size = ui->ui_size = UBIFS_INO_NODE_SZ;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ubifs_symlink_inode_operations;\n\t\tbreak;\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tinode->i_op  = &ubifs_file_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tui->flags = inherit_flags(dir, mode);\n\tubifs_set_inode_flags(inode);\n\tif (S_ISREG(mode))\n\t\tui->compr_type = c->default_compr;\n\telse\n\t\tui->compr_type = UBIFS_COMPR_NONE;\n\tui->synced_i_size = 0;\n\n\tspin_lock(&c->cnt_lock);\n\t/* Inode number overflow is currently not supported */\n\tif (c->highest_inum >= INUM_WARN_WATERMARK) {\n\t\tif (c->highest_inum >= INUM_WATERMARK) {\n\t\t\tspin_unlock(&c->cnt_lock);\n\t\t\tubifs_err(\"out of inode numbers\");\n\t\t\tmake_bad_inode(inode);\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tubifs_warn(\"running out of inode numbers (current %lu, max %d)\",\n\t\t\t   (unsigned long)c->highest_inum, INUM_WATERMARK);\n\t}\n\n\tinode->i_ino = ++c->highest_inum;\n\t/*\n\t * The creation sequence number remains with this inode for its\n\t * lifetime. All nodes for this inode have a greater sequence number,\n\t * and so it is possible to distinguish obsolete nodes belonging to a\n\t * previous incarnation of the same inode number - for example, for the\n\t * purpose of rebuilding the index.\n\t */\n\tui->creat_sqnum = ++c->max_sqnum;\n\tspin_unlock(&c->cnt_lock);\n\treturn inode;\n}\n\nstatic int"
  },
  {
    "function_name": "(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/dir.c",
    "lines": "59-76",
    "snippet": "herit_flags(const struct inode *dir, umode_t mode)\n{\n\tint flags;\n\tconst struct ubifs_inode *ui = ubifs_inode(dir);\n\n\tif (!S_ISDIR(dir->i_mode))\n\t\t/*\n\t\t * The parent is not a directory, which means that an extended\n\t\t * attribute inode is being created. No flags.\n\t\t */\n\t\treturn 0;\n\n\tflags = ui->flags & (UBIFS_COMPR_FL | UBIFS_SYNC_FL | UBIFS_DIRSYNC_FL);\n\tif (!S_ISDIR(mode))\n\t\t/* The \"DIRSYNC\" flag only applies to directories */\n\t\tflags &= ~UBIFS_DIRSYNC_FL;\n\treturn flags;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * inher"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ")\n\t\t/*",
          "args": [
            "he \""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mode)",
          "args": [
            "/*\n\t\t *"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir);\n\n\tif (",
          "args": [
            "S_I"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * inher\n\nherit_flags(const struct inode *dir, umode_t mode)\n{\n\tint flags;\n\tconst struct ubifs_inode *ui = ubifs_inode(dir);\n\n\tif (!S_ISDIR(dir->i_mode))\n\t\t/*\n\t\t * The parent is not a directory, which means that an extended\n\t\t * attribute inode is being created. No flags.\n\t\t */\n\t\treturn 0;\n\n\tflags = ui->flags & (UBIFS_COMPR_FL | UBIFS_SYNC_FL | UBIFS_DIRSYNC_FL);\n\tif (!S_ISDIR(mode))\n\t\t/* The \"DIRSYNC\" flag only applies to directories */\n\t\tflags &= ~UBIFS_DIRSYNC_FL;\n\treturn flags;\n}\n\n/**\n * ubif"
  }
]