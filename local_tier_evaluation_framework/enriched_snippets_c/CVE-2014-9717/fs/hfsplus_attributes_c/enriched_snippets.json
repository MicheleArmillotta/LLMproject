[
  {
    "function_name": "hfsplus_delete_all_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "339-371",
    "snippet": "int hfsplus_delete_all_attrs(struct inode *dir, u32 cnid)\n{\n\tint err = 0;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_all_attrs: %d\\n\", cnid);\n\n\tif (!HFSPLUS_SB(dir->i_sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(dir->i_sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tfor (;;) {\n\t\terr = hfsplus_find_attr(dir->i_sb, cnid, NULL, &fd);\n\t\tif (err) {\n\t\t\tif (err != -ENOENT)\n\t\t\t\tpr_err(\"xattr search failed\\n\");\n\t\t\tgoto end_delete_all;\n\t\t}\n\n\t\terr = __hfsplus_delete_attr(dir, cnid, &fd);\n\t\tif (err)\n\t\t\tgoto end_delete_all;\n\t}\n\nend_delete_all:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfsplus_delete_attr",
          "args": [
            "dir",
            "cnid",
            "&fd"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_delete_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "260-295",
          "snippet": "static int __hfsplus_delete_attr(struct inode *inode, u32 cnid,\n\t\t\t\t\tstruct hfs_find_data *fd)\n{\n\tint err = 0;\n\t__be32 found_cnid, record_type;\n\n\thfs_bnode_read(fd->bnode, &found_cnid,\n\t\t\tfd->keyoffset +\n\t\t\toffsetof(struct hfsplus_attr_key, cnid),\n\t\t\tsizeof(__be32));\n\tif (cnid != be32_to_cpu(found_cnid))\n\t\treturn -ENOENT;\n\n\thfs_bnode_read(fd->bnode, &record_type,\n\t\t\tfd->entryoffset, sizeof(record_type));\n\n\tswitch (be32_to_cpu(record_type)) {\n\tcase HFSPLUS_ATTR_INLINE_DATA:\n\t\t/* All is OK. Do nothing. */\n\t\tbreak;\n\tcase HFSPLUS_ATTR_FORK_DATA:\n\tcase HFSPLUS_ATTR_EXTENTS:\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tpr_err(\"invalid extended attribute record\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\terr = hfs_brec_remove(fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic int __hfsplus_delete_attr(struct inode *inode, u32 cnid,\n\t\t\t\t\tstruct hfs_find_data *fd)\n{\n\tint err = 0;\n\t__be32 found_cnid, record_type;\n\n\thfs_bnode_read(fd->bnode, &found_cnid,\n\t\t\tfd->keyoffset +\n\t\t\toffsetof(struct hfsplus_attr_key, cnid),\n\t\t\tsizeof(__be32));\n\tif (cnid != be32_to_cpu(found_cnid))\n\t\treturn -ENOENT;\n\n\thfs_bnode_read(fd->bnode, &record_type,\n\t\t\tfd->entryoffset, sizeof(record_type));\n\n\tswitch (be32_to_cpu(record_type)) {\n\tcase HFSPLUS_ATTR_INLINE_DATA:\n\t\t/* All is OK. Do nothing. */\n\t\tbreak;\n\tcase HFSPLUS_ATTR_FORK_DATA:\n\tcase HFSPLUS_ATTR_EXTENTS:\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tpr_err(\"invalid extended attribute record\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\terr = hfs_brec_remove(fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"xattr search failed\\n\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_find_attr",
          "args": [
            "dir->i_sb",
            "cnid",
            "NULL",
            "&fd"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_find_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "136-166",
          "snippet": "int hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(dir->i_sb)->attr_tree",
            "&fd"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"attributes file doesn't exist\\n\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "ATTR_MOD",
            "\"delete_all_attrs: %d\\n\"",
            "cnid"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_all_attrs(struct inode *dir, u32 cnid)\n{\n\tint err = 0;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_all_attrs: %d\\n\", cnid);\n\n\tif (!HFSPLUS_SB(dir->i_sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(dir->i_sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tfor (;;) {\n\t\terr = hfsplus_find_attr(dir->i_sb, cnid, NULL, &fd);\n\t\tif (err) {\n\t\t\tif (err != -ENOENT)\n\t\t\t\tpr_err(\"xattr search failed\\n\");\n\t\t\tgoto end_delete_all;\n\t\t}\n\n\t\terr = __hfsplus_delete_attr(dir, cnid, &fd);\n\t\tif (err)\n\t\t\tgoto end_delete_all;\n\t}\n\nend_delete_all:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_delete_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "297-337",
    "snippet": "int hfsplus_delete_attr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid extended attribute name\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = __hfsplus_delete_attr(inode, inode->i_ino, &fd);\n\tif (err)\n\t\tgoto out;\n\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfsplus_delete_attr",
          "args": [
            "inode",
            "inode->i_ino",
            "&fd"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_delete_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "260-295",
          "snippet": "static int __hfsplus_delete_attr(struct inode *inode, u32 cnid,\n\t\t\t\t\tstruct hfs_find_data *fd)\n{\n\tint err = 0;\n\t__be32 found_cnid, record_type;\n\n\thfs_bnode_read(fd->bnode, &found_cnid,\n\t\t\tfd->keyoffset +\n\t\t\toffsetof(struct hfsplus_attr_key, cnid),\n\t\t\tsizeof(__be32));\n\tif (cnid != be32_to_cpu(found_cnid))\n\t\treturn -ENOENT;\n\n\thfs_bnode_read(fd->bnode, &record_type,\n\t\t\tfd->entryoffset, sizeof(record_type));\n\n\tswitch (be32_to_cpu(record_type)) {\n\tcase HFSPLUS_ATTR_INLINE_DATA:\n\t\t/* All is OK. Do nothing. */\n\t\tbreak;\n\tcase HFSPLUS_ATTR_FORK_DATA:\n\tcase HFSPLUS_ATTR_EXTENTS:\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tpr_err(\"invalid extended attribute record\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\terr = hfs_brec_remove(fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic int __hfsplus_delete_attr(struct inode *inode, u32 cnid,\n\t\t\t\t\tstruct hfs_find_data *fd)\n{\n\tint err = 0;\n\t__be32 found_cnid, record_type;\n\n\thfs_bnode_read(fd->bnode, &found_cnid,\n\t\t\tfd->keyoffset +\n\t\t\toffsetof(struct hfsplus_attr_key, cnid),\n\t\t\tsizeof(__be32));\n\tif (cnid != be32_to_cpu(found_cnid))\n\t\treturn -ENOENT;\n\n\thfs_bnode_read(fd->bnode, &record_type,\n\t\t\tfd->entryoffset, sizeof(record_type));\n\n\tswitch (be32_to_cpu(record_type)) {\n\tcase HFSPLUS_ATTR_INLINE_DATA:\n\t\t/* All is OK. Do nothing. */\n\t\tbreak;\n\tcase HFSPLUS_ATTR_FORK_DATA:\n\tcase HFSPLUS_ATTR_EXTENTS:\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tpr_err(\"invalid extended attribute record\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\terr = hfs_brec_remove(fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd",
            "hfs_find_rec_by_key"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid extended attribute name\\n\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_attr_build_key",
          "args": [
            "sb",
            "fd.search_key",
            "inode->i_ino",
            "name"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_attr_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "49-80",
          "snippet": "int hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\tu32 cnid, const char *name)\n{\n\tint len;\n\n\tmemset(key, 0, sizeof(struct hfsplus_attr_key));\n\tkey->attr.cnid = cpu_to_be32(cnid);\n\tif (name) {\n\t\tint res = hfsplus_asc2uni(sb,\n\t\t\t\t(struct hfsplus_unistr *)&key->attr.key_name,\n\t\t\t\tHFSPLUS_ATTR_MAX_STRLEN, name, strlen(name));\n\t\tif (res)\n\t\t\treturn res;\n\t\tlen = be16_to_cpu(key->attr.key_name.length);\n\t} else {\n\t\tkey->attr.key_name.length = 0;\n\t\tlen = 0;\n\t}\n\n\t/* The length of the key, as stored in key_len field, does not include\n\t * the size of the key_len field itself.\n\t * So, offsetof(hfsplus_attr_key, key_name) is a trick because\n\t * it takes into consideration key_len field (__be16) of\n\t * hfsplus_attr_key structure instead of length field (__be16) of\n\t * hfsplus_attr_unistr structure.\n\t */\n\tkey->key_len =\n\t\tcpu_to_be16(offsetof(struct hfsplus_attr_key, key_name) +\n\t\t\t\t2 * len);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\tu32 cnid, const char *name)\n{\n\tint len;\n\n\tmemset(key, 0, sizeof(struct hfsplus_attr_key));\n\tkey->attr.cnid = cpu_to_be32(cnid);\n\tif (name) {\n\t\tint res = hfsplus_asc2uni(sb,\n\t\t\t\t(struct hfsplus_unistr *)&key->attr.key_name,\n\t\t\t\tHFSPLUS_ATTR_MAX_STRLEN, name, strlen(name));\n\t\tif (res)\n\t\t\treturn res;\n\t\tlen = be16_to_cpu(key->attr.key_name.length);\n\t} else {\n\t\tkey->attr.key_name.length = 0;\n\t\tlen = 0;\n\t}\n\n\t/* The length of the key, as stored in key_len field, does not include\n\t * the size of the key_len field itself.\n\t * So, offsetof(hfsplus_attr_key, key_name) is a trick because\n\t * it takes into consideration key_len field (__be16) of\n\t * hfsplus_attr_key structure instead of length field (__be16) of\n\t * hfsplus_attr_unistr structure.\n\t */\n\tkey->key_len =\n\t\tcpu_to_be16(offsetof(struct hfsplus_attr_key, key_name) +\n\t\t\t\t2 * len);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(sb)->attr_tree",
            "&fd"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"attributes file doesn't exist\\n\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "ATTR_MOD",
            "\"delete_attr: %s,%ld\\n\"",
            "name ? name : NULL",
            "inode->i_ino"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_attr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid extended attribute name\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = __hfsplus_delete_attr(inode, inode->i_ino, &fd);\n\tif (err)\n\t\tgoto out;\n\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
  },
  {
    "function_name": "__hfsplus_delete_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "260-295",
    "snippet": "static int __hfsplus_delete_attr(struct inode *inode, u32 cnid,\n\t\t\t\t\tstruct hfs_find_data *fd)\n{\n\tint err = 0;\n\t__be32 found_cnid, record_type;\n\n\thfs_bnode_read(fd->bnode, &found_cnid,\n\t\t\tfd->keyoffset +\n\t\t\toffsetof(struct hfsplus_attr_key, cnid),\n\t\t\tsizeof(__be32));\n\tif (cnid != be32_to_cpu(found_cnid))\n\t\treturn -ENOENT;\n\n\thfs_bnode_read(fd->bnode, &record_type,\n\t\t\tfd->entryoffset, sizeof(record_type));\n\n\tswitch (be32_to_cpu(record_type)) {\n\tcase HFSPLUS_ATTR_INLINE_DATA:\n\t\t/* All is OK. Do nothing. */\n\t\tbreak;\n\tcase HFSPLUS_ATTR_FORK_DATA:\n\tcase HFSPLUS_ATTR_EXTENTS:\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tpr_err(\"invalid extended attribute record\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\terr = hfs_brec_remove(fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\treturn err;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "inode",
            "HFSPLUS_I_ATTR_DIRTY"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_remove",
          "args": [
            "fd"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "177-231",
          "snippet": "int hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid extended attribute record\\n\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"only inline data xattr are supported\\n\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "record_type"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd->bnode",
            "&record_type",
            "fd->entryoffset",
            "sizeof(record_type)"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "found_cnid"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic int __hfsplus_delete_attr(struct inode *inode, u32 cnid,\n\t\t\t\t\tstruct hfs_find_data *fd)\n{\n\tint err = 0;\n\t__be32 found_cnid, record_type;\n\n\thfs_bnode_read(fd->bnode, &found_cnid,\n\t\t\tfd->keyoffset +\n\t\t\toffsetof(struct hfsplus_attr_key, cnid),\n\t\t\tsizeof(__be32));\n\tif (cnid != be32_to_cpu(found_cnid))\n\t\treturn -ENOENT;\n\n\thfs_bnode_read(fd->bnode, &record_type,\n\t\t\tfd->entryoffset, sizeof(record_type));\n\n\tswitch (be32_to_cpu(record_type)) {\n\tcase HFSPLUS_ATTR_INLINE_DATA:\n\t\t/* All is OK. Do nothing. */\n\t\tbreak;\n\tcase HFSPLUS_ATTR_FORK_DATA:\n\tcase HFSPLUS_ATTR_EXTENTS:\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tpr_err(\"invalid extended attribute record\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\terr = hfs_brec_remove(fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_create_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "193-258",
    "snippet": "int hfsplus_create_attr(struct inode *inode,\n\t\t\t\tconst char *name,\n\t\t\t\tconst void *value, size_t size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry_ptr;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(ATTR_MOD, \"create_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry_ptr = hfsplus_alloc_attr_entry();\n\tif (!entry_ptr)\n\t\treturn -ENOMEM;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\tgoto failed_init_create_attr;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto failed_create_attr;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto failed_create_attr;\n\t}\n\n\t/* Mac OS X supports only inline data attributes. */\n\tentry_size = hfsplus_attr_build_record(entry_ptr,\n\t\t\t\t\tHFSPLUS_ATTR_INLINE_DATA,\n\t\t\t\t\tinode->i_ino,\n\t\t\t\t\tvalue, size);\n\tif (entry_size == HFSPLUS_INVALID_ATTR_RECORD) {\n\t\terr = -EINVAL;\n\t\tgoto failed_create_attr;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto failed_create_attr;\n\t}\n\n\terr = hfs_brec_insert(&fd, entry_ptr, entry_size);\n\tif (err)\n\t\tgoto failed_create_attr;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\nfailed_create_attr:\n\thfs_find_exit(&fd);\n\nfailed_init_create_attr:\n\thfsplus_destroy_attr_entry(entry_ptr);\n\treturn err;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [
      "#define HFSPLUS_INVALID_ATTR_RECORD -1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_destroy_attr_entry",
          "args": [
            "entry_ptr"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_destroy_attr_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "87-91",
          "snippet": "void hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nvoid hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "inode",
            "HFSPLUS_I_ATTR_DIRTY"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_insert",
          "args": [
            "&fd",
            "entry_ptr",
            "entry_size"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "62-175",
          "snippet": "int hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd",
            "hfs_find_rec_by_key"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_attr_build_record",
          "args": [
            "entry_ptr",
            "HFSPLUS_ATTR_INLINE_DATA",
            "inode->i_ino",
            "value",
            "size"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_attr_build_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "95-134",
          "snippet": "static int hfsplus_attr_build_record(hfsplus_attr_entry *entry, int record_type,\n\t\t\t\tu32 cnid, const void *value, size_t size)\n{\n\tif (record_type == HFSPLUS_ATTR_FORK_DATA) {\n\t\t/*\n\t\t * Mac OS X supports only inline data attributes.\n\t\t * Do nothing\n\t\t */\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\treturn sizeof(struct hfsplus_attr_fork_data);\n\t} else if (record_type == HFSPLUS_ATTR_EXTENTS) {\n\t\t/*\n\t\t * Mac OS X supports only inline data attributes.\n\t\t * Do nothing.\n\t\t */\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\treturn sizeof(struct hfsplus_attr_extents);\n\t} else if (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\tu16 len;\n\n\t\tmemset(entry, 0, sizeof(struct hfsplus_attr_inline_data));\n\t\tentry->inline_data.record_type = cpu_to_be32(record_type);\n\t\tif (size <= HFSPLUS_MAX_INLINE_DATA_SIZE)\n\t\t\tlen = size;\n\t\telse\n\t\t\treturn HFSPLUS_INVALID_ATTR_RECORD;\n\t\tentry->inline_data.length = cpu_to_be16(len);\n\t\tmemcpy(entry->inline_data.raw_bytes, value, len);\n\t\t/*\n\t\t * Align len on two-byte boundary.\n\t\t * It needs to add pad byte if we have odd len.\n\t\t */\n\t\tlen = round_up(len, 2);\n\t\treturn offsetof(struct hfsplus_attr_inline_data, raw_bytes) +\n\t\t\t\t\tlen;\n\t} else /* invalid input */\n\t\tmemset(entry, 0, sizeof(*entry));\n\n\treturn HFSPLUS_INVALID_ATTR_RECORD;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [
            "#define HFSPLUS_INVALID_ATTR_RECORD -1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\n#define HFSPLUS_INVALID_ATTR_RECORD -1\n\nstatic int hfsplus_attr_build_record(hfsplus_attr_entry *entry, int record_type,\n\t\t\t\tu32 cnid, const void *value, size_t size)\n{\n\tif (record_type == HFSPLUS_ATTR_FORK_DATA) {\n\t\t/*\n\t\t * Mac OS X supports only inline data attributes.\n\t\t * Do nothing\n\t\t */\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\treturn sizeof(struct hfsplus_attr_fork_data);\n\t} else if (record_type == HFSPLUS_ATTR_EXTENTS) {\n\t\t/*\n\t\t * Mac OS X supports only inline data attributes.\n\t\t * Do nothing.\n\t\t */\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\treturn sizeof(struct hfsplus_attr_extents);\n\t} else if (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\tu16 len;\n\n\t\tmemset(entry, 0, sizeof(struct hfsplus_attr_inline_data));\n\t\tentry->inline_data.record_type = cpu_to_be32(record_type);\n\t\tif (size <= HFSPLUS_MAX_INLINE_DATA_SIZE)\n\t\t\tlen = size;\n\t\telse\n\t\t\treturn HFSPLUS_INVALID_ATTR_RECORD;\n\t\tentry->inline_data.length = cpu_to_be16(len);\n\t\tmemcpy(entry->inline_data.raw_bytes, value, len);\n\t\t/*\n\t\t * Align len on two-byte boundary.\n\t\t * It needs to add pad byte if we have odd len.\n\t\t */\n\t\tlen = round_up(len, 2);\n\t\treturn offsetof(struct hfsplus_attr_inline_data, raw_bytes) +\n\t\t\t\t\tlen;\n\t} else /* invalid input */\n\t\tmemset(entry, 0, sizeof(*entry));\n\n\treturn HFSPLUS_INVALID_ATTR_RECORD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_attr_build_key",
          "args": [
            "sb",
            "fd.search_key",
            "inode->i_ino",
            "name"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_attr_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "49-80",
          "snippet": "int hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\tu32 cnid, const char *name)\n{\n\tint len;\n\n\tmemset(key, 0, sizeof(struct hfsplus_attr_key));\n\tkey->attr.cnid = cpu_to_be32(cnid);\n\tif (name) {\n\t\tint res = hfsplus_asc2uni(sb,\n\t\t\t\t(struct hfsplus_unistr *)&key->attr.key_name,\n\t\t\t\tHFSPLUS_ATTR_MAX_STRLEN, name, strlen(name));\n\t\tif (res)\n\t\t\treturn res;\n\t\tlen = be16_to_cpu(key->attr.key_name.length);\n\t} else {\n\t\tkey->attr.key_name.length = 0;\n\t\tlen = 0;\n\t}\n\n\t/* The length of the key, as stored in key_len field, does not include\n\t * the size of the key_len field itself.\n\t * So, offsetof(hfsplus_attr_key, key_name) is a trick because\n\t * it takes into consideration key_len field (__be16) of\n\t * hfsplus_attr_key structure instead of length field (__be16) of\n\t * hfsplus_attr_unistr structure.\n\t */\n\tkey->key_len =\n\t\tcpu_to_be16(offsetof(struct hfsplus_attr_key, key_name) +\n\t\t\t\t2 * len);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\tu32 cnid, const char *name)\n{\n\tint len;\n\n\tmemset(key, 0, sizeof(struct hfsplus_attr_key));\n\tkey->attr.cnid = cpu_to_be32(cnid);\n\tif (name) {\n\t\tint res = hfsplus_asc2uni(sb,\n\t\t\t\t(struct hfsplus_unistr *)&key->attr.key_name,\n\t\t\t\tHFSPLUS_ATTR_MAX_STRLEN, name, strlen(name));\n\t\tif (res)\n\t\t\treturn res;\n\t\tlen = be16_to_cpu(key->attr.key_name.length);\n\t} else {\n\t\tkey->attr.key_name.length = 0;\n\t\tlen = 0;\n\t}\n\n\t/* The length of the key, as stored in key_len field, does not include\n\t * the size of the key_len field itself.\n\t * So, offsetof(hfsplus_attr_key, key_name) is a trick because\n\t * it takes into consideration key_len field (__be16) of\n\t * hfsplus_attr_key structure instead of length field (__be16) of\n\t * hfsplus_attr_unistr structure.\n\t */\n\tkey->key_len =\n\t\tcpu_to_be16(offsetof(struct hfsplus_attr_key, key_name) +\n\t\t\t\t2 * len);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(sb)->attr_tree",
            "&fd"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_alloc_attr_entry",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_alloc_attr_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "82-85",
          "snippet": "hfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nhfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"attributes file doesn't exist\\n\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "ATTR_MOD",
            "\"create_attr: %s,%ld\\n\"",
            "name ? name : NULL",
            "inode->i_ino"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\n#define HFSPLUS_INVALID_ATTR_RECORD -1\n\nint hfsplus_create_attr(struct inode *inode,\n\t\t\t\tconst char *name,\n\t\t\t\tconst void *value, size_t size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry_ptr;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(ATTR_MOD, \"create_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry_ptr = hfsplus_alloc_attr_entry();\n\tif (!entry_ptr)\n\t\treturn -ENOMEM;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\tgoto failed_init_create_attr;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto failed_create_attr;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto failed_create_attr;\n\t}\n\n\t/* Mac OS X supports only inline data attributes. */\n\tentry_size = hfsplus_attr_build_record(entry_ptr,\n\t\t\t\t\tHFSPLUS_ATTR_INLINE_DATA,\n\t\t\t\t\tinode->i_ino,\n\t\t\t\t\tvalue, size);\n\tif (entry_size == HFSPLUS_INVALID_ATTR_RECORD) {\n\t\terr = -EINVAL;\n\t\tgoto failed_create_attr;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto failed_create_attr;\n\t}\n\n\terr = hfs_brec_insert(&fd, entry_ptr, entry_size);\n\tif (err)\n\t\tgoto failed_create_attr;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\nfailed_create_attr:\n\thfs_find_exit(&fd);\n\nfailed_init_create_attr:\n\thfsplus_destroy_attr_entry(entry_ptr);\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_attr_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "168-191",
    "snippet": "int hfsplus_attr_exists(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\tif (!HFSPLUS_SB(sb)->attr_tree)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn 0;\n\n\terr = hfsplus_find_attr(sb, inode->i_ino, name, &fd);\n\tif (err)\n\t\tgoto attr_not_found;\n\n\thfs_find_exit(&fd);\n\treturn 1;\n\nattr_not_found:\n\thfs_find_exit(&fd);\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_find_attr",
          "args": [
            "sb",
            "inode->i_ino",
            "name",
            "&fd"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_find_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "136-166",
          "snippet": "int hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(sb)->attr_tree",
            "&fd"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_attr_exists(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\tif (!HFSPLUS_SB(sb)->attr_tree)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn 0;\n\n\terr = hfsplus_find_attr(sb, inode->i_ino, name, &fd);\n\tif (err)\n\t\tgoto attr_not_found;\n\n\thfs_find_exit(&fd);\n\treturn 1;\n\nattr_not_found:\n\thfs_find_exit(&fd);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_find_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "136-166",
    "snippet": "int hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "fd",
            "hfs_find_1st_rec_by_cnid"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_attr_build_key",
          "args": [
            "sb",
            "fd->search_key",
            "cnid",
            "NULL"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_attr_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "49-80",
          "snippet": "int hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\tu32 cnid, const char *name)\n{\n\tint len;\n\n\tmemset(key, 0, sizeof(struct hfsplus_attr_key));\n\tkey->attr.cnid = cpu_to_be32(cnid);\n\tif (name) {\n\t\tint res = hfsplus_asc2uni(sb,\n\t\t\t\t(struct hfsplus_unistr *)&key->attr.key_name,\n\t\t\t\tHFSPLUS_ATTR_MAX_STRLEN, name, strlen(name));\n\t\tif (res)\n\t\t\treturn res;\n\t\tlen = be16_to_cpu(key->attr.key_name.length);\n\t} else {\n\t\tkey->attr.key_name.length = 0;\n\t\tlen = 0;\n\t}\n\n\t/* The length of the key, as stored in key_len field, does not include\n\t * the size of the key_len field itself.\n\t * So, offsetof(hfsplus_attr_key, key_name) is a trick because\n\t * it takes into consideration key_len field (__be16) of\n\t * hfsplus_attr_key structure instead of length field (__be16) of\n\t * hfsplus_attr_unistr structure.\n\t */\n\tkey->key_len =\n\t\tcpu_to_be16(offsetof(struct hfsplus_attr_key, key_name) +\n\t\t\t\t2 * len);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\tu32 cnid, const char *name)\n{\n\tint len;\n\n\tmemset(key, 0, sizeof(struct hfsplus_attr_key));\n\tkey->attr.cnid = cpu_to_be32(cnid);\n\tif (name) {\n\t\tint res = hfsplus_asc2uni(sb,\n\t\t\t\t(struct hfsplus_unistr *)&key->attr.key_name,\n\t\t\t\tHFSPLUS_ATTR_MAX_STRLEN, name, strlen(name));\n\t\tif (res)\n\t\t\treturn res;\n\t\tlen = be16_to_cpu(key->attr.key_name.length);\n\t} else {\n\t\tkey->attr.key_name.length = 0;\n\t\tlen = 0;\n\t}\n\n\t/* The length of the key, as stored in key_len field, does not include\n\t * the size of the key_len field itself.\n\t * So, offsetof(hfsplus_attr_key, key_name) is a trick because\n\t * it takes into consideration key_len field (__be16) of\n\t * hfsplus_attr_key structure instead of length field (__be16) of\n\t * hfsplus_attr_unistr structure.\n\t */\n\tkey->key_len =\n\t\tcpu_to_be16(offsetof(struct hfsplus_attr_key, key_name) +\n\t\t\t\t2 * len);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"attributes file doesn't exist\\n\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "ATTR_MOD",
            "\"find_attr: %s,%d\\n\"",
            "name ? name : NULL",
            "cnid"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_attr_build_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "95-134",
    "snippet": "static int hfsplus_attr_build_record(hfsplus_attr_entry *entry, int record_type,\n\t\t\t\tu32 cnid, const void *value, size_t size)\n{\n\tif (record_type == HFSPLUS_ATTR_FORK_DATA) {\n\t\t/*\n\t\t * Mac OS X supports only inline data attributes.\n\t\t * Do nothing\n\t\t */\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\treturn sizeof(struct hfsplus_attr_fork_data);\n\t} else if (record_type == HFSPLUS_ATTR_EXTENTS) {\n\t\t/*\n\t\t * Mac OS X supports only inline data attributes.\n\t\t * Do nothing.\n\t\t */\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\treturn sizeof(struct hfsplus_attr_extents);\n\t} else if (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\tu16 len;\n\n\t\tmemset(entry, 0, sizeof(struct hfsplus_attr_inline_data));\n\t\tentry->inline_data.record_type = cpu_to_be32(record_type);\n\t\tif (size <= HFSPLUS_MAX_INLINE_DATA_SIZE)\n\t\t\tlen = size;\n\t\telse\n\t\t\treturn HFSPLUS_INVALID_ATTR_RECORD;\n\t\tentry->inline_data.length = cpu_to_be16(len);\n\t\tmemcpy(entry->inline_data.raw_bytes, value, len);\n\t\t/*\n\t\t * Align len on two-byte boundary.\n\t\t * It needs to add pad byte if we have odd len.\n\t\t */\n\t\tlen = round_up(len, 2);\n\t\treturn offsetof(struct hfsplus_attr_inline_data, raw_bytes) +\n\t\t\t\t\tlen;\n\t} else /* invalid input */\n\t\tmemset(entry, 0, sizeof(*entry));\n\n\treturn HFSPLUS_INVALID_ATTR_RECORD;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [
      "#define HFSPLUS_INVALID_ATTR_RECORD -1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entry",
            "0",
            "sizeof(*entry)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "len",
            "2"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->inline_data.raw_bytes",
            "value",
            "len"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "len"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "record_type"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entry",
            "0",
            "sizeof(struct hfsplus_attr_inline_data)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entry",
            "0",
            "sizeof(*entry)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entry",
            "0",
            "sizeof(*entry)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\n#define HFSPLUS_INVALID_ATTR_RECORD -1\n\nstatic int hfsplus_attr_build_record(hfsplus_attr_entry *entry, int record_type,\n\t\t\t\tu32 cnid, const void *value, size_t size)\n{\n\tif (record_type == HFSPLUS_ATTR_FORK_DATA) {\n\t\t/*\n\t\t * Mac OS X supports only inline data attributes.\n\t\t * Do nothing\n\t\t */\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\treturn sizeof(struct hfsplus_attr_fork_data);\n\t} else if (record_type == HFSPLUS_ATTR_EXTENTS) {\n\t\t/*\n\t\t * Mac OS X supports only inline data attributes.\n\t\t * Do nothing.\n\t\t */\n\t\tmemset(entry, 0, sizeof(*entry));\n\t\treturn sizeof(struct hfsplus_attr_extents);\n\t} else if (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\tu16 len;\n\n\t\tmemset(entry, 0, sizeof(struct hfsplus_attr_inline_data));\n\t\tentry->inline_data.record_type = cpu_to_be32(record_type);\n\t\tif (size <= HFSPLUS_MAX_INLINE_DATA_SIZE)\n\t\t\tlen = size;\n\t\telse\n\t\t\treturn HFSPLUS_INVALID_ATTR_RECORD;\n\t\tentry->inline_data.length = cpu_to_be16(len);\n\t\tmemcpy(entry->inline_data.raw_bytes, value, len);\n\t\t/*\n\t\t * Align len on two-byte boundary.\n\t\t * It needs to add pad byte if we have odd len.\n\t\t */\n\t\tlen = round_up(len, 2);\n\t\treturn offsetof(struct hfsplus_attr_inline_data, raw_bytes) +\n\t\t\t\t\tlen;\n\t} else /* invalid input */\n\t\tmemset(entry, 0, sizeof(*entry));\n\n\treturn HFSPLUS_INVALID_ATTR_RECORD;\n}"
  },
  {
    "function_name": "hfsplus_destroy_attr_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "87-91",
    "snippet": "void hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hfsplus_attr_tree_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "hfsplus_attr_tree_cachep",
            "entry"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nvoid hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}"
  },
  {
    "function_name": "hfsplus_alloc_attr_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "82-85",
    "snippet": "hfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hfsplus_attr_tree_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "hfsplus_attr_tree_cachep",
            "GFP_KERNEL"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nhfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}"
  },
  {
    "function_name": "hfsplus_attr_build_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "49-80",
    "snippet": "int hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\tu32 cnid, const char *name)\n{\n\tint len;\n\n\tmemset(key, 0, sizeof(struct hfsplus_attr_key));\n\tkey->attr.cnid = cpu_to_be32(cnid);\n\tif (name) {\n\t\tint res = hfsplus_asc2uni(sb,\n\t\t\t\t(struct hfsplus_unistr *)&key->attr.key_name,\n\t\t\t\tHFSPLUS_ATTR_MAX_STRLEN, name, strlen(name));\n\t\tif (res)\n\t\t\treturn res;\n\t\tlen = be16_to_cpu(key->attr.key_name.length);\n\t} else {\n\t\tkey->attr.key_name.length = 0;\n\t\tlen = 0;\n\t}\n\n\t/* The length of the key, as stored in key_len field, does not include\n\t * the size of the key_len field itself.\n\t * So, offsetof(hfsplus_attr_key, key_name) is a trick because\n\t * it takes into consideration key_len field (__be16) of\n\t * hfsplus_attr_key structure instead of length field (__be16) of\n\t * hfsplus_attr_unistr structure.\n\t */\n\tkey->key_len =\n\t\tcpu_to_be16(offsetof(struct hfsplus_attr_key, key_name) +\n\t\t\t\t2 * len);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "offsetof(struct hfsplus_attr_key, key_name) +\n\t\t\t\t2 * len"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "key->attr.key_name.length"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_asc2uni",
          "args": [
            "sb",
            "(struct hfsplus_unistr *)&key->attr.key_name",
            "HFSPLUS_ATTR_MAX_STRLEN",
            "name",
            "strlen(name)"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_asc2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "298-330",
          "snippet": "int hfsplus_asc2uni(struct super_block *sb,\n\t\t    struct hfsplus_unistr *ustr, int max_unistr_len,\n\t\t    const char *astr, int len)\n{\n\tint size, dsize, decompose;\n\tu16 *dstr, outlen = 0;\n\twchar_t c;\n\n\tdecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\twhile (outlen < max_unistr_len && len > 0) {\n\t\tsize = asc2unichar(sb, astr, len, &c);\n\n\t\tif (decompose)\n\t\t\tdstr = decompose_unichar(c, &dsize);\n\t\telse\n\t\t\tdstr = NULL;\n\t\tif (dstr) {\n\t\t\tif (outlen + dsize > max_unistr_len)\n\t\t\t\tbreak;\n\t\t\tdo {\n\t\t\t\tustr->unicode[outlen++] = cpu_to_be16(*dstr++);\n\t\t\t} while (--dsize > 0);\n\t\t} else\n\t\t\tustr->unicode[outlen++] = cpu_to_be16(c);\n\n\t\tastr += size;\n\t\tlen -= size;\n\t}\n\tustr->length = cpu_to_be16(outlen);\n\tif (len > 0)\n\t\treturn -ENAMETOOLONG;\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_asc2uni(struct super_block *sb,\n\t\t    struct hfsplus_unistr *ustr, int max_unistr_len,\n\t\t    const char *astr, int len)\n{\n\tint size, dsize, decompose;\n\tu16 *dstr, outlen = 0;\n\twchar_t c;\n\n\tdecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\twhile (outlen < max_unistr_len && len > 0) {\n\t\tsize = asc2unichar(sb, astr, len, &c);\n\n\t\tif (decompose)\n\t\t\tdstr = decompose_unichar(c, &dsize);\n\t\telse\n\t\t\tdstr = NULL;\n\t\tif (dstr) {\n\t\t\tif (outlen + dsize > max_unistr_len)\n\t\t\t\tbreak;\n\t\t\tdo {\n\t\t\t\tustr->unicode[outlen++] = cpu_to_be16(*dstr++);\n\t\t\t} while (--dsize > 0);\n\t\t} else\n\t\t\tustr->unicode[outlen++] = cpu_to_be16(c);\n\n\t\tastr += size;\n\t\tlen -= size;\n\t}\n\tustr->length = cpu_to_be16(outlen);\n\tif (len > 0)\n\t\treturn -ENAMETOOLONG;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cnid"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key",
            "0",
            "sizeof(struct hfsplus_attr_key)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\tu32 cnid, const char *name)\n{\n\tint len;\n\n\tmemset(key, 0, sizeof(struct hfsplus_attr_key));\n\tkey->attr.cnid = cpu_to_be32(cnid);\n\tif (name) {\n\t\tint res = hfsplus_asc2uni(sb,\n\t\t\t\t(struct hfsplus_unistr *)&key->attr.key_name,\n\t\t\t\tHFSPLUS_ATTR_MAX_STRLEN, name, strlen(name));\n\t\tif (res)\n\t\t\treturn res;\n\t\tlen = be16_to_cpu(key->attr.key_name.length);\n\t} else {\n\t\tkey->attr.key_name.length = 0;\n\t\tlen = 0;\n\t}\n\n\t/* The length of the key, as stored in key_len field, does not include\n\t * the size of the key_len field itself.\n\t * So, offsetof(hfsplus_attr_key, key_name) is a trick because\n\t * it takes into consideration key_len field (__be16) of\n\t * hfsplus_attr_key structure instead of length field (__be16) of\n\t * hfsplus_attr_unistr structure.\n\t */\n\tkey->key_len =\n\t\tcpu_to_be16(offsetof(struct hfsplus_attr_key, key_name) +\n\t\t\t\t2 * len);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_attr_bin_cmp_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "34-47",
    "snippet": "int hfsplus_attr_bin_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t\tconst hfsplus_btree_key *k2)\n{\n\t__be32 k1_cnid, k2_cnid;\n\n\tk1_cnid = k1->attr.cnid;\n\tk2_cnid = k2->attr.cnid;\n\tif (k1_cnid != k2_cnid)\n\t\treturn be32_to_cpu(k1_cnid) < be32_to_cpu(k2_cnid) ? -1 : 1;\n\n\treturn hfsplus_strcmp(\n\t\t\t(const struct hfsplus_unistr *)&k1->attr.key_name,\n\t\t\t(const struct hfsplus_unistr *)&k2->attr.key_name);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_strcmp",
          "args": [
            "(const struct hfsplus_unistr *)&k1->attr.key_name",
            "(const struct hfsplus_unistr *)&k2->attr.key_name"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "64-87",
          "snippet": "int hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k2_cnid"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k1_cnid"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_attr_bin_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t\tconst hfsplus_btree_key *k2)\n{\n\t__be32 k1_cnid, k2_cnid;\n\n\tk1_cnid = k1->attr.cnid;\n\tk2_cnid = k2->attr.cnid;\n\tif (k1_cnid != k2_cnid)\n\t\treturn be32_to_cpu(k1_cnid) < be32_to_cpu(k2_cnid) ? -1 : 1;\n\n\treturn hfsplus_strcmp(\n\t\t\t(const struct hfsplus_unistr *)&k1->attr.key_name,\n\t\t\t(const struct hfsplus_unistr *)&k2->attr.key_name);\n}"
  },
  {
    "function_name": "hfsplus_destroy_attr_tree_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "29-32",
    "snippet": "void hfsplus_destroy_attr_tree_cache(void)\n{\n\tkmem_cache_destroy(hfsplus_attr_tree_cachep);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hfsplus_attr_tree_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "hfsplus_attr_tree_cachep"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nvoid hfsplus_destroy_attr_tree_cache(void)\n{\n\tkmem_cache_destroy(hfsplus_attr_tree_cachep);\n}"
  },
  {
    "function_name": "hfsplus_create_attr_tree_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
    "lines": "14-27",
    "snippet": "int __init hfsplus_create_attr_tree_cache(void)\n{\n\tif (hfsplus_attr_tree_cachep)\n\t\treturn -EEXIST;\n\n\thfsplus_attr_tree_cachep =\n\t\tkmem_cache_create(\"hfsplus_attr_cache\",\n\t\t\tsizeof(hfsplus_attr_entry), 0,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!hfsplus_attr_tree_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hfsplus_attr_tree_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"hfsplus_attr_cache\"",
            "sizeof(hfsplus_attr_entry)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nint __init hfsplus_create_attr_tree_cache(void)\n{\n\tif (hfsplus_attr_tree_cachep)\n\t\treturn -EEXIST;\n\n\thfsplus_attr_tree_cachep =\n\t\tkmem_cache_create(\"hfsplus_attr_cache\",\n\t\t\tsizeof(hfsplus_attr_entry), 0,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!hfsplus_attr_tree_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  }
]