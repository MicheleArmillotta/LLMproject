[
  {
    "function_name": "ext2_count_dirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
    "lines": "662-674",
    "snippet": "unsigned long ext2_count_dirs (struct super_block * sb)\n{\n\tunsigned long count = 0;\n\tint i;\n\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += le16_to_cpu(gdp->bg_used_dirs_count);\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/random.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gdp->bg_used_dirs_count"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nunsigned long ext2_count_dirs (struct super_block * sb)\n{\n\tunsigned long count = 0;\n\tint i;\n\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += le16_to_cpu(gdp->bg_used_dirs_count);\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "ext2_count_free_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
    "lines": "615-659",
    "snippet": "unsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/random.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "desc->bg_free_inodes_count"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\"",
            "(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter)",
            "desc_count",
            "bitmap_count"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_read",
          "args": [
            "&EXT2_SB(sb)->s_freeinodes_counter"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_count_free",
          "args": [
            "bitmap_bh",
            "EXT2_INODES_PER_GROUP(sb) / 8"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_count_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1439-1442",
          "snippet": "unsigned long ext2_count_free(struct buffer_head *map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nunsigned long ext2_count_free(struct buffer_head *map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_inode_bitmap",
          "args": [
            "sb",
            "i"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "read_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "45-63",
          "snippet": "static struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext2_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text2_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext2_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text2_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nunsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}"
  },
  {
    "function_name": "ext2_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
    "lines": "430-613",
    "snippet": "struct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/random.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_preread_inode",
          "args": [
            "inode"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_preread_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "165-192",
          "snippet": "static void ext2_preread_inode(struct inode *inode)\n{\n\tunsigned long block_group;\n\tunsigned long offset;\n\tunsigned long block;\n\tstruct ext2_group_desc * gdp;\n\tstruct backing_dev_info *bdi;\n\n\tbdi = inode_to_bdi(inode);\n\tif (bdi_read_congested(bdi))\n\t\treturn;\n\tif (bdi_write_congested(bdi))\n\t\treturn;\n\n\tblock_group = (inode->i_ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tgdp = ext2_get_group_desc(inode->i_sb, block_group, NULL);\n\tif (gdp == NULL)\n\t\treturn;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((inode->i_ino - 1) % EXT2_INODES_PER_GROUP(inode->i_sb)) *\n\t\t\t\tEXT2_INODE_SIZE(inode->i_sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t\t\t(offset >> EXT2_BLOCK_SIZE_BITS(inode->i_sb));\n\tsb_breadahead(inode->i_sb, block);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic void ext2_preread_inode(struct inode *inode)\n{\n\tunsigned long block_group;\n\tunsigned long offset;\n\tunsigned long block;\n\tstruct ext2_group_desc * gdp;\n\tstruct backing_dev_info *bdi;\n\n\tbdi = inode_to_bdi(inode);\n\tif (bdi_read_congested(bdi))\n\t\treturn;\n\tif (bdi_write_congested(bdi))\n\t\treturn;\n\n\tblock_group = (inode->i_ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tgdp = ext2_get_group_desc(inode->i_sb, block_group, NULL);\n\tif (gdp == NULL)\n\t\treturn;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((inode->i_ino - 1) % EXT2_INODES_PER_GROUP(inode->i_sb)) *\n\t\t\t\tEXT2_INODE_SIZE(inode->i_sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t\t\t(offset >> EXT2_BLOCK_SIZE_BITS(inode->i_sb));\n\tsb_breadahead(inode->i_sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_debug",
          "args": [
            "\"allocating inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_init_security",
          "args": [
            "inode",
            "dir",
            "qstr"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_init_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr_security.c",
          "lines": "61-67",
          "snippet": "int\next2_init_security(struct inode *inode, struct inode *dir,\n\t\t   const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ext2_initxattrs, NULL);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include <linux/security.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include <linux/security.h>\n#include \"ext2.h\"\n\nint\next2_init_security(struct inode *inode, struct inode *dir,\n\t\t   const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ext2_initxattrs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_init_acl",
          "args": [
            "inode",
            "dir"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_init_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/acl.c",
          "lines": "237-257",
          "snippet": "int\next2_init_acl(struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = ext2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = ext2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nint\next2_init_acl(struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = ext2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = ext2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_inode",
          "args": [
            "inode"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1651-1685",
          "snippet": "int dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "\"ext2_new_inode\"",
            "\"inode number already in use - inode=%lu\"",
            "(unsigned long) ino"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_locked",
          "args": [
            "inode"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1323-1362",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1273-1291",
          "snippet": "void ext2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT2_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t\tS_DIRSYNC | S_DAX);\n\tif (flags & EXT2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tinode->i_flags |= S_DAX;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nvoid ext2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT2_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t\tS_DIRSYNC | S_DAX);\n\tif (flags & EXT2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tinode->i_flags |= S_DAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_mask_flags",
          "args": [
            "mode",
            "EXT2_I(dir)->i_flags & EXT2_FL_INHERITED"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_mask_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "266-274",
          "snippet": "static inline __u32 ext2_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT2_REG_FLMASK;\n\telse\n\t\treturn flags & EXT2_OTHER_FLMASK;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT2_OTHER_FLMASK (EXT2_NODUMP_FL | EXT2_NOATIME_FL)",
            "#define EXT2_REG_FLMASK (~(EXT2_DIRSYNC_FL | EXT2_TOPDIR_FL))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\n#define EXT2_OTHER_FLMASK (EXT2_NODUMP_FL | EXT2_NOATIME_FL)\n#define EXT2_REG_FLMASK (~(EXT2_DIRSYNC_FL | EXT2_TOPDIR_FL))\n\nstatic inline __u32 ext2_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT2_REG_FLMASK;\n\telse\n\t\treturn flags & EXT2_OTHER_FLMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "dir"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ei->i_data",
            "0",
            "sizeof(ei->i_data)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPID"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh2"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "sbi",
            "group"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "116-120",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&gdp->bg_used_dirs_count",
            "1"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&gdp->bg_free_inodes_count",
            "-1"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_inc",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_freeinodes_counter",
            "-1"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_inodes_count"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bitmap_bh"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_set_bit_atomic",
          "args": [
            "sb_bgl_lock(sbi, group)",
            "ino",
            "bitmap_bh->b_data"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_find_next_zero_bit",
          "args": [
            "(unsigned long *)bitmap_bh->b_data",
            "EXT2_INODES_PER_GROUP(sb)",
            "ino"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_inode_bitmap",
          "args": [
            "sb",
            "group"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "read_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "45-63",
          "snippet": "static struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext2_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text2_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext2_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text2_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "group",
            "&bh2"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_group_other",
          "args": [
            "sb",
            "dir"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "find_group_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "370-428",
          "snippet": "static int find_group_other(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT2_I(parent)->i_block_group;\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tstruct ext2_group_desc *desc;\n\tint group, i;\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\tgroup = parent_group;\n\tdesc = ext2_get_group_desc (sb, group, NULL);\n\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\tgoto found;\n\n\t/*\n\t * We're going to place this inode in a different blockgroup from its\n\t * parent.  We want to cause files in a common directory to all land in\n\t * the same blockgroup.  But we want files which are in a different\n\t * directory which shares a blockgroup with our parent to land in a\n\t * different blockgroup.\n\t *\n\t * So add our directory's i_ino into the starting point for the hash.\n\t */\n\tgroup = (group + parent->i_ino) % ngroups;\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode and some\n\t * free blocks.\n\t */\n\tfor (i = 1; i < ngroups; i <<= 1) {\n\t\tgroup += i;\n\t\tif (group >= ngroups)\n\t\t\tgroup -= ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\t\tgoto found;\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode, even if that group\n\t * has no free blocks.\n\t */\n\tgroup = parent_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count))\n\t\t\tgoto found;\n\t}\n\n\treturn -1;\n\nfound:\n\treturn group;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic int find_group_other(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT2_I(parent)->i_block_group;\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tstruct ext2_group_desc *desc;\n\tint group, i;\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\tgroup = parent_group;\n\tdesc = ext2_get_group_desc (sb, group, NULL);\n\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\tgoto found;\n\n\t/*\n\t * We're going to place this inode in a different blockgroup from its\n\t * parent.  We want to cause files in a common directory to all land in\n\t * the same blockgroup.  But we want files which are in a different\n\t * directory which shares a blockgroup with our parent to land in a\n\t * different blockgroup.\n\t *\n\t * So add our directory's i_ino into the starting point for the hash.\n\t */\n\tgroup = (group + parent->i_ino) % ngroups;\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode and some\n\t * free blocks.\n\t */\n\tfor (i = 1; i < ngroups; i <<= 1) {\n\t\tgroup += i;\n\t\tif (group >= ngroups)\n\t\t\tgroup -= ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\t\tgoto found;\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode, even if that group\n\t * has no free blocks.\n\t */\n\tgroup = parent_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count))\n\t\t\tgoto found;\n\t}\n\n\treturn -1;\n\nfound:\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_group_orlov",
          "args": [
            "sb",
            "dir"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "find_group_orlov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "258-368",
          "snippet": "static int find_group_orlov(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT2_I(parent)->i_block_group;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tint ngroups = sbi->s_groups_count;\n\tint inodes_per_group = EXT2_INODES_PER_GROUP(sb);\n\tint freei;\n\tint avefreei;\n\tint free_blocks;\n\tint avefreeb;\n\tint blocks_per_dir;\n\tint ndirs;\n\tint max_debt, max_dirs, min_blocks, min_inodes;\n\tint group = -1, i;\n\tstruct ext2_group_desc *desc;\n\n\tfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\n\tavefreei = freei / ngroups;\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\tavefreeb = free_blocks / ngroups;\n\tndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\n\n\tif ((parent == sb->s_root->d_inode) ||\n\t    (EXT2_I(parent)->i_flags & EXT2_TOPDIR_FL)) {\n\t\tstruct ext2_group_desc *best_desc = NULL;\n\t\tint best_ndir = inodes_per_group;\n\t\tint best_group = -1;\n\n\t\tgroup = prandom_u32();\n\t\tparent_group = (unsigned)group % ngroups;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgroup = (parent_group + i) % ngroups;\n\t\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < avefreeb)\n\t\t\t\tcontinue;\n\t\t\tbest_group = group;\n\t\t\tbest_ndir = le16_to_cpu(desc->bg_used_dirs_count);\n\t\t\tbest_desc = desc;\n\t\t}\n\t\tif (best_group >= 0) {\n\t\t\tdesc = best_desc;\n\t\t\tgroup = best_group;\n\t\t\tgoto found;\n\t\t}\n\t\tgoto fallback;\n\t}\n\n\tif (ndirs == 0)\n\t\tndirs = 1;\t/* percpu_counters are approximate... */\n\n\tblocks_per_dir = (le32_to_cpu(es->s_blocks_count)-free_blocks) / ndirs;\n\n\tmax_dirs = ndirs / ngroups + inodes_per_group / 16;\n\tmin_inodes = avefreei - inodes_per_group / 4;\n\tmin_blocks = avefreeb - EXT2_BLOCKS_PER_GROUP(sb) / 4;\n\n\tmax_debt = EXT2_BLOCKS_PER_GROUP(sb) / max(blocks_per_dir, BLOCK_COST);\n\tif (max_debt * INODE_COST > inodes_per_group)\n\t\tmax_debt = inodes_per_group / INODE_COST;\n\tif (max_debt > 255)\n\t\tmax_debt = 255;\n\tif (max_debt == 0)\n\t\tmax_debt = 1;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (sbi->s_debts[group] >= max_debt)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= max_dirs)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < min_inodes)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < min_blocks)\n\t\t\tcontinue;\n\t\tgoto found;\n\t}\n\nfallback:\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)\n\t\t\tgoto found;\n\t}\n\n\tif (avefreei) {\n\t\t/*\n\t\t * The free-inodes counter is approximate, and for really small\n\t\t * filesystems the above test can fail to find any blockgroups\n\t\t */\n\t\tavefreei = 0;\n\t\tgoto fallback;\n\t}\n\n\treturn -1;\n\nfound:\n\treturn group;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [
            "#define BLOCK_COST 256",
            "#define INODE_COST 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\n#define BLOCK_COST 256\n#define INODE_COST 64\n\nstatic int find_group_orlov(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT2_I(parent)->i_block_group;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tint ngroups = sbi->s_groups_count;\n\tint inodes_per_group = EXT2_INODES_PER_GROUP(sb);\n\tint freei;\n\tint avefreei;\n\tint free_blocks;\n\tint avefreeb;\n\tint blocks_per_dir;\n\tint ndirs;\n\tint max_debt, max_dirs, min_blocks, min_inodes;\n\tint group = -1, i;\n\tstruct ext2_group_desc *desc;\n\n\tfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\n\tavefreei = freei / ngroups;\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\tavefreeb = free_blocks / ngroups;\n\tndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\n\n\tif ((parent == sb->s_root->d_inode) ||\n\t    (EXT2_I(parent)->i_flags & EXT2_TOPDIR_FL)) {\n\t\tstruct ext2_group_desc *best_desc = NULL;\n\t\tint best_ndir = inodes_per_group;\n\t\tint best_group = -1;\n\n\t\tgroup = prandom_u32();\n\t\tparent_group = (unsigned)group % ngroups;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgroup = (parent_group + i) % ngroups;\n\t\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < avefreeb)\n\t\t\t\tcontinue;\n\t\t\tbest_group = group;\n\t\t\tbest_ndir = le16_to_cpu(desc->bg_used_dirs_count);\n\t\t\tbest_desc = desc;\n\t\t}\n\t\tif (best_group >= 0) {\n\t\t\tdesc = best_desc;\n\t\t\tgroup = best_group;\n\t\t\tgoto found;\n\t\t}\n\t\tgoto fallback;\n\t}\n\n\tif (ndirs == 0)\n\t\tndirs = 1;\t/* percpu_counters are approximate... */\n\n\tblocks_per_dir = (le32_to_cpu(es->s_blocks_count)-free_blocks) / ndirs;\n\n\tmax_dirs = ndirs / ngroups + inodes_per_group / 16;\n\tmin_inodes = avefreei - inodes_per_group / 4;\n\tmin_blocks = avefreeb - EXT2_BLOCKS_PER_GROUP(sb) / 4;\n\n\tmax_debt = EXT2_BLOCKS_PER_GROUP(sb) / max(blocks_per_dir, BLOCK_COST);\n\tif (max_debt * INODE_COST > inodes_per_group)\n\t\tmax_debt = inodes_per_group / INODE_COST;\n\tif (max_debt > 255)\n\t\tmax_debt = 255;\n\tif (max_debt == 0)\n\t\tmax_debt = 1;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (sbi->s_debts[group] >= max_debt)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= max_dirs)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < min_inodes)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < min_blocks)\n\t\t\tcontinue;\n\t\tgoto found;\n\t}\n\nfallback:\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)\n\t\t\tgoto found;\n\t}\n\n\tif (avefreei) {\n\t\t/*\n\t\t * The free-inodes counter is approximate, and for really small\n\t\t * filesystems the above test can fail to find any blockgroups\n\t\t */\n\t\tavefreei = 0;\n\t\tgoto fallback;\n\t}\n\n\treturn -1;\n\nfound:\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_group_dir",
          "args": [
            "sb",
            "dir"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "find_group_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "204-228",
          "snippet": "static int find_group_dir(struct super_block *sb, struct inode *parent)\n{\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tint avefreei = ext2_count_free_inodes(sb) / ngroups;\n\tstruct ext2_group_desc *desc, *best_desc = NULL;\n\tint group, best_group = -1;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\tcontinue;\n\t\tif (!best_desc || \n\t\t    (le16_to_cpu(desc->bg_free_blocks_count) >\n\t\t     le16_to_cpu(best_desc->bg_free_blocks_count))) {\n\t\t\tbest_group = group;\n\t\t\tbest_desc = desc;\n\t\t}\n\t}\n\tif (!best_desc)\n\t\treturn -1;\n\n\treturn best_group;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic int find_group_dir(struct super_block *sb, struct inode *parent)\n{\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tint avefreei = ext2_count_free_inodes(sb) / ngroups;\n\tstruct ext2_group_desc *desc, *best_desc = NULL;\n\tint group, best_group = -1;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\tcontinue;\n\t\tif (!best_desc || \n\t\t    (le16_to_cpu(desc->bg_free_blocks_count) >\n\t\t     le16_to_cpu(best_desc->bg_free_blocks_count))) {\n\t\t\tbest_group = group;\n\t\t\tbest_desc = desc;\n\t\t}\n\t}\n\tif (!best_desc)\n\t\treturn -1;\n\n\treturn best_group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "OLDALLOC"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "find_group_other",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
    "lines": "370-428",
    "snippet": "static int find_group_other(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT2_I(parent)->i_block_group;\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tstruct ext2_group_desc *desc;\n\tint group, i;\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\tgroup = parent_group;\n\tdesc = ext2_get_group_desc (sb, group, NULL);\n\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\tgoto found;\n\n\t/*\n\t * We're going to place this inode in a different blockgroup from its\n\t * parent.  We want to cause files in a common directory to all land in\n\t * the same blockgroup.  But we want files which are in a different\n\t * directory which shares a blockgroup with our parent to land in a\n\t * different blockgroup.\n\t *\n\t * So add our directory's i_ino into the starting point for the hash.\n\t */\n\tgroup = (group + parent->i_ino) % ngroups;\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode and some\n\t * free blocks.\n\t */\n\tfor (i = 1; i < ngroups; i <<= 1) {\n\t\tgroup += i;\n\t\tif (group >= ngroups)\n\t\t\tgroup -= ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\t\tgoto found;\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode, even if that group\n\t * has no free blocks.\n\t */\n\tgroup = parent_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count))\n\t\t\tgoto found;\n\t}\n\n\treturn -1;\n\nfound:\n\treturn group;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/random.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "desc->bg_free_inodes_count"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "group",
            "NULL"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "parent"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic int find_group_other(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT2_I(parent)->i_block_group;\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tstruct ext2_group_desc *desc;\n\tint group, i;\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\tgroup = parent_group;\n\tdesc = ext2_get_group_desc (sb, group, NULL);\n\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\tgoto found;\n\n\t/*\n\t * We're going to place this inode in a different blockgroup from its\n\t * parent.  We want to cause files in a common directory to all land in\n\t * the same blockgroup.  But we want files which are in a different\n\t * directory which shares a blockgroup with our parent to land in a\n\t * different blockgroup.\n\t *\n\t * So add our directory's i_ino into the starting point for the hash.\n\t */\n\tgroup = (group + parent->i_ino) % ngroups;\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode and some\n\t * free blocks.\n\t */\n\tfor (i = 1; i < ngroups; i <<= 1) {\n\t\tgroup += i;\n\t\tif (group >= ngroups)\n\t\t\tgroup -= ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\t\tgoto found;\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode, even if that group\n\t * has no free blocks.\n\t */\n\tgroup = parent_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count))\n\t\t\tgoto found;\n\t}\n\n\treturn -1;\n\nfound:\n\treturn group;\n}"
  },
  {
    "function_name": "find_group_orlov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
    "lines": "258-368",
    "snippet": "static int find_group_orlov(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT2_I(parent)->i_block_group;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tint ngroups = sbi->s_groups_count;\n\tint inodes_per_group = EXT2_INODES_PER_GROUP(sb);\n\tint freei;\n\tint avefreei;\n\tint free_blocks;\n\tint avefreeb;\n\tint blocks_per_dir;\n\tint ndirs;\n\tint max_debt, max_dirs, min_blocks, min_inodes;\n\tint group = -1, i;\n\tstruct ext2_group_desc *desc;\n\n\tfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\n\tavefreei = freei / ngroups;\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\tavefreeb = free_blocks / ngroups;\n\tndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\n\n\tif ((parent == sb->s_root->d_inode) ||\n\t    (EXT2_I(parent)->i_flags & EXT2_TOPDIR_FL)) {\n\t\tstruct ext2_group_desc *best_desc = NULL;\n\t\tint best_ndir = inodes_per_group;\n\t\tint best_group = -1;\n\n\t\tgroup = prandom_u32();\n\t\tparent_group = (unsigned)group % ngroups;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgroup = (parent_group + i) % ngroups;\n\t\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < avefreeb)\n\t\t\t\tcontinue;\n\t\t\tbest_group = group;\n\t\t\tbest_ndir = le16_to_cpu(desc->bg_used_dirs_count);\n\t\t\tbest_desc = desc;\n\t\t}\n\t\tif (best_group >= 0) {\n\t\t\tdesc = best_desc;\n\t\t\tgroup = best_group;\n\t\t\tgoto found;\n\t\t}\n\t\tgoto fallback;\n\t}\n\n\tif (ndirs == 0)\n\t\tndirs = 1;\t/* percpu_counters are approximate... */\n\n\tblocks_per_dir = (le32_to_cpu(es->s_blocks_count)-free_blocks) / ndirs;\n\n\tmax_dirs = ndirs / ngroups + inodes_per_group / 16;\n\tmin_inodes = avefreei - inodes_per_group / 4;\n\tmin_blocks = avefreeb - EXT2_BLOCKS_PER_GROUP(sb) / 4;\n\n\tmax_debt = EXT2_BLOCKS_PER_GROUP(sb) / max(blocks_per_dir, BLOCK_COST);\n\tif (max_debt * INODE_COST > inodes_per_group)\n\t\tmax_debt = inodes_per_group / INODE_COST;\n\tif (max_debt > 255)\n\t\tmax_debt = 255;\n\tif (max_debt == 0)\n\t\tmax_debt = 1;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (sbi->s_debts[group] >= max_debt)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= max_dirs)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < min_inodes)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < min_blocks)\n\t\t\tcontinue;\n\t\tgoto found;\n\t}\n\nfallback:\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)\n\t\t\tgoto found;\n\t}\n\n\tif (avefreei) {\n\t\t/*\n\t\t * The free-inodes counter is approximate, and for really small\n\t\t * filesystems the above test can fail to find any blockgroups\n\t\t */\n\t\tavefreei = 0;\n\t\tgoto fallback;\n\t}\n\n\treturn -1;\n\nfound:\n\treturn group;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/random.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [
      "#define BLOCK_COST 256",
      "#define INODE_COST 64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "desc->bg_free_inodes_count"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "group",
            "NULL"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "blocks_per_dir",
            "BLOCK_COST"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_blocks_count"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "parent"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_freeblocks_counter"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\n#define BLOCK_COST 256\n#define INODE_COST 64\n\nstatic int find_group_orlov(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT2_I(parent)->i_block_group;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tint ngroups = sbi->s_groups_count;\n\tint inodes_per_group = EXT2_INODES_PER_GROUP(sb);\n\tint freei;\n\tint avefreei;\n\tint free_blocks;\n\tint avefreeb;\n\tint blocks_per_dir;\n\tint ndirs;\n\tint max_debt, max_dirs, min_blocks, min_inodes;\n\tint group = -1, i;\n\tstruct ext2_group_desc *desc;\n\n\tfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\n\tavefreei = freei / ngroups;\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\tavefreeb = free_blocks / ngroups;\n\tndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\n\n\tif ((parent == sb->s_root->d_inode) ||\n\t    (EXT2_I(parent)->i_flags & EXT2_TOPDIR_FL)) {\n\t\tstruct ext2_group_desc *best_desc = NULL;\n\t\tint best_ndir = inodes_per_group;\n\t\tint best_group = -1;\n\n\t\tgroup = prandom_u32();\n\t\tparent_group = (unsigned)group % ngroups;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgroup = (parent_group + i) % ngroups;\n\t\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < avefreeb)\n\t\t\t\tcontinue;\n\t\t\tbest_group = group;\n\t\t\tbest_ndir = le16_to_cpu(desc->bg_used_dirs_count);\n\t\t\tbest_desc = desc;\n\t\t}\n\t\tif (best_group >= 0) {\n\t\t\tdesc = best_desc;\n\t\t\tgroup = best_group;\n\t\t\tgoto found;\n\t\t}\n\t\tgoto fallback;\n\t}\n\n\tif (ndirs == 0)\n\t\tndirs = 1;\t/* percpu_counters are approximate... */\n\n\tblocks_per_dir = (le32_to_cpu(es->s_blocks_count)-free_blocks) / ndirs;\n\n\tmax_dirs = ndirs / ngroups + inodes_per_group / 16;\n\tmin_inodes = avefreei - inodes_per_group / 4;\n\tmin_blocks = avefreeb - EXT2_BLOCKS_PER_GROUP(sb) / 4;\n\n\tmax_debt = EXT2_BLOCKS_PER_GROUP(sb) / max(blocks_per_dir, BLOCK_COST);\n\tif (max_debt * INODE_COST > inodes_per_group)\n\t\tmax_debt = inodes_per_group / INODE_COST;\n\tif (max_debt > 255)\n\t\tmax_debt = 255;\n\tif (max_debt == 0)\n\t\tmax_debt = 1;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (sbi->s_debts[group] >= max_debt)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= max_dirs)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < min_inodes)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < min_blocks)\n\t\t\tcontinue;\n\t\tgoto found;\n\t}\n\nfallback:\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)\n\t\t\tgoto found;\n\t}\n\n\tif (avefreei) {\n\t\t/*\n\t\t * The free-inodes counter is approximate, and for really small\n\t\t * filesystems the above test can fail to find any blockgroups\n\t\t */\n\t\tavefreei = 0;\n\t\tgoto fallback;\n\t}\n\n\treturn -1;\n\nfound:\n\treturn group;\n}"
  },
  {
    "function_name": "find_group_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
    "lines": "204-228",
    "snippet": "static int find_group_dir(struct super_block *sb, struct inode *parent)\n{\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tint avefreei = ext2_count_free_inodes(sb) / ngroups;\n\tstruct ext2_group_desc *desc, *best_desc = NULL;\n\tint group, best_group = -1;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\tcontinue;\n\t\tif (!best_desc || \n\t\t    (le16_to_cpu(desc->bg_free_blocks_count) >\n\t\t     le16_to_cpu(best_desc->bg_free_blocks_count))) {\n\t\t\tbest_group = group;\n\t\t\tbest_desc = desc;\n\t\t}\n\t}\n\tif (!best_desc)\n\t\treturn -1;\n\n\treturn best_group;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/random.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "best_desc->bg_free_blocks_count"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "group",
            "NULL"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_count_free_inodes",
          "args": [
            "sb"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_count_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "615-659",
          "snippet": "unsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nunsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic int find_group_dir(struct super_block *sb, struct inode *parent)\n{\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tint avefreei = ext2_count_free_inodes(sb) / ngroups;\n\tstruct ext2_group_desc *desc, *best_desc = NULL;\n\tint group, best_group = -1;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\tcontinue;\n\t\tif (!best_desc || \n\t\t    (le16_to_cpu(desc->bg_free_blocks_count) >\n\t\t     le16_to_cpu(best_desc->bg_free_blocks_count))) {\n\t\t\tbest_group = group;\n\t\t\tbest_desc = desc;\n\t\t}\n\t}\n\tif (!best_desc)\n\t\treturn -1;\n\n\treturn best_group;\n}"
  },
  {
    "function_name": "ext2_preread_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
    "lines": "165-192",
    "snippet": "static void ext2_preread_inode(struct inode *inode)\n{\n\tunsigned long block_group;\n\tunsigned long offset;\n\tunsigned long block;\n\tstruct ext2_group_desc * gdp;\n\tstruct backing_dev_info *bdi;\n\n\tbdi = inode_to_bdi(inode);\n\tif (bdi_read_congested(bdi))\n\t\treturn;\n\tif (bdi_write_congested(bdi))\n\t\treturn;\n\n\tblock_group = (inode->i_ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tgdp = ext2_get_group_desc(inode->i_sb, block_group, NULL);\n\tif (gdp == NULL)\n\t\treturn;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((inode->i_ino - 1) % EXT2_INODES_PER_GROUP(inode->i_sb)) *\n\t\t\t\tEXT2_INODE_SIZE(inode->i_sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t\t\t(offset >> EXT2_BLOCK_SIZE_BITS(inode->i_sb));\n\tsb_breadahead(inode->i_sb, block);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/random.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_breadahead",
          "args": [
            "inode->i_sb",
            "block"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCK_SIZE_BITS",
          "args": [
            "inode->i_sb"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "gdp->bg_inode_table"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "inode->i_sb",
            "block_group",
            "NULL"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_write_congested",
          "args": [
            "bdi"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_read_congested",
          "args": [
            "bdi"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic void ext2_preread_inode(struct inode *inode)\n{\n\tunsigned long block_group;\n\tunsigned long offset;\n\tunsigned long block;\n\tstruct ext2_group_desc * gdp;\n\tstruct backing_dev_info *bdi;\n\n\tbdi = inode_to_bdi(inode);\n\tif (bdi_read_congested(bdi))\n\t\treturn;\n\tif (bdi_write_congested(bdi))\n\t\treturn;\n\n\tblock_group = (inode->i_ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tgdp = ext2_get_group_desc(inode->i_sb, block_group, NULL);\n\tif (gdp == NULL)\n\t\treturn;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((inode->i_ino - 1) % EXT2_INODES_PER_GROUP(inode->i_sb)) *\n\t\t\t\tEXT2_INODE_SIZE(inode->i_sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t\t\t(offset >> EXT2_BLOCK_SIZE_BITS(inode->i_sb));\n\tsb_breadahead(inode->i_sb, block);\n}"
  },
  {
    "function_name": "ext2_free_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
    "lines": "103-151",
    "snippet": "void ext2_free_inode (struct inode * inode)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tstruct ext2_super_block * es;\n\n\tino = inode->i_ino;\n\text2_debug (\"freeing inode %lu\\n\", ino);\n\n\t/*\n\t * Note: we must free any quota before locking the superblock,\n\t * as writing the quota to disk may need the lock as well.\n\t */\n\t/* Quota is already initialized in iput() */\n\tdquot_free_inode(inode);\n\tdquot_drop(inode);\n\n\tes = EXT2_SB(sb)->s_es;\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tif (ino < EXT2_FIRST_INO(sb) ||\n\t    ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_free_inode\",\n\t\t\t    \"reserved or nonexistent inode %lu\", ino);\n\t\treturn;\n\t}\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT2_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\treturn;\n\n\t/* Ok, now we can actually update the inode bitmaps.. */\n\tif (!ext2_clear_bit_atomic(sb_bgl_lock(EXT2_SB(sb), block_group),\n\t\t\t\tbit, (void *) bitmap_bh->b_data))\n\t\text2_error (sb, \"ext2_free_inode\",\n\t\t\t      \"bit already cleared for inode %lu\", ino);\n\telse\n\t\text2_release_inode(sb, block_group, is_directory);\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tbrelse(bitmap_bh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/random.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bitmap_bh"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bitmap_bh"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_release_inode",
          "args": [
            "sb",
            "block_group",
            "is_directory"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_release_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "65-85",
          "snippet": "static void ext2_release_inode(struct super_block *sb, int group, int dir)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head *bh;\n\n\tdesc = ext2_get_group_desc(sb, group, &bh);\n\tif (!desc) {\n\t\text2_error(sb, \"ext2_release_inode\",\n\t\t\t\"can't get descriptor for group %d\", group);\n\t\treturn;\n\t}\n\n\tspin_lock(sb_bgl_lock(EXT2_SB(sb), group));\n\tle16_add_cpu(&desc->bg_free_inodes_count, 1);\n\tif (dir)\n\t\tle16_add_cpu(&desc->bg_used_dirs_count, -1);\n\tspin_unlock(sb_bgl_lock(EXT2_SB(sb), group));\n\tif (dir)\n\t\tpercpu_counter_dec(&EXT2_SB(sb)->s_dirs_counter);\n\tmark_buffer_dirty(bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic void ext2_release_inode(struct super_block *sb, int group, int dir)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head *bh;\n\n\tdesc = ext2_get_group_desc(sb, group, &bh);\n\tif (!desc) {\n\t\text2_error(sb, \"ext2_release_inode\",\n\t\t\t\"can't get descriptor for group %d\", group);\n\t\treturn;\n\t}\n\n\tspin_lock(sb_bgl_lock(EXT2_SB(sb), group));\n\tle16_add_cpu(&desc->bg_free_inodes_count, 1);\n\tif (dir)\n\t\tle16_add_cpu(&desc->bg_used_dirs_count, -1);\n\tspin_unlock(sb_bgl_lock(EXT2_SB(sb), group));\n\tif (dir)\n\t\tpercpu_counter_dec(&EXT2_SB(sb)->s_dirs_counter);\n\tmark_buffer_dirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "\"ext2_free_inode\"",
            "\"bit already cleared for inode %lu\"",
            "ino"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_clear_bit_atomic",
          "args": [
            "sb_bgl_lock(EXT2_SB(sb), block_group)",
            "bit",
            "(void *) bitmap_bh->b_data"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "EXT2_SB(sb)",
            "block_group"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "116-120",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_inode_bitmap",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "read_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "45-63",
          "snippet": "static struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext2_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text2_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext2_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text2_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_inodes_count"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_debug",
          "args": [
            "\"freeing inode %lu\\n\"",
            "ino"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nvoid ext2_free_inode (struct inode * inode)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tstruct ext2_super_block * es;\n\n\tino = inode->i_ino;\n\text2_debug (\"freeing inode %lu\\n\", ino);\n\n\t/*\n\t * Note: we must free any quota before locking the superblock,\n\t * as writing the quota to disk may need the lock as well.\n\t */\n\t/* Quota is already initialized in iput() */\n\tdquot_free_inode(inode);\n\tdquot_drop(inode);\n\n\tes = EXT2_SB(sb)->s_es;\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tif (ino < EXT2_FIRST_INO(sb) ||\n\t    ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_free_inode\",\n\t\t\t    \"reserved or nonexistent inode %lu\", ino);\n\t\treturn;\n\t}\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT2_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\treturn;\n\n\t/* Ok, now we can actually update the inode bitmaps.. */\n\tif (!ext2_clear_bit_atomic(sb_bgl_lock(EXT2_SB(sb), block_group),\n\t\t\t\tbit, (void *) bitmap_bh->b_data))\n\t\text2_error (sb, \"ext2_free_inode\",\n\t\t\t      \"bit already cleared for inode %lu\", ino);\n\telse\n\t\text2_release_inode(sb, block_group, is_directory);\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tbrelse(bitmap_bh);\n}"
  },
  {
    "function_name": "ext2_release_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
    "lines": "65-85",
    "snippet": "static void ext2_release_inode(struct super_block *sb, int group, int dir)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head *bh;\n\n\tdesc = ext2_get_group_desc(sb, group, &bh);\n\tif (!desc) {\n\t\text2_error(sb, \"ext2_release_inode\",\n\t\t\t\"can't get descriptor for group %d\", group);\n\t\treturn;\n\t}\n\n\tspin_lock(sb_bgl_lock(EXT2_SB(sb), group));\n\tle16_add_cpu(&desc->bg_free_inodes_count, 1);\n\tif (dir)\n\t\tle16_add_cpu(&desc->bg_used_dirs_count, -1);\n\tspin_unlock(sb_bgl_lock(EXT2_SB(sb), group));\n\tif (dir)\n\t\tpercpu_counter_dec(&EXT2_SB(sb)->s_dirs_counter);\n\tmark_buffer_dirty(bh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/random.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_dec",
          "args": [
            "&EXT2_SB(sb)->s_dirs_counter"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "sb_bgl_lock(EXT2_SB(sb), group)"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "EXT2_SB(sb)",
            "group"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "116-120",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&desc->bg_used_dirs_count",
            "-1"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&desc->bg_free_inodes_count",
            "1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "sb_bgl_lock(EXT2_SB(sb), group)"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "\"ext2_release_inode\"",
            "\"can't get descriptor for group %d\"",
            "group"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "group",
            "&bh"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic void ext2_release_inode(struct super_block *sb, int group, int dir)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head *bh;\n\n\tdesc = ext2_get_group_desc(sb, group, &bh);\n\tif (!desc) {\n\t\text2_error(sb, \"ext2_release_inode\",\n\t\t\t\"can't get descriptor for group %d\", group);\n\t\treturn;\n\t}\n\n\tspin_lock(sb_bgl_lock(EXT2_SB(sb), group));\n\tle16_add_cpu(&desc->bg_free_inodes_count, 1);\n\tif (dir)\n\t\tle16_add_cpu(&desc->bg_used_dirs_count, -1);\n\tspin_unlock(sb_bgl_lock(EXT2_SB(sb), group));\n\tif (dir)\n\t\tpercpu_counter_dec(&EXT2_SB(sb)->s_dirs_counter);\n\tmark_buffer_dirty(bh);\n}"
  },
  {
    "function_name": "read_inode_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
    "lines": "45-63",
    "snippet": "static struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext2_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text2_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/random.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "\"read_inode_bitmap\"",
            "\"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\"",
            "block_group",
            "le32_to_cpu(desc->bg_inode_bitmap)"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "desc->bg_inode_bitmap"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "le32_to_cpu(desc->bg_inode_bitmap)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "NULL"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext2_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text2_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}"
  }
]