[
  {
    "function_name": "exit_hugetlbfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "1066-1082",
    "snippet": "static void __exit exit_hugetlbfs_fs(void)\n{\n\tstruct hstate *h;\n\tint i;\n\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(hugetlbfs_inode_cachep);\n\ti = 0;\n\tfor_each_hstate(h)\n\t\tkern_unmount(hugetlbfs_vfsmount[i++]);\n\tunregister_filesystem(&hugetlbfs_fs_type);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hugetlbfs_inode_cachep;",
      "static struct file_system_type hugetlbfs_fs_type = {\n\t.name\t\t= \"hugetlbfs\",\n\t.mount\t\t= hugetlbfs_mount,\n\t.kill_sb\t= kill_litter_super,\n};",
      "static struct vfsmount *hugetlbfs_vfsmount[HUGE_MAX_HSTATE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&hugetlbfs_fs_type"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "hugetlbfs_inode_cachep"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *hugetlbfs_inode_cachep;\nstatic struct file_system_type hugetlbfs_fs_type = {\n\t.name\t\t= \"hugetlbfs\",\n\t.mount\t\t= hugetlbfs_mount,\n\t.kill_sb\t= kill_litter_super,\n};\nstatic struct vfsmount *hugetlbfs_vfsmount[HUGE_MAX_HSTATE];\n\nstatic void __exit exit_hugetlbfs_fs(void)\n{\n\tstruct hstate *h;\n\tint i;\n\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(hugetlbfs_inode_cachep);\n\ti = 0;\n\tfor_each_hstate(h)\n\t\tkern_unmount(hugetlbfs_vfsmount[i++]);\n\tunregister_filesystem(&hugetlbfs_fs_type);\n}"
  },
  {
    "function_name": "init_hugetlbfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "1017-1064",
    "snippet": "static int __init init_hugetlbfs_fs(void)\n{\n\tstruct hstate *h;\n\tint error;\n\tint i;\n\n\tif (!hugepages_supported()) {\n\t\tpr_info(\"disabling because there are no supported hugepage sizes\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\terror = -ENOMEM;\n\thugetlbfs_inode_cachep = kmem_cache_create(\"hugetlbfs_inode_cache\",\n\t\t\t\t\tsizeof(struct hugetlbfs_inode_info),\n\t\t\t\t\t0, 0, init_once);\n\tif (hugetlbfs_inode_cachep == NULL)\n\t\tgoto out2;\n\n\terror = register_filesystem(&hugetlbfs_fs_type);\n\tif (error)\n\t\tgoto out;\n\n\ti = 0;\n\tfor_each_hstate(h) {\n\t\tchar buf[50];\n\t\tunsigned ps_kb = 1U << (h->order + PAGE_SHIFT - 10);\n\n\t\tsnprintf(buf, sizeof(buf), \"pagesize=%uK\", ps_kb);\n\t\thugetlbfs_vfsmount[i] = kern_mount_data(&hugetlbfs_fs_type,\n\t\t\t\t\t\t\tbuf);\n\n\t\tif (IS_ERR(hugetlbfs_vfsmount[i])) {\n\t\t\tpr_err(\"Cannot mount internal hugetlbfs for \"\n\t\t\t\t\"page size %uK\", ps_kb);\n\t\t\terror = PTR_ERR(hugetlbfs_vfsmount[i]);\n\t\t\thugetlbfs_vfsmount[i] = NULL;\n\t\t}\n\t\ti++;\n\t}\n\t/* Non default hstates are optional */\n\tif (!IS_ERR_OR_NULL(hugetlbfs_vfsmount[default_hstate_idx]))\n\t\treturn 0;\n\n out:\n\tkmem_cache_destroy(hugetlbfs_inode_cachep);\n out2:\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hugetlbfs_inode_cachep;",
      "static struct file_system_type hugetlbfs_fs_type = {\n\t.name\t\t= \"hugetlbfs\",\n\t.mount\t\t= hugetlbfs_mount,\n\t.kill_sb\t= kill_litter_super,\n};",
      "static struct vfsmount *hugetlbfs_vfsmount[HUGE_MAX_HSTATE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "hugetlbfs_inode_cachep"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "hugetlbfs_vfsmount[default_hstate_idx]"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hugetlbfs_vfsmount[i]"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot mount internal hugetlbfs for \"\n\t\t\t\t\"page size %uK\"",
            "ps_kb"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hugetlbfs_vfsmount[i]"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount_data",
          "args": [
            "&hugetlbfs_fs_type",
            "buf"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "kern_mount_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3085-3097",
          "snippet": "struct vfsmount *kern_mount_data(struct file_system_type *type, void *data)\n{\n\tstruct vfsmount *mnt;\n\tmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, data);\n\tif (!IS_ERR(mnt)) {\n\t\t/*\n\t\t * it is a longterm mount, don't release mnt until\n\t\t * we unmount before file sys is unregistered\n\t\t*/\n\t\treal_mount(mnt)->mnt_ns = MNT_NS_INTERNAL;\n\t}\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *kern_mount_data(struct file_system_type *type, void *data)\n{\n\tstruct vfsmount *mnt;\n\tmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, data);\n\tif (!IS_ERR(mnt)) {\n\t\t/*\n\t\t * it is a longterm mount, don't release mnt until\n\t\t * we unmount before file sys is unregistered\n\t\t*/\n\t\treal_mount(mnt)->mnt_ns = MNT_NS_INTERNAL;\n\t}\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"pagesize=%uK\"",
            "ps_kb"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&hugetlbfs_fs_type"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"hugetlbfs_inode_cache\"",
            "sizeof(struct hugetlbfs_inode_info)",
            "0",
            "0",
            "init_once"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"disabling because there are no supported hugepage sizes\\n\""
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepages_supported",
          "args": [],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *hugetlbfs_inode_cachep;\nstatic struct file_system_type hugetlbfs_fs_type = {\n\t.name\t\t= \"hugetlbfs\",\n\t.mount\t\t= hugetlbfs_mount,\n\t.kill_sb\t= kill_litter_super,\n};\nstatic struct vfsmount *hugetlbfs_vfsmount[HUGE_MAX_HSTATE];\n\nstatic int __init init_hugetlbfs_fs(void)\n{\n\tstruct hstate *h;\n\tint error;\n\tint i;\n\n\tif (!hugepages_supported()) {\n\t\tpr_info(\"disabling because there are no supported hugepage sizes\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\terror = -ENOMEM;\n\thugetlbfs_inode_cachep = kmem_cache_create(\"hugetlbfs_inode_cache\",\n\t\t\t\t\tsizeof(struct hugetlbfs_inode_info),\n\t\t\t\t\t0, 0, init_once);\n\tif (hugetlbfs_inode_cachep == NULL)\n\t\tgoto out2;\n\n\terror = register_filesystem(&hugetlbfs_fs_type);\n\tif (error)\n\t\tgoto out;\n\n\ti = 0;\n\tfor_each_hstate(h) {\n\t\tchar buf[50];\n\t\tunsigned ps_kb = 1U << (h->order + PAGE_SHIFT - 10);\n\n\t\tsnprintf(buf, sizeof(buf), \"pagesize=%uK\", ps_kb);\n\t\thugetlbfs_vfsmount[i] = kern_mount_data(&hugetlbfs_fs_type,\n\t\t\t\t\t\t\tbuf);\n\n\t\tif (IS_ERR(hugetlbfs_vfsmount[i])) {\n\t\t\tpr_err(\"Cannot mount internal hugetlbfs for \"\n\t\t\t\t\"page size %uK\", ps_kb);\n\t\t\terror = PTR_ERR(hugetlbfs_vfsmount[i]);\n\t\t\thugetlbfs_vfsmount[i] = NULL;\n\t\t}\n\t\ti++;\n\t}\n\t/* Non default hstates are optional */\n\tif (!IS_ERR_OR_NULL(hugetlbfs_vfsmount[default_hstate_idx]))\n\t\treturn 0;\n\n out:\n\tkmem_cache_destroy(hugetlbfs_inode_cachep);\n out2:\n\treturn error;\n}"
  },
  {
    "function_name": "hugetlb_file_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "941-1015",
    "snippet": "struct file *hugetlb_file_setup(const char *name, size_t size,\n\t\t\t\tvm_flags_t acctflag, struct user_struct **user,\n\t\t\t\tint creat_flags, int page_size_log)\n{\n\tstruct file *file = ERR_PTR(-ENOMEM);\n\tstruct inode *inode;\n\tstruct path path;\n\tstruct super_block *sb;\n\tstruct qstr quick_string;\n\tint hstate_idx;\n\n\thstate_idx = get_hstate_idx(page_size_log);\n\tif (hstate_idx < 0)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t*user = NULL;\n\tif (!hugetlbfs_vfsmount[hstate_idx])\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (creat_flags == HUGETLB_SHMFS_INODE && !can_do_hugetlb_shm()) {\n\t\t*user = current_user();\n\t\tif (user_shm_lock(size, *user)) {\n\t\t\ttask_lock(current);\n\t\t\tpr_warn_once(\"%s (%d): Using mlock ulimits for SHM_HUGETLB is deprecated\\n\",\n\t\t\t\tcurrent->comm, current->pid);\n\t\t\ttask_unlock(current);\n\t\t} else {\n\t\t\t*user = NULL;\n\t\t\treturn ERR_PTR(-EPERM);\n\t\t}\n\t}\n\n\tsb = hugetlbfs_vfsmount[hstate_idx]->mnt_sb;\n\tquick_string.name = name;\n\tquick_string.len = strlen(quick_string.name);\n\tquick_string.hash = 0;\n\tpath.dentry = d_alloc_pseudo(sb, &quick_string);\n\tif (!path.dentry)\n\t\tgoto out_shm_unlock;\n\n\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(hugetlbfs_vfsmount[hstate_idx]);\n\tfile = ERR_PTR(-ENOSPC);\n\tinode = hugetlbfs_get_inode(sb, NULL, S_IFREG | S_IRWXUGO, 0);\n\tif (!inode)\n\t\tgoto out_dentry;\n\n\tfile = ERR_PTR(-ENOMEM);\n\tif (hugetlb_reserve_pages(inode, 0,\n\t\t\tsize >> huge_page_shift(hstate_inode(inode)), NULL,\n\t\t\tacctflag))\n\t\tgoto out_inode;\n\n\td_instantiate(path.dentry, inode);\n\tinode->i_size = size;\n\tclear_nlink(inode);\n\n\tfile = alloc_file(&path, FMODE_WRITE | FMODE_READ,\n\t\t\t&hugetlbfs_file_operations);\n\tif (IS_ERR(file))\n\t\tgoto out_dentry; /* inode is already attached */\n\n\treturn file;\n\nout_inode:\n\tiput(inode);\nout_dentry:\n\tpath_put(&path);\nout_shm_unlock:\n\tif (*user) {\n\t\tuser_shm_unlock(size, *user);\n\t\t*user = NULL;\n\t}\n\treturn file;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations hugetlbfs_file_operations;",
      "const struct file_operations hugetlbfs_file_operations = {\n\t.read\t\t\t= hugetlbfs_read,\n\t.mmap\t\t\t= hugetlbfs_file_mmap,\n\t.fsync\t\t\t= noop_fsync,\n\t.get_unmapped_area\t= hugetlb_get_unmapped_area,\n\t.llseek\t\t= default_llseek,\n};",
      "static struct vfsmount *hugetlbfs_vfsmount[HUGE_MAX_HSTATE];",
      "static const struct dentry_operations anon_ops = {\n\t.d_dname = simple_dname\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_shm_unlock",
          "args": [
            "size",
            "*user"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_file",
          "args": [
            "&path",
            "FMODE_WRITE | FMODE_READ",
            "&hugetlbfs_file_operations"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "158-181",
          "snippet": "struct file *alloc_file(struct path *path, fmode_t mode,\n\t\tconst struct file_operations *fop)\n{\n\tstruct file *file;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_path = *path;\n\tfile->f_inode = path->dentry->d_inode;\n\tfile->f_mapping = path->dentry->d_inode->i_mapping;\n\tif ((mode & FMODE_READ) &&\n\t     likely(fop->read || fop->aio_read || fop->read_iter))\n\t\tmode |= FMODE_CAN_READ;\n\tif ((mode & FMODE_WRITE) &&\n\t     likely(fop->write || fop->aio_write || fop->write_iter))\n\t\tmode |= FMODE_CAN_WRITE;\n\tfile->f_mode = mode;\n\tfile->f_op = fop;\n\tif ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(path->dentry->d_inode);\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_file(struct path *path, fmode_t mode,\n\t\tconst struct file_operations *fop)\n{\n\tstruct file *file;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_path = *path;\n\tfile->f_inode = path->dentry->d_inode;\n\tfile->f_mapping = path->dentry->d_inode->i_mapping;\n\tif ((mode & FMODE_READ) &&\n\t     likely(fop->read || fop->aio_read || fop->read_iter))\n\t\tmode |= FMODE_CAN_READ;\n\tif ((mode & FMODE_WRITE) &&\n\t     likely(fop->write || fop->aio_write || fop->write_iter))\n\t\tmode |= FMODE_CAN_WRITE;\n\tfile->f_mode = mode;\n\tfile->f_op = fop;\n\tif ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(path->dentry->d_inode);\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "path.dentry",
            "inode"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_reserve_pages",
          "args": [
            "inode",
            "0",
            "size >> huge_page_shift(hstate_inode(inode))",
            "NULL",
            "acctflag"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "hstate_inode(inode)"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_inode",
          "args": [
            "inode"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlbfs_get_inode",
          "args": [
            "sb",
            "NULL",
            "S_IFREG | S_IRWXUGO",
            "0"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "476-530",
          "snippet": "static struct inode *hugetlbfs_get_inode(struct super_block *sb,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tumode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tstruct resv_map *resv_map;\n\n\tresv_map = resv_map_alloc();\n\tif (!resv_map)\n\t\treturn NULL;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tlockdep_set_class(&inode->i_mapping->i_mmap_rwsem,\n\t\t\t\t&hugetlbfs_i_mmap_rwsem_key);\n\t\tinode->i_mapping->a_ops = &hugetlbfs_aops;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_mapping->private_data = resv_map;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\t/*\n\t\t * The policy is initialized here even if we are creating a\n\t\t * private inode because initialization simply creates an\n\t\t * an empty rb tree and calls spin_lock_init(), later when we\n\t\t * call mpol_free_shared_policy() it will just return because\n\t\t * the rb tree will still be empty.\n\t\t */\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &hugetlbfs_inode_operations;\n\t\t\tinode->i_fop = &hugetlbfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t} else\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\n\treturn inode;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations hugetlbfs_aops;",
            "const struct file_operations hugetlbfs_file_operations;",
            "static const struct inode_operations hugetlbfs_dir_inode_operations;",
            "static const struct inode_operations hugetlbfs_inode_operations;",
            "static struct lock_class_key hugetlbfs_i_mmap_rwsem_key;",
            "static const struct address_space_operations hugetlbfs_aops = {\n\t.write_begin\t= hugetlbfs_write_begin,\n\t.write_end\t= hugetlbfs_write_end,\n\t.set_page_dirty\t= hugetlbfs_set_page_dirty,\n\t.migratepage    = hugetlbfs_migrate_page,\n};",
            "const struct file_operations hugetlbfs_file_operations = {\n\t.read\t\t\t= hugetlbfs_read,\n\t.mmap\t\t\t= hugetlbfs_file_mmap,\n\t.fsync\t\t\t= noop_fsync,\n\t.get_unmapped_area\t= hugetlb_get_unmapped_area,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};",
            "static const struct inode_operations hugetlbfs_inode_operations = {\n\t.setattr\t= hugetlbfs_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic const struct address_space_operations hugetlbfs_aops;\nconst struct file_operations hugetlbfs_file_operations;\nstatic const struct inode_operations hugetlbfs_dir_inode_operations;\nstatic const struct inode_operations hugetlbfs_inode_operations;\nstatic struct lock_class_key hugetlbfs_i_mmap_rwsem_key;\nstatic const struct address_space_operations hugetlbfs_aops = {\n\t.write_begin\t= hugetlbfs_write_begin,\n\t.write_end\t= hugetlbfs_write_end,\n\t.set_page_dirty\t= hugetlbfs_set_page_dirty,\n\t.migratepage    = hugetlbfs_migrate_page,\n};\nconst struct file_operations hugetlbfs_file_operations = {\n\t.read\t\t\t= hugetlbfs_read,\n\t.mmap\t\t\t= hugetlbfs_file_mmap,\n\t.fsync\t\t\t= noop_fsync,\n\t.get_unmapped_area\t= hugetlb_get_unmapped_area,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};\nstatic const struct inode_operations hugetlbfs_inode_operations = {\n\t.setattr\t= hugetlbfs_setattr,\n};\n\nstatic struct inode *hugetlbfs_get_inode(struct super_block *sb,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tumode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tstruct resv_map *resv_map;\n\n\tresv_map = resv_map_alloc();\n\tif (!resv_map)\n\t\treturn NULL;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tlockdep_set_class(&inode->i_mapping->i_mmap_rwsem,\n\t\t\t\t&hugetlbfs_i_mmap_rwsem_key);\n\t\tinode->i_mapping->a_ops = &hugetlbfs_aops;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_mapping->private_data = resv_map;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\t/*\n\t\t * The policy is initialized here even if we are creating a\n\t\t * private inode because initialization simply creates an\n\t\t * an empty rb tree and calls spin_lock_init(), later when we\n\t\t * call mpol_free_shared_policy() it will just return because\n\t\t * the rb tree will still be empty.\n\t\t */\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &hugetlbfs_inode_operations;\n\t\t\tinode->i_fop = &hugetlbfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t} else\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "hugetlbfs_vfsmount[hstate_idx]"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1130-1135",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "path.dentry",
            "&anon_ops"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_pseudo",
          "args": [
            "sb",
            "&quick_string"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1618-1621",
          "snippet": "struct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "quick_string.name"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"%s (%d): Using mlock ulimits for SHM_HUGETLB is deprecated\\n\"",
            "current->comm",
            "current->pid"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_shm_lock",
          "args": [
            "size",
            "*user"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user",
          "args": [],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_do_hugetlb_shm",
          "args": [],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "can_do_hugetlb_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "917-922",
          "snippet": "static int can_do_hugetlb_shm(void)\n{\n\tkgid_t shm_group;\n\tshm_group = make_kgid(&init_user_ns, sysctl_hugetlb_shm_group);\n\treturn capable(CAP_IPC_LOCK) || in_group_p(shm_group);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_hugetlb_shm_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nint sysctl_hugetlb_shm_group;\n\nstatic int can_do_hugetlb_shm(void)\n{\n\tkgid_t shm_group;\n\tshm_group = make_kgid(&init_user_ns, sysctl_hugetlb_shm_group);\n\treturn capable(CAP_IPC_LOCK) || in_group_p(shm_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hstate_idx",
          "args": [
            "page_size_log"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "get_hstate_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "924-931",
          "snippet": "static int get_hstate_idx(int page_size_log)\n{\n\tstruct hstate *h = hstate_sizelog(page_size_log);\n\n\tif (!h)\n\t\treturn -1;\n\treturn h - hstates;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int get_hstate_idx(int page_size_log)\n{\n\tstruct hstate *h = hstate_sizelog(page_size_log);\n\n\tif (!h)\n\t\treturn -1;\n\treturn h - hstates;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nconst struct file_operations hugetlbfs_file_operations;\nconst struct file_operations hugetlbfs_file_operations = {\n\t.read\t\t\t= hugetlbfs_read,\n\t.mmap\t\t\t= hugetlbfs_file_mmap,\n\t.fsync\t\t\t= noop_fsync,\n\t.get_unmapped_area\t= hugetlb_get_unmapped_area,\n\t.llseek\t\t= default_llseek,\n};\nstatic struct vfsmount *hugetlbfs_vfsmount[HUGE_MAX_HSTATE];\nstatic const struct dentry_operations anon_ops = {\n\t.d_dname = simple_dname\n};\n\nstruct file *hugetlb_file_setup(const char *name, size_t size,\n\t\t\t\tvm_flags_t acctflag, struct user_struct **user,\n\t\t\t\tint creat_flags, int page_size_log)\n{\n\tstruct file *file = ERR_PTR(-ENOMEM);\n\tstruct inode *inode;\n\tstruct path path;\n\tstruct super_block *sb;\n\tstruct qstr quick_string;\n\tint hstate_idx;\n\n\thstate_idx = get_hstate_idx(page_size_log);\n\tif (hstate_idx < 0)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t*user = NULL;\n\tif (!hugetlbfs_vfsmount[hstate_idx])\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (creat_flags == HUGETLB_SHMFS_INODE && !can_do_hugetlb_shm()) {\n\t\t*user = current_user();\n\t\tif (user_shm_lock(size, *user)) {\n\t\t\ttask_lock(current);\n\t\t\tpr_warn_once(\"%s (%d): Using mlock ulimits for SHM_HUGETLB is deprecated\\n\",\n\t\t\t\tcurrent->comm, current->pid);\n\t\t\ttask_unlock(current);\n\t\t} else {\n\t\t\t*user = NULL;\n\t\t\treturn ERR_PTR(-EPERM);\n\t\t}\n\t}\n\n\tsb = hugetlbfs_vfsmount[hstate_idx]->mnt_sb;\n\tquick_string.name = name;\n\tquick_string.len = strlen(quick_string.name);\n\tquick_string.hash = 0;\n\tpath.dentry = d_alloc_pseudo(sb, &quick_string);\n\tif (!path.dentry)\n\t\tgoto out_shm_unlock;\n\n\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(hugetlbfs_vfsmount[hstate_idx]);\n\tfile = ERR_PTR(-ENOSPC);\n\tinode = hugetlbfs_get_inode(sb, NULL, S_IFREG | S_IRWXUGO, 0);\n\tif (!inode)\n\t\tgoto out_dentry;\n\n\tfile = ERR_PTR(-ENOMEM);\n\tif (hugetlb_reserve_pages(inode, 0,\n\t\t\tsize >> huge_page_shift(hstate_inode(inode)), NULL,\n\t\t\tacctflag))\n\t\tgoto out_inode;\n\n\td_instantiate(path.dentry, inode);\n\tinode->i_size = size;\n\tclear_nlink(inode);\n\n\tfile = alloc_file(&path, FMODE_WRITE | FMODE_READ,\n\t\t\t&hugetlbfs_file_operations);\n\tif (IS_ERR(file))\n\t\tgoto out_dentry; /* inode is already attached */\n\n\treturn file;\n\nout_inode:\n\tiput(inode);\nout_dentry:\n\tpath_put(&path);\nout_shm_unlock:\n\tif (*user) {\n\t\tuser_shm_unlock(size, *user);\n\t\t*user = NULL;\n\t}\n\treturn file;\n}"
  },
  {
    "function_name": "get_hstate_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "924-931",
    "snippet": "static int get_hstate_idx(int page_size_log)\n{\n\tstruct hstate *h = hstate_sizelog(page_size_log);\n\n\tif (!h)\n\t\treturn -1;\n\treturn h - hstates;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hstate_sizelog",
          "args": [
            "page_size_log"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int get_hstate_idx(int page_size_log)\n{\n\tstruct hstate *h = hstate_sizelog(page_size_log);\n\n\tif (!h)\n\t\treturn -1;\n\treturn h - hstates;\n}"
  },
  {
    "function_name": "can_do_hugetlb_shm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "917-922",
    "snippet": "static int can_do_hugetlb_shm(void)\n{\n\tkgid_t shm_group;\n\tshm_group = make_kgid(&init_user_ns, sysctl_hugetlb_shm_group);\n\treturn capable(CAP_IPC_LOCK) || in_group_p(shm_group);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_hugetlb_shm_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "shm_group"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_IPC_LOCK"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "sysctl_hugetlb_shm_group"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nint sysctl_hugetlb_shm_group;\n\nstatic int can_do_hugetlb_shm(void)\n{\n\tkgid_t shm_group;\n\tshm_group = make_kgid(&init_user_ns, sysctl_hugetlb_shm_group);\n\treturn capable(CAP_IPC_LOCK) || in_group_p(shm_group);\n}"
  },
  {
    "function_name": "hugetlbfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "902-906",
    "snippet": "static struct dentry *hugetlbfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, hugetlbfs_fill_super);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_nodev",
          "args": [
            "fs_type",
            "flags",
            "data",
            "hugetlbfs_fill_super"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic struct dentry *hugetlbfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, hugetlbfs_fill_super);\n}"
  },
  {
    "function_name": "hugetlbfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "853-900",
    "snippet": "static int\nhugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint ret;\n\tstruct hugetlbfs_config config;\n\tstruct hugetlbfs_sb_info *sbinfo;\n\n\tsave_mount_options(sb, data);\n\n\tconfig.nr_blocks = -1; /* No limit on size by default */\n\tconfig.nr_inodes = -1; /* No limit on number of inodes by default */\n\tconfig.uid = current_fsuid();\n\tconfig.gid = current_fsgid();\n\tconfig.mode = 0755;\n\tconfig.hstate = &default_hstate;\n\tret = hugetlbfs_parse_options(data, &config);\n\tif (ret)\n\t\treturn ret;\n\n\tsbinfo = kmalloc(sizeof(struct hugetlbfs_sb_info), GFP_KERNEL);\n\tif (!sbinfo)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbinfo;\n\tsbinfo->hstate = config.hstate;\n\tspin_lock_init(&sbinfo->stat_lock);\n\tsbinfo->max_inodes = config.nr_inodes;\n\tsbinfo->free_inodes = config.nr_inodes;\n\tsbinfo->spool = NULL;\n\tif (config.nr_blocks != -1) {\n\t\tsbinfo->spool = hugepage_new_subpool(config.nr_blocks);\n\t\tif (!sbinfo->spool)\n\t\t\tgoto out_free;\n\t}\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize = huge_page_size(config.hstate);\n\tsb->s_blocksize_bits = huge_page_shift(config.hstate);\n\tsb->s_magic = HUGETLBFS_MAGIC;\n\tsb->s_op = &hugetlbfs_ops;\n\tsb->s_time_gran = 1;\n\tsb->s_root = d_make_root(hugetlbfs_get_root(sb, &config));\n\tif (!sb->s_root)\n\t\tgoto out_free;\n\treturn 0;\nout_free:\n\tkfree(sbinfo->spool);\n\tkfree(sbinfo);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations hugetlbfs_ops;",
      "static const struct super_operations hugetlbfs_ops = {\n\t.alloc_inode    = hugetlbfs_alloc_inode,\n\t.destroy_inode  = hugetlbfs_destroy_inode,\n\t.evict_inode\t= hugetlbfs_evict_inode,\n\t.statfs\t\t= hugetlbfs_statfs,\n\t.put_super\t= hugetlbfs_put_super,\n\t.show_options\t= generic_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbinfo"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbinfo->spool"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "hugetlbfs_get_root(sb, &config)"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlbfs_get_root",
          "args": [
            "sb",
            "&config"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "444-466",
          "snippet": "static struct inode *hugetlbfs_get_root(struct super_block *sb,\n\t\t\t\t\tstruct hugetlbfs_config *config)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = S_IFDIR | config->mode;\n\t\tinode->i_uid = config->uid;\n\t\tinode->i_gid = config->gid;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations hugetlbfs_dir_inode_operations;",
            "static const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations hugetlbfs_dir_inode_operations;\nstatic const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};\n\nstatic struct inode *hugetlbfs_get_root(struct super_block *sb,\n\t\t\t\t\tstruct hugetlbfs_config *config)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = S_IFDIR | config->mode;\n\t\tinode->i_uid = config->uid;\n\t\tinode->i_gid = config->gid;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "config.hstate"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "config.hstate"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_new_subpool",
          "args": [
            "config.nr_blocks"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbinfo->stat_lock"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct hugetlbfs_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlbfs_parse_options",
          "args": [
            "data",
            "&config"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "757-851",
          "snippet": "static int\nhugetlbfs_parse_options(char *options, struct hugetlbfs_config *pconfig)\n{\n\tchar *p, *rest;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tunsigned long long size = 0;\n\tenum { NO_SIZE, SIZE_STD, SIZE_PERCENT } setsize = NO_SIZE;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(pconfig->uid))\n\t\t\t\tgoto bad_val;\n\t\t\tbreak;\n\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(pconfig->gid))\n\t\t\t\tgoto bad_val;\n\t\t\tbreak;\n\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->mode = option & 01777U;\n\t\t\tbreak;\n\n\t\tcase Opt_size: {\n\t\t\t/* memparse() will accept a K/M/G without a digit */\n\t\t\tif (!isdigit(*args[0].from))\n\t\t\t\tgoto bad_val;\n\t\t\tsize = memparse(args[0].from, &rest);\n\t\t\tsetsize = SIZE_STD;\n\t\t\tif (*rest == '%')\n\t\t\t\tsetsize = SIZE_PERCENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_nr_inodes:\n\t\t\t/* memparse() will accept a K/M/G without a digit */\n\t\t\tif (!isdigit(*args[0].from))\n\t\t\t\tgoto bad_val;\n\t\t\tpconfig->nr_inodes = memparse(args[0].from, &rest);\n\t\t\tbreak;\n\n\t\tcase Opt_pagesize: {\n\t\t\tunsigned long ps;\n\t\t\tps = memparse(args[0].from, &rest);\n\t\t\tpconfig->hstate = size_to_hstate(ps);\n\t\t\tif (!pconfig->hstate) {\n\t\t\t\tpr_err(\"Unsupported page size %lu MB\\n\",\n\t\t\t\t\tps >> 20);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tpr_err(\"Bad mount option: \\\"%s\\\"\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Do size after hstate is set up */\n\tif (setsize > NO_SIZE) {\n\t\tstruct hstate *h = pconfig->hstate;\n\t\tif (setsize == SIZE_PERCENT) {\n\t\t\tsize <<= huge_page_shift(h);\n\t\t\tsize *= h->max_huge_pages;\n\t\t\tdo_div(size, 100);\n\t\t}\n\t\tpconfig->nr_blocks = (size >> huge_page_shift(h));\n\t}\n\n\treturn 0;\n\nbad_val:\n\tpr_err(\"Bad value '%s' for mount option '%s'\\n\", args[0].from, p);\n \treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_size,\t\"size=%s\"},\n\t{Opt_nr_inodes,\t\"nr_inodes=%s\"},\n\t{Opt_mode,\t\"mode=%o\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_pagesize,\t\"pagesize=%s\"},\n\t{Opt_err,\tNULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_size,\t\"size=%s\"},\n\t{Opt_nr_inodes,\t\"nr_inodes=%s\"},\n\t{Opt_mode,\t\"mode=%o\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_pagesize,\t\"pagesize=%s\"},\n\t{Opt_err,\tNULL},\n};\n\nstatic int\nhugetlbfs_parse_options(char *options, struct hugetlbfs_config *pconfig)\n{\n\tchar *p, *rest;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tunsigned long long size = 0;\n\tenum { NO_SIZE, SIZE_STD, SIZE_PERCENT } setsize = NO_SIZE;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(pconfig->uid))\n\t\t\t\tgoto bad_val;\n\t\t\tbreak;\n\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(pconfig->gid))\n\t\t\t\tgoto bad_val;\n\t\t\tbreak;\n\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->mode = option & 01777U;\n\t\t\tbreak;\n\n\t\tcase Opt_size: {\n\t\t\t/* memparse() will accept a K/M/G without a digit */\n\t\t\tif (!isdigit(*args[0].from))\n\t\t\t\tgoto bad_val;\n\t\t\tsize = memparse(args[0].from, &rest);\n\t\t\tsetsize = SIZE_STD;\n\t\t\tif (*rest == '%')\n\t\t\t\tsetsize = SIZE_PERCENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_nr_inodes:\n\t\t\t/* memparse() will accept a K/M/G without a digit */\n\t\t\tif (!isdigit(*args[0].from))\n\t\t\t\tgoto bad_val;\n\t\t\tpconfig->nr_inodes = memparse(args[0].from, &rest);\n\t\t\tbreak;\n\n\t\tcase Opt_pagesize: {\n\t\t\tunsigned long ps;\n\t\t\tps = memparse(args[0].from, &rest);\n\t\t\tpconfig->hstate = size_to_hstate(ps);\n\t\t\tif (!pconfig->hstate) {\n\t\t\t\tpr_err(\"Unsupported page size %lu MB\\n\",\n\t\t\t\t\tps >> 20);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tpr_err(\"Bad mount option: \\\"%s\\\"\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Do size after hstate is set up */\n\tif (setsize > NO_SIZE) {\n\t\tstruct hstate *h = pconfig->hstate;\n\t\tif (setsize == SIZE_PERCENT) {\n\t\t\tsize <<= huge_page_shift(h);\n\t\t\tsize *= h->max_huge_pages;\n\t\t\tdo_div(size, 100);\n\t\t}\n\t\tpconfig->nr_blocks = (size >> huge_page_shift(h));\n\t}\n\n\treturn 0;\n\nbad_val:\n\tpr_err(\"Bad value '%s' for mount option '%s'\\n\", args[0].from, p);\n \treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic const struct super_operations hugetlbfs_ops;\nstatic const struct super_operations hugetlbfs_ops = {\n\t.alloc_inode    = hugetlbfs_alloc_inode,\n\t.destroy_inode  = hugetlbfs_destroy_inode,\n\t.evict_inode\t= hugetlbfs_evict_inode,\n\t.statfs\t\t= hugetlbfs_statfs,\n\t.put_super\t= hugetlbfs_put_super,\n\t.show_options\t= generic_show_options,\n};\n\nstatic int\nhugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint ret;\n\tstruct hugetlbfs_config config;\n\tstruct hugetlbfs_sb_info *sbinfo;\n\n\tsave_mount_options(sb, data);\n\n\tconfig.nr_blocks = -1; /* No limit on size by default */\n\tconfig.nr_inodes = -1; /* No limit on number of inodes by default */\n\tconfig.uid = current_fsuid();\n\tconfig.gid = current_fsgid();\n\tconfig.mode = 0755;\n\tconfig.hstate = &default_hstate;\n\tret = hugetlbfs_parse_options(data, &config);\n\tif (ret)\n\t\treturn ret;\n\n\tsbinfo = kmalloc(sizeof(struct hugetlbfs_sb_info), GFP_KERNEL);\n\tif (!sbinfo)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbinfo;\n\tsbinfo->hstate = config.hstate;\n\tspin_lock_init(&sbinfo->stat_lock);\n\tsbinfo->max_inodes = config.nr_inodes;\n\tsbinfo->free_inodes = config.nr_inodes;\n\tsbinfo->spool = NULL;\n\tif (config.nr_blocks != -1) {\n\t\tsbinfo->spool = hugepage_new_subpool(config.nr_blocks);\n\t\tif (!sbinfo->spool)\n\t\t\tgoto out_free;\n\t}\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize = huge_page_size(config.hstate);\n\tsb->s_blocksize_bits = huge_page_shift(config.hstate);\n\tsb->s_magic = HUGETLBFS_MAGIC;\n\tsb->s_op = &hugetlbfs_ops;\n\tsb->s_time_gran = 1;\n\tsb->s_root = d_make_root(hugetlbfs_get_root(sb, &config));\n\tif (!sb->s_root)\n\t\tgoto out_free;\n\treturn 0;\nout_free:\n\tkfree(sbinfo->spool);\n\tkfree(sbinfo);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "hugetlbfs_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "757-851",
    "snippet": "static int\nhugetlbfs_parse_options(char *options, struct hugetlbfs_config *pconfig)\n{\n\tchar *p, *rest;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tunsigned long long size = 0;\n\tenum { NO_SIZE, SIZE_STD, SIZE_PERCENT } setsize = NO_SIZE;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(pconfig->uid))\n\t\t\t\tgoto bad_val;\n\t\t\tbreak;\n\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(pconfig->gid))\n\t\t\t\tgoto bad_val;\n\t\t\tbreak;\n\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->mode = option & 01777U;\n\t\t\tbreak;\n\n\t\tcase Opt_size: {\n\t\t\t/* memparse() will accept a K/M/G without a digit */\n\t\t\tif (!isdigit(*args[0].from))\n\t\t\t\tgoto bad_val;\n\t\t\tsize = memparse(args[0].from, &rest);\n\t\t\tsetsize = SIZE_STD;\n\t\t\tif (*rest == '%')\n\t\t\t\tsetsize = SIZE_PERCENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_nr_inodes:\n\t\t\t/* memparse() will accept a K/M/G without a digit */\n\t\t\tif (!isdigit(*args[0].from))\n\t\t\t\tgoto bad_val;\n\t\t\tpconfig->nr_inodes = memparse(args[0].from, &rest);\n\t\t\tbreak;\n\n\t\tcase Opt_pagesize: {\n\t\t\tunsigned long ps;\n\t\t\tps = memparse(args[0].from, &rest);\n\t\t\tpconfig->hstate = size_to_hstate(ps);\n\t\t\tif (!pconfig->hstate) {\n\t\t\t\tpr_err(\"Unsupported page size %lu MB\\n\",\n\t\t\t\t\tps >> 20);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tpr_err(\"Bad mount option: \\\"%s\\\"\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Do size after hstate is set up */\n\tif (setsize > NO_SIZE) {\n\t\tstruct hstate *h = pconfig->hstate;\n\t\tif (setsize == SIZE_PERCENT) {\n\t\t\tsize <<= huge_page_shift(h);\n\t\t\tsize *= h->max_huge_pages;\n\t\t\tdo_div(size, 100);\n\t\t}\n\t\tpconfig->nr_blocks = (size >> huge_page_shift(h));\n\t}\n\n\treturn 0;\n\nbad_val:\n\tpr_err(\"Bad value '%s' for mount option '%s'\\n\", args[0].from, p);\n \treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_size,\t\"size=%s\"},\n\t{Opt_nr_inodes,\t\"nr_inodes=%s\"},\n\t{Opt_mode,\t\"mode=%o\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_pagesize,\t\"pagesize=%s\"},\n\t{Opt_err,\tNULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Bad value '%s' for mount option '%s'\\n\"",
            "args[0].from",
            "p"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "size",
            "100"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Bad mount option: \\\"%s\\\"\\n\"",
            "p"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unsupported page size %lu MB\\n\"",
            "ps >> 20"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_to_hstate",
          "args": [
            "ps"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "args[0].from",
            "&rest"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "args[0].from",
            "&rest"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*args[0].from"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "args[0].from",
            "&rest"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*args[0].from"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "pconfig->gid"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "pconfig->uid"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_size,\t\"size=%s\"},\n\t{Opt_nr_inodes,\t\"nr_inodes=%s\"},\n\t{Opt_mode,\t\"mode=%o\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_pagesize,\t\"pagesize=%s\"},\n\t{Opt_err,\tNULL},\n};\n\nstatic int\nhugetlbfs_parse_options(char *options, struct hugetlbfs_config *pconfig)\n{\n\tchar *p, *rest;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tunsigned long long size = 0;\n\tenum { NO_SIZE, SIZE_STD, SIZE_PERCENT } setsize = NO_SIZE;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(pconfig->uid))\n\t\t\t\tgoto bad_val;\n\t\t\tbreak;\n\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(pconfig->gid))\n\t\t\t\tgoto bad_val;\n\t\t\tbreak;\n\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n \t\t\t\tgoto bad_val;\n\t\t\tpconfig->mode = option & 01777U;\n\t\t\tbreak;\n\n\t\tcase Opt_size: {\n\t\t\t/* memparse() will accept a K/M/G without a digit */\n\t\t\tif (!isdigit(*args[0].from))\n\t\t\t\tgoto bad_val;\n\t\t\tsize = memparse(args[0].from, &rest);\n\t\t\tsetsize = SIZE_STD;\n\t\t\tif (*rest == '%')\n\t\t\t\tsetsize = SIZE_PERCENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_nr_inodes:\n\t\t\t/* memparse() will accept a K/M/G without a digit */\n\t\t\tif (!isdigit(*args[0].from))\n\t\t\t\tgoto bad_val;\n\t\t\tpconfig->nr_inodes = memparse(args[0].from, &rest);\n\t\t\tbreak;\n\n\t\tcase Opt_pagesize: {\n\t\t\tunsigned long ps;\n\t\t\tps = memparse(args[0].from, &rest);\n\t\t\tpconfig->hstate = size_to_hstate(ps);\n\t\t\tif (!pconfig->hstate) {\n\t\t\t\tpr_err(\"Unsupported page size %lu MB\\n\",\n\t\t\t\t\tps >> 20);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tpr_err(\"Bad mount option: \\\"%s\\\"\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Do size after hstate is set up */\n\tif (setsize > NO_SIZE) {\n\t\tstruct hstate *h = pconfig->hstate;\n\t\tif (setsize == SIZE_PERCENT) {\n\t\t\tsize <<= huge_page_shift(h);\n\t\t\tsize *= h->max_huge_pages;\n\t\t\tdo_div(size, 100);\n\t\t}\n\t\tpconfig->nr_blocks = (size >> huge_page_shift(h));\n\t}\n\n\treturn 0;\n\nbad_val:\n\tpr_err(\"Bad value '%s' for mount option '%s'\\n\", args[0].from, p);\n \treturn -EINVAL;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "716-721",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct hugetlbfs_inode_info *ei = (struct hugetlbfs_inode_info *)foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct hugetlbfs_inode_info *ei = (struct hugetlbfs_inode_info *)foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "hugetlbfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "701-706",
    "snippet": "static void hugetlbfs_destroy_inode(struct inode *inode)\n{\n\thugetlbfs_inc_free_inodes(HUGETLBFS_SB(inode->i_sb));\n\tmpol_free_shared_policy(&HUGETLBFS_I(inode)->policy);\n\tcall_rcu(&inode->i_rcu, hugetlbfs_i_callback);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "hugetlbfs_i_callback"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_free_shared_policy",
          "args": [
            "&HUGETLBFS_I(inode)->policy"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HUGETLBFS_I",
          "args": [
            "inode"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "HUGETLBFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "60-63",
          "snippet": "static inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlbfs_inc_free_inodes",
          "args": [
            "HUGETLBFS_SB(inode->i_sb)"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_inc_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "668-675",
          "snippet": "static void hugetlbfs_inc_free_inodes(struct hugetlbfs_sb_info *sbinfo)\n{\n\tif (sbinfo->free_inodes >= 0) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tsbinfo->free_inodes++;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void hugetlbfs_inc_free_inodes(struct hugetlbfs_sb_info *sbinfo)\n{\n\tif (sbinfo->free_inodes >= 0) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tsbinfo->free_inodes++;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HUGETLBFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void hugetlbfs_destroy_inode(struct inode *inode)\n{\n\thugetlbfs_inc_free_inodes(HUGETLBFS_SB(inode->i_sb));\n\tmpol_free_shared_policy(&HUGETLBFS_I(inode)->policy);\n\tcall_rcu(&inode->i_rcu, hugetlbfs_i_callback);\n}"
  },
  {
    "function_name": "hugetlbfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "695-699",
    "snippet": "static void hugetlbfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(hugetlbfs_inode_cachep, HUGETLBFS_I(inode));\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hugetlbfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "hugetlbfs_inode_cachep",
            "HUGETLBFS_I(inode)"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HUGETLBFS_I",
          "args": [
            "inode"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "HUGETLBFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "60-63",
          "snippet": "static inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *hugetlbfs_inode_cachep;\n\nstatic void hugetlbfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(hugetlbfs_inode_cachep, HUGETLBFS_I(inode));\n}"
  },
  {
    "function_name": "hugetlbfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "680-693",
    "snippet": "static struct inode *hugetlbfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(sb);\n\tstruct hugetlbfs_inode_info *p;\n\n\tif (unlikely(!hugetlbfs_dec_free_inodes(sbinfo)))\n\t\treturn NULL;\n\tp = kmem_cache_alloc(hugetlbfs_inode_cachep, GFP_KERNEL);\n\tif (unlikely(!p)) {\n\t\thugetlbfs_inc_free_inodes(sbinfo);\n\t\treturn NULL;\n\t}\n\treturn &p->vfs_inode;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hugetlbfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlbfs_inc_free_inodes",
          "args": [
            "sbinfo"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_inc_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "668-675",
          "snippet": "static void hugetlbfs_inc_free_inodes(struct hugetlbfs_sb_info *sbinfo)\n{\n\tif (sbinfo->free_inodes >= 0) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tsbinfo->free_inodes++;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void hugetlbfs_inc_free_inodes(struct hugetlbfs_sb_info *sbinfo)\n{\n\tif (sbinfo->free_inodes >= 0) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tsbinfo->free_inodes++;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "hugetlbfs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!hugetlbfs_dec_free_inodes(sbinfo)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlbfs_dec_free_inodes",
          "args": [
            "sbinfo"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_dec_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "653-666",
          "snippet": "static inline int hugetlbfs_dec_free_inodes(struct hugetlbfs_sb_info *sbinfo)\n{\n\tif (sbinfo->free_inodes >= 0) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tif (unlikely(!sbinfo->free_inodes)) {\n\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tsbinfo->free_inodes--;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline int hugetlbfs_dec_free_inodes(struct hugetlbfs_sb_info *sbinfo)\n{\n\tif (sbinfo->free_inodes >= 0) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tif (unlikely(!sbinfo->free_inodes)) {\n\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tsbinfo->free_inodes--;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HUGETLBFS_SB",
          "args": [
            "sb"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *hugetlbfs_inode_cachep;\n\nstatic struct inode *hugetlbfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(sb);\n\tstruct hugetlbfs_inode_info *p;\n\n\tif (unlikely(!hugetlbfs_dec_free_inodes(sbinfo)))\n\t\treturn NULL;\n\tp = kmem_cache_alloc(hugetlbfs_inode_cachep, GFP_KERNEL);\n\tif (unlikely(!p)) {\n\t\thugetlbfs_inc_free_inodes(sbinfo);\n\t\treturn NULL;\n\t}\n\treturn &p->vfs_inode;\n}"
  },
  {
    "function_name": "hugetlbfs_inc_free_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "668-675",
    "snippet": "static void hugetlbfs_inc_free_inodes(struct hugetlbfs_sb_info *sbinfo)\n{\n\tif (sbinfo->free_inodes >= 0) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tsbinfo->free_inodes++;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbinfo->stat_lock"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbinfo->stat_lock"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void hugetlbfs_inc_free_inodes(struct hugetlbfs_sb_info *sbinfo)\n{\n\tif (sbinfo->free_inodes >= 0) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tsbinfo->free_inodes++;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n}"
  },
  {
    "function_name": "hugetlbfs_dec_free_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "653-666",
    "snippet": "static inline int hugetlbfs_dec_free_inodes(struct hugetlbfs_sb_info *sbinfo)\n{\n\tif (sbinfo->free_inodes >= 0) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tif (unlikely(!sbinfo->free_inodes)) {\n\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tsbinfo->free_inodes--;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbinfo->stat_lock"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!sbinfo->free_inodes"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbinfo->stat_lock"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline int hugetlbfs_dec_free_inodes(struct hugetlbfs_sb_info *sbinfo)\n{\n\tif (sbinfo->free_inodes >= 0) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tif (unlikely(!sbinfo->free_inodes)) {\n\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tsbinfo->free_inodes--;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "hugetlbfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "639-651",
    "snippet": "static void hugetlbfs_put_super(struct super_block *sb)\n{\n\tstruct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);\n\n\tif (sbi) {\n\t\tsb->s_fs_info = NULL;\n\n\t\tif (sbi->spool)\n\t\t\thugepage_put_subpool(sbi->spool);\n\n\t\tkfree(sbi);\n\t}\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_put_subpool",
          "args": [
            "sbi->spool"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HUGETLBFS_SB",
          "args": [
            "sb"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void hugetlbfs_put_super(struct super_block *sb)\n{\n\tstruct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);\n\n\tif (sbi) {\n\t\tsb->s_fs_info = NULL;\n\n\t\tif (sbi->spool)\n\t\t\thugepage_put_subpool(sbi->spool);\n\n\t\tkfree(sbi);\n\t}\n}"
  },
  {
    "function_name": "hugetlbfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "610-637",
    "snippet": "static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(dentry->d_sb);\n\tstruct hstate *h = hstate_inode(dentry->d_inode);\n\n\tbuf->f_type = HUGETLBFS_MAGIC;\n\tbuf->f_bsize = huge_page_size(h);\n\tif (sbinfo) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\t/* If no limits set, just report 0 for max/free/used\n\t\t * blocks, like simple_statfs() */\n\t\tif (sbinfo->spool) {\n\t\t\tlong free_pages;\n\n\t\t\tspin_lock(&sbinfo->spool->lock);\n\t\t\tbuf->f_blocks = sbinfo->spool->max_hpages;\n\t\t\tfree_pages = sbinfo->spool->max_hpages\n\t\t\t\t- sbinfo->spool->used_hpages;\n\t\t\tbuf->f_bavail = buf->f_bfree = free_pages;\n\t\t\tspin_unlock(&sbinfo->spool->lock);\n\t\t\tbuf->f_files = sbinfo->max_inodes;\n\t\t\tbuf->f_ffree = sbinfo->free_inodes;\n\t\t}\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbinfo->stat_lock"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbinfo->spool->lock"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_inode",
          "args": [
            "dentry->d_inode"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HUGETLBFS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(dentry->d_sb);\n\tstruct hstate *h = hstate_inode(dentry->d_inode);\n\n\tbuf->f_type = HUGETLBFS_MAGIC;\n\tbuf->f_bsize = huge_page_size(h);\n\tif (sbinfo) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\t/* If no limits set, just report 0 for max/free/used\n\t\t * blocks, like simple_statfs() */\n\t\tif (sbinfo->spool) {\n\t\t\tlong free_pages;\n\n\t\t\tspin_lock(&sbinfo->spool->lock);\n\t\t\tbuf->f_blocks = sbinfo->spool->max_hpages;\n\t\t\tfree_pages = sbinfo->spool->max_hpages\n\t\t\t\t- sbinfo->spool->used_hpages;\n\t\t\tbuf->f_bavail = buf->f_bfree = free_pages;\n\t\t\tspin_unlock(&sbinfo->spool->lock);\n\t\t\tbuf->f_files = sbinfo->max_inodes;\n\t\t\tbuf->f_ffree = sbinfo->free_inodes;\n\t\t}\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}"
  },
  {
    "function_name": "hugetlbfs_migrate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "596-608",
    "snippet": "static int hugetlbfs_migrate_page(struct address_space *mapping,\n\t\t\t\tstruct page *newpage, struct page *page,\n\t\t\t\tenum migrate_mode mode)\n{\n\tint rc;\n\n\trc = migrate_huge_page_move_mapping(mapping, newpage, page);\n\tif (rc != MIGRATEPAGE_SUCCESS)\n\t\treturn rc;\n\tmigrate_page_copy(newpage, page);\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_page_copy",
          "args": [
            "newpage",
            "page"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_huge_page_move_mapping",
          "args": [
            "mapping",
            "newpage",
            "page"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_migrate_page(struct address_space *mapping,\n\t\t\t\tstruct page *newpage, struct page *page,\n\t\t\t\tenum migrate_mode mode)\n{\n\tint rc;\n\n\trc = migrate_huge_page_move_mapping(mapping, newpage, page);\n\tif (rc != MIGRATEPAGE_SUCCESS)\n\t\treturn rc;\n\tmigrate_page_copy(newpage, page);\n\n\treturn MIGRATEPAGE_SUCCESS;\n}"
  },
  {
    "function_name": "hugetlbfs_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "588-594",
    "snippet": "static int hugetlbfs_set_page_dirty(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tSetPageDirty(head);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "head"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_set_page_dirty(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tSetPageDirty(head);\n\treturn 0;\n}"
  },
  {
    "function_name": "hugetlbfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "564-583",
    "snippet": "static int hugetlbfs_symlink(struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *symname)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = hugetlbfs_get_inode(dir->i_sb, dir, S_IFLNK|S_IRWXUGO, 0);\n\tif (inode) {\n\t\tint l = strlen(symname)+1;\n\t\terror = page_symlink(inode, symname, l);\n\t\tif (!error) {\n\t\t\td_instantiate(dentry, inode);\n\t\t\tdget(dentry);\n\t\t} else\n\t\t\tiput(inode);\n\t}\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_symlink",
          "args": [
            "inode",
            "symname",
            "l"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "page_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4532-4536",
          "snippet": "int page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlbfs_get_inode",
          "args": [
            "dir->i_sb",
            "dir",
            "S_IFLNK|S_IRWXUGO",
            "0"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "476-530",
          "snippet": "static struct inode *hugetlbfs_get_inode(struct super_block *sb,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tumode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tstruct resv_map *resv_map;\n\n\tresv_map = resv_map_alloc();\n\tif (!resv_map)\n\t\treturn NULL;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tlockdep_set_class(&inode->i_mapping->i_mmap_rwsem,\n\t\t\t\t&hugetlbfs_i_mmap_rwsem_key);\n\t\tinode->i_mapping->a_ops = &hugetlbfs_aops;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_mapping->private_data = resv_map;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\t/*\n\t\t * The policy is initialized here even if we are creating a\n\t\t * private inode because initialization simply creates an\n\t\t * an empty rb tree and calls spin_lock_init(), later when we\n\t\t * call mpol_free_shared_policy() it will just return because\n\t\t * the rb tree will still be empty.\n\t\t */\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &hugetlbfs_inode_operations;\n\t\t\tinode->i_fop = &hugetlbfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t} else\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\n\treturn inode;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations hugetlbfs_aops;",
            "const struct file_operations hugetlbfs_file_operations;",
            "static const struct inode_operations hugetlbfs_dir_inode_operations;",
            "static const struct inode_operations hugetlbfs_inode_operations;",
            "static struct lock_class_key hugetlbfs_i_mmap_rwsem_key;",
            "static const struct address_space_operations hugetlbfs_aops = {\n\t.write_begin\t= hugetlbfs_write_begin,\n\t.write_end\t= hugetlbfs_write_end,\n\t.set_page_dirty\t= hugetlbfs_set_page_dirty,\n\t.migratepage    = hugetlbfs_migrate_page,\n};",
            "const struct file_operations hugetlbfs_file_operations = {\n\t.read\t\t\t= hugetlbfs_read,\n\t.mmap\t\t\t= hugetlbfs_file_mmap,\n\t.fsync\t\t\t= noop_fsync,\n\t.get_unmapped_area\t= hugetlb_get_unmapped_area,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};",
            "static const struct inode_operations hugetlbfs_inode_operations = {\n\t.setattr\t= hugetlbfs_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic const struct address_space_operations hugetlbfs_aops;\nconst struct file_operations hugetlbfs_file_operations;\nstatic const struct inode_operations hugetlbfs_dir_inode_operations;\nstatic const struct inode_operations hugetlbfs_inode_operations;\nstatic struct lock_class_key hugetlbfs_i_mmap_rwsem_key;\nstatic const struct address_space_operations hugetlbfs_aops = {\n\t.write_begin\t= hugetlbfs_write_begin,\n\t.write_end\t= hugetlbfs_write_end,\n\t.set_page_dirty\t= hugetlbfs_set_page_dirty,\n\t.migratepage    = hugetlbfs_migrate_page,\n};\nconst struct file_operations hugetlbfs_file_operations = {\n\t.read\t\t\t= hugetlbfs_read,\n\t.mmap\t\t\t= hugetlbfs_file_mmap,\n\t.fsync\t\t\t= noop_fsync,\n\t.get_unmapped_area\t= hugetlb_get_unmapped_area,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};\nstatic const struct inode_operations hugetlbfs_inode_operations = {\n\t.setattr\t= hugetlbfs_setattr,\n};\n\nstatic struct inode *hugetlbfs_get_inode(struct super_block *sb,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tumode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tstruct resv_map *resv_map;\n\n\tresv_map = resv_map_alloc();\n\tif (!resv_map)\n\t\treturn NULL;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tlockdep_set_class(&inode->i_mapping->i_mmap_rwsem,\n\t\t\t\t&hugetlbfs_i_mmap_rwsem_key);\n\t\tinode->i_mapping->a_ops = &hugetlbfs_aops;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_mapping->private_data = resv_map;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\t/*\n\t\t * The policy is initialized here even if we are creating a\n\t\t * private inode because initialization simply creates an\n\t\t * an empty rb tree and calls spin_lock_init(), later when we\n\t\t * call mpol_free_shared_policy() it will just return because\n\t\t * the rb tree will still be empty.\n\t\t */\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &hugetlbfs_inode_operations;\n\t\t\tinode->i_fop = &hugetlbfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t} else\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_symlink(struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *symname)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = hugetlbfs_get_inode(dir->i_sb, dir, S_IFLNK|S_IRWXUGO, 0);\n\tif (inode) {\n\t\tint l = strlen(symname)+1;\n\t\terror = page_symlink(inode, symname, l);\n\t\tif (!error) {\n\t\t\td_instantiate(dentry, inode);\n\t\t\tdget(dentry);\n\t\t} else\n\t\t\tiput(inode);\n\t}\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\treturn error;\n}"
  },
  {
    "function_name": "hugetlbfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "559-562",
    "snippet": "static int hugetlbfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn hugetlbfs_mknod(dir, dentry, mode | S_IFREG, 0);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlbfs_mknod",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFREG",
            "0"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "535-549",
          "snippet": "static int hugetlbfs_mknod(struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = hugetlbfs_get_inode(dir->i_sb, dir, mode, dev);\n\tif (inode) {\n\t\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_mknod(struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = hugetlbfs_get_inode(dir->i_sb, dir, mode, dev);\n\tif (inode) {\n\t\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn hugetlbfs_mknod(dir, dentry, mode | S_IFREG, 0);\n}"
  },
  {
    "function_name": "hugetlbfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "551-557",
    "snippet": "static int hugetlbfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint retval = hugetlbfs_mknod(dir, dentry, mode | S_IFDIR, 0);\n\tif (!retval)\n\t\tinc_nlink(dir);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlbfs_mknod",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFDIR",
            "0"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "535-549",
          "snippet": "static int hugetlbfs_mknod(struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = hugetlbfs_get_inode(dir->i_sb, dir, mode, dev);\n\tif (inode) {\n\t\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_mknod(struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = hugetlbfs_get_inode(dir->i_sb, dir, mode, dev);\n\tif (inode) {\n\t\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint retval = hugetlbfs_mknod(dir, dentry, mode | S_IFDIR, 0);\n\tif (!retval)\n\t\tinc_nlink(dir);\n\treturn retval;\n}"
  },
  {
    "function_name": "hugetlbfs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "535-549",
    "snippet": "static int hugetlbfs_mknod(struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = hugetlbfs_get_inode(dir->i_sb, dir, mode, dev);\n\tif (inode) {\n\t\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlbfs_get_inode",
          "args": [
            "dir->i_sb",
            "dir",
            "mode",
            "dev"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "476-530",
          "snippet": "static struct inode *hugetlbfs_get_inode(struct super_block *sb,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tumode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tstruct resv_map *resv_map;\n\n\tresv_map = resv_map_alloc();\n\tif (!resv_map)\n\t\treturn NULL;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tlockdep_set_class(&inode->i_mapping->i_mmap_rwsem,\n\t\t\t\t&hugetlbfs_i_mmap_rwsem_key);\n\t\tinode->i_mapping->a_ops = &hugetlbfs_aops;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_mapping->private_data = resv_map;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\t/*\n\t\t * The policy is initialized here even if we are creating a\n\t\t * private inode because initialization simply creates an\n\t\t * an empty rb tree and calls spin_lock_init(), later when we\n\t\t * call mpol_free_shared_policy() it will just return because\n\t\t * the rb tree will still be empty.\n\t\t */\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &hugetlbfs_inode_operations;\n\t\t\tinode->i_fop = &hugetlbfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t} else\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\n\treturn inode;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations hugetlbfs_aops;",
            "const struct file_operations hugetlbfs_file_operations;",
            "static const struct inode_operations hugetlbfs_dir_inode_operations;",
            "static const struct inode_operations hugetlbfs_inode_operations;",
            "static struct lock_class_key hugetlbfs_i_mmap_rwsem_key;",
            "static const struct address_space_operations hugetlbfs_aops = {\n\t.write_begin\t= hugetlbfs_write_begin,\n\t.write_end\t= hugetlbfs_write_end,\n\t.set_page_dirty\t= hugetlbfs_set_page_dirty,\n\t.migratepage    = hugetlbfs_migrate_page,\n};",
            "const struct file_operations hugetlbfs_file_operations = {\n\t.read\t\t\t= hugetlbfs_read,\n\t.mmap\t\t\t= hugetlbfs_file_mmap,\n\t.fsync\t\t\t= noop_fsync,\n\t.get_unmapped_area\t= hugetlb_get_unmapped_area,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};",
            "static const struct inode_operations hugetlbfs_inode_operations = {\n\t.setattr\t= hugetlbfs_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic const struct address_space_operations hugetlbfs_aops;\nconst struct file_operations hugetlbfs_file_operations;\nstatic const struct inode_operations hugetlbfs_dir_inode_operations;\nstatic const struct inode_operations hugetlbfs_inode_operations;\nstatic struct lock_class_key hugetlbfs_i_mmap_rwsem_key;\nstatic const struct address_space_operations hugetlbfs_aops = {\n\t.write_begin\t= hugetlbfs_write_begin,\n\t.write_end\t= hugetlbfs_write_end,\n\t.set_page_dirty\t= hugetlbfs_set_page_dirty,\n\t.migratepage    = hugetlbfs_migrate_page,\n};\nconst struct file_operations hugetlbfs_file_operations = {\n\t.read\t\t\t= hugetlbfs_read,\n\t.mmap\t\t\t= hugetlbfs_file_mmap,\n\t.fsync\t\t\t= noop_fsync,\n\t.get_unmapped_area\t= hugetlb_get_unmapped_area,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};\nstatic const struct inode_operations hugetlbfs_inode_operations = {\n\t.setattr\t= hugetlbfs_setattr,\n};\n\nstatic struct inode *hugetlbfs_get_inode(struct super_block *sb,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tumode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tstruct resv_map *resv_map;\n\n\tresv_map = resv_map_alloc();\n\tif (!resv_map)\n\t\treturn NULL;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tlockdep_set_class(&inode->i_mapping->i_mmap_rwsem,\n\t\t\t\t&hugetlbfs_i_mmap_rwsem_key);\n\t\tinode->i_mapping->a_ops = &hugetlbfs_aops;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_mapping->private_data = resv_map;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\t/*\n\t\t * The policy is initialized here even if we are creating a\n\t\t * private inode because initialization simply creates an\n\t\t * an empty rb tree and calls spin_lock_init(), later when we\n\t\t * call mpol_free_shared_policy() it will just return because\n\t\t * the rb tree will still be empty.\n\t\t */\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &hugetlbfs_inode_operations;\n\t\t\tinode->i_fop = &hugetlbfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t} else\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_mknod(struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = hugetlbfs_get_inode(dir->i_sb, dir, mode, dev);\n\tif (inode) {\n\t\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\t\terror = 0;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "hugetlbfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "476-530",
    "snippet": "static struct inode *hugetlbfs_get_inode(struct super_block *sb,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tumode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tstruct resv_map *resv_map;\n\n\tresv_map = resv_map_alloc();\n\tif (!resv_map)\n\t\treturn NULL;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tlockdep_set_class(&inode->i_mapping->i_mmap_rwsem,\n\t\t\t\t&hugetlbfs_i_mmap_rwsem_key);\n\t\tinode->i_mapping->a_ops = &hugetlbfs_aops;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_mapping->private_data = resv_map;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\t/*\n\t\t * The policy is initialized here even if we are creating a\n\t\t * private inode because initialization simply creates an\n\t\t * an empty rb tree and calls spin_lock_init(), later when we\n\t\t * call mpol_free_shared_policy() it will just return because\n\t\t * the rb tree will still be empty.\n\t\t */\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &hugetlbfs_inode_operations;\n\t\t\tinode->i_fop = &hugetlbfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t} else\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\n\treturn inode;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations hugetlbfs_aops;",
      "const struct file_operations hugetlbfs_file_operations;",
      "static const struct inode_operations hugetlbfs_dir_inode_operations;",
      "static const struct inode_operations hugetlbfs_inode_operations;",
      "static struct lock_class_key hugetlbfs_i_mmap_rwsem_key;",
      "static const struct address_space_operations hugetlbfs_aops = {\n\t.write_begin\t= hugetlbfs_write_begin,\n\t.write_end\t= hugetlbfs_write_end,\n\t.set_page_dirty\t= hugetlbfs_set_page_dirty,\n\t.migratepage    = hugetlbfs_migrate_page,\n};",
      "const struct file_operations hugetlbfs_file_operations = {\n\t.read\t\t\t= hugetlbfs_read,\n\t.mmap\t\t\t= hugetlbfs_file_mmap,\n\t.fsync\t\t\t= noop_fsync,\n\t.get_unmapped_area\t= hugetlb_get_unmapped_area,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};",
      "static const struct inode_operations hugetlbfs_inode_operations = {\n\t.setattr\t= hugetlbfs_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&resv_map->refs",
            "resv_map_release"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_annotate_inode_mutex_key",
          "args": [
            "inode"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_annotate_inode_mutex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "897-913",
          "snippet": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tmutex_destroy(&inode->i_mutex);\n\t\t\tmutex_init(&inode->i_mutex);\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tmutex_destroy(&inode->i_mutex);\n\t\t\tmutex_init(&inode->i_mutex);\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "mode",
            "dev"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_shared_policy_init",
          "args": [
            "&info->policy",
            "NULL"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HUGETLBFS_I",
          "args": [
            "inode"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "HUGETLBFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "60-63",
          "snippet": "static inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&inode->i_mapping->i_mmap_rwsem",
            "&hugetlbfs_i_mmap_rwsem_key"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resv_map_alloc",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic const struct address_space_operations hugetlbfs_aops;\nconst struct file_operations hugetlbfs_file_operations;\nstatic const struct inode_operations hugetlbfs_dir_inode_operations;\nstatic const struct inode_operations hugetlbfs_inode_operations;\nstatic struct lock_class_key hugetlbfs_i_mmap_rwsem_key;\nstatic const struct address_space_operations hugetlbfs_aops = {\n\t.write_begin\t= hugetlbfs_write_begin,\n\t.write_end\t= hugetlbfs_write_end,\n\t.set_page_dirty\t= hugetlbfs_set_page_dirty,\n\t.migratepage    = hugetlbfs_migrate_page,\n};\nconst struct file_operations hugetlbfs_file_operations = {\n\t.read\t\t\t= hugetlbfs_read,\n\t.mmap\t\t\t= hugetlbfs_file_mmap,\n\t.fsync\t\t\t= noop_fsync,\n\t.get_unmapped_area\t= hugetlb_get_unmapped_area,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};\nstatic const struct inode_operations hugetlbfs_inode_operations = {\n\t.setattr\t= hugetlbfs_setattr,\n};\n\nstatic struct inode *hugetlbfs_get_inode(struct super_block *sb,\n\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\tumode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tstruct resv_map *resv_map;\n\n\tresv_map = resv_map_alloc();\n\tif (!resv_map)\n\t\treturn NULL;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, dir, mode);\n\t\tlockdep_set_class(&inode->i_mapping->i_mmap_rwsem,\n\t\t\t\t&hugetlbfs_i_mmap_rwsem_key);\n\t\tinode->i_mapping->a_ops = &hugetlbfs_aops;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_mapping->private_data = resv_map;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\t/*\n\t\t * The policy is initialized here even if we are creating a\n\t\t * private inode because initialization simply creates an\n\t\t * an empty rb tree and calls spin_lock_init(), later when we\n\t\t * call mpol_free_shared_policy() it will just return because\n\t\t * the rb tree will still be empty.\n\t\t */\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &hugetlbfs_inode_operations;\n\t\t\tinode->i_fop = &hugetlbfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tbreak;\n\t\t}\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t} else\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "hugetlbfs_get_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "444-466",
    "snippet": "static struct inode *hugetlbfs_get_root(struct super_block *sb,\n\t\t\t\t\tstruct hugetlbfs_config *config)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = S_IFDIR | config->mode;\n\t\tinode->i_uid = config->uid;\n\t\tinode->i_gid = config->gid;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations hugetlbfs_dir_inode_operations;",
      "static const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_annotate_inode_mutex_key",
          "args": [
            "inode"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_annotate_inode_mutex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "897-913",
          "snippet": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tmutex_destroy(&inode->i_mutex);\n\t\t\tmutex_init(&inode->i_mutex);\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tmutex_destroy(&inode->i_mutex);\n\t\t\tmutex_init(&inode->i_mutex);\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_shared_policy_init",
          "args": [
            "&info->policy",
            "NULL"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HUGETLBFS_I",
          "args": [
            "inode"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "HUGETLBFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "60-63",
          "snippet": "static inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations hugetlbfs_dir_inode_operations;\nstatic const struct inode_operations hugetlbfs_dir_inode_operations = {\n\t.create\t\t= hugetlbfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= hugetlbfs_symlink,\n\t.mkdir\t\t= hugetlbfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= hugetlbfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.setattr\t= hugetlbfs_setattr,\n};\n\nstatic struct inode *hugetlbfs_get_root(struct super_block *sb,\n\t\t\t\t\tstruct hugetlbfs_config *config)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tstruct hugetlbfs_inode_info *info;\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = S_IFDIR | config->mode;\n\t\tinode->i_uid = config->uid;\n\t\tinode->i_gid = config->gid;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinfo = HUGETLBFS_I(inode);\n\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\tinode->i_op = &hugetlbfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tlockdep_annotate_inode_mutex_key(inode);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "hugetlbfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "417-442",
    "snippet": "static int hugetlbfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hstate *h = hstate_inode(inode);\n\tint error;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tBUG_ON(!inode);\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (ia_valid & ATTR_SIZE) {\n\t\terror = -EINVAL;\n\t\tif (attr->ia_size & ~huge_page_mask(h))\n\t\t\treturn -EINVAL;\n\t\terror = hugetlb_vmtruncate(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_vmtruncate",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_vmtruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "399-415",
          "snippet": "static int hugetlb_vmtruncate(struct inode *inode, loff_t offset)\n{\n\tpgoff_t pgoff;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct hstate *h = hstate_inode(inode);\n\n\tBUG_ON(offset & ~huge_page_mask(h));\n\tpgoff = offset >> PAGE_SHIFT;\n\n\ti_size_write(inode, offset);\n\ti_mmap_lock_write(mapping);\n\tif (!RB_EMPTY_ROOT(&mapping->i_mmap))\n\t\thugetlb_vmtruncate_list(&mapping->i_mmap, pgoff);\n\ti_mmap_unlock_write(mapping);\n\ttruncate_hugepages(inode, offset);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlb_vmtruncate(struct inode *inode, loff_t offset)\n{\n\tpgoff_t pgoff;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct hstate *h = hstate_inode(inode);\n\n\tBUG_ON(offset & ~huge_page_mask(h));\n\tpgoff = offset >> PAGE_SHIFT;\n\n\ti_size_write(inode, offset);\n\ti_mmap_lock_write(mapping);\n\tif (!RB_EMPTY_ROOT(&mapping->i_mmap))\n\t\thugetlb_vmtruncate_list(&mapping->i_mmap, pgoff);\n\ti_mmap_unlock_write(mapping);\n\ttruncate_hugepages(inode, offset);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_inode",
          "args": [
            "inode"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hstate *h = hstate_inode(inode);\n\tint error;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tBUG_ON(!inode);\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (ia_valid & ATTR_SIZE) {\n\t\terror = -EINVAL;\n\t\tif (attr->ia_size & ~huge_page_mask(h))\n\t\t\treturn -EINVAL;\n\t\terror = hugetlb_vmtruncate(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "hugetlb_vmtruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "399-415",
    "snippet": "static int hugetlb_vmtruncate(struct inode *inode, loff_t offset)\n{\n\tpgoff_t pgoff;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct hstate *h = hstate_inode(inode);\n\n\tBUG_ON(offset & ~huge_page_mask(h));\n\tpgoff = offset >> PAGE_SHIFT;\n\n\ti_size_write(inode, offset);\n\ti_mmap_lock_write(mapping);\n\tif (!RB_EMPTY_ROOT(&mapping->i_mmap))\n\t\thugetlb_vmtruncate_list(&mapping->i_mmap, pgoff);\n\ti_mmap_unlock_write(mapping);\n\ttruncate_hugepages(inode, offset);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_hugepages",
          "args": [
            "inode",
            "offset"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_hugepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "327-361",
          "snippet": "static void truncate_hugepages(struct inode *inode, loff_t lstart)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct address_space *mapping = &inode->i_data;\n\tconst pgoff_t start = lstart >> huge_page_shift(h);\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i, freed = 0;\n\n\tpagevec_init(&pvec, 0);\n\tnext = start;\n\twhile (1) {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE)) {\n\t\t\tif (next == start)\n\t\t\t\tbreak;\n\t\t\tnext = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); ++i) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tif (page->index > next)\n\t\t\t\tnext = page->index;\n\t\t\t++next;\n\t\t\ttruncate_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tfreed++;\n\t\t}\n\t\thuge_pagevec_release(&pvec);\n\t}\n\tBUG_ON(!lstart && mapping->nrpages);\n\thugetlb_unreserve_pages(inode, start, freed);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void truncate_hugepages(struct inode *inode, loff_t lstart)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct address_space *mapping = &inode->i_data;\n\tconst pgoff_t start = lstart >> huge_page_shift(h);\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i, freed = 0;\n\n\tpagevec_init(&pvec, 0);\n\tnext = start;\n\twhile (1) {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE)) {\n\t\t\tif (next == start)\n\t\t\t\tbreak;\n\t\t\tnext = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); ++i) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tif (page->index > next)\n\t\t\t\tnext = page->index;\n\t\t\t++next;\n\t\t\ttruncate_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tfreed++;\n\t\t}\n\t\thuge_pagevec_release(&pvec);\n\t}\n\tBUG_ON(!lstart && mapping->nrpages);\n\thugetlb_unreserve_pages(inode, start, freed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "mapping"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_vmtruncate_list",
          "args": [
            "&mapping->i_mmap",
            "pgoff"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_vmtruncate_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "375-397",
          "snippet": "static inline void\nhugetlb_vmtruncate_list(struct rb_root *root, pgoff_t pgoff)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma_interval_tree_foreach(vma, root, pgoff, ULONG_MAX) {\n\t\tunsigned long v_offset;\n\n\t\t/*\n\t\t * Can the expression below overflow on 32-bit arches?\n\t\t * No, because the interval tree returns us only those vmas\n\t\t * which overlap the truncated area starting at pgoff,\n\t\t * and no vma on a 32-bit arch can span beyond the 4GB.\n\t\t */\n\t\tif (vma->vm_pgoff < pgoff)\n\t\t\tv_offset = (pgoff - vma->vm_pgoff) << PAGE_SHIFT;\n\t\telse\n\t\t\tv_offset = 0;\n\n\t\tunmap_hugepage_range(vma, vma->vm_start + v_offset,\n\t\t\t\t     vma->vm_end, NULL);\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline void\nhugetlb_vmtruncate_list(struct rb_root *root, pgoff_t pgoff)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma_interval_tree_foreach(vma, root, pgoff, ULONG_MAX) {\n\t\tunsigned long v_offset;\n\n\t\t/*\n\t\t * Can the expression below overflow on 32-bit arches?\n\t\t * No, because the interval tree returns us only those vmas\n\t\t * which overlap the truncated area starting at pgoff,\n\t\t * and no vma on a 32-bit arch can span beyond the 4GB.\n\t\t */\n\t\tif (vma->vm_pgoff < pgoff)\n\t\t\tv_offset = (pgoff - vma->vm_pgoff) << PAGE_SHIFT;\n\t\telse\n\t\t\tv_offset = 0;\n\n\t\tunmap_hugepage_range(vma, vma->vm_start + v_offset,\n\t\t\t\t     vma->vm_end, NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&mapping->i_mmap"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "mapping"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "offset"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset & ~huge_page_mask(h)"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_inode",
          "args": [
            "inode"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlb_vmtruncate(struct inode *inode, loff_t offset)\n{\n\tpgoff_t pgoff;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct hstate *h = hstate_inode(inode);\n\n\tBUG_ON(offset & ~huge_page_mask(h));\n\tpgoff = offset >> PAGE_SHIFT;\n\n\ti_size_write(inode, offset);\n\ti_mmap_lock_write(mapping);\n\tif (!RB_EMPTY_ROOT(&mapping->i_mmap))\n\t\thugetlb_vmtruncate_list(&mapping->i_mmap, pgoff);\n\ti_mmap_unlock_write(mapping);\n\ttruncate_hugepages(inode, offset);\n\treturn 0;\n}"
  },
  {
    "function_name": "hugetlb_vmtruncate_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "375-397",
    "snippet": "static inline void\nhugetlb_vmtruncate_list(struct rb_root *root, pgoff_t pgoff)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma_interval_tree_foreach(vma, root, pgoff, ULONG_MAX) {\n\t\tunsigned long v_offset;\n\n\t\t/*\n\t\t * Can the expression below overflow on 32-bit arches?\n\t\t * No, because the interval tree returns us only those vmas\n\t\t * which overlap the truncated area starting at pgoff,\n\t\t * and no vma on a 32-bit arch can span beyond the 4GB.\n\t\t */\n\t\tif (vma->vm_pgoff < pgoff)\n\t\t\tv_offset = (pgoff - vma->vm_pgoff) << PAGE_SHIFT;\n\t\telse\n\t\t\tv_offset = 0;\n\n\t\tunmap_hugepage_range(vma, vma->vm_start + v_offset,\n\t\t\t\t     vma->vm_end, NULL);\n\t}\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_hugepage_range",
          "args": [
            "vma",
            "vma->vm_start + v_offset",
            "vma->vm_end",
            "NULL"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_foreach",
          "args": [
            "vma",
            "root",
            "pgoff",
            "ULONG_MAX"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline void\nhugetlb_vmtruncate_list(struct rb_root *root, pgoff_t pgoff)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma_interval_tree_foreach(vma, root, pgoff, ULONG_MAX) {\n\t\tunsigned long v_offset;\n\n\t\t/*\n\t\t * Can the expression below overflow on 32-bit arches?\n\t\t * No, because the interval tree returns us only those vmas\n\t\t * which overlap the truncated area starting at pgoff,\n\t\t * and no vma on a 32-bit arch can span beyond the 4GB.\n\t\t */\n\t\tif (vma->vm_pgoff < pgoff)\n\t\t\tv_offset = (pgoff - vma->vm_pgoff) << PAGE_SHIFT;\n\t\telse\n\t\t\tv_offset = 0;\n\n\t\tunmap_hugepage_range(vma, vma->vm_start + v_offset,\n\t\t\t\t     vma->vm_end, NULL);\n\t}\n}"
  },
  {
    "function_name": "hugetlbfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "363-373",
    "snippet": "static void hugetlbfs_evict_inode(struct inode *inode)\n{\n\tstruct resv_map *resv_map;\n\n\ttruncate_hugepages(inode, 0);\n\tresv_map = (struct resv_map *)inode->i_mapping->private_data;\n\t/* root inode doesn't have the resv_map, so we should check it */\n\tif (resv_map)\n\t\tresv_map_release(&resv_map->refs);\n\tclear_inode(inode);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resv_map_release",
          "args": [
            "&resv_map->refs"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_hugepages",
          "args": [
            "inode",
            "0"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_hugepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "327-361",
          "snippet": "static void truncate_hugepages(struct inode *inode, loff_t lstart)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct address_space *mapping = &inode->i_data;\n\tconst pgoff_t start = lstart >> huge_page_shift(h);\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i, freed = 0;\n\n\tpagevec_init(&pvec, 0);\n\tnext = start;\n\twhile (1) {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE)) {\n\t\t\tif (next == start)\n\t\t\t\tbreak;\n\t\t\tnext = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); ++i) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tif (page->index > next)\n\t\t\t\tnext = page->index;\n\t\t\t++next;\n\t\t\ttruncate_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tfreed++;\n\t\t}\n\t\thuge_pagevec_release(&pvec);\n\t}\n\tBUG_ON(!lstart && mapping->nrpages);\n\thugetlb_unreserve_pages(inode, start, freed);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void truncate_hugepages(struct inode *inode, loff_t lstart)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct address_space *mapping = &inode->i_data;\n\tconst pgoff_t start = lstart >> huge_page_shift(h);\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i, freed = 0;\n\n\tpagevec_init(&pvec, 0);\n\tnext = start;\n\twhile (1) {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE)) {\n\t\t\tif (next == start)\n\t\t\t\tbreak;\n\t\t\tnext = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); ++i) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tif (page->index > next)\n\t\t\t\tnext = page->index;\n\t\t\t++next;\n\t\t\ttruncate_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tfreed++;\n\t\t}\n\t\thuge_pagevec_release(&pvec);\n\t}\n\tBUG_ON(!lstart && mapping->nrpages);\n\thugetlb_unreserve_pages(inode, start, freed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void hugetlbfs_evict_inode(struct inode *inode)\n{\n\tstruct resv_map *resv_map;\n\n\ttruncate_hugepages(inode, 0);\n\tresv_map = (struct resv_map *)inode->i_mapping->private_data;\n\t/* root inode doesn't have the resv_map, so we should check it */\n\tif (resv_map)\n\t\tresv_map_release(&resv_map->refs);\n\tclear_inode(inode);\n}"
  },
  {
    "function_name": "truncate_hugepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "327-361",
    "snippet": "static void truncate_hugepages(struct inode *inode, loff_t lstart)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct address_space *mapping = &inode->i_data;\n\tconst pgoff_t start = lstart >> huge_page_shift(h);\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i, freed = 0;\n\n\tpagevec_init(&pvec, 0);\n\tnext = start;\n\twhile (1) {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE)) {\n\t\t\tif (next == start)\n\t\t\t\tbreak;\n\t\t\tnext = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); ++i) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tif (page->index > next)\n\t\t\t\tnext = page->index;\n\t\t\t++next;\n\t\t\ttruncate_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tfreed++;\n\t\t}\n\t\thuge_pagevec_release(&pvec);\n\t}\n\tBUG_ON(!lstart && mapping->nrpages);\n\thugetlb_unreserve_pages(inode, start, freed);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_unreserve_pages",
          "args": [
            "inode",
            "start",
            "freed"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lstart && mapping->nrpages"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_huge_page",
          "args": [
            "page"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "320-325",
          "snippet": "static void truncate_huge_page(struct page *page)\n{\n\tcancel_dirty_page(page, /* No IO accounting for huge pages? */0);\n\tClearPageUptodate(page);\n\tdelete_from_page_cache(page);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void truncate_huge_page(struct page *page)\n{\n\tcancel_dirty_page(page, /* No IO accounting for huge pages? */0);\n\tClearPageUptodate(page);\n\tdelete_from_page_cache(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "mapping",
            "next",
            "PAGEVEC_SIZE"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_inode",
          "args": [
            "inode"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void truncate_hugepages(struct inode *inode, loff_t lstart)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct address_space *mapping = &inode->i_data;\n\tconst pgoff_t start = lstart >> huge_page_shift(h);\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i, freed = 0;\n\n\tpagevec_init(&pvec, 0);\n\tnext = start;\n\twhile (1) {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE)) {\n\t\t\tif (next == start)\n\t\t\t\tbreak;\n\t\t\tnext = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); ++i) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tif (page->index > next)\n\t\t\t\tnext = page->index;\n\t\t\t++next;\n\t\t\ttruncate_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tfreed++;\n\t\t}\n\t\thuge_pagevec_release(&pvec);\n\t}\n\tBUG_ON(!lstart && mapping->nrpages);\n\thugetlb_unreserve_pages(inode, start, freed);\n}"
  },
  {
    "function_name": "truncate_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "320-325",
    "snippet": "static void truncate_huge_page(struct page *page)\n{\n\tcancel_dirty_page(page, /* No IO accounting for huge pages? */0);\n\tClearPageUptodate(page);\n\tdelete_from_page_cache(page);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delete_from_page_cache",
          "args": [
            "page"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_dirty_page",
          "args": [
            "page",
            "/* No IO accounting for huge pages? */0"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void truncate_huge_page(struct page *page)\n{\n\tcancel_dirty_page(page, /* No IO accounting for huge pages? */0);\n\tClearPageUptodate(page);\n\tdelete_from_page_cache(page);\n}"
  },
  {
    "function_name": "hugetlbfs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "312-318",
    "snippet": "static int hugetlbfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tBUG();\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tBUG();\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "hugetlbfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "304-310",
    "snippet": "static int hugetlbfs_write_begin(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_write_begin(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "hugetlbfs_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "225-302",
    "snippet": "static ssize_t hugetlbfs_read(struct file *filp, char __user *buf,\n\t\t\t      size_t len, loff_t *ppos)\n{\n\tstruct hstate *h = hstate_file(filp);\n\tstruct address_space *mapping = filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tunsigned long index = *ppos >> huge_page_shift(h);\n\tunsigned long offset = *ppos & ~huge_page_mask(h);\n\tunsigned long end_index;\n\tloff_t isize;\n\tssize_t retval = 0;\n\n\t/* validate length */\n\tif (len == 0)\n\t\tgoto out;\n\n\tfor (;;) {\n\t\tstruct page *page;\n\t\tunsigned long nr, ret;\n\t\tint ra;\n\n\t\t/* nr is the maximum number of bytes to copy from this page */\n\t\tnr = huge_page_size(h);\n\t\tisize = i_size_read(inode);\n\t\tif (!isize)\n\t\t\tgoto out;\n\t\tend_index = (isize - 1) >> huge_page_shift(h);\n\t\tif (index >= end_index) {\n\t\t\tif (index > end_index)\n\t\t\t\tgoto out;\n\t\t\tnr = ((isize - 1) & ~huge_page_mask(h)) + 1;\n\t\t\tif (nr <= offset)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnr = nr - offset;\n\n\t\t/* Find the page */\n\t\tpage = find_lock_page(mapping, index);\n\t\tif (unlikely(page == NULL)) {\n\t\t\t/*\n\t\t\t * We have a HOLE, zero out the user-buffer for the\n\t\t\t * length of the hole or request.\n\t\t\t */\n\t\t\tret = len < nr ? len : nr;\n\t\t\tif (clear_user(buf, ret))\n\t\t\t\tra = -EFAULT;\n\t\t\telse\n\t\t\t\tra = 0;\n\t\t} else {\n\t\t\tunlock_page(page);\n\n\t\t\t/*\n\t\t\t * We have the page, copy it to user space buffer.\n\t\t\t */\n\t\t\tra = hugetlbfs_read_actor(page, offset, buf, len, nr);\n\t\t\tret = ra;\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tif (ra < 0) {\n\t\t\tif (retval == 0)\n\t\t\t\tretval = ra;\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += ret;\n\t\tretval += ret;\n\t\tlen -= ret;\n\t\tindex += offset >> huge_page_shift(h);\n\t\toffset &= ~huge_page_mask(h);\n\n\t\t/* short read or no more work */\n\t\tif ((ret != nr) || (len == 0))\n\t\t\tbreak;\n\t}\nout:\n\t*ppos = ((loff_t)index << huge_page_shift(h)) + offset;\n\treturn retval;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlbfs_read_actor",
          "args": [
            "page",
            "offset",
            "buf",
            "len",
            "nr"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlbfs_read_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "182-218",
          "snippet": "static int\nhugetlbfs_read_actor(struct page *page, unsigned long offset,\n\t\t\tchar __user *buf, unsigned long count,\n\t\t\tunsigned long size)\n{\n\tchar *kaddr;\n\tunsigned long left, copied = 0;\n\tint i, chunksize;\n\n\tif (size > count)\n\t\tsize = count;\n\n\t/* Find which 4k chunk and offset with in that chunk */\n\ti = offset >> PAGE_CACHE_SHIFT;\n\toffset = offset & ~PAGE_CACHE_MASK;\n\n\twhile (size) {\n\t\tchunksize = PAGE_CACHE_SIZE;\n\t\tif (offset)\n\t\t\tchunksize -= offset;\n\t\tif (chunksize > size)\n\t\t\tchunksize = size;\n\t\tkaddr = kmap(&page[i]);\n\t\tleft = __copy_to_user(buf, kaddr + offset, chunksize);\n\t\tkunmap(&page[i]);\n\t\tif (left) {\n\t\t\tcopied += (chunksize - left);\n\t\t\tbreak;\n\t\t}\n\t\toffset = 0;\n\t\tsize -= chunksize;\n\t\tbuf += chunksize;\n\t\tcopied += chunksize;\n\t\ti++;\n\t}\n\treturn copied ? copied : -EFAULT;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int\nhugetlbfs_read_actor(struct page *page, unsigned long offset,\n\t\t\tchar __user *buf, unsigned long count,\n\t\t\tunsigned long size)\n{\n\tchar *kaddr;\n\tunsigned long left, copied = 0;\n\tint i, chunksize;\n\n\tif (size > count)\n\t\tsize = count;\n\n\t/* Find which 4k chunk and offset with in that chunk */\n\ti = offset >> PAGE_CACHE_SHIFT;\n\toffset = offset & ~PAGE_CACHE_MASK;\n\n\twhile (size) {\n\t\tchunksize = PAGE_CACHE_SIZE;\n\t\tif (offset)\n\t\t\tchunksize -= offset;\n\t\tif (chunksize > size)\n\t\t\tchunksize = size;\n\t\tkaddr = kmap(&page[i]);\n\t\tleft = __copy_to_user(buf, kaddr + offset, chunksize);\n\t\tkunmap(&page[i]);\n\t\tif (left) {\n\t\t\tcopied += (chunksize - left);\n\t\t\tbreak;\n\t\t}\n\t\toffset = 0;\n\t\tsize -= chunksize;\n\t\tbuf += chunksize;\n\t\tcopied += chunksize;\n\t\ti++;\n\t}\n\treturn copied ? copied : -EFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "buf",
            "ret"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page == NULL"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_file",
          "args": [
            "filp"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic ssize_t hugetlbfs_read(struct file *filp, char __user *buf,\n\t\t\t      size_t len, loff_t *ppos)\n{\n\tstruct hstate *h = hstate_file(filp);\n\tstruct address_space *mapping = filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tunsigned long index = *ppos >> huge_page_shift(h);\n\tunsigned long offset = *ppos & ~huge_page_mask(h);\n\tunsigned long end_index;\n\tloff_t isize;\n\tssize_t retval = 0;\n\n\t/* validate length */\n\tif (len == 0)\n\t\tgoto out;\n\n\tfor (;;) {\n\t\tstruct page *page;\n\t\tunsigned long nr, ret;\n\t\tint ra;\n\n\t\t/* nr is the maximum number of bytes to copy from this page */\n\t\tnr = huge_page_size(h);\n\t\tisize = i_size_read(inode);\n\t\tif (!isize)\n\t\t\tgoto out;\n\t\tend_index = (isize - 1) >> huge_page_shift(h);\n\t\tif (index >= end_index) {\n\t\t\tif (index > end_index)\n\t\t\t\tgoto out;\n\t\t\tnr = ((isize - 1) & ~huge_page_mask(h)) + 1;\n\t\t\tif (nr <= offset)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnr = nr - offset;\n\n\t\t/* Find the page */\n\t\tpage = find_lock_page(mapping, index);\n\t\tif (unlikely(page == NULL)) {\n\t\t\t/*\n\t\t\t * We have a HOLE, zero out the user-buffer for the\n\t\t\t * length of the hole or request.\n\t\t\t */\n\t\t\tret = len < nr ? len : nr;\n\t\t\tif (clear_user(buf, ret))\n\t\t\t\tra = -EFAULT;\n\t\t\telse\n\t\t\t\tra = 0;\n\t\t} else {\n\t\t\tunlock_page(page);\n\n\t\t\t/*\n\t\t\t * We have the page, copy it to user space buffer.\n\t\t\t */\n\t\t\tra = hugetlbfs_read_actor(page, offset, buf, len, nr);\n\t\t\tret = ra;\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tif (ra < 0) {\n\t\t\tif (retval == 0)\n\t\t\t\tretval = ra;\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += ret;\n\t\tretval += ret;\n\t\tlen -= ret;\n\t\tindex += offset >> huge_page_shift(h);\n\t\toffset &= ~huge_page_mask(h);\n\n\t\t/* short read or no more work */\n\t\tif ((ret != nr) || (len == 0))\n\t\t\tbreak;\n\t}\nout:\n\t*ppos = ((loff_t)index << huge_page_shift(h)) + offset;\n\treturn retval;\n}"
  },
  {
    "function_name": "hugetlbfs_read_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "182-218",
    "snippet": "static int\nhugetlbfs_read_actor(struct page *page, unsigned long offset,\n\t\t\tchar __user *buf, unsigned long count,\n\t\t\tunsigned long size)\n{\n\tchar *kaddr;\n\tunsigned long left, copied = 0;\n\tint i, chunksize;\n\n\tif (size > count)\n\t\tsize = count;\n\n\t/* Find which 4k chunk and offset with in that chunk */\n\ti = offset >> PAGE_CACHE_SHIFT;\n\toffset = offset & ~PAGE_CACHE_MASK;\n\n\twhile (size) {\n\t\tchunksize = PAGE_CACHE_SIZE;\n\t\tif (offset)\n\t\t\tchunksize -= offset;\n\t\tif (chunksize > size)\n\t\t\tchunksize = size;\n\t\tkaddr = kmap(&page[i]);\n\t\tleft = __copy_to_user(buf, kaddr + offset, chunksize);\n\t\tkunmap(&page[i]);\n\t\tif (left) {\n\t\t\tcopied += (chunksize - left);\n\t\t\tbreak;\n\t\t}\n\t\toffset = 0;\n\t\tsize -= chunksize;\n\t\tbuf += chunksize;\n\t\tcopied += chunksize;\n\t\ti++;\n\t}\n\treturn copied ? copied : -EFAULT;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "&page[i]"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "buf",
            "kaddr + offset",
            "chunksize"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "&page[i]"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int\nhugetlbfs_read_actor(struct page *page, unsigned long offset,\n\t\t\tchar __user *buf, unsigned long count,\n\t\t\tunsigned long size)\n{\n\tchar *kaddr;\n\tunsigned long left, copied = 0;\n\tint i, chunksize;\n\n\tif (size > count)\n\t\tsize = count;\n\n\t/* Find which 4k chunk and offset with in that chunk */\n\ti = offset >> PAGE_CACHE_SHIFT;\n\toffset = offset & ~PAGE_CACHE_MASK;\n\n\twhile (size) {\n\t\tchunksize = PAGE_CACHE_SIZE;\n\t\tif (offset)\n\t\t\tchunksize -= offset;\n\t\tif (chunksize > size)\n\t\t\tchunksize = size;\n\t\tkaddr = kmap(&page[i]);\n\t\tleft = __copy_to_user(buf, kaddr + offset, chunksize);\n\t\tkunmap(&page[i]);\n\t\tif (left) {\n\t\t\tcopied += (chunksize - left);\n\t\t\tbreak;\n\t\t}\n\t\toffset = 0;\n\t\tsize -= chunksize;\n\t\tbuf += chunksize;\n\t\tcopied += chunksize;\n\t\ti++;\n\t}\n\treturn copied ? copied : -EFAULT;\n}"
  },
  {
    "function_name": "hugetlb_get_unmapped_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "144-179",
    "snippet": "static unsigned long\nhugetlb_get_unmapped_area(struct file *file, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tstruct hstate *h = hstate_file(file);\n\tstruct vm_unmapped_area_info info;\n\n\tif (len & ~huge_page_mask(h))\n\t\treturn -EINVAL;\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED) {\n\t\tif (prepare_hugepage_range(file, addr, len))\n\t\t\treturn -EINVAL;\n\t\treturn addr;\n\t}\n\n\tif (addr) {\n\t\taddr = ALIGN(addr, huge_page_size(h));\n\t\tvma = find_vma(mm, addr);\n\t\tif (TASK_SIZE - len >= addr &&\n\t\t    (!vma || addr + len <= vma->vm_start))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = 0;\n\tinfo.length = len;\n\tinfo.low_limit = TASK_UNMAPPED_BASE;\n\tinfo.high_limit = TASK_SIZE;\n\tinfo.align_mask = PAGE_MASK & ~huge_page_mask(h);\n\tinfo.align_offset = 0;\n\treturn vm_unmapped_area(&info);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unmapped_area",
          "args": [
            "&info"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "addr",
            "huge_page_size(h)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_hugepage_range",
          "args": [
            "file",
            "addr",
            "len"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_file",
          "args": [
            "file"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic unsigned long\nhugetlb_get_unmapped_area(struct file *file, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tstruct hstate *h = hstate_file(file);\n\tstruct vm_unmapped_area_info info;\n\n\tif (len & ~huge_page_mask(h))\n\t\treturn -EINVAL;\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED) {\n\t\tif (prepare_hugepage_range(file, addr, len))\n\t\t\treturn -EINVAL;\n\t\treturn addr;\n\t}\n\n\tif (addr) {\n\t\taddr = ALIGN(addr, huge_page_size(h));\n\t\tvma = find_vma(mm, addr);\n\t\tif (TASK_SIZE - len >= addr &&\n\t\t    (!vma || addr + len <= vma->vm_start))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = 0;\n\tinfo.length = len;\n\tinfo.low_limit = TASK_UNMAPPED_BASE;\n\tinfo.high_limit = TASK_SIZE;\n\tinfo.align_mask = PAGE_MASK & ~huge_page_mask(h);\n\tinfo.align_offset = 0;\n\treturn vm_unmapped_area(&info);\n}"
  },
  {
    "function_name": "hugetlbfs_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "94-137",
    "snippet": "static int hugetlbfs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t len, vma_len;\n\tint ret;\n\tstruct hstate *h = hstate_file(file);\n\n\t/*\n\t * vma address alignment (but not the pgoff alignment) has\n\t * already been checked by prepare_hugepage_range.  If you add\n\t * any error returns here, do so after setting VM_HUGETLB, so\n\t * is_vm_hugetlb_page tests below unmap_region go the right\n\t * way when do_mmap_pgoff unwinds (may be important on powerpc\n\t * and ia64).\n\t */\n\tvma->vm_flags |= VM_HUGETLB | VM_DONTEXPAND;\n\tvma->vm_ops = &hugetlb_vm_ops;\n\n\tif (vma->vm_pgoff & (~huge_page_mask(h) >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\tvma_len = (loff_t)(vma->vm_end - vma->vm_start);\n\n\tmutex_lock(&inode->i_mutex);\n\tfile_accessed(file);\n\n\tret = -ENOMEM;\n\tlen = vma_len + ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\n\tif (hugetlb_reserve_pages(inode,\n\t\t\t\tvma->vm_pgoff >> huge_page_order(h),\n\t\t\t\tlen >> huge_page_shift(h), vma,\n\t\t\t\tvma->vm_flags))\n\t\tgoto out;\n\n\tret = 0;\n\thugetlb_prefault_arch_hook(vma->vm_mm);\n\tif (vma->vm_flags & VM_WRITE && inode->i_size < len)\n\t\tinode->i_size = len;\nout:\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_prefault_arch_hook",
          "args": [
            "vma->vm_mm"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_reserve_pages",
          "args": [
            "inode",
            "vma->vm_pgoff >> huge_page_order(h)",
            "len >> huge_page_shift(h)",
            "vma",
            "vma->vm_flags"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "h"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "vma->vm_end - vma->vm_start"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_file",
          "args": [
            "file"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic int hugetlbfs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t len, vma_len;\n\tint ret;\n\tstruct hstate *h = hstate_file(file);\n\n\t/*\n\t * vma address alignment (but not the pgoff alignment) has\n\t * already been checked by prepare_hugepage_range.  If you add\n\t * any error returns here, do so after setting VM_HUGETLB, so\n\t * is_vm_hugetlb_page tests below unmap_region go the right\n\t * way when do_mmap_pgoff unwinds (may be important on powerpc\n\t * and ia64).\n\t */\n\tvma->vm_flags |= VM_HUGETLB | VM_DONTEXPAND;\n\tvma->vm_ops = &hugetlb_vm_ops;\n\n\tif (vma->vm_pgoff & (~huge_page_mask(h) >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\tvma_len = (loff_t)(vma->vm_end - vma->vm_start);\n\n\tmutex_lock(&inode->i_mutex);\n\tfile_accessed(file);\n\n\tret = -ENOMEM;\n\tlen = vma_len + ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\n\tif (hugetlb_reserve_pages(inode,\n\t\t\t\tvma->vm_pgoff >> huge_page_order(h),\n\t\t\t\tlen >> huge_page_shift(h), vma,\n\t\t\t\tvma->vm_flags))\n\t\tgoto out;\n\n\tret = 0;\n\thugetlb_prefault_arch_hook(vma->vm_mm);\n\tif (vma->vm_flags & VM_WRITE && inode->i_size < len)\n\t\tinode->i_size = len;\nout:\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "huge_pagevec_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "84-92",
    "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_reinit",
          "args": [
            "pvec"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pvec->pages[i]"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
  },
  {
    "function_name": "HUGETLBFS_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
    "lines": "60-63",
    "snippet": "static inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/migrate.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/parser.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ctype.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>\t\t/* remove ASAP */",
      "#include <asm/current.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode",
            "structhugetlbfs_inode_info",
            "vfs_inode"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}"
  }
]