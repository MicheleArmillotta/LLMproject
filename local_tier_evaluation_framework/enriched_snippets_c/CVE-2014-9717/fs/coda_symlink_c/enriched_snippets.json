[
  {
    "function_name": "coda_symlink_filler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/symlink.c",
    "lines": "23-46",
    "snippet": "static int coda_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint error;\n\tstruct coda_inode_info *cii;\n\tunsigned int len = PAGE_SIZE;\n\tchar *p = kmap(page);\n\n\tcii = ITOC(inode);\n\n\terror = venus_readlink(inode->i_sb, &cii->c_fid, p, &len);\n\tif (error)\n\t\tgoto fail;\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nfail:\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "venus_readlink",
          "args": [
            "inode->i_sb",
            "&cii->c_fid",
            "p",
            "&len"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "venus_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "346-374",
          "snippet": "int venus_readlink(struct super_block *sb, struct CodaFid *fid, \n\t\t      char *buffer, int *length)\n{ \n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int retlen;\n        char *result;\n        \n\tinsize = max_t(unsigned int,\n\t\t     INSIZE(readlink), OUTSIZE(readlink)+ *length + 1);\n\tUPARG(CODA_READLINK);\n\n        inp->coda_readlink.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\tretlen = outp->coda_readlink.count;\n\t\tif ( retlen > *length )\n\t\t\tretlen = *length;\n\t\t*length = retlen;\n\t\tresult =  (char *)outp + (long)outp->coda_readlink.data;\n\t\tmemcpy(buffer, result, retlen);\n\t\t*(buffer + retlen) = '\\0';\n\t}\n\n        CODA_FREE(inp, insize);\n        return error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nint venus_readlink(struct super_block *sb, struct CodaFid *fid, \n\t\t      char *buffer, int *length)\n{ \n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int retlen;\n        char *result;\n        \n\tinsize = max_t(unsigned int,\n\t\t     INSIZE(readlink), OUTSIZE(readlink)+ *length + 1);\n\tUPARG(CODA_READLINK);\n\n        inp->coda_readlink.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\tretlen = outp->coda_readlink.count;\n\t\tif ( retlen > *length )\n\t\t\tretlen = *length;\n\t\t*length = retlen;\n\t\tresult =  (char *)outp + (long)outp->coda_readlink.data;\n\t\tmemcpy(buffer, result, retlen);\n\t\t*(buffer + retlen) = '\\0';\n\t}\n\n        CODA_FREE(inp, insize);\n        return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "inode"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint error;\n\tstruct coda_inode_info *cii;\n\tunsigned int len = PAGE_SIZE;\n\tchar *p = kmap(page);\n\n\tcii = ITOC(inode);\n\n\terror = venus_readlink(inode->i_sb, &cii->c_fid, p, &len);\n\tif (error)\n\t\tgoto fail;\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nfail:\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn error;\n}"
  }
]