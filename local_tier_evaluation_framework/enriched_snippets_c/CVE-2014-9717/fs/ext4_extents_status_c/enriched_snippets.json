[
  {
    "function_name": "es_reclaim_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1283-1304",
    "snippet": "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan)\n{\n\tstruct inode *inode = &ei->vfs_inode;\n\tint nr_shrunk = 0;\n\text4_lblk_t start = ei->i_es_shrink_lblk;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif (ei->i_es_shk_nr == 0)\n\t\treturn 0;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_EXT_PRECACHED) &&\n\t    __ratelimit(&_rs))\n\t\text4_warning(inode->i_sb, \"forced shrink of precached extents\");\n\n\tif (!es_do_reclaim_extents(ei, EXT_MAX_BLOCKS, nr_to_scan, &nr_shrunk) &&\n\t    start != 0)\n\t\tes_do_reclaim_extents(ei, start - 1, nr_to_scan, &nr_shrunk);\n\n\tei->i_es_tree.cache_es = NULL;\n\treturn nr_shrunk;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "es_do_reclaim_extents",
          "args": [
            "ei",
            "start - 1",
            "nr_to_scan",
            "&nr_shrunk"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "es_do_reclaim_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1237-1281",
          "snippet": "static int es_do_reclaim_extents(struct ext4_inode_info *ei, ext4_lblk_t end,\n\t\t\t\t int *nr_to_scan, int *nr_shrunk)\n{\n\tstruct inode *inode = &ei->vfs_inode;\n\tstruct ext4_es_tree *tree = &ei->i_es_tree;\n\tstruct extent_status *es;\n\tstruct rb_node *node;\n\n\tes = __es_tree_search(&tree->root, ei->i_es_shrink_lblk);\n\tif (!es)\n\t\tgoto out_wrap;\n\tnode = &es->rb_node;\n\twhile (*nr_to_scan > 0) {\n\t\tif (es->es_lblk > end) {\n\t\t\tei->i_es_shrink_lblk = end + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t(*nr_to_scan)--;\n\t\tnode = rb_next(&es->rb_node);\n\t\t/*\n\t\t * We can't reclaim delayed extent from status tree because\n\t\t * fiemap, bigallic, and seek_data/hole need to use it.\n\t\t */\n\t\tif (ext4_es_is_delayed(es))\n\t\t\tgoto next;\n\t\tif (ext4_es_is_referenced(es)) {\n\t\t\text4_es_clear_referenced(es);\n\t\t\tgoto next;\n\t\t}\n\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\t(*nr_shrunk)++;\nnext:\n\t\tif (!node)\n\t\t\tgoto out_wrap;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\tei->i_es_shrink_lblk = es->es_lblk;\n\treturn 1;\nout_wrap:\n\tei->i_es_shrink_lblk = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);",
            "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\n\nstatic int es_do_reclaim_extents(struct ext4_inode_info *ei, ext4_lblk_t end,\n\t\t\t\t int *nr_to_scan, int *nr_shrunk)\n{\n\tstruct inode *inode = &ei->vfs_inode;\n\tstruct ext4_es_tree *tree = &ei->i_es_tree;\n\tstruct extent_status *es;\n\tstruct rb_node *node;\n\n\tes = __es_tree_search(&tree->root, ei->i_es_shrink_lblk);\n\tif (!es)\n\t\tgoto out_wrap;\n\tnode = &es->rb_node;\n\twhile (*nr_to_scan > 0) {\n\t\tif (es->es_lblk > end) {\n\t\t\tei->i_es_shrink_lblk = end + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t(*nr_to_scan)--;\n\t\tnode = rb_next(&es->rb_node);\n\t\t/*\n\t\t * We can't reclaim delayed extent from status tree because\n\t\t * fiemap, bigallic, and seek_data/hole need to use it.\n\t\t */\n\t\tif (ext4_es_is_delayed(es))\n\t\t\tgoto next;\n\t\tif (ext4_es_is_referenced(es)) {\n\t\t\text4_es_clear_referenced(es);\n\t\t\tgoto next;\n\t\t}\n\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\t(*nr_shrunk)++;\nnext:\n\t\tif (!node)\n\t\t\tgoto out_wrap;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\tei->i_es_shrink_lblk = es->es_lblk;\n\treturn 1;\nout_wrap:\n\tei->i_es_shrink_lblk = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"forced shrink of precached extents\""
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&_rs"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_EXT_PRECACHED"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan)\n{\n\tstruct inode *inode = &ei->vfs_inode;\n\tint nr_shrunk = 0;\n\text4_lblk_t start = ei->i_es_shrink_lblk;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif (ei->i_es_shk_nr == 0)\n\t\treturn 0;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_EXT_PRECACHED) &&\n\t    __ratelimit(&_rs))\n\t\text4_warning(inode->i_sb, \"forced shrink of precached extents\");\n\n\tif (!es_do_reclaim_extents(ei, EXT_MAX_BLOCKS, nr_to_scan, &nr_shrunk) &&\n\t    start != 0)\n\t\tes_do_reclaim_extents(ei, start - 1, nr_to_scan, &nr_shrunk);\n\n\tei->i_es_tree.cache_es = NULL;\n\treturn nr_shrunk;\n}"
  },
  {
    "function_name": "es_do_reclaim_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1237-1281",
    "snippet": "static int es_do_reclaim_extents(struct ext4_inode_info *ei, ext4_lblk_t end,\n\t\t\t\t int *nr_to_scan, int *nr_shrunk)\n{\n\tstruct inode *inode = &ei->vfs_inode;\n\tstruct ext4_es_tree *tree = &ei->i_es_tree;\n\tstruct extent_status *es;\n\tstruct rb_node *node;\n\n\tes = __es_tree_search(&tree->root, ei->i_es_shrink_lblk);\n\tif (!es)\n\t\tgoto out_wrap;\n\tnode = &es->rb_node;\n\twhile (*nr_to_scan > 0) {\n\t\tif (es->es_lblk > end) {\n\t\t\tei->i_es_shrink_lblk = end + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t(*nr_to_scan)--;\n\t\tnode = rb_next(&es->rb_node);\n\t\t/*\n\t\t * We can't reclaim delayed extent from status tree because\n\t\t * fiemap, bigallic, and seek_data/hole need to use it.\n\t\t */\n\t\tif (ext4_es_is_delayed(es))\n\t\t\tgoto next;\n\t\tif (ext4_es_is_referenced(es)) {\n\t\t\text4_es_clear_referenced(es);\n\t\t\tgoto next;\n\t\t}\n\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\t(*nr_shrunk)++;\nnext:\n\t\tif (!node)\n\t\t\tgoto out_wrap;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\tei->i_es_shrink_lblk = es->es_lblk;\n\treturn 1;\nout_wrap:\n\tei->i_es_shrink_lblk = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);",
      "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_status",
            "rb_node"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_free_extent",
          "args": [
            "inode",
            "es"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "358-373",
          "snippet": "static void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_es_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nstatic void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&es->rb_node",
            "&tree->root"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_clear_referenced",
          "args": [
            "es"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_clear_referenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "133-136",
          "snippet": "static inline void ext4_es_clear_referenced(struct extent_status *es)\n{\n\tes->es_pblk &= ~(((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT);\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)",
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)\n#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline void ext4_es_clear_referenced(struct extent_status *es)\n{\n\tes->es_pblk &= ~(((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_referenced",
          "args": [
            "es"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_referenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "138-141",
          "snippet": "static inline int ext4_es_is_referenced(struct extent_status *es)\n{\n\treturn (ext4_es_status(es) & EXTENT_STATUS_REFERENCED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)\n\nstatic inline int ext4_es_is_referenced(struct extent_status *es)\n{\n\treturn (ext4_es_status(es) & EXTENT_STATUS_REFERENCED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_delayed",
          "args": [
            "es"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "118-121",
          "snippet": "static inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&es->rb_node"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__es_tree_search",
          "args": [
            "&tree->root",
            "ei->i_es_shrink_lblk"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "__es_tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "209-235",
          "snippet": "static struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\n\nstatic int es_do_reclaim_extents(struct ext4_inode_info *ei, ext4_lblk_t end,\n\t\t\t\t int *nr_to_scan, int *nr_shrunk)\n{\n\tstruct inode *inode = &ei->vfs_inode;\n\tstruct ext4_es_tree *tree = &ei->i_es_tree;\n\tstruct extent_status *es;\n\tstruct rb_node *node;\n\n\tes = __es_tree_search(&tree->root, ei->i_es_shrink_lblk);\n\tif (!es)\n\t\tgoto out_wrap;\n\tnode = &es->rb_node;\n\twhile (*nr_to_scan > 0) {\n\t\tif (es->es_lblk > end) {\n\t\t\tei->i_es_shrink_lblk = end + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t(*nr_to_scan)--;\n\t\tnode = rb_next(&es->rb_node);\n\t\t/*\n\t\t * We can't reclaim delayed extent from status tree because\n\t\t * fiemap, bigallic, and seek_data/hole need to use it.\n\t\t */\n\t\tif (ext4_es_is_delayed(es))\n\t\t\tgoto next;\n\t\tif (ext4_es_is_referenced(es)) {\n\t\t\text4_es_clear_referenced(es);\n\t\t\tgoto next;\n\t\t}\n\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\t(*nr_shrunk)++;\nnext:\n\t\tif (!node)\n\t\t\tgoto out_wrap;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\tei->i_es_shrink_lblk = es->es_lblk;\n\treturn 1;\nout_wrap:\n\tei->i_es_shrink_lblk = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_es_unregister_shrinker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1220-1227",
    "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_shrinker",
          "args": [
            "&sbi->s_es_shrinker"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1220-1227",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_es_stats.es_stats_shk_cnt"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_es_stats.es_stats_all_cnt"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"es_shrinker_info\"",
            "sbi->s_proc"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
  },
  {
    "function_name": "ext4_es_register_shrinker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1179-1218",
    "snippet": "int ext4_es_register_shrinker(struct ext4_sb_info *sbi)\n{\n\tint err;\n\n\t/* Make sure we have enough bits for physical block number */\n\tBUILD_BUG_ON(ES_SHIFT < 48);\n\tINIT_LIST_HEAD(&sbi->s_es_list);\n\tsbi->s_es_nr_inode = 0;\n\tspin_lock_init(&sbi->s_es_lock);\n\tsbi->s_es_stats.es_stats_shrunk = 0;\n\tsbi->s_es_stats.es_stats_cache_hits = 0;\n\tsbi->s_es_stats.es_stats_cache_misses = 0;\n\tsbi->s_es_stats.es_stats_scan_time = 0;\n\tsbi->s_es_stats.es_stats_max_scan_time = 0;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_all_cnt, 0, GFP_KERNEL);\n\tif (err)\n\t\treturn err;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_shk_cnt, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err1;\n\n\tsbi->s_es_shrinker.scan_objects = ext4_es_scan;\n\tsbi->s_es_shrinker.count_objects = ext4_es_count;\n\tsbi->s_es_shrinker.seeks = DEFAULT_SEEKS;\n\terr = register_shrinker(&sbi->s_es_shrinker);\n\tif (err)\n\t\tgoto err2;\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"es_shrinker_info\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_es_seq_shrinker_info_fops, sbi);\n\n\treturn 0;\n\nerr2:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\nerr1:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations ext4_es_seq_shrinker_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ext4_es_seq_shrinker_info_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= ext4_es_seq_shrinker_info_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_es_stats.es_stats_all_cnt"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_es_stats.es_stats_shk_cnt"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "\"es_shrinker_info\"",
            "S_IRUGO",
            "sbi->s_proc",
            "&ext4_es_seq_shrinker_info_fops",
            "sbi"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "proc_create_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "458-489",
          "snippet": "struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};\n\nstruct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_shrinker",
          "args": [
            "&sbi->s_es_shrinker"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1220-1227",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_es_stats.es_stats_shk_cnt",
            "0",
            "GFP_KERNEL"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_es_stats.es_stats_all_cnt",
            "0",
            "GFP_KERNEL"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->s_es_lock"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sbi->s_es_list"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ES_SHIFT < 48"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic const struct file_operations ext4_es_seq_shrinker_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ext4_es_seq_shrinker_info_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= ext4_es_seq_shrinker_info_release,\n};\n\nint ext4_es_register_shrinker(struct ext4_sb_info *sbi)\n{\n\tint err;\n\n\t/* Make sure we have enough bits for physical block number */\n\tBUILD_BUG_ON(ES_SHIFT < 48);\n\tINIT_LIST_HEAD(&sbi->s_es_list);\n\tsbi->s_es_nr_inode = 0;\n\tspin_lock_init(&sbi->s_es_lock);\n\tsbi->s_es_stats.es_stats_shrunk = 0;\n\tsbi->s_es_stats.es_stats_cache_hits = 0;\n\tsbi->s_es_stats.es_stats_cache_misses = 0;\n\tsbi->s_es_stats.es_stats_scan_time = 0;\n\tsbi->s_es_stats.es_stats_max_scan_time = 0;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_all_cnt, 0, GFP_KERNEL);\n\tif (err)\n\t\treturn err;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_shk_cnt, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err1;\n\n\tsbi->s_es_shrinker.scan_objects = ext4_es_scan;\n\tsbi->s_es_shrinker.count_objects = ext4_es_count;\n\tsbi->s_es_shrinker.seeks = DEFAULT_SEEKS;\n\terr = register_shrinker(&sbi->s_es_shrinker);\n\tif (err)\n\t\tgoto err2;\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"es_shrinker_info\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_es_seq_shrinker_info_fops, sbi);\n\n\treturn 0;\n\nerr2:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\nerr1:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_es_seq_shrinker_info_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1165-1169",
    "snippet": "static int\next4_es_seq_shrinker_info_release(struct inode *inode, struct file *file)\n{\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int\next4_es_seq_shrinker_info_release(struct inode *inode, struct file *file)\n{\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "ext4_es_seq_shrinker_info_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1151-1163",
    "snippet": "static int\next4_es_seq_shrinker_info_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = seq_open(file, &ext4_es_seq_shrinker_info_ops);\n\tif (!ret) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tm->private = PDE_DATA(inode);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations ext4_es_seq_shrinker_info_ops = {\n\t.start = ext4_es_seq_shrinker_info_start,\n\t.next  = ext4_es_seq_shrinker_info_next,\n\t.stop  = ext4_es_seq_shrinker_info_stop,\n\t.show  = ext4_es_seq_shrinker_info_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "__PDE_DATA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "85-88",
          "snippet": "static inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&ext4_es_seq_shrinker_info_ops"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic const struct seq_operations ext4_es_seq_shrinker_info_ops = {\n\t.start = ext4_es_seq_shrinker_info_start,\n\t.next  = ext4_es_seq_shrinker_info_next,\n\t.stop  = ext4_es_seq_shrinker_info_stop,\n\t.show  = ext4_es_seq_shrinker_info_show,\n};\n\nstatic int\next4_es_seq_shrinker_info_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = seq_open(file, &ext4_es_seq_shrinker_info_ops);\n\tif (!ret) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tm->private = PDE_DATA(inode);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_es_seq_shrinker_info_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1140-1142",
    "snippet": "static void ext4_es_seq_shrinker_info_stop(struct seq_file *seq, void *v)\n{\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_seq_shrinker_info_stop(struct seq_file *seq, void *v)\n{\n}"
  },
  {
    "function_name": "ext4_es_seq_shrinker_info_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1097-1138",
    "snippet": "static int ext4_es_seq_shrinker_info_show(struct seq_file *seq, void *v)\n{\n\tstruct ext4_sb_info *sbi = seq->private;\n\tstruct ext4_es_stats *es_stats = &sbi->s_es_stats;\n\tstruct ext4_inode_info *ei, *max = NULL;\n\tunsigned int inode_cnt = 0;\n\n\tif (v != SEQ_START_TOKEN)\n\t\treturn 0;\n\n\t/* here we just find an inode that has the max nr. of objects */\n\tspin_lock(&sbi->s_es_lock);\n\tlist_for_each_entry(ei, &sbi->s_es_list, i_es_list) {\n\t\tinode_cnt++;\n\t\tif (max && max->i_es_all_nr < ei->i_es_all_nr)\n\t\t\tmax = ei;\n\t\telse if (!max)\n\t\t\tmax = ei;\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\tseq_printf(seq, \"stats:\\n  %lld objects\\n  %lld reclaimable objects\\n\",\n\t\t   percpu_counter_sum_positive(&es_stats->es_stats_all_cnt),\n\t\t   percpu_counter_sum_positive(&es_stats->es_stats_shk_cnt));\n\tseq_printf(seq, \"  %lu/%lu cache hits/misses\\n\",\n\t\t   es_stats->es_stats_cache_hits,\n\t\t   es_stats->es_stats_cache_misses);\n\tif (inode_cnt)\n\t\tseq_printf(seq, \"  %d inodes on list\\n\", inode_cnt);\n\n\tseq_printf(seq, \"average:\\n  %llu us scan time\\n\",\n\t    div_u64(es_stats->es_stats_scan_time, 1000));\n\tseq_printf(seq, \"  %lu shrunk objects\\n\", es_stats->es_stats_shrunk);\n\tif (inode_cnt)\n\t\tseq_printf(seq,\n\t\t    \"maximum:\\n  %lu inode (%u objects, %u reclaimable)\\n\"\n\t\t    \"  %llu us max scan time\\n\",\n\t\t    max->vfs_inode.i_ino, max->i_es_all_nr, max->i_es_shk_nr,\n\t\t    div_u64(es_stats->es_stats_max_scan_time, 1000));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"maximum:\\n  %lu inode (%u objects, %u reclaimable)\\n\"\n\t\t    \"  %llu us max scan time\\n\"",
            "max->vfs_inode.i_ino",
            "max->i_es_all_nr",
            "max->i_es_shk_nr",
            "div_u64(es_stats->es_stats_max_scan_time, 1000)"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "es_stats->es_stats_max_scan_time",
            "1000"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "es_stats->es_stats_scan_time",
            "1000"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "&es_stats->es_stats_shk_cnt"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "&es_stats->es_stats_all_cnt"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_es_lock"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ei",
            "&sbi->s_es_list",
            "i_es_list"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_es_lock"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int ext4_es_seq_shrinker_info_show(struct seq_file *seq, void *v)\n{\n\tstruct ext4_sb_info *sbi = seq->private;\n\tstruct ext4_es_stats *es_stats = &sbi->s_es_stats;\n\tstruct ext4_inode_info *ei, *max = NULL;\n\tunsigned int inode_cnt = 0;\n\n\tif (v != SEQ_START_TOKEN)\n\t\treturn 0;\n\n\t/* here we just find an inode that has the max nr. of objects */\n\tspin_lock(&sbi->s_es_lock);\n\tlist_for_each_entry(ei, &sbi->s_es_list, i_es_list) {\n\t\tinode_cnt++;\n\t\tif (max && max->i_es_all_nr < ei->i_es_all_nr)\n\t\t\tmax = ei;\n\t\telse if (!max)\n\t\t\tmax = ei;\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\tseq_printf(seq, \"stats:\\n  %lld objects\\n  %lld reclaimable objects\\n\",\n\t\t   percpu_counter_sum_positive(&es_stats->es_stats_all_cnt),\n\t\t   percpu_counter_sum_positive(&es_stats->es_stats_shk_cnt));\n\tseq_printf(seq, \"  %lu/%lu cache hits/misses\\n\",\n\t\t   es_stats->es_stats_cache_hits,\n\t\t   es_stats->es_stats_cache_misses);\n\tif (inode_cnt)\n\t\tseq_printf(seq, \"  %d inodes on list\\n\", inode_cnt);\n\n\tseq_printf(seq, \"average:\\n  %llu us scan time\\n\",\n\t    div_u64(es_stats->es_stats_scan_time, 1000));\n\tseq_printf(seq, \"  %lu shrunk objects\\n\", es_stats->es_stats_shrunk);\n\tif (inode_cnt)\n\t\tseq_printf(seq,\n\t\t    \"maximum:\\n  %lu inode (%u objects, %u reclaimable)\\n\"\n\t\t    \"  %llu us max scan time\\n\",\n\t\t    max->vfs_inode.i_ino, max->i_es_all_nr, max->i_es_shk_nr,\n\t\t    div_u64(es_stats->es_stats_max_scan_time, 1000));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_es_seq_shrinker_info_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1091-1095",
    "snippet": "static void *\next4_es_seq_shrinker_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void *\next4_es_seq_shrinker_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext4_es_seq_shrinker_info_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1086-1089",
    "snippet": "static void *ext4_es_seq_shrinker_info_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos ? NULL : SEQ_START_TOKEN;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void *ext4_es_seq_shrinker_info_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos ? NULL : SEQ_START_TOKEN;\n}"
  },
  {
    "function_name": "ext4_es_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1066-1084",
    "snippet": "static unsigned long ext4_es_scan(struct shrinker *shrink,\n\t\t\t\t  struct shrink_control *sc)\n{\n\tstruct ext4_sb_info *sbi = container_of(shrink,\n\t\t\t\t\tstruct ext4_sb_info, s_es_shrinker);\n\tint nr_to_scan = sc->nr_to_scan;\n\tint ret, nr_shrunk;\n\n\tret = percpu_counter_read_positive(&sbi->s_es_stats.es_stats_shk_cnt);\n\ttrace_ext4_es_shrink_scan_enter(sbi->s_sb, nr_to_scan, ret);\n\n\tif (!nr_to_scan)\n\t\treturn ret;\n\n\tnr_shrunk = __es_shrink(sbi, nr_to_scan, NULL);\n\n\ttrace_ext4_es_shrink_scan_exit(sbi->s_sb, nr_shrunk, ret);\n\treturn nr_shrunk;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_es_shrink_scan_exit",
          "args": [
            "sbi->s_sb",
            "nr_shrunk",
            "ret"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__es_shrink",
          "args": [
            "sbi",
            "nr_to_scan",
            "NULL"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "__es_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "966-1052",
          "snippet": "static int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei)\n{\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_es_stats *es_stats;\n\tktime_t start_time;\n\tu64 scan_time;\n\tint nr_to_walk;\n\tint nr_shrunk = 0;\n\tint retried = 0, nr_skipped = 0;\n\n\tes_stats = &sbi->s_es_stats;\n\tstart_time = ktime_get();\n\nretry:\n\tspin_lock(&sbi->s_es_lock);\n\tnr_to_walk = sbi->s_es_nr_inode;\n\twhile (nr_to_walk-- > 0) {\n\t\tif (list_empty(&sbi->s_es_list)) {\n\t\t\tspin_unlock(&sbi->s_es_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tei = list_first_entry(&sbi->s_es_list, struct ext4_inode_info,\n\t\t\t\t      i_es_list);\n\t\t/* Move the inode to the tail */\n\t\tlist_move_tail(&ei->i_es_list, &sbi->s_es_list);\n\n\t\t/*\n\t\t * Normally we try hard to avoid shrinking precached inodes,\n\t\t * but we will as a last resort.\n\t\t */\n\t\tif (!retried && ext4_test_inode_state(&ei->vfs_inode,\n\t\t\t\t\t\tEXT4_STATE_EXT_PRECACHED)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ei == locked_ei || !write_trylock(&ei->i_es_lock)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now we hold i_es_lock which protects us from inode reclaim\n\t\t * freeing inode under us\n\t\t */\n\t\tspin_unlock(&sbi->s_es_lock);\n\n\t\tnr_shrunk += es_reclaim_extents(ei, &nr_to_scan);\n\t\twrite_unlock(&ei->i_es_lock);\n\n\t\tif (nr_to_scan <= 0)\n\t\t\tgoto out;\n\t\tspin_lock(&sbi->s_es_lock);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\t/*\n\t * If we skipped any inodes, and we weren't able to make any\n\t * forward progress, try again to scan precached inodes.\n\t */\n\tif ((nr_shrunk == 0) && nr_skipped && !retried) {\n\t\tretried++;\n\t\tgoto retry;\n\t}\n\n\tif (locked_ei && nr_shrunk == 0)\n\t\tnr_shrunk = es_reclaim_extents(locked_ei, &nr_to_scan);\n\nout:\n\tscan_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\tif (likely(es_stats->es_stats_scan_time))\n\t\tes_stats->es_stats_scan_time = (scan_time +\n\t\t\t\tes_stats->es_stats_scan_time*3) / 4;\n\telse\n\t\tes_stats->es_stats_scan_time = scan_time;\n\tif (scan_time > es_stats->es_stats_max_scan_time)\n\t\tes_stats->es_stats_max_scan_time = scan_time;\n\tif (likely(es_stats->es_stats_shrunk))\n\t\tes_stats->es_stats_shrunk = (nr_shrunk +\n\t\t\t\tes_stats->es_stats_shrunk*3) / 4;\n\telse\n\t\tes_stats->es_stats_shrunk = nr_shrunk;\n\n\ttrace_ext4_es_shrink(sbi->s_sb, nr_shrunk, scan_time,\n\t\t\t     nr_skipped, retried);\n\treturn nr_shrunk;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);",
            "static int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei);\n\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei)\n{\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_es_stats *es_stats;\n\tktime_t start_time;\n\tu64 scan_time;\n\tint nr_to_walk;\n\tint nr_shrunk = 0;\n\tint retried = 0, nr_skipped = 0;\n\n\tes_stats = &sbi->s_es_stats;\n\tstart_time = ktime_get();\n\nretry:\n\tspin_lock(&sbi->s_es_lock);\n\tnr_to_walk = sbi->s_es_nr_inode;\n\twhile (nr_to_walk-- > 0) {\n\t\tif (list_empty(&sbi->s_es_list)) {\n\t\t\tspin_unlock(&sbi->s_es_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tei = list_first_entry(&sbi->s_es_list, struct ext4_inode_info,\n\t\t\t\t      i_es_list);\n\t\t/* Move the inode to the tail */\n\t\tlist_move_tail(&ei->i_es_list, &sbi->s_es_list);\n\n\t\t/*\n\t\t * Normally we try hard to avoid shrinking precached inodes,\n\t\t * but we will as a last resort.\n\t\t */\n\t\tif (!retried && ext4_test_inode_state(&ei->vfs_inode,\n\t\t\t\t\t\tEXT4_STATE_EXT_PRECACHED)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ei == locked_ei || !write_trylock(&ei->i_es_lock)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now we hold i_es_lock which protects us from inode reclaim\n\t\t * freeing inode under us\n\t\t */\n\t\tspin_unlock(&sbi->s_es_lock);\n\n\t\tnr_shrunk += es_reclaim_extents(ei, &nr_to_scan);\n\t\twrite_unlock(&ei->i_es_lock);\n\n\t\tif (nr_to_scan <= 0)\n\t\t\tgoto out;\n\t\tspin_lock(&sbi->s_es_lock);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\t/*\n\t * If we skipped any inodes, and we weren't able to make any\n\t * forward progress, try again to scan precached inodes.\n\t */\n\tif ((nr_shrunk == 0) && nr_skipped && !retried) {\n\t\tretried++;\n\t\tgoto retry;\n\t}\n\n\tif (locked_ei && nr_shrunk == 0)\n\t\tnr_shrunk = es_reclaim_extents(locked_ei, &nr_to_scan);\n\nout:\n\tscan_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\tif (likely(es_stats->es_stats_scan_time))\n\t\tes_stats->es_stats_scan_time = (scan_time +\n\t\t\t\tes_stats->es_stats_scan_time*3) / 4;\n\telse\n\t\tes_stats->es_stats_scan_time = scan_time;\n\tif (scan_time > es_stats->es_stats_max_scan_time)\n\t\tes_stats->es_stats_max_scan_time = scan_time;\n\tif (likely(es_stats->es_stats_shrunk))\n\t\tes_stats->es_stats_shrunk = (nr_shrunk +\n\t\t\t\tes_stats->es_stats_shrunk*3) / 4;\n\telse\n\t\tes_stats->es_stats_shrunk = nr_shrunk;\n\n\ttrace_ext4_es_shrink(sbi->s_sb, nr_shrunk, scan_time,\n\t\t\t     nr_skipped, retried);\n\treturn nr_shrunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_es_shrink_scan_enter",
          "args": [
            "sbi->s_sb",
            "nr_to_scan",
            "ret"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_es_stats.es_stats_shk_cnt"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "shrink",
            "structext4_sb_info",
            "s_es_shrinker"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\n\nstatic unsigned long ext4_es_scan(struct shrinker *shrink,\n\t\t\t\t  struct shrink_control *sc)\n{\n\tstruct ext4_sb_info *sbi = container_of(shrink,\n\t\t\t\t\tstruct ext4_sb_info, s_es_shrinker);\n\tint nr_to_scan = sc->nr_to_scan;\n\tint ret, nr_shrunk;\n\n\tret = percpu_counter_read_positive(&sbi->s_es_stats.es_stats_shk_cnt);\n\ttrace_ext4_es_shrink_scan_enter(sbi->s_sb, nr_to_scan, ret);\n\n\tif (!nr_to_scan)\n\t\treturn ret;\n\n\tnr_shrunk = __es_shrink(sbi, nr_to_scan, NULL);\n\n\ttrace_ext4_es_shrink_scan_exit(sbi->s_sb, nr_shrunk, ret);\n\treturn nr_shrunk;\n}"
  },
  {
    "function_name": "ext4_es_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "1054-1064",
    "snippet": "static unsigned long ext4_es_count(struct shrinker *shrink,\n\t\t\t\t   struct shrink_control *sc)\n{\n\tunsigned long nr;\n\tstruct ext4_sb_info *sbi;\n\n\tsbi = container_of(shrink, struct ext4_sb_info, s_es_shrinker);\n\tnr = percpu_counter_read_positive(&sbi->s_es_stats.es_stats_shk_cnt);\n\ttrace_ext4_es_shrink_count(sbi->s_sb, sc->nr_to_scan, nr);\n\treturn nr;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_es_shrink_count",
          "args": [
            "sbi->s_sb",
            "sc->nr_to_scan",
            "nr"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_es_stats.es_stats_shk_cnt"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "shrink",
            "structext4_sb_info",
            "s_es_shrinker"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\n\nstatic unsigned long ext4_es_count(struct shrinker *shrink,\n\t\t\t\t   struct shrink_control *sc)\n{\n\tunsigned long nr;\n\tstruct ext4_sb_info *sbi;\n\n\tsbi = container_of(shrink, struct ext4_sb_info, s_es_shrinker);\n\tnr = percpu_counter_read_positive(&sbi->s_es_stats.es_stats_shk_cnt);\n\ttrace_ext4_es_shrink_count(sbi->s_sb, sc->nr_to_scan, nr);\n\treturn nr;\n}"
  },
  {
    "function_name": "__es_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "966-1052",
    "snippet": "static int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei)\n{\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_es_stats *es_stats;\n\tktime_t start_time;\n\tu64 scan_time;\n\tint nr_to_walk;\n\tint nr_shrunk = 0;\n\tint retried = 0, nr_skipped = 0;\n\n\tes_stats = &sbi->s_es_stats;\n\tstart_time = ktime_get();\n\nretry:\n\tspin_lock(&sbi->s_es_lock);\n\tnr_to_walk = sbi->s_es_nr_inode;\n\twhile (nr_to_walk-- > 0) {\n\t\tif (list_empty(&sbi->s_es_list)) {\n\t\t\tspin_unlock(&sbi->s_es_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tei = list_first_entry(&sbi->s_es_list, struct ext4_inode_info,\n\t\t\t\t      i_es_list);\n\t\t/* Move the inode to the tail */\n\t\tlist_move_tail(&ei->i_es_list, &sbi->s_es_list);\n\n\t\t/*\n\t\t * Normally we try hard to avoid shrinking precached inodes,\n\t\t * but we will as a last resort.\n\t\t */\n\t\tif (!retried && ext4_test_inode_state(&ei->vfs_inode,\n\t\t\t\t\t\tEXT4_STATE_EXT_PRECACHED)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ei == locked_ei || !write_trylock(&ei->i_es_lock)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now we hold i_es_lock which protects us from inode reclaim\n\t\t * freeing inode under us\n\t\t */\n\t\tspin_unlock(&sbi->s_es_lock);\n\n\t\tnr_shrunk += es_reclaim_extents(ei, &nr_to_scan);\n\t\twrite_unlock(&ei->i_es_lock);\n\n\t\tif (nr_to_scan <= 0)\n\t\t\tgoto out;\n\t\tspin_lock(&sbi->s_es_lock);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\t/*\n\t * If we skipped any inodes, and we weren't able to make any\n\t * forward progress, try again to scan precached inodes.\n\t */\n\tif ((nr_shrunk == 0) && nr_skipped && !retried) {\n\t\tretried++;\n\t\tgoto retry;\n\t}\n\n\tif (locked_ei && nr_shrunk == 0)\n\t\tnr_shrunk = es_reclaim_extents(locked_ei, &nr_to_scan);\n\nout:\n\tscan_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\tif (likely(es_stats->es_stats_scan_time))\n\t\tes_stats->es_stats_scan_time = (scan_time +\n\t\t\t\tes_stats->es_stats_scan_time*3) / 4;\n\telse\n\t\tes_stats->es_stats_scan_time = scan_time;\n\tif (scan_time > es_stats->es_stats_max_scan_time)\n\t\tes_stats->es_stats_max_scan_time = scan_time;\n\tif (likely(es_stats->es_stats_shrunk))\n\t\tes_stats->es_stats_shrunk = (nr_shrunk +\n\t\t\t\tes_stats->es_stats_shrunk*3) / 4;\n\telse\n\t\tes_stats->es_stats_shrunk = nr_shrunk;\n\n\ttrace_ext4_es_shrink(sbi->s_sb, nr_shrunk, scan_time,\n\t\t\t     nr_skipped, retried);\n\treturn nr_shrunk;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);",
      "static int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_es_shrink",
          "args": [
            "sbi->s_sb",
            "nr_shrunk",
            "scan_time",
            "nr_skipped",
            "retried"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "es_stats->es_stats_shrunk"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "es_stats->es_stats_scan_time"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ktime_get(), start_time)"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "start_time"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es_reclaim_extents",
          "args": [
            "locked_ei",
            "&nr_to_scan"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "es_reclaim_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1283-1304",
          "snippet": "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan)\n{\n\tstruct inode *inode = &ei->vfs_inode;\n\tint nr_shrunk = 0;\n\text4_lblk_t start = ei->i_es_shrink_lblk;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif (ei->i_es_shk_nr == 0)\n\t\treturn 0;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_EXT_PRECACHED) &&\n\t    __ratelimit(&_rs))\n\t\text4_warning(inode->i_sb, \"forced shrink of precached extents\");\n\n\tif (!es_do_reclaim_extents(ei, EXT_MAX_BLOCKS, nr_to_scan, &nr_shrunk) &&\n\t    start != 0)\n\t\tes_do_reclaim_extents(ei, start - 1, nr_to_scan, &nr_shrunk);\n\n\tei->i_es_tree.cache_es = NULL;\n\treturn nr_shrunk;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan)\n{\n\tstruct inode *inode = &ei->vfs_inode;\n\tint nr_shrunk = 0;\n\text4_lblk_t start = ei->i_es_shrink_lblk;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif (ei->i_es_shk_nr == 0)\n\t\treturn 0;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_EXT_PRECACHED) &&\n\t    __ratelimit(&_rs))\n\t\text4_warning(inode->i_sb, \"forced shrink of precached extents\");\n\n\tif (!es_do_reclaim_extents(ei, EXT_MAX_BLOCKS, nr_to_scan, &nr_shrunk) &&\n\t    start != 0)\n\t\tes_do_reclaim_extents(ei, start - 1, nr_to_scan, &nr_shrunk);\n\n\tei->i_es_tree.cache_es = NULL;\n\treturn nr_shrunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_es_lock"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_es_lock"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&ei->i_es_lock"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_trylock",
          "args": [
            "&ei->i_es_lock"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "&ei->vfs_inode",
            "EXT4_STATE_EXT_PRECACHED"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&ei->i_es_list",
            "&sbi->s_es_list"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&sbi->s_es_list",
            "structext4_inode_info",
            "i_es_list"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sbi->s_es_list"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei);\n\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei)\n{\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_es_stats *es_stats;\n\tktime_t start_time;\n\tu64 scan_time;\n\tint nr_to_walk;\n\tint nr_shrunk = 0;\n\tint retried = 0, nr_skipped = 0;\n\n\tes_stats = &sbi->s_es_stats;\n\tstart_time = ktime_get();\n\nretry:\n\tspin_lock(&sbi->s_es_lock);\n\tnr_to_walk = sbi->s_es_nr_inode;\n\twhile (nr_to_walk-- > 0) {\n\t\tif (list_empty(&sbi->s_es_list)) {\n\t\t\tspin_unlock(&sbi->s_es_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tei = list_first_entry(&sbi->s_es_list, struct ext4_inode_info,\n\t\t\t\t      i_es_list);\n\t\t/* Move the inode to the tail */\n\t\tlist_move_tail(&ei->i_es_list, &sbi->s_es_list);\n\n\t\t/*\n\t\t * Normally we try hard to avoid shrinking precached inodes,\n\t\t * but we will as a last resort.\n\t\t */\n\t\tif (!retried && ext4_test_inode_state(&ei->vfs_inode,\n\t\t\t\t\t\tEXT4_STATE_EXT_PRECACHED)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ei == locked_ei || !write_trylock(&ei->i_es_lock)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now we hold i_es_lock which protects us from inode reclaim\n\t\t * freeing inode under us\n\t\t */\n\t\tspin_unlock(&sbi->s_es_lock);\n\n\t\tnr_shrunk += es_reclaim_extents(ei, &nr_to_scan);\n\t\twrite_unlock(&ei->i_es_lock);\n\n\t\tif (nr_to_scan <= 0)\n\t\t\tgoto out;\n\t\tspin_lock(&sbi->s_es_lock);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\t/*\n\t * If we skipped any inodes, and we weren't able to make any\n\t * forward progress, try again to scan precached inodes.\n\t */\n\tif ((nr_shrunk == 0) && nr_skipped && !retried) {\n\t\tretried++;\n\t\tgoto retry;\n\t}\n\n\tif (locked_ei && nr_shrunk == 0)\n\t\tnr_shrunk = es_reclaim_extents(locked_ei, &nr_to_scan);\n\nout:\n\tscan_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\tif (likely(es_stats->es_stats_scan_time))\n\t\tes_stats->es_stats_scan_time = (scan_time +\n\t\t\t\tes_stats->es_stats_scan_time*3) / 4;\n\telse\n\t\tes_stats->es_stats_scan_time = scan_time;\n\tif (scan_time > es_stats->es_stats_max_scan_time)\n\t\tes_stats->es_stats_max_scan_time = scan_time;\n\tif (likely(es_stats->es_stats_shrunk))\n\t\tes_stats->es_stats_shrunk = (nr_shrunk +\n\t\t\t\tes_stats->es_stats_shrunk*3) / 4;\n\telse\n\t\tes_stats->es_stats_shrunk = nr_shrunk;\n\n\ttrace_ext4_es_shrink(sbi->s_sb, nr_shrunk, scan_time,\n\t\t\t     nr_skipped, retried);\n\treturn nr_shrunk;\n}"
  },
  {
    "function_name": "ext4_es_remove_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "938-964",
    "snippet": "int ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_es_print_tree",
          "args": [
            "inode"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_print_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "177-194",
          "snippet": "static void ext4_es_print_tree(struct inode *inode)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct rb_node *node;\n\n\tprintk(KERN_DEBUG \"status extents for inode %lu:\", inode->i_ino);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tnode = rb_first(&tree->root);\n\twhile (node) {\n\t\tstruct extent_status *es;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tprintk(KERN_DEBUG \" [%u/%u) %llu %x\",\n\t\t       es->es_lblk, es->es_len,\n\t\t       ext4_es_pblock(es), ext4_es_status(es));\n\t\tnode = rb_next(node);\n\t}\n\tprintk(KERN_DEBUG \"\\n\");\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_print_tree(struct inode *inode)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct rb_node *node;\n\n\tprintk(KERN_DEBUG \"status extents for inode %lu:\", inode->i_ino);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tnode = rb_first(&tree->root);\n\twhile (node) {\n\t\tstruct extent_status *es;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tprintk(KERN_DEBUG \" [%u/%u) %llu %x\",\n\t\t       es->es_lblk, es->es_len,\n\t\t       ext4_es_pblock(es), ext4_es_status(es));\n\t\tnode = rb_next(node);\n\t}\n\tprintk(KERN_DEBUG \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&EXT4_I(inode)->i_es_lock"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__es_remove_extent",
          "args": [
            "inode",
            "lblk",
            "end"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "__es_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "833-931",
          "snippet": "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node *node;\n\tstruct extent_status *es;\n\tstruct extent_status orig_es;\n\text4_lblk_t len1, len2;\n\text4_fsblk_t block;\n\tint err;\n\nretry:\n\terr = 0;\n\tes = __es_tree_search(&tree->root, lblk);\n\tif (!es)\n\t\tgoto out;\n\tif (es->es_lblk > end)\n\t\tgoto out;\n\n\t/* Simply invalidate cache_es. */\n\ttree->cache_es = NULL;\n\n\torig_es.es_lblk = es->es_lblk;\n\torig_es.es_len = es->es_len;\n\torig_es.es_pblk = es->es_pblk;\n\n\tlen1 = lblk > es->es_lblk ? lblk - es->es_lblk : 0;\n\tlen2 = ext4_es_end(es) > end ? ext4_es_end(es) - end : 0;\n\tif (len1 > 0)\n\t\tes->es_len = len1;\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct extent_status newes;\n\n\t\t\tnewes.es_lblk = end + 1;\n\t\t\tnewes.es_len = len2;\n\t\t\tblock = 0x7FDEADBEEFULL;\n\t\t\tif (ext4_es_is_written(&orig_es) ||\n\t\t\t    ext4_es_is_unwritten(&orig_es))\n\t\t\t\tblock = ext4_es_pblock(&orig_es) +\n\t\t\t\t\torig_es.es_len - len2;\n\t\t\text4_es_store_pblock_status(&newes, block,\n\t\t\t\t\t\t    ext4_es_status(&orig_es));\n\t\t\terr = __es_insert_extent(inode, &newes);\n\t\t\tif (err) {\n\t\t\t\tes->es_lblk = orig_es.es_lblk;\n\t\t\t\tes->es_len = orig_es.es_len;\n\t\t\t\tif ((err == -ENOMEM) &&\n\t\t\t\t    __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t\t128, EXT4_I(inode)))\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tes->es_lblk = end + 1;\n\t\t\tes->es_len = len2;\n\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t    ext4_es_is_unwritten(es)) {\n\t\t\t\tblock = orig_es.es_pblk + orig_es.es_len - len2;\n\t\t\t\text4_es_store_pblock(es, block);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (len1 > 0) {\n\t\tnode = rb_next(&es->rb_node);\n\t\tif (node)\n\t\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\telse\n\t\t\tes = NULL;\n\t}\n\n\twhile (es && ext4_es_end(es) <= end) {\n\t\tnode = rb_next(&es->rb_node);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tif (!node) {\n\t\t\tes = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\n\tif (es && es->es_lblk < end + 1) {\n\t\text4_lblk_t orig_len = es->es_len;\n\n\t\tlen1 = ext4_es_end(es) - end;\n\t\tes->es_lblk = end + 1;\n\t\tes->es_len = len1;\n\t\tif (ext4_es_is_written(es) || ext4_es_is_unwritten(es)) {\n\t\t\tblock = es->es_pblk + orig_len - len1;\n\t\t\text4_es_store_pblock(es, block);\n\t\t}\n\t}\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);",
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node *node;\n\tstruct extent_status *es;\n\tstruct extent_status orig_es;\n\text4_lblk_t len1, len2;\n\text4_fsblk_t block;\n\tint err;\n\nretry:\n\terr = 0;\n\tes = __es_tree_search(&tree->root, lblk);\n\tif (!es)\n\t\tgoto out;\n\tif (es->es_lblk > end)\n\t\tgoto out;\n\n\t/* Simply invalidate cache_es. */\n\ttree->cache_es = NULL;\n\n\torig_es.es_lblk = es->es_lblk;\n\torig_es.es_len = es->es_len;\n\torig_es.es_pblk = es->es_pblk;\n\n\tlen1 = lblk > es->es_lblk ? lblk - es->es_lblk : 0;\n\tlen2 = ext4_es_end(es) > end ? ext4_es_end(es) - end : 0;\n\tif (len1 > 0)\n\t\tes->es_len = len1;\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct extent_status newes;\n\n\t\t\tnewes.es_lblk = end + 1;\n\t\t\tnewes.es_len = len2;\n\t\t\tblock = 0x7FDEADBEEFULL;\n\t\t\tif (ext4_es_is_written(&orig_es) ||\n\t\t\t    ext4_es_is_unwritten(&orig_es))\n\t\t\t\tblock = ext4_es_pblock(&orig_es) +\n\t\t\t\t\torig_es.es_len - len2;\n\t\t\text4_es_store_pblock_status(&newes, block,\n\t\t\t\t\t\t    ext4_es_status(&orig_es));\n\t\t\terr = __es_insert_extent(inode, &newes);\n\t\t\tif (err) {\n\t\t\t\tes->es_lblk = orig_es.es_lblk;\n\t\t\t\tes->es_len = orig_es.es_len;\n\t\t\t\tif ((err == -ENOMEM) &&\n\t\t\t\t    __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t\t128, EXT4_I(inode)))\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tes->es_lblk = end + 1;\n\t\t\tes->es_len = len2;\n\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t    ext4_es_is_unwritten(es)) {\n\t\t\t\tblock = orig_es.es_pblk + orig_es.es_len - len2;\n\t\t\t\text4_es_store_pblock(es, block);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (len1 > 0) {\n\t\tnode = rb_next(&es->rb_node);\n\t\tif (node)\n\t\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\telse\n\t\t\tes = NULL;\n\t}\n\n\twhile (es && ext4_es_end(es) <= end) {\n\t\tnode = rb_next(&es->rb_node);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tif (!node) {\n\t\t\tes = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\n\tif (es && es->es_lblk < end + 1) {\n\t\text4_lblk_t orig_len = es->es_len;\n\n\t\tlen1 = ext4_es_end(es) - end;\n\t\tes->es_lblk = end + 1;\n\t\tes->es_len = len1;\n\t\tif (ext4_es_is_written(es) || ext4_es_is_unwritten(es)) {\n\t\t\tblock = es->es_pblk + orig_len - len1;\n\t\t\text4_es_store_pblock(es, block);\n\t\t}\n\t}\n\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&EXT4_I(inode)->i_es_lock"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end < lblk"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es_debug",
          "args": [
            "\"remove [%u/%u) from extent status tree of inode %lu\\n\"",
            "lblk",
            "len",
            "inode->i_ino"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_es_remove_extent",
          "args": [
            "inode",
            "lblk",
            "len"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nint ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "__es_remove_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "833-931",
    "snippet": "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node *node;\n\tstruct extent_status *es;\n\tstruct extent_status orig_es;\n\text4_lblk_t len1, len2;\n\text4_fsblk_t block;\n\tint err;\n\nretry:\n\terr = 0;\n\tes = __es_tree_search(&tree->root, lblk);\n\tif (!es)\n\t\tgoto out;\n\tif (es->es_lblk > end)\n\t\tgoto out;\n\n\t/* Simply invalidate cache_es. */\n\ttree->cache_es = NULL;\n\n\torig_es.es_lblk = es->es_lblk;\n\torig_es.es_len = es->es_len;\n\torig_es.es_pblk = es->es_pblk;\n\n\tlen1 = lblk > es->es_lblk ? lblk - es->es_lblk : 0;\n\tlen2 = ext4_es_end(es) > end ? ext4_es_end(es) - end : 0;\n\tif (len1 > 0)\n\t\tes->es_len = len1;\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct extent_status newes;\n\n\t\t\tnewes.es_lblk = end + 1;\n\t\t\tnewes.es_len = len2;\n\t\t\tblock = 0x7FDEADBEEFULL;\n\t\t\tif (ext4_es_is_written(&orig_es) ||\n\t\t\t    ext4_es_is_unwritten(&orig_es))\n\t\t\t\tblock = ext4_es_pblock(&orig_es) +\n\t\t\t\t\torig_es.es_len - len2;\n\t\t\text4_es_store_pblock_status(&newes, block,\n\t\t\t\t\t\t    ext4_es_status(&orig_es));\n\t\t\terr = __es_insert_extent(inode, &newes);\n\t\t\tif (err) {\n\t\t\t\tes->es_lblk = orig_es.es_lblk;\n\t\t\t\tes->es_len = orig_es.es_len;\n\t\t\t\tif ((err == -ENOMEM) &&\n\t\t\t\t    __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t\t128, EXT4_I(inode)))\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tes->es_lblk = end + 1;\n\t\t\tes->es_len = len2;\n\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t    ext4_es_is_unwritten(es)) {\n\t\t\t\tblock = orig_es.es_pblk + orig_es.es_len - len2;\n\t\t\t\text4_es_store_pblock(es, block);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (len1 > 0) {\n\t\tnode = rb_next(&es->rb_node);\n\t\tif (node)\n\t\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\telse\n\t\t\tes = NULL;\n\t}\n\n\twhile (es && ext4_es_end(es) <= end) {\n\t\tnode = rb_next(&es->rb_node);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tif (!node) {\n\t\t\tes = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\n\tif (es && es->es_lblk < end + 1) {\n\t\text4_lblk_t orig_len = es->es_len;\n\n\t\tlen1 = ext4_es_end(es) - end;\n\t\tes->es_lblk = end + 1;\n\t\tes->es_len = len1;\n\t\tif (ext4_es_is_written(es) || ext4_es_is_unwritten(es)) {\n\t\t\tblock = es->es_pblk + orig_len - len1;\n\t\t\text4_es_store_pblock(es, block);\n\t\t}\n\t}\n\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);",
      "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_es_store_pblock",
          "args": [
            "es",
            "block"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_store_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "148-155",
          "snippet": "static inline void ext4_es_store_pblock(struct extent_status *es,\n\t\t\t\t\text4_fsblk_t pb)\n{\n\text4_fsblk_t block;\n\n\tblock = (pb & ~ES_MASK) | (es->es_pblk & ES_MASK);\n\tes->es_pblk = block;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\nstatic inline void ext4_es_store_pblock(struct extent_status *es,\n\t\t\t\t\text4_fsblk_t pb)\n{\n\text4_fsblk_t block;\n\n\tblock = (pb & ~ES_MASK) | (es->es_pblk & ES_MASK);\n\tes->es_pblk = block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_unwritten",
          "args": [
            "es"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "113-116",
          "snippet": "static inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)\n\nstatic inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_written",
          "args": [
            "es"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "108-111",
          "snippet": "static inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)\n\nstatic inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_end",
          "args": [
            "es"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "199-203",
          "snippet": "static inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_status",
            "rb_node"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_free_extent",
          "args": [
            "inode",
            "es"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "358-373",
          "snippet": "static void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_es_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nstatic void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&es->rb_node",
            "&tree->root"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&es->rb_node"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_status",
            "rb_node"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&es->rb_node"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__es_shrink",
          "args": [
            "EXT4_SB(inode->i_sb)",
            "128",
            "EXT4_I(inode)"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "__es_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "966-1052",
          "snippet": "static int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei)\n{\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_es_stats *es_stats;\n\tktime_t start_time;\n\tu64 scan_time;\n\tint nr_to_walk;\n\tint nr_shrunk = 0;\n\tint retried = 0, nr_skipped = 0;\n\n\tes_stats = &sbi->s_es_stats;\n\tstart_time = ktime_get();\n\nretry:\n\tspin_lock(&sbi->s_es_lock);\n\tnr_to_walk = sbi->s_es_nr_inode;\n\twhile (nr_to_walk-- > 0) {\n\t\tif (list_empty(&sbi->s_es_list)) {\n\t\t\tspin_unlock(&sbi->s_es_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tei = list_first_entry(&sbi->s_es_list, struct ext4_inode_info,\n\t\t\t\t      i_es_list);\n\t\t/* Move the inode to the tail */\n\t\tlist_move_tail(&ei->i_es_list, &sbi->s_es_list);\n\n\t\t/*\n\t\t * Normally we try hard to avoid shrinking precached inodes,\n\t\t * but we will as a last resort.\n\t\t */\n\t\tif (!retried && ext4_test_inode_state(&ei->vfs_inode,\n\t\t\t\t\t\tEXT4_STATE_EXT_PRECACHED)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ei == locked_ei || !write_trylock(&ei->i_es_lock)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now we hold i_es_lock which protects us from inode reclaim\n\t\t * freeing inode under us\n\t\t */\n\t\tspin_unlock(&sbi->s_es_lock);\n\n\t\tnr_shrunk += es_reclaim_extents(ei, &nr_to_scan);\n\t\twrite_unlock(&ei->i_es_lock);\n\n\t\tif (nr_to_scan <= 0)\n\t\t\tgoto out;\n\t\tspin_lock(&sbi->s_es_lock);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\t/*\n\t * If we skipped any inodes, and we weren't able to make any\n\t * forward progress, try again to scan precached inodes.\n\t */\n\tif ((nr_shrunk == 0) && nr_skipped && !retried) {\n\t\tretried++;\n\t\tgoto retry;\n\t}\n\n\tif (locked_ei && nr_shrunk == 0)\n\t\tnr_shrunk = es_reclaim_extents(locked_ei, &nr_to_scan);\n\nout:\n\tscan_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\tif (likely(es_stats->es_stats_scan_time))\n\t\tes_stats->es_stats_scan_time = (scan_time +\n\t\t\t\tes_stats->es_stats_scan_time*3) / 4;\n\telse\n\t\tes_stats->es_stats_scan_time = scan_time;\n\tif (scan_time > es_stats->es_stats_max_scan_time)\n\t\tes_stats->es_stats_max_scan_time = scan_time;\n\tif (likely(es_stats->es_stats_shrunk))\n\t\tes_stats->es_stats_shrunk = (nr_shrunk +\n\t\t\t\tes_stats->es_stats_shrunk*3) / 4;\n\telse\n\t\tes_stats->es_stats_shrunk = nr_shrunk;\n\n\ttrace_ext4_es_shrink(sbi->s_sb, nr_shrunk, scan_time,\n\t\t\t     nr_skipped, retried);\n\treturn nr_shrunk;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);",
            "static int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei);\n\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei)\n{\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_es_stats *es_stats;\n\tktime_t start_time;\n\tu64 scan_time;\n\tint nr_to_walk;\n\tint nr_shrunk = 0;\n\tint retried = 0, nr_skipped = 0;\n\n\tes_stats = &sbi->s_es_stats;\n\tstart_time = ktime_get();\n\nretry:\n\tspin_lock(&sbi->s_es_lock);\n\tnr_to_walk = sbi->s_es_nr_inode;\n\twhile (nr_to_walk-- > 0) {\n\t\tif (list_empty(&sbi->s_es_list)) {\n\t\t\tspin_unlock(&sbi->s_es_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tei = list_first_entry(&sbi->s_es_list, struct ext4_inode_info,\n\t\t\t\t      i_es_list);\n\t\t/* Move the inode to the tail */\n\t\tlist_move_tail(&ei->i_es_list, &sbi->s_es_list);\n\n\t\t/*\n\t\t * Normally we try hard to avoid shrinking precached inodes,\n\t\t * but we will as a last resort.\n\t\t */\n\t\tif (!retried && ext4_test_inode_state(&ei->vfs_inode,\n\t\t\t\t\t\tEXT4_STATE_EXT_PRECACHED)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ei == locked_ei || !write_trylock(&ei->i_es_lock)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now we hold i_es_lock which protects us from inode reclaim\n\t\t * freeing inode under us\n\t\t */\n\t\tspin_unlock(&sbi->s_es_lock);\n\n\t\tnr_shrunk += es_reclaim_extents(ei, &nr_to_scan);\n\t\twrite_unlock(&ei->i_es_lock);\n\n\t\tif (nr_to_scan <= 0)\n\t\t\tgoto out;\n\t\tspin_lock(&sbi->s_es_lock);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\t/*\n\t * If we skipped any inodes, and we weren't able to make any\n\t * forward progress, try again to scan precached inodes.\n\t */\n\tif ((nr_shrunk == 0) && nr_skipped && !retried) {\n\t\tretried++;\n\t\tgoto retry;\n\t}\n\n\tif (locked_ei && nr_shrunk == 0)\n\t\tnr_shrunk = es_reclaim_extents(locked_ei, &nr_to_scan);\n\nout:\n\tscan_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\tif (likely(es_stats->es_stats_scan_time))\n\t\tes_stats->es_stats_scan_time = (scan_time +\n\t\t\t\tes_stats->es_stats_scan_time*3) / 4;\n\telse\n\t\tes_stats->es_stats_scan_time = scan_time;\n\tif (scan_time > es_stats->es_stats_max_scan_time)\n\t\tes_stats->es_stats_max_scan_time = scan_time;\n\tif (likely(es_stats->es_stats_shrunk))\n\t\tes_stats->es_stats_shrunk = (nr_shrunk +\n\t\t\t\tes_stats->es_stats_shrunk*3) / 4;\n\telse\n\t\tes_stats->es_stats_shrunk = nr_shrunk;\n\n\ttrace_ext4_es_shrink(sbi->s_sb, nr_shrunk, scan_time,\n\t\t\t     nr_skipped, retried);\n\treturn nr_shrunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__es_insert_extent",
          "args": [
            "inode",
            "&newes"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "__es_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "634-684",
          "snippet": "static int __es_insert_extent(struct inode *inode, struct extent_status *newes)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node **p = &tree->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_status *es;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tes = rb_entry(parent, struct extent_status, rb_node);\n\n\t\tif (newes->es_lblk < es->es_lblk) {\n\t\t\tif (ext4_es_can_be_merged(newes, es)) {\n\t\t\t\t/*\n\t\t\t\t * Here we can modify es_lblk directly\n\t\t\t\t * because it isn't overlapped.\n\t\t\t\t */\n\t\t\t\tes->es_lblk = newes->es_lblk;\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t\t    ext4_es_is_unwritten(es))\n\t\t\t\t\text4_es_store_pblock(es,\n\t\t\t\t\t\t\t     newes->es_pblk);\n\t\t\t\tes = ext4_es_try_to_merge_left(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (newes->es_lblk > ext4_es_end(es)) {\n\t\t\tif (ext4_es_can_be_merged(es, newes)) {\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tes = ext4_es_try_to_merge_right(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tes = ext4_es_alloc_extent(inode, newes->es_lblk, newes->es_len,\n\t\t\t\t  newes->es_pblk);\n\tif (!es)\n\t\treturn -ENOMEM;\n\trb_link_node(&es->rb_node, parent, p);\n\trb_insert_color(&es->rb_node, &tree->root);\n\nout:\n\ttree->cache_es = es;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node **p = &tree->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_status *es;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tes = rb_entry(parent, struct extent_status, rb_node);\n\n\t\tif (newes->es_lblk < es->es_lblk) {\n\t\t\tif (ext4_es_can_be_merged(newes, es)) {\n\t\t\t\t/*\n\t\t\t\t * Here we can modify es_lblk directly\n\t\t\t\t * because it isn't overlapped.\n\t\t\t\t */\n\t\t\t\tes->es_lblk = newes->es_lblk;\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t\t    ext4_es_is_unwritten(es))\n\t\t\t\t\text4_es_store_pblock(es,\n\t\t\t\t\t\t\t     newes->es_pblk);\n\t\t\t\tes = ext4_es_try_to_merge_left(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (newes->es_lblk > ext4_es_end(es)) {\n\t\t\tif (ext4_es_can_be_merged(es, newes)) {\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tes = ext4_es_try_to_merge_right(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tes = ext4_es_alloc_extent(inode, newes->es_lblk, newes->es_len,\n\t\t\t\t  newes->es_pblk);\n\tif (!es)\n\t\treturn -ENOMEM;\n\trb_link_node(&es->rb_node, parent, p);\n\trb_insert_color(&es->rb_node, &tree->root);\n\nout:\n\ttree->cache_es = es;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_store_pblock_status",
          "args": [
            "&newes",
            "block",
            "ext4_es_status(&orig_es)"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_store_pblock_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "164-170",
          "snippet": "static inline void ext4_es_store_pblock_status(struct extent_status *es,\n\t\t\t\t\t       ext4_fsblk_t pb,\n\t\t\t\t\t       unsigned int status)\n{\n\tes->es_pblk = (((ext4_fsblk_t)status << ES_SHIFT) & ES_MASK) |\n\t\t      (pb & ~ES_MASK);\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)",
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline void ext4_es_store_pblock_status(struct extent_status *es,\n\t\t\t\t\t       ext4_fsblk_t pb,\n\t\t\t\t\t       unsigned int status)\n{\n\tes->es_pblk = (((ext4_fsblk_t)status << ES_SHIFT) & ES_MASK) |\n\t\t      (pb & ~ES_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_status",
          "args": [
            "&orig_es"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "98-101",
          "snippet": "static inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_pblock",
          "args": [
            "&orig_es"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "143-146",
          "snippet": "static inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\nstatic inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__es_tree_search",
          "args": [
            "&tree->root",
            "lblk"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "__es_tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "209-235",
          "snippet": "static struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node *node;\n\tstruct extent_status *es;\n\tstruct extent_status orig_es;\n\text4_lblk_t len1, len2;\n\text4_fsblk_t block;\n\tint err;\n\nretry:\n\terr = 0;\n\tes = __es_tree_search(&tree->root, lblk);\n\tif (!es)\n\t\tgoto out;\n\tif (es->es_lblk > end)\n\t\tgoto out;\n\n\t/* Simply invalidate cache_es. */\n\ttree->cache_es = NULL;\n\n\torig_es.es_lblk = es->es_lblk;\n\torig_es.es_len = es->es_len;\n\torig_es.es_pblk = es->es_pblk;\n\n\tlen1 = lblk > es->es_lblk ? lblk - es->es_lblk : 0;\n\tlen2 = ext4_es_end(es) > end ? ext4_es_end(es) - end : 0;\n\tif (len1 > 0)\n\t\tes->es_len = len1;\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct extent_status newes;\n\n\t\t\tnewes.es_lblk = end + 1;\n\t\t\tnewes.es_len = len2;\n\t\t\tblock = 0x7FDEADBEEFULL;\n\t\t\tif (ext4_es_is_written(&orig_es) ||\n\t\t\t    ext4_es_is_unwritten(&orig_es))\n\t\t\t\tblock = ext4_es_pblock(&orig_es) +\n\t\t\t\t\torig_es.es_len - len2;\n\t\t\text4_es_store_pblock_status(&newes, block,\n\t\t\t\t\t\t    ext4_es_status(&orig_es));\n\t\t\terr = __es_insert_extent(inode, &newes);\n\t\t\tif (err) {\n\t\t\t\tes->es_lblk = orig_es.es_lblk;\n\t\t\t\tes->es_len = orig_es.es_len;\n\t\t\t\tif ((err == -ENOMEM) &&\n\t\t\t\t    __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t\t128, EXT4_I(inode)))\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tes->es_lblk = end + 1;\n\t\t\tes->es_len = len2;\n\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t    ext4_es_is_unwritten(es)) {\n\t\t\t\tblock = orig_es.es_pblk + orig_es.es_len - len2;\n\t\t\t\text4_es_store_pblock(es, block);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (len1 > 0) {\n\t\tnode = rb_next(&es->rb_node);\n\t\tif (node)\n\t\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\telse\n\t\t\tes = NULL;\n\t}\n\n\twhile (es && ext4_es_end(es) <= end) {\n\t\tnode = rb_next(&es->rb_node);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tif (!node) {\n\t\t\tes = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\n\tif (es && es->es_lblk < end + 1) {\n\t\text4_lblk_t orig_len = es->es_len;\n\n\t\tlen1 = ext4_es_end(es) - end;\n\t\tes->es_lblk = end + 1;\n\t\tes->es_len = len1;\n\t\tif (ext4_es_is_written(es) || ext4_es_is_unwritten(es)) {\n\t\t\tblock = es->es_pblk + orig_len - len1;\n\t\t\text4_es_store_pblock(es, block);\n\t\t}\n\t}\n\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_es_lookup_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "773-831",
    "snippet": "int ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct ext4_es_stats *stats;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\tint found = 0;\n\n\ttrace_ext4_es_lookup_extent_enter(inode, lblk);\n\tes_debug(\"lookup extent in block %u\\n\", lblk);\n\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u)\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len);\n\t\t\tfound = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnode = tree->root.rb_node;\n\twhile (node) {\n\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es1->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es1))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tstats = &EXT4_SB(inode->i_sb)->s_es_stats;\n\tif (found) {\n\t\tBUG_ON(!es1);\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t\tif (!ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es);\n\t\tstats->es_stats_cache_hits++;\n\t} else {\n\t\tstats->es_stats_cache_misses++;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_lookup_extent_exit(inode, es, found);\n\treturn found;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_es_lookup_extent_exit",
          "args": [
            "inode",
            "es",
            "found"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&EXT4_I(inode)->i_es_lock"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_set_referenced",
          "args": [
            "es"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_set_referenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "128-131",
          "snippet": "static inline void ext4_es_set_referenced(struct extent_status *es)\n{\n\tes->es_pblk |= ((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)",
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)\n#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline void ext4_es_set_referenced(struct extent_status *es)\n{\n\tes->es_pblk |= ((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_referenced",
          "args": [
            "es"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_referenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "138-141",
          "snippet": "static inline int ext4_es_is_referenced(struct extent_status *es)\n{\n\treturn (ext4_es_status(es) & EXTENT_STATUS_REFERENCED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)\n\nstatic inline int ext4_es_is_referenced(struct extent_status *es)\n{\n\treturn (ext4_es_status(es) & EXTENT_STATUS_REFERENCED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!es1"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_end",
          "args": [
            "es1"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "199-203",
          "snippet": "static inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_status",
            "rb_node"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es_debug",
          "args": [
            "\"%u cached by [%u/%u)\\n\"",
            "lblk",
            "es1->es_lblk",
            "es1->es_len"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "lblk",
            "es1->es_lblk",
            "es1->es_len"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&EXT4_I(inode)->i_es_lock"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "es_debug",
          "args": [
            "\"lookup extent in block %u\\n\"",
            "lblk"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_es_lookup_extent_enter",
          "args": [
            "inode",
            "lblk"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nint ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct ext4_es_stats *stats;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\tint found = 0;\n\n\ttrace_ext4_es_lookup_extent_enter(inode, lblk);\n\tes_debug(\"lookup extent in block %u\\n\", lblk);\n\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u)\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len);\n\t\t\tfound = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnode = tree->root.rb_node;\n\twhile (node) {\n\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es1->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es1))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tstats = &EXT4_SB(inode->i_sb)->s_es_stats;\n\tif (found) {\n\t\tBUG_ON(!es1);\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t\tif (!ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es);\n\t\tstats->es_stats_cache_hits++;\n\t} else {\n\t\tstats->es_stats_cache_misses++;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_lookup_extent_exit(inode, es, found);\n\treturn found;\n}"
  },
  {
    "function_name": "ext4_es_cache_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "740-764",
    "snippet": "void ext4_es_cache_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t  unsigned int status)\n{\n\tstruct extent_status *es;\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_cache_extent(inode, &newes);\n\n\tif (!len)\n\t\treturn;\n\n\tBUG_ON(end < lblk);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\n\tes = __es_tree_search(&EXT4_I(inode)->i_es_tree.root, lblk);\n\tif (!es || es->es_lblk > end)\n\t\t__es_insert_extent(inode, &newes);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);",
      "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&EXT4_I(inode)->i_es_lock"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__es_insert_extent",
          "args": [
            "inode",
            "&newes"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__es_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "634-684",
          "snippet": "static int __es_insert_extent(struct inode *inode, struct extent_status *newes)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node **p = &tree->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_status *es;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tes = rb_entry(parent, struct extent_status, rb_node);\n\n\t\tif (newes->es_lblk < es->es_lblk) {\n\t\t\tif (ext4_es_can_be_merged(newes, es)) {\n\t\t\t\t/*\n\t\t\t\t * Here we can modify es_lblk directly\n\t\t\t\t * because it isn't overlapped.\n\t\t\t\t */\n\t\t\t\tes->es_lblk = newes->es_lblk;\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t\t    ext4_es_is_unwritten(es))\n\t\t\t\t\text4_es_store_pblock(es,\n\t\t\t\t\t\t\t     newes->es_pblk);\n\t\t\t\tes = ext4_es_try_to_merge_left(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (newes->es_lblk > ext4_es_end(es)) {\n\t\t\tif (ext4_es_can_be_merged(es, newes)) {\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tes = ext4_es_try_to_merge_right(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tes = ext4_es_alloc_extent(inode, newes->es_lblk, newes->es_len,\n\t\t\t\t  newes->es_pblk);\n\tif (!es)\n\t\treturn -ENOMEM;\n\trb_link_node(&es->rb_node, parent, p);\n\trb_insert_color(&es->rb_node, &tree->root);\n\nout:\n\ttree->cache_es = es;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node **p = &tree->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_status *es;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tes = rb_entry(parent, struct extent_status, rb_node);\n\n\t\tif (newes->es_lblk < es->es_lblk) {\n\t\t\tif (ext4_es_can_be_merged(newes, es)) {\n\t\t\t\t/*\n\t\t\t\t * Here we can modify es_lblk directly\n\t\t\t\t * because it isn't overlapped.\n\t\t\t\t */\n\t\t\t\tes->es_lblk = newes->es_lblk;\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t\t    ext4_es_is_unwritten(es))\n\t\t\t\t\text4_es_store_pblock(es,\n\t\t\t\t\t\t\t     newes->es_pblk);\n\t\t\t\tes = ext4_es_try_to_merge_left(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (newes->es_lblk > ext4_es_end(es)) {\n\t\t\tif (ext4_es_can_be_merged(es, newes)) {\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tes = ext4_es_try_to_merge_right(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tes = ext4_es_alloc_extent(inode, newes->es_lblk, newes->es_len,\n\t\t\t\t  newes->es_pblk);\n\tif (!es)\n\t\treturn -ENOMEM;\n\trb_link_node(&es->rb_node, parent, p);\n\trb_insert_color(&es->rb_node, &tree->root);\n\nout:\n\ttree->cache_es = es;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__es_tree_search",
          "args": [
            "&EXT4_I(inode)->i_es_tree.root",
            "lblk"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "__es_tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "209-235",
          "snippet": "static struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&EXT4_I(inode)->i_es_lock"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end < lblk"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_es_cache_extent",
          "args": [
            "inode",
            "&newes"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_store_pblock_status",
          "args": [
            "&newes",
            "pblk",
            "status"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_store_pblock_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "164-170",
          "snippet": "static inline void ext4_es_store_pblock_status(struct extent_status *es,\n\t\t\t\t\t       ext4_fsblk_t pb,\n\t\t\t\t\t       unsigned int status)\n{\n\tes->es_pblk = (((ext4_fsblk_t)status << ES_SHIFT) & ES_MASK) |\n\t\t      (pb & ~ES_MASK);\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)",
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline void ext4_es_store_pblock_status(struct extent_status *es,\n\t\t\t\t\t       ext4_fsblk_t pb,\n\t\t\t\t\t       unsigned int status)\n{\n\tes->es_pblk = (((ext4_fsblk_t)status << ES_SHIFT) & ES_MASK) |\n\t\t      (pb & ~ES_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nvoid ext4_es_cache_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t  unsigned int status)\n{\n\tstruct extent_status *es;\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_cache_extent(inode, &newes);\n\n\tif (!len)\n\t\treturn;\n\n\tBUG_ON(end < lblk);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\n\tes = __es_tree_search(&EXT4_I(inode)->i_es_tree.root, lblk);\n\tif (!es || es->es_lblk > end)\n\t\t__es_insert_extent(inode, &newes);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n}"
  },
  {
    "function_name": "ext4_es_insert_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "692-733",
    "snippet": "int ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t  unsigned int status)\n{\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\tint err = 0;\n\n\tes_debug(\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\",\n\t\t lblk, len, pblk, status, inode->i_ino);\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(end < lblk);\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_insert_extent(inode, &newes);\n\n\text4_es_insert_extent_check(inode, &newes);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\tif (err != 0)\n\t\tgoto error;\nretry:\n\terr = __es_insert_extent(inode, &newes);\n\tif (err == -ENOMEM && __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t  128, EXT4_I(inode)))\n\t\tgoto retry;\n\tif (err == -ENOMEM && !ext4_es_is_delayed(&newes))\n\t\terr = 0;\n\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\n\text4_es_print_tree(inode);\n\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);",
      "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_es_print_tree",
          "args": [
            "inode"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_print_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "177-194",
          "snippet": "static void ext4_es_print_tree(struct inode *inode)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct rb_node *node;\n\n\tprintk(KERN_DEBUG \"status extents for inode %lu:\", inode->i_ino);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tnode = rb_first(&tree->root);\n\twhile (node) {\n\t\tstruct extent_status *es;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tprintk(KERN_DEBUG \" [%u/%u) %llu %x\",\n\t\t       es->es_lblk, es->es_len,\n\t\t       ext4_es_pblock(es), ext4_es_status(es));\n\t\tnode = rb_next(node);\n\t}\n\tprintk(KERN_DEBUG \"\\n\");\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_print_tree(struct inode *inode)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct rb_node *node;\n\n\tprintk(KERN_DEBUG \"status extents for inode %lu:\", inode->i_ino);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tnode = rb_first(&tree->root);\n\twhile (node) {\n\t\tstruct extent_status *es;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tprintk(KERN_DEBUG \" [%u/%u) %llu %x\",\n\t\t       es->es_lblk, es->es_len,\n\t\t       ext4_es_pblock(es), ext4_es_status(es));\n\t\tnode = rb_next(node);\n\t}\n\tprintk(KERN_DEBUG \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&EXT4_I(inode)->i_es_lock"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_delayed",
          "args": [
            "&newes"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "118-121",
          "snippet": "static inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__es_shrink",
          "args": [
            "EXT4_SB(inode->i_sb)",
            "128",
            "EXT4_I(inode)"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "__es_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "966-1052",
          "snippet": "static int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei)\n{\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_es_stats *es_stats;\n\tktime_t start_time;\n\tu64 scan_time;\n\tint nr_to_walk;\n\tint nr_shrunk = 0;\n\tint retried = 0, nr_skipped = 0;\n\n\tes_stats = &sbi->s_es_stats;\n\tstart_time = ktime_get();\n\nretry:\n\tspin_lock(&sbi->s_es_lock);\n\tnr_to_walk = sbi->s_es_nr_inode;\n\twhile (nr_to_walk-- > 0) {\n\t\tif (list_empty(&sbi->s_es_list)) {\n\t\t\tspin_unlock(&sbi->s_es_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tei = list_first_entry(&sbi->s_es_list, struct ext4_inode_info,\n\t\t\t\t      i_es_list);\n\t\t/* Move the inode to the tail */\n\t\tlist_move_tail(&ei->i_es_list, &sbi->s_es_list);\n\n\t\t/*\n\t\t * Normally we try hard to avoid shrinking precached inodes,\n\t\t * but we will as a last resort.\n\t\t */\n\t\tif (!retried && ext4_test_inode_state(&ei->vfs_inode,\n\t\t\t\t\t\tEXT4_STATE_EXT_PRECACHED)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ei == locked_ei || !write_trylock(&ei->i_es_lock)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now we hold i_es_lock which protects us from inode reclaim\n\t\t * freeing inode under us\n\t\t */\n\t\tspin_unlock(&sbi->s_es_lock);\n\n\t\tnr_shrunk += es_reclaim_extents(ei, &nr_to_scan);\n\t\twrite_unlock(&ei->i_es_lock);\n\n\t\tif (nr_to_scan <= 0)\n\t\t\tgoto out;\n\t\tspin_lock(&sbi->s_es_lock);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\t/*\n\t * If we skipped any inodes, and we weren't able to make any\n\t * forward progress, try again to scan precached inodes.\n\t */\n\tif ((nr_shrunk == 0) && nr_skipped && !retried) {\n\t\tretried++;\n\t\tgoto retry;\n\t}\n\n\tif (locked_ei && nr_shrunk == 0)\n\t\tnr_shrunk = es_reclaim_extents(locked_ei, &nr_to_scan);\n\nout:\n\tscan_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\tif (likely(es_stats->es_stats_scan_time))\n\t\tes_stats->es_stats_scan_time = (scan_time +\n\t\t\t\tes_stats->es_stats_scan_time*3) / 4;\n\telse\n\t\tes_stats->es_stats_scan_time = scan_time;\n\tif (scan_time > es_stats->es_stats_max_scan_time)\n\t\tes_stats->es_stats_max_scan_time = scan_time;\n\tif (likely(es_stats->es_stats_shrunk))\n\t\tes_stats->es_stats_shrunk = (nr_shrunk +\n\t\t\t\tes_stats->es_stats_shrunk*3) / 4;\n\telse\n\t\tes_stats->es_stats_shrunk = nr_shrunk;\n\n\ttrace_ext4_es_shrink(sbi->s_sb, nr_shrunk, scan_time,\n\t\t\t     nr_skipped, retried);\n\treturn nr_shrunk;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);",
            "static int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei);\n\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei)\n{\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_es_stats *es_stats;\n\tktime_t start_time;\n\tu64 scan_time;\n\tint nr_to_walk;\n\tint nr_shrunk = 0;\n\tint retried = 0, nr_skipped = 0;\n\n\tes_stats = &sbi->s_es_stats;\n\tstart_time = ktime_get();\n\nretry:\n\tspin_lock(&sbi->s_es_lock);\n\tnr_to_walk = sbi->s_es_nr_inode;\n\twhile (nr_to_walk-- > 0) {\n\t\tif (list_empty(&sbi->s_es_list)) {\n\t\t\tspin_unlock(&sbi->s_es_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tei = list_first_entry(&sbi->s_es_list, struct ext4_inode_info,\n\t\t\t\t      i_es_list);\n\t\t/* Move the inode to the tail */\n\t\tlist_move_tail(&ei->i_es_list, &sbi->s_es_list);\n\n\t\t/*\n\t\t * Normally we try hard to avoid shrinking precached inodes,\n\t\t * but we will as a last resort.\n\t\t */\n\t\tif (!retried && ext4_test_inode_state(&ei->vfs_inode,\n\t\t\t\t\t\tEXT4_STATE_EXT_PRECACHED)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ei == locked_ei || !write_trylock(&ei->i_es_lock)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now we hold i_es_lock which protects us from inode reclaim\n\t\t * freeing inode under us\n\t\t */\n\t\tspin_unlock(&sbi->s_es_lock);\n\n\t\tnr_shrunk += es_reclaim_extents(ei, &nr_to_scan);\n\t\twrite_unlock(&ei->i_es_lock);\n\n\t\tif (nr_to_scan <= 0)\n\t\t\tgoto out;\n\t\tspin_lock(&sbi->s_es_lock);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\t/*\n\t * If we skipped any inodes, and we weren't able to make any\n\t * forward progress, try again to scan precached inodes.\n\t */\n\tif ((nr_shrunk == 0) && nr_skipped && !retried) {\n\t\tretried++;\n\t\tgoto retry;\n\t}\n\n\tif (locked_ei && nr_shrunk == 0)\n\t\tnr_shrunk = es_reclaim_extents(locked_ei, &nr_to_scan);\n\nout:\n\tscan_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\tif (likely(es_stats->es_stats_scan_time))\n\t\tes_stats->es_stats_scan_time = (scan_time +\n\t\t\t\tes_stats->es_stats_scan_time*3) / 4;\n\telse\n\t\tes_stats->es_stats_scan_time = scan_time;\n\tif (scan_time > es_stats->es_stats_max_scan_time)\n\t\tes_stats->es_stats_max_scan_time = scan_time;\n\tif (likely(es_stats->es_stats_shrunk))\n\t\tes_stats->es_stats_shrunk = (nr_shrunk +\n\t\t\t\tes_stats->es_stats_shrunk*3) / 4;\n\telse\n\t\tes_stats->es_stats_shrunk = nr_shrunk;\n\n\ttrace_ext4_es_shrink(sbi->s_sb, nr_shrunk, scan_time,\n\t\t\t     nr_skipped, retried);\n\treturn nr_shrunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__es_insert_extent",
          "args": [
            "inode",
            "&newes"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "__es_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "634-684",
          "snippet": "static int __es_insert_extent(struct inode *inode, struct extent_status *newes)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node **p = &tree->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_status *es;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tes = rb_entry(parent, struct extent_status, rb_node);\n\n\t\tif (newes->es_lblk < es->es_lblk) {\n\t\t\tif (ext4_es_can_be_merged(newes, es)) {\n\t\t\t\t/*\n\t\t\t\t * Here we can modify es_lblk directly\n\t\t\t\t * because it isn't overlapped.\n\t\t\t\t */\n\t\t\t\tes->es_lblk = newes->es_lblk;\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t\t    ext4_es_is_unwritten(es))\n\t\t\t\t\text4_es_store_pblock(es,\n\t\t\t\t\t\t\t     newes->es_pblk);\n\t\t\t\tes = ext4_es_try_to_merge_left(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (newes->es_lblk > ext4_es_end(es)) {\n\t\t\tif (ext4_es_can_be_merged(es, newes)) {\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tes = ext4_es_try_to_merge_right(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tes = ext4_es_alloc_extent(inode, newes->es_lblk, newes->es_len,\n\t\t\t\t  newes->es_pblk);\n\tif (!es)\n\t\treturn -ENOMEM;\n\trb_link_node(&es->rb_node, parent, p);\n\trb_insert_color(&es->rb_node, &tree->root);\n\nout:\n\ttree->cache_es = es;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node **p = &tree->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_status *es;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tes = rb_entry(parent, struct extent_status, rb_node);\n\n\t\tif (newes->es_lblk < es->es_lblk) {\n\t\t\tif (ext4_es_can_be_merged(newes, es)) {\n\t\t\t\t/*\n\t\t\t\t * Here we can modify es_lblk directly\n\t\t\t\t * because it isn't overlapped.\n\t\t\t\t */\n\t\t\t\tes->es_lblk = newes->es_lblk;\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t\t    ext4_es_is_unwritten(es))\n\t\t\t\t\text4_es_store_pblock(es,\n\t\t\t\t\t\t\t     newes->es_pblk);\n\t\t\t\tes = ext4_es_try_to_merge_left(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (newes->es_lblk > ext4_es_end(es)) {\n\t\t\tif (ext4_es_can_be_merged(es, newes)) {\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tes = ext4_es_try_to_merge_right(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tes = ext4_es_alloc_extent(inode, newes->es_lblk, newes->es_len,\n\t\t\t\t  newes->es_pblk);\n\tif (!es)\n\t\treturn -ENOMEM;\n\trb_link_node(&es->rb_node, parent, p);\n\trb_insert_color(&es->rb_node, &tree->root);\n\nout:\n\ttree->cache_es = es;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__es_remove_extent",
          "args": [
            "inode",
            "lblk",
            "end"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "__es_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "833-931",
          "snippet": "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node *node;\n\tstruct extent_status *es;\n\tstruct extent_status orig_es;\n\text4_lblk_t len1, len2;\n\text4_fsblk_t block;\n\tint err;\n\nretry:\n\terr = 0;\n\tes = __es_tree_search(&tree->root, lblk);\n\tif (!es)\n\t\tgoto out;\n\tif (es->es_lblk > end)\n\t\tgoto out;\n\n\t/* Simply invalidate cache_es. */\n\ttree->cache_es = NULL;\n\n\torig_es.es_lblk = es->es_lblk;\n\torig_es.es_len = es->es_len;\n\torig_es.es_pblk = es->es_pblk;\n\n\tlen1 = lblk > es->es_lblk ? lblk - es->es_lblk : 0;\n\tlen2 = ext4_es_end(es) > end ? ext4_es_end(es) - end : 0;\n\tif (len1 > 0)\n\t\tes->es_len = len1;\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct extent_status newes;\n\n\t\t\tnewes.es_lblk = end + 1;\n\t\t\tnewes.es_len = len2;\n\t\t\tblock = 0x7FDEADBEEFULL;\n\t\t\tif (ext4_es_is_written(&orig_es) ||\n\t\t\t    ext4_es_is_unwritten(&orig_es))\n\t\t\t\tblock = ext4_es_pblock(&orig_es) +\n\t\t\t\t\torig_es.es_len - len2;\n\t\t\text4_es_store_pblock_status(&newes, block,\n\t\t\t\t\t\t    ext4_es_status(&orig_es));\n\t\t\terr = __es_insert_extent(inode, &newes);\n\t\t\tif (err) {\n\t\t\t\tes->es_lblk = orig_es.es_lblk;\n\t\t\t\tes->es_len = orig_es.es_len;\n\t\t\t\tif ((err == -ENOMEM) &&\n\t\t\t\t    __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t\t128, EXT4_I(inode)))\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tes->es_lblk = end + 1;\n\t\t\tes->es_len = len2;\n\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t    ext4_es_is_unwritten(es)) {\n\t\t\t\tblock = orig_es.es_pblk + orig_es.es_len - len2;\n\t\t\t\text4_es_store_pblock(es, block);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (len1 > 0) {\n\t\tnode = rb_next(&es->rb_node);\n\t\tif (node)\n\t\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\telse\n\t\t\tes = NULL;\n\t}\n\n\twhile (es && ext4_es_end(es) <= end) {\n\t\tnode = rb_next(&es->rb_node);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tif (!node) {\n\t\t\tes = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\n\tif (es && es->es_lblk < end + 1) {\n\t\text4_lblk_t orig_len = es->es_len;\n\n\t\tlen1 = ext4_es_end(es) - end;\n\t\tes->es_lblk = end + 1;\n\t\tes->es_len = len1;\n\t\tif (ext4_es_is_written(es) || ext4_es_is_unwritten(es)) {\n\t\t\tblock = es->es_pblk + orig_len - len1;\n\t\t\text4_es_store_pblock(es, block);\n\t\t}\n\t}\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);",
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node *node;\n\tstruct extent_status *es;\n\tstruct extent_status orig_es;\n\text4_lblk_t len1, len2;\n\text4_fsblk_t block;\n\tint err;\n\nretry:\n\terr = 0;\n\tes = __es_tree_search(&tree->root, lblk);\n\tif (!es)\n\t\tgoto out;\n\tif (es->es_lblk > end)\n\t\tgoto out;\n\n\t/* Simply invalidate cache_es. */\n\ttree->cache_es = NULL;\n\n\torig_es.es_lblk = es->es_lblk;\n\torig_es.es_len = es->es_len;\n\torig_es.es_pblk = es->es_pblk;\n\n\tlen1 = lblk > es->es_lblk ? lblk - es->es_lblk : 0;\n\tlen2 = ext4_es_end(es) > end ? ext4_es_end(es) - end : 0;\n\tif (len1 > 0)\n\t\tes->es_len = len1;\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct extent_status newes;\n\n\t\t\tnewes.es_lblk = end + 1;\n\t\t\tnewes.es_len = len2;\n\t\t\tblock = 0x7FDEADBEEFULL;\n\t\t\tif (ext4_es_is_written(&orig_es) ||\n\t\t\t    ext4_es_is_unwritten(&orig_es))\n\t\t\t\tblock = ext4_es_pblock(&orig_es) +\n\t\t\t\t\torig_es.es_len - len2;\n\t\t\text4_es_store_pblock_status(&newes, block,\n\t\t\t\t\t\t    ext4_es_status(&orig_es));\n\t\t\terr = __es_insert_extent(inode, &newes);\n\t\t\tif (err) {\n\t\t\t\tes->es_lblk = orig_es.es_lblk;\n\t\t\t\tes->es_len = orig_es.es_len;\n\t\t\t\tif ((err == -ENOMEM) &&\n\t\t\t\t    __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t\t128, EXT4_I(inode)))\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tes->es_lblk = end + 1;\n\t\t\tes->es_len = len2;\n\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t    ext4_es_is_unwritten(es)) {\n\t\t\t\tblock = orig_es.es_pblk + orig_es.es_len - len2;\n\t\t\t\text4_es_store_pblock(es, block);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (len1 > 0) {\n\t\tnode = rb_next(&es->rb_node);\n\t\tif (node)\n\t\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\telse\n\t\t\tes = NULL;\n\t}\n\n\twhile (es && ext4_es_end(es) <= end) {\n\t\tnode = rb_next(&es->rb_node);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tif (!node) {\n\t\t\tes = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\n\tif (es && es->es_lblk < end + 1) {\n\t\text4_lblk_t orig_len = es->es_len;\n\n\t\tlen1 = ext4_es_end(es) - end;\n\t\tes->es_lblk = end + 1;\n\t\tes->es_len = len1;\n\t\tif (ext4_es_is_written(es) || ext4_es_is_unwritten(es)) {\n\t\t\tblock = es->es_pblk + orig_len - len1;\n\t\t\text4_es_store_pblock(es, block);\n\t\t}\n\t}\n\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&EXT4_I(inode)->i_es_lock"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_insert_extent_check",
          "args": [
            "inode",
            "&newes"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_insert_extent_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "628-631",
          "snippet": "static inline void ext4_es_insert_extent_check(struct inode *inode,\n\t\t\t\t\t       struct extent_status *es)\n{\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic inline void ext4_es_insert_extent_check(struct inode *inode,\n\t\t\t\t\t       struct extent_status *es)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_es_insert_extent",
          "args": [
            "inode",
            "&newes"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_store_pblock_status",
          "args": [
            "&newes",
            "pblk",
            "status"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_store_pblock_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "164-170",
          "snippet": "static inline void ext4_es_store_pblock_status(struct extent_status *es,\n\t\t\t\t\t       ext4_fsblk_t pb,\n\t\t\t\t\t       unsigned int status)\n{\n\tes->es_pblk = (((ext4_fsblk_t)status << ES_SHIFT) & ES_MASK) |\n\t\t      (pb & ~ES_MASK);\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)",
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline void ext4_es_store_pblock_status(struct extent_status *es,\n\t\t\t\t\t       ext4_fsblk_t pb,\n\t\t\t\t\t       unsigned int status)\n{\n\tes->es_pblk = (((ext4_fsblk_t)status << ES_SHIFT) & ES_MASK) |\n\t\t      (pb & ~ES_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end < lblk"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es_debug",
          "args": [
            "\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\"",
            "lblk",
            "len",
            "pblk",
            "status",
            "inode->i_ino"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nint ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t  unsigned int status)\n{\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\tint err = 0;\n\n\tes_debug(\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\",\n\t\t lblk, len, pblk, status, inode->i_ino);\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(end < lblk);\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_insert_extent(inode, &newes);\n\n\text4_es_insert_extent_check(inode, &newes);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\tif (err != 0)\n\t\tgoto error;\nretry:\n\terr = __es_insert_extent(inode, &newes);\n\tif (err == -ENOMEM && __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t  128, EXT4_I(inode)))\n\t\tgoto retry;\n\tif (err == -ENOMEM && !ext4_es_is_delayed(&newes))\n\t\terr = 0;\n\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\n\text4_es_print_tree(inode);\n\n\treturn err;\n}"
  },
  {
    "function_name": "__es_insert_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "634-684",
    "snippet": "static int __es_insert_extent(struct inode *inode, struct extent_status *newes)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node **p = &tree->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_status *es;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tes = rb_entry(parent, struct extent_status, rb_node);\n\n\t\tif (newes->es_lblk < es->es_lblk) {\n\t\t\tif (ext4_es_can_be_merged(newes, es)) {\n\t\t\t\t/*\n\t\t\t\t * Here we can modify es_lblk directly\n\t\t\t\t * because it isn't overlapped.\n\t\t\t\t */\n\t\t\t\tes->es_lblk = newes->es_lblk;\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t\t    ext4_es_is_unwritten(es))\n\t\t\t\t\text4_es_store_pblock(es,\n\t\t\t\t\t\t\t     newes->es_pblk);\n\t\t\t\tes = ext4_es_try_to_merge_left(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (newes->es_lblk > ext4_es_end(es)) {\n\t\t\tif (ext4_es_can_be_merged(es, newes)) {\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tes = ext4_es_try_to_merge_right(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tes = ext4_es_alloc_extent(inode, newes->es_lblk, newes->es_len,\n\t\t\t\t  newes->es_pblk);\n\tif (!es)\n\t\treturn -ENOMEM;\n\trb_link_node(&es->rb_node, parent, p);\n\trb_insert_color(&es->rb_node, &tree->root);\n\nout:\n\ttree->cache_es = es;\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&es->rb_node",
            "&tree->root"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&es->rb_node",
            "parent",
            "p"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_alloc_extent",
          "args": [
            "inode",
            "newes->es_lblk",
            "newes->es_len",
            "newes->es_pblk"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_alloc_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "330-356",
          "snippet": "static struct extent_status *\next4_es_alloc_extent(struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len,\n\t\t     ext4_fsblk_t pblk)\n{\n\tstruct extent_status *es;\n\tes = kmem_cache_alloc(ext4_es_cachep, GFP_ATOMIC);\n\tif (es == NULL)\n\t\treturn NULL;\n\tes->es_lblk = lblk;\n\tes->es_len = len;\n\tes->es_pblk = pblk;\n\n\t/*\n\t * We don't count delayed extent because we never try to reclaim them\n\t */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tif (!EXT4_I(inode)->i_es_shk_nr++)\n\t\t\text4_es_list_add(inode);\n\t\tpercpu_counter_inc(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tEXT4_I(inode)->i_es_all_nr++;\n\tpercpu_counter_inc(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\treturn es;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_es_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nstatic struct extent_status *\next4_es_alloc_extent(struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len,\n\t\t     ext4_fsblk_t pblk)\n{\n\tstruct extent_status *es;\n\tes = kmem_cache_alloc(ext4_es_cachep, GFP_ATOMIC);\n\tif (es == NULL)\n\t\treturn NULL;\n\tes->es_lblk = lblk;\n\tes->es_len = len;\n\tes->es_pblk = pblk;\n\n\t/*\n\t * We don't count delayed extent because we never try to reclaim them\n\t */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tif (!EXT4_I(inode)->i_es_shk_nr++)\n\t\t\text4_es_list_add(inode);\n\t\tpercpu_counter_inc(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tEXT4_I(inode)->i_es_all_nr++;\n\tpercpu_counter_inc(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\treturn es;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_try_to_merge_right",
          "args": [
            "inode",
            "es"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_try_to_merge_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "438-459",
          "snippet": "static struct extent_status *\next4_es_try_to_merge_right(struct inode *inode, struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es1;\n\tstruct rb_node *node;\n\n\tnode = rb_next(&es->rb_node);\n\tif (!node)\n\t\treturn es;\n\n\tes1 = rb_entry(node, struct extent_status, rb_node);\n\tif (ext4_es_can_be_merged(es, es1)) {\n\t\tes->es_len += es1->es_len;\n\t\tif (ext4_es_is_referenced(es1))\n\t\t\text4_es_set_referenced(es);\n\t\trb_erase(node, &tree->root);\n\t\text4_es_free_extent(inode, es1);\n\t}\n\n\treturn es;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct extent_status *\next4_es_try_to_merge_right(struct inode *inode, struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es1;\n\tstruct rb_node *node;\n\n\tnode = rb_next(&es->rb_node);\n\tif (!node)\n\t\treturn es;\n\n\tes1 = rb_entry(node, struct extent_status, rb_node);\n\tif (ext4_es_can_be_merged(es, es1)) {\n\t\tes->es_len += es1->es_len;\n\t\tif (ext4_es_is_referenced(es1))\n\t\t\text4_es_set_referenced(es);\n\t\trb_erase(node, &tree->root);\n\t\text4_es_free_extent(inode, es1);\n\t}\n\n\treturn es;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_can_be_merged",
          "args": [
            "es",
            "newes"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_can_be_merged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "382-412",
          "snippet": "static int ext4_es_can_be_merged(struct extent_status *es1,\n\t\t\t\t struct extent_status *es2)\n{\n\tif (ext4_es_type(es1) != ext4_es_type(es2))\n\t\treturn 0;\n\n\tif (((__u64) es1->es_len) + es2->es_len > EXT_MAX_BLOCKS) {\n\t\tpr_warn(\"ES assertion failed when merging extents. \"\n\t\t\t\"The sum of lengths of es1 (%d) and es2 (%d) \"\n\t\t\t\"is bigger than allowed file size (%d)\\n\",\n\t\t\tes1->es_len, es2->es_len, EXT_MAX_BLOCKS);\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (((__u64) es1->es_lblk) + es1->es_len != es2->es_lblk)\n\t\treturn 0;\n\n\tif ((ext4_es_is_written(es1) || ext4_es_is_unwritten(es1)) &&\n\t    (ext4_es_pblock(es1) + es1->es_len == ext4_es_pblock(es2)))\n\t\treturn 1;\n\n\tif (ext4_es_is_hole(es1))\n\t\treturn 1;\n\n\t/* we need to check delayed extent is without unwritten status */\n\tif (ext4_es_is_delayed(es1) && !ext4_es_is_unwritten(es1))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int ext4_es_can_be_merged(struct extent_status *es1,\n\t\t\t\t struct extent_status *es2)\n{\n\tif (ext4_es_type(es1) != ext4_es_type(es2))\n\t\treturn 0;\n\n\tif (((__u64) es1->es_len) + es2->es_len > EXT_MAX_BLOCKS) {\n\t\tpr_warn(\"ES assertion failed when merging extents. \"\n\t\t\t\"The sum of lengths of es1 (%d) and es2 (%d) \"\n\t\t\t\"is bigger than allowed file size (%d)\\n\",\n\t\t\tes1->es_len, es2->es_len, EXT_MAX_BLOCKS);\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (((__u64) es1->es_lblk) + es1->es_len != es2->es_lblk)\n\t\treturn 0;\n\n\tif ((ext4_es_is_written(es1) || ext4_es_is_unwritten(es1)) &&\n\t    (ext4_es_pblock(es1) + es1->es_len == ext4_es_pblock(es2)))\n\t\treturn 1;\n\n\tif (ext4_es_is_hole(es1))\n\t\treturn 1;\n\n\t/* we need to check delayed extent is without unwritten status */\n\tif (ext4_es_is_delayed(es1) && !ext4_es_is_unwritten(es1))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_end",
          "args": [
            "es"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "199-203",
          "snippet": "static inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_try_to_merge_left",
          "args": [
            "inode",
            "es"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_try_to_merge_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "414-436",
          "snippet": "static struct extent_status *\next4_es_try_to_merge_left(struct inode *inode, struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es1;\n\tstruct rb_node *node;\n\n\tnode = rb_prev(&es->rb_node);\n\tif (!node)\n\t\treturn es;\n\n\tes1 = rb_entry(node, struct extent_status, rb_node);\n\tif (ext4_es_can_be_merged(es1, es)) {\n\t\tes1->es_len += es->es_len;\n\t\tif (ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es1);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tes = es1;\n\t}\n\n\treturn es;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct extent_status *\next4_es_try_to_merge_left(struct inode *inode, struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es1;\n\tstruct rb_node *node;\n\n\tnode = rb_prev(&es->rb_node);\n\tif (!node)\n\t\treturn es;\n\n\tes1 = rb_entry(node, struct extent_status, rb_node);\n\tif (ext4_es_can_be_merged(es1, es)) {\n\t\tes1->es_len += es->es_len;\n\t\tif (ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es1);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tes = es1;\n\t}\n\n\treturn es;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_store_pblock",
          "args": [
            "es",
            "newes->es_pblk"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_store_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "148-155",
          "snippet": "static inline void ext4_es_store_pblock(struct extent_status *es,\n\t\t\t\t\text4_fsblk_t pb)\n{\n\text4_fsblk_t block;\n\n\tblock = (pb & ~ES_MASK) | (es->es_pblk & ES_MASK);\n\tes->es_pblk = block;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\nstatic inline void ext4_es_store_pblock(struct extent_status *es,\n\t\t\t\t\text4_fsblk_t pb)\n{\n\text4_fsblk_t block;\n\n\tblock = (pb & ~ES_MASK) | (es->es_pblk & ES_MASK);\n\tes->es_pblk = block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_unwritten",
          "args": [
            "es"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "113-116",
          "snippet": "static inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)\n\nstatic inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_written",
          "args": [
            "es"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "108-111",
          "snippet": "static inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)\n\nstatic inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structextent_status",
            "rb_node"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node **p = &tree->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_status *es;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tes = rb_entry(parent, struct extent_status, rb_node);\n\n\t\tif (newes->es_lblk < es->es_lblk) {\n\t\t\tif (ext4_es_can_be_merged(newes, es)) {\n\t\t\t\t/*\n\t\t\t\t * Here we can modify es_lblk directly\n\t\t\t\t * because it isn't overlapped.\n\t\t\t\t */\n\t\t\t\tes->es_lblk = newes->es_lblk;\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t\t    ext4_es_is_unwritten(es))\n\t\t\t\t\text4_es_store_pblock(es,\n\t\t\t\t\t\t\t     newes->es_pblk);\n\t\t\t\tes = ext4_es_try_to_merge_left(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (newes->es_lblk > ext4_es_end(es)) {\n\t\t\tif (ext4_es_can_be_merged(es, newes)) {\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tes = ext4_es_try_to_merge_right(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tes = ext4_es_alloc_extent(inode, newes->es_lblk, newes->es_len,\n\t\t\t\t  newes->es_pblk);\n\tif (!es)\n\t\treturn -ENOMEM;\n\trb_link_node(&es->rb_node, parent, p);\n\trb_insert_color(&es->rb_node, &tree->root);\n\nout:\n\ttree->cache_es = es;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_es_insert_extent_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "628-631",
    "snippet": "static inline void ext4_es_insert_extent_check(struct inode *inode,\n\t\t\t\t\t       struct extent_status *es)\n{\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic inline void ext4_es_insert_extent_check(struct inode *inode,\n\t\t\t\t\t       struct extent_status *es)\n{\n}"
  },
  {
    "function_name": "ext4_es_insert_extent_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "614-626",
    "snippet": "static inline void ext4_es_insert_extent_check(struct inode *inode,\n\t\t\t\t\t       struct extent_status *es)\n{\n\t/*\n\t * We don't need to worry about the race condition because\n\t * caller takes i_data_sem locking.\n\t */\n\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode)->i_data_sem));\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_es_insert_extent_ext_check(inode, es);\n\telse\n\t\text4_es_insert_extent_ind_check(inode, es);\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_es_insert_extent_ind_check",
          "args": [
            "inode",
            "es"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_insert_extent_ind_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "551-612",
          "snippet": "static void ext4_es_insert_extent_ind_check(struct inode *inode,\n\t\t\t\t\t    struct extent_status *es)\n{\n\tstruct ext4_map_blocks map;\n\tint retval;\n\n\t/*\n\t * Here we call ext4_ind_map_blocks to lookup a block mapping because\n\t * 'Indirect' structure is defined in indirect.c.  So we couldn't\n\t * access direct/indirect tree from outside.  It is too dirty to define\n\t * this function in indirect.c file.\n\t */\n\n\tmap.m_lblk = es->es_lblk;\n\tmap.m_len = es->es_len;\n\n\tretval = ext4_ind_map_blocks(NULL, inode, &map, 0);\n\tif (retval > 0) {\n\t\tif (ext4_es_is_delayed(es) || ext4_es_is_hole(es)) {\n\t\t\t/*\n\t\t\t * We want to add a delayed/hole extent but this\n\t\t\t * block has been allocated.\n\t\t\t */\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can find blocks but we want to add a \"\n\t\t\t\t\"delayed/hole extent [%d/%d/%llu/%x]\\n\",\n\t\t\t\tinode->i_ino, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\treturn;\n\t\t} else if (ext4_es_is_written(es)) {\n\t\t\tif (retval != es->es_len) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu retval %d != es_len %d\\n\",\n\t\t\t\t\tinode->i_ino, retval, es->es_len);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (map.m_pblk != ext4_es_pblock(es)) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu m_pblk %llu != \"\n\t\t\t\t\t\"es_pblk %llu\\n\",\n\t\t\t\t\tinode->i_ino, map.m_pblk,\n\t\t\t\t\text4_es_pblock(es));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't need to check unwritten extent because\n\t\t\t * indirect-based file doesn't have it.\n\t\t\t */\n\t\t\tBUG_ON(1);\n\t\t}\n\t} else if (retval == 0) {\n\t\tif (ext4_es_is_written(es)) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can't find the block but we want to add \"\n\t\t\t\t\"a written extent [%d/%d/%llu/%x]\\n\",\n\t\t\t\tinode->i_ino, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_insert_extent_ind_check(struct inode *inode,\n\t\t\t\t\t    struct extent_status *es)\n{\n\tstruct ext4_map_blocks map;\n\tint retval;\n\n\t/*\n\t * Here we call ext4_ind_map_blocks to lookup a block mapping because\n\t * 'Indirect' structure is defined in indirect.c.  So we couldn't\n\t * access direct/indirect tree from outside.  It is too dirty to define\n\t * this function in indirect.c file.\n\t */\n\n\tmap.m_lblk = es->es_lblk;\n\tmap.m_len = es->es_len;\n\n\tretval = ext4_ind_map_blocks(NULL, inode, &map, 0);\n\tif (retval > 0) {\n\t\tif (ext4_es_is_delayed(es) || ext4_es_is_hole(es)) {\n\t\t\t/*\n\t\t\t * We want to add a delayed/hole extent but this\n\t\t\t * block has been allocated.\n\t\t\t */\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can find blocks but we want to add a \"\n\t\t\t\t\"delayed/hole extent [%d/%d/%llu/%x]\\n\",\n\t\t\t\tinode->i_ino, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\treturn;\n\t\t} else if (ext4_es_is_written(es)) {\n\t\t\tif (retval != es->es_len) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu retval %d != es_len %d\\n\",\n\t\t\t\t\tinode->i_ino, retval, es->es_len);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (map.m_pblk != ext4_es_pblock(es)) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu m_pblk %llu != \"\n\t\t\t\t\t\"es_pblk %llu\\n\",\n\t\t\t\t\tinode->i_ino, map.m_pblk,\n\t\t\t\t\text4_es_pblock(es));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't need to check unwritten extent because\n\t\t\t * indirect-based file doesn't have it.\n\t\t\t */\n\t\t\tBUG_ON(1);\n\t\t}\n\t} else if (retval == 0) {\n\t\tif (ext4_es_is_written(es)) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can't find the block but we want to add \"\n\t\t\t\t\"a written extent [%d/%d/%llu/%x]\\n\",\n\t\t\t\tinode->i_ino, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_insert_extent_ext_check",
          "args": [
            "inode",
            "es"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_insert_extent_ext_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "464-549",
          "snippet": "static void ext4_es_insert_extent_ext_check(struct inode *inode,\n\t\t\t\t\t    struct extent_status *es)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ex;\n\text4_lblk_t ee_block;\n\text4_fsblk_t ee_start;\n\tunsigned short ee_len;\n\tint depth, ee_status, es_status;\n\n\tpath = ext4_find_extent(inode, es->es_lblk, NULL, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\n\tif (ex) {\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\t\tee_start = ext4_ext_pblock(ex);\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\tee_status = ext4_ext_is_unwritten(ex) ? 1 : 0;\n\t\tes_status = ext4_es_is_unwritten(es) ? 1 : 0;\n\n\t\t/*\n\t\t * Make sure ex and es are not overlap when we try to insert\n\t\t * a delayed/hole extent.\n\t\t */\n\t\tif (!ext4_es_is_written(es) && !ext4_es_is_unwritten(es)) {\n\t\t\tif (in_range(es->es_lblk, ee_block, ee_len)) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu we can find an extent \"\n\t\t\t\t\t\"at block [%d/%d/%llu/%c], but we \"\n\t\t\t\t\t\"want to add a delayed/hole extent \"\n\t\t\t\t\t\"[%d/%d/%llu/%x]\\n\",\n\t\t\t\t\tinode->i_ino, ee_block, ee_len,\n\t\t\t\t\tee_start, ee_status ? 'u' : 'w',\n\t\t\t\t\tes->es_lblk, es->es_len,\n\t\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We don't check ee_block == es->es_lblk, etc. because es\n\t\t * might be a part of whole extent, vice versa.\n\t\t */\n\t\tif (es->es_lblk < ee_block ||\n\t\t    ext4_es_pblock(es) != ee_start + es->es_lblk - ee_block) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\", inode->i_ino,\n\t\t\t\tee_block, ee_len, ee_start,\n\t\t\t\tee_status ? 'u' : 'w', es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), es_status ? 'u' : 'w');\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ee_status ^ es_status) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\", inode->i_ino,\n\t\t\t\tee_block, ee_len, ee_start,\n\t\t\t\tee_status ? 'u' : 'w', es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), es_status ? 'u' : 'w');\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We can't find an extent on disk.  So we need to make sure\n\t\t * that we don't want to add an written/unwritten extent.\n\t\t */\n\t\tif (!ext4_es_is_delayed(es) && !ext4_es_is_hole(es)) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"can't find an extent at block %d but we want \"\n\t\t\t\t\"to add a written/unwritten extent \"\n\t\t\t\t\"[%d/%d/%llu/%x]\\n\", inode->i_ino,\n\t\t\t\tes->es_lblk, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t}\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_insert_extent_ext_check(struct inode *inode,\n\t\t\t\t\t    struct extent_status *es)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ex;\n\text4_lblk_t ee_block;\n\text4_fsblk_t ee_start;\n\tunsigned short ee_len;\n\tint depth, ee_status, es_status;\n\n\tpath = ext4_find_extent(inode, es->es_lblk, NULL, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\n\tif (ex) {\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\t\tee_start = ext4_ext_pblock(ex);\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\tee_status = ext4_ext_is_unwritten(ex) ? 1 : 0;\n\t\tes_status = ext4_es_is_unwritten(es) ? 1 : 0;\n\n\t\t/*\n\t\t * Make sure ex and es are not overlap when we try to insert\n\t\t * a delayed/hole extent.\n\t\t */\n\t\tif (!ext4_es_is_written(es) && !ext4_es_is_unwritten(es)) {\n\t\t\tif (in_range(es->es_lblk, ee_block, ee_len)) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu we can find an extent \"\n\t\t\t\t\t\"at block [%d/%d/%llu/%c], but we \"\n\t\t\t\t\t\"want to add a delayed/hole extent \"\n\t\t\t\t\t\"[%d/%d/%llu/%x]\\n\",\n\t\t\t\t\tinode->i_ino, ee_block, ee_len,\n\t\t\t\t\tee_start, ee_status ? 'u' : 'w',\n\t\t\t\t\tes->es_lblk, es->es_len,\n\t\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We don't check ee_block == es->es_lblk, etc. because es\n\t\t * might be a part of whole extent, vice versa.\n\t\t */\n\t\tif (es->es_lblk < ee_block ||\n\t\t    ext4_es_pblock(es) != ee_start + es->es_lblk - ee_block) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\", inode->i_ino,\n\t\t\t\tee_block, ee_len, ee_start,\n\t\t\t\tee_status ? 'u' : 'w', es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), es_status ? 'u' : 'w');\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ee_status ^ es_status) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\", inode->i_ino,\n\t\t\t\tee_block, ee_len, ee_start,\n\t\t\t\tee_status ? 'u' : 'w', es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), es_status ? 'u' : 'w');\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We can't find an extent on disk.  So we need to make sure\n\t\t * that we don't want to add an written/unwritten extent.\n\t\t */\n\t\tif (!ext4_es_is_delayed(es) && !ext4_es_is_hole(es)) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"can't find an extent at block %d but we want \"\n\t\t\t\t\"to add a written/unwritten extent \"\n\t\t\t\t\"[%d/%d/%llu/%x]\\n\", inode->i_ino,\n\t\t\t\tes->es_lblk, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t}\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rwsem_is_locked(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic inline void ext4_es_insert_extent_check(struct inode *inode,\n\t\t\t\t\t       struct extent_status *es)\n{\n\t/*\n\t * We don't need to worry about the race condition because\n\t * caller takes i_data_sem locking.\n\t */\n\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode)->i_data_sem));\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_es_insert_extent_ext_check(inode, es);\n\telse\n\t\text4_es_insert_extent_ind_check(inode, es);\n}"
  },
  {
    "function_name": "ext4_es_insert_extent_ind_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "551-612",
    "snippet": "static void ext4_es_insert_extent_ind_check(struct inode *inode,\n\t\t\t\t\t    struct extent_status *es)\n{\n\tstruct ext4_map_blocks map;\n\tint retval;\n\n\t/*\n\t * Here we call ext4_ind_map_blocks to lookup a block mapping because\n\t * 'Indirect' structure is defined in indirect.c.  So we couldn't\n\t * access direct/indirect tree from outside.  It is too dirty to define\n\t * this function in indirect.c file.\n\t */\n\n\tmap.m_lblk = es->es_lblk;\n\tmap.m_len = es->es_len;\n\n\tretval = ext4_ind_map_blocks(NULL, inode, &map, 0);\n\tif (retval > 0) {\n\t\tif (ext4_es_is_delayed(es) || ext4_es_is_hole(es)) {\n\t\t\t/*\n\t\t\t * We want to add a delayed/hole extent but this\n\t\t\t * block has been allocated.\n\t\t\t */\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can find blocks but we want to add a \"\n\t\t\t\t\"delayed/hole extent [%d/%d/%llu/%x]\\n\",\n\t\t\t\tinode->i_ino, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\treturn;\n\t\t} else if (ext4_es_is_written(es)) {\n\t\t\tif (retval != es->es_len) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu retval %d != es_len %d\\n\",\n\t\t\t\t\tinode->i_ino, retval, es->es_len);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (map.m_pblk != ext4_es_pblock(es)) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu m_pblk %llu != \"\n\t\t\t\t\t\"es_pblk %llu\\n\",\n\t\t\t\t\tinode->i_ino, map.m_pblk,\n\t\t\t\t\text4_es_pblock(es));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't need to check unwritten extent because\n\t\t\t * indirect-based file doesn't have it.\n\t\t\t */\n\t\t\tBUG_ON(1);\n\t\t}\n\t} else if (retval == 0) {\n\t\tif (ext4_es_is_written(es)) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can't find the block but we want to add \"\n\t\t\t\t\"a written extent [%d/%d/%llu/%x]\\n\",\n\t\t\t\tinode->i_ino, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can't find the block but we want to add \"\n\t\t\t\t\"a written extent [%d/%d/%llu/%x]\\n\"",
            "inode->i_ino",
            "es->es_lblk",
            "es->es_len",
            "ext4_es_pblock(es)",
            "ext4_es_status(es)"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_status",
          "args": [
            "es"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "98-101",
          "snippet": "static inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_pblock",
          "args": [
            "es"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "143-146",
          "snippet": "static inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\nstatic inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_written",
          "args": [
            "es"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "108-111",
          "snippet": "static inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)\n\nstatic inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu m_pblk %llu != \"\n\t\t\t\t\t\"es_pblk %llu\\n\"",
            "inode->i_ino",
            "map.m_pblk",
            "ext4_es_pblock(es)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu retval %d != es_len %d\\n\"",
            "inode->i_ino",
            "retval",
            "es->es_len"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can find blocks but we want to add a \"\n\t\t\t\t\"delayed/hole extent [%d/%d/%llu/%x]\\n\"",
            "inode->i_ino",
            "es->es_lblk",
            "es->es_len",
            "ext4_es_pblock(es)",
            "ext4_es_status(es)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_is_hole",
          "args": [
            "es"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "123-126",
          "snippet": "static inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)\n\nstatic inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_delayed",
          "args": [
            "es"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "118-121",
          "snippet": "static inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ind_map_blocks",
          "args": [
            "NULL",
            "inode",
            "&map",
            "0"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ind_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "513-632",
          "snippet": "int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tint flags)\n{\n\tstruct ext4_allocation_request ar;\n\tint err = -EIO;\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tint count = 0;\n\text4_fsblk_t first_block = 0;\n\n\ttrace_ext4_ind_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\tJ_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));\n\tJ_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);\n\tdepth = ext4_block_to_path(inode, map->m_lblk, offsets,\n\t\t\t\t   &blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext4_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < map->m_len && count <= blocks_to_boundary) {\n\t\t\text4_fsblk_t blk;\n\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0 || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t*/\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\tEXT4_ERROR_INODE(inode, \"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/* Set up for the direct block allocation */\n\tmemset(&ar, 0, sizeof(ar));\n\tar.inode = inode;\n\tar.logical = map->m_lblk;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\n\tar.goal = ext4_find_goal(inode, map->m_lblk, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tar.len = ext4_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t       map->m_len, blocks_to_boundary);\n\n\t/*\n\t * Block out ext4_truncate while we alter the tree\n\t */\n\terr = ext4_alloc_branch(handle, &ar, indirect_blks,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext4_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext4_splice_branch(handle, &ar, partial, indirect_blks);\n\tif (err)\n\t\tgoto cleanup;\n\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\tcount = ar.len;\ngot_it:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = le32_to_cpu(chain[depth-1].key);\n\tmap->m_len = count;\n\tif (count > blocks_to_boundary)\n\t\tmap->m_flags |= EXT4_MAP_BOUNDARY;\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nout:\n\ttrace_ext4_ind_map_blocks_exit(inode, flags, map, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nint ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tint flags)\n{\n\tstruct ext4_allocation_request ar;\n\tint err = -EIO;\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tint count = 0;\n\text4_fsblk_t first_block = 0;\n\n\ttrace_ext4_ind_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\tJ_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));\n\tJ_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);\n\tdepth = ext4_block_to_path(inode, map->m_lblk, offsets,\n\t\t\t\t   &blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext4_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < map->m_len && count <= blocks_to_boundary) {\n\t\t\text4_fsblk_t blk;\n\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0 || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t*/\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\tEXT4_ERROR_INODE(inode, \"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/* Set up for the direct block allocation */\n\tmemset(&ar, 0, sizeof(ar));\n\tar.inode = inode;\n\tar.logical = map->m_lblk;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\n\tar.goal = ext4_find_goal(inode, map->m_lblk, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tar.len = ext4_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t       map->m_len, blocks_to_boundary);\n\n\t/*\n\t * Block out ext4_truncate while we alter the tree\n\t */\n\terr = ext4_alloc_branch(handle, &ar, indirect_blks,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext4_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext4_splice_branch(handle, &ar, partial, indirect_blks);\n\tif (err)\n\t\tgoto cleanup;\n\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\tcount = ar.len;\ngot_it:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = le32_to_cpu(chain[depth-1].key);\n\tmap->m_len = count;\n\tif (count > blocks_to_boundary)\n\t\tmap->m_flags |= EXT4_MAP_BOUNDARY;\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nout:\n\ttrace_ext4_ind_map_blocks_exit(inode, flags, map, err);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_insert_extent_ind_check(struct inode *inode,\n\t\t\t\t\t    struct extent_status *es)\n{\n\tstruct ext4_map_blocks map;\n\tint retval;\n\n\t/*\n\t * Here we call ext4_ind_map_blocks to lookup a block mapping because\n\t * 'Indirect' structure is defined in indirect.c.  So we couldn't\n\t * access direct/indirect tree from outside.  It is too dirty to define\n\t * this function in indirect.c file.\n\t */\n\n\tmap.m_lblk = es->es_lblk;\n\tmap.m_len = es->es_len;\n\n\tretval = ext4_ind_map_blocks(NULL, inode, &map, 0);\n\tif (retval > 0) {\n\t\tif (ext4_es_is_delayed(es) || ext4_es_is_hole(es)) {\n\t\t\t/*\n\t\t\t * We want to add a delayed/hole extent but this\n\t\t\t * block has been allocated.\n\t\t\t */\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can find blocks but we want to add a \"\n\t\t\t\t\"delayed/hole extent [%d/%d/%llu/%x]\\n\",\n\t\t\t\tinode->i_ino, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\treturn;\n\t\t} else if (ext4_es_is_written(es)) {\n\t\t\tif (retval != es->es_len) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu retval %d != es_len %d\\n\",\n\t\t\t\t\tinode->i_ino, retval, es->es_len);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (map.m_pblk != ext4_es_pblock(es)) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu m_pblk %llu != \"\n\t\t\t\t\t\"es_pblk %llu\\n\",\n\t\t\t\t\tinode->i_ino, map.m_pblk,\n\t\t\t\t\text4_es_pblock(es));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't need to check unwritten extent because\n\t\t\t * indirect-based file doesn't have it.\n\t\t\t */\n\t\t\tBUG_ON(1);\n\t\t}\n\t} else if (retval == 0) {\n\t\tif (ext4_es_is_written(es)) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can't find the block but we want to add \"\n\t\t\t\t\"a written extent [%d/%d/%llu/%x]\\n\",\n\t\t\t\tinode->i_ino, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ext4_es_insert_extent_ext_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "464-549",
    "snippet": "static void ext4_es_insert_extent_ext_check(struct inode *inode,\n\t\t\t\t\t    struct extent_status *es)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ex;\n\text4_lblk_t ee_block;\n\text4_fsblk_t ee_start;\n\tunsigned short ee_len;\n\tint depth, ee_status, es_status;\n\n\tpath = ext4_find_extent(inode, es->es_lblk, NULL, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\n\tif (ex) {\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\t\tee_start = ext4_ext_pblock(ex);\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\tee_status = ext4_ext_is_unwritten(ex) ? 1 : 0;\n\t\tes_status = ext4_es_is_unwritten(es) ? 1 : 0;\n\n\t\t/*\n\t\t * Make sure ex and es are not overlap when we try to insert\n\t\t * a delayed/hole extent.\n\t\t */\n\t\tif (!ext4_es_is_written(es) && !ext4_es_is_unwritten(es)) {\n\t\t\tif (in_range(es->es_lblk, ee_block, ee_len)) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu we can find an extent \"\n\t\t\t\t\t\"at block [%d/%d/%llu/%c], but we \"\n\t\t\t\t\t\"want to add a delayed/hole extent \"\n\t\t\t\t\t\"[%d/%d/%llu/%x]\\n\",\n\t\t\t\t\tinode->i_ino, ee_block, ee_len,\n\t\t\t\t\tee_start, ee_status ? 'u' : 'w',\n\t\t\t\t\tes->es_lblk, es->es_len,\n\t\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We don't check ee_block == es->es_lblk, etc. because es\n\t\t * might be a part of whole extent, vice versa.\n\t\t */\n\t\tif (es->es_lblk < ee_block ||\n\t\t    ext4_es_pblock(es) != ee_start + es->es_lblk - ee_block) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\", inode->i_ino,\n\t\t\t\tee_block, ee_len, ee_start,\n\t\t\t\tee_status ? 'u' : 'w', es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), es_status ? 'u' : 'w');\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ee_status ^ es_status) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\", inode->i_ino,\n\t\t\t\tee_block, ee_len, ee_start,\n\t\t\t\tee_status ? 'u' : 'w', es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), es_status ? 'u' : 'w');\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We can't find an extent on disk.  So we need to make sure\n\t\t * that we don't want to add an written/unwritten extent.\n\t\t */\n\t\tif (!ext4_es_is_delayed(es) && !ext4_es_is_hole(es)) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"can't find an extent at block %d but we want \"\n\t\t\t\t\"to add a written/unwritten extent \"\n\t\t\t\t\"[%d/%d/%llu/%x]\\n\", inode->i_ino,\n\t\t\t\tes->es_lblk, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t}\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_drop_refs",
          "args": [
            "path"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_drop_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "708-720",
          "snippet": "void ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++)\n\t\tif (path->p_bh) {\n\t\t\tbrelse(path->p_bh);\n\t\t\tpath->p_bh = NULL;\n\t\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++)\n\t\tif (path->p_bh) {\n\t\t\tbrelse(path->p_bh);\n\t\t\tpath->p_bh = NULL;\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"can't find an extent at block %d but we want \"\n\t\t\t\t\"to add a written/unwritten extent \"\n\t\t\t\t\"[%d/%d/%llu/%x]\\n\"",
            "inode->i_ino",
            "es->es_lblk",
            "es->es_lblk",
            "es->es_len",
            "ext4_es_pblock(es)",
            "ext4_es_status(es)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_status",
          "args": [
            "es"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "98-101",
          "snippet": "static inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_pblock",
          "args": [
            "es"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "143-146",
          "snippet": "static inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\nstatic inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_hole",
          "args": [
            "es"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "123-126",
          "snippet": "static inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)\n\nstatic inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_delayed",
          "args": [
            "es"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "118-121",
          "snippet": "static inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\"",
            "inode->i_ino",
            "ee_block",
            "ee_len",
            "ee_start",
            "ee_status ? 'u' : 'w'",
            "es->es_lblk",
            "es->es_len",
            "ext4_es_pblock(es)",
            "es_status ? 'u' : 'w'"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\"",
            "inode->i_ino",
            "ee_block",
            "ee_len",
            "ee_start",
            "ee_status ? 'u' : 'w'",
            "es->es_lblk",
            "es->es_len",
            "ext4_es_pblock(es)",
            "es_status ? 'u' : 'w'"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu we can find an extent \"\n\t\t\t\t\t\"at block [%d/%d/%llu/%c], but we \"\n\t\t\t\t\t\"want to add a delayed/hole extent \"\n\t\t\t\t\t\"[%d/%d/%llu/%x]\\n\"",
            "inode->i_ino",
            "ee_block",
            "ee_len",
            "ee_start",
            "ee_status ? 'u' : 'w'",
            "es->es_lblk",
            "es->es_len",
            "ext4_es_pblock(es)",
            "ext4_es_status(es)"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "es->es_lblk",
            "ee_block",
            "ee_len"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_unwritten",
          "args": [
            "es"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "113-116",
          "snippet": "static inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)\n\nstatic inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_written",
          "args": [
            "es"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "108-111",
          "snippet": "static inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)\n\nstatic inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_is_unwritten",
          "args": [
            "ex"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_is_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "198-202",
          "snippet": "static inline int ext4_ext_is_unwritten(struct ext4_extent *ext)\n{\n\t/* Extent with ee_len of 0x8000 is treated as an initialized extent */\n\treturn (le16_to_cpu(ext->ee_len) > EXT_INIT_MAX_LEN);\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [
            "#define EXT_INIT_MAX_LEN\t(1UL << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\n#define EXT_INIT_MAX_LEN\t(1UL << 15)\n\nstatic inline int ext4_ext_is_unwritten(struct ext4_extent *ext)\n{\n\t/* Extent with ee_len of 0x8000 is treated as an initialized extent */\n\treturn (le16_to_cpu(ext->ee_len) > EXT_INIT_MAX_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_get_actual_len",
          "args": [
            "ex"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_get_actual_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "204-209",
          "snippet": "static inline int ext4_ext_get_actual_len(struct ext4_extent *ext)\n{\n\treturn (le16_to_cpu(ext->ee_len) <= EXT_INIT_MAX_LEN ?\n\t\tle16_to_cpu(ext->ee_len) :\n\t\t(le16_to_cpu(ext->ee_len) - EXT_INIT_MAX_LEN));\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [
            "#define EXT_INIT_MAX_LEN\t(1UL << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\n#define EXT_INIT_MAX_LEN\t(1UL << 15)\n\nstatic inline int ext4_ext_get_actual_len(struct ext4_extent *ext)\n{\n\treturn (le16_to_cpu(ext->ee_len) <= EXT_INIT_MAX_LEN ?\n\t\tle16_to_cpu(ext->ee_len) :\n\t\t(le16_to_cpu(ext->ee_len) - EXT_INIT_MAX_LEN));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_pblock",
          "args": [
            "ex"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "220-227",
          "snippet": "static inline ext4_fsblk_t ext4_ext_pblock(struct ext4_extent *ex)\n{\n\text4_fsblk_t block;\n\n\tblock = le32_to_cpu(ex->ee_start_lo);\n\tblock |= ((ext4_fsblk_t) le16_to_cpu(ex->ee_start_hi) << 31) << 1;\n\treturn block;\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\nstatic inline ext4_fsblk_t ext4_ext_pblock(struct ext4_extent *ex)\n{\n\text4_fsblk_t block;\n\n\tblock = le32_to_cpu(ex->ee_start_lo);\n\tblock |= ((ext4_fsblk_t) le16_to_cpu(ex->ee_start_hi) << 31) << 1;\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ex->ee_block"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_depth",
          "args": [
            "inode"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ext_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "186-189",
          "snippet": "static inline unsigned short ext_depth(struct inode *inode)\n{\n\treturn le16_to_cpu(ext_inode_hdr(inode)->eh_depth);\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\nstatic inline unsigned short ext_depth(struct inode *inode)\n{\n\treturn le16_to_cpu(ext_inode_hdr(inode)->eh_depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_extent",
          "args": [
            "inode",
            "es->es_lblk",
            "NULL",
            "EXT4_EX_NOCACHE"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "857-939",
          "snippet": "struct ext4_ext_path *\next4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\t/* account possible depth increase */\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),\n\t\t\t\tGFP_NOFS);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\n\ti = depth;\n\t/* walk through the tree */\n\twhile (i) {\n\t\text_debug(\"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_block, --i,\n\t\t\t\t\t    flags);\n\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tif (unlikely(ppos > depth)) {\n\t\t\tput_bh(bh);\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"ppos %d > depth %d\", ppos, depth);\n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\n\t/* find extent */\n\text4_ext_binsearch(inode, path + ppos, block);\n\t/* if not an empty leaf */\n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\n\text4_ext_show_path(inode, path);\n\n\treturn path;\n\nerr:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);",
            "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);\nstatic int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);\n\nstruct ext4_ext_path *\next4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\t/* account possible depth increase */\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),\n\t\t\t\tGFP_NOFS);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\n\ti = depth;\n\t/* walk through the tree */\n\twhile (i) {\n\t\text_debug(\"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_block, --i,\n\t\t\t\t\t    flags);\n\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tif (unlikely(ppos > depth)) {\n\t\t\tput_bh(bh);\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"ppos %d > depth %d\", ppos, depth);\n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\n\t/* find extent */\n\text4_ext_binsearch(inode, path + ppos, block);\n\t/* if not an empty leaf */\n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\n\text4_ext_show_path(inode, path);\n\n\treturn path;\n\nerr:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_insert_extent_ext_check(struct inode *inode,\n\t\t\t\t\t    struct extent_status *es)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ex;\n\text4_lblk_t ee_block;\n\text4_fsblk_t ee_start;\n\tunsigned short ee_len;\n\tint depth, ee_status, es_status;\n\n\tpath = ext4_find_extent(inode, es->es_lblk, NULL, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\n\tif (ex) {\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\t\tee_start = ext4_ext_pblock(ex);\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\tee_status = ext4_ext_is_unwritten(ex) ? 1 : 0;\n\t\tes_status = ext4_es_is_unwritten(es) ? 1 : 0;\n\n\t\t/*\n\t\t * Make sure ex and es are not overlap when we try to insert\n\t\t * a delayed/hole extent.\n\t\t */\n\t\tif (!ext4_es_is_written(es) && !ext4_es_is_unwritten(es)) {\n\t\t\tif (in_range(es->es_lblk, ee_block, ee_len)) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu we can find an extent \"\n\t\t\t\t\t\"at block [%d/%d/%llu/%c], but we \"\n\t\t\t\t\t\"want to add a delayed/hole extent \"\n\t\t\t\t\t\"[%d/%d/%llu/%x]\\n\",\n\t\t\t\t\tinode->i_ino, ee_block, ee_len,\n\t\t\t\t\tee_start, ee_status ? 'u' : 'w',\n\t\t\t\t\tes->es_lblk, es->es_len,\n\t\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We don't check ee_block == es->es_lblk, etc. because es\n\t\t * might be a part of whole extent, vice versa.\n\t\t */\n\t\tif (es->es_lblk < ee_block ||\n\t\t    ext4_es_pblock(es) != ee_start + es->es_lblk - ee_block) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\", inode->i_ino,\n\t\t\t\tee_block, ee_len, ee_start,\n\t\t\t\tee_status ? 'u' : 'w', es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), es_status ? 'u' : 'w');\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ee_status ^ es_status) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\", inode->i_ino,\n\t\t\t\tee_block, ee_len, ee_start,\n\t\t\t\tee_status ? 'u' : 'w', es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), es_status ? 'u' : 'w');\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We can't find an extent on disk.  So we need to make sure\n\t\t * that we don't want to add an written/unwritten extent.\n\t\t */\n\t\tif (!ext4_es_is_delayed(es) && !ext4_es_is_hole(es)) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"can't find an extent at block %d but we want \"\n\t\t\t\t\"to add a written/unwritten extent \"\n\t\t\t\t\"[%d/%d/%llu/%x]\\n\", inode->i_ino,\n\t\t\t\tes->es_lblk, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t}\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n}"
  },
  {
    "function_name": "ext4_es_try_to_merge_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "438-459",
    "snippet": "static struct extent_status *\next4_es_try_to_merge_right(struct inode *inode, struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es1;\n\tstruct rb_node *node;\n\n\tnode = rb_next(&es->rb_node);\n\tif (!node)\n\t\treturn es;\n\n\tes1 = rb_entry(node, struct extent_status, rb_node);\n\tif (ext4_es_can_be_merged(es, es1)) {\n\t\tes->es_len += es1->es_len;\n\t\tif (ext4_es_is_referenced(es1))\n\t\t\text4_es_set_referenced(es);\n\t\trb_erase(node, &tree->root);\n\t\text4_es_free_extent(inode, es1);\n\t}\n\n\treturn es;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_es_free_extent",
          "args": [
            "inode",
            "es1"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "358-373",
          "snippet": "static void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_es_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nstatic void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "&tree->root"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_set_referenced",
          "args": [
            "es"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_set_referenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "128-131",
          "snippet": "static inline void ext4_es_set_referenced(struct extent_status *es)\n{\n\tes->es_pblk |= ((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)",
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)\n#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline void ext4_es_set_referenced(struct extent_status *es)\n{\n\tes->es_pblk |= ((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_referenced",
          "args": [
            "es1"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_referenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "138-141",
          "snippet": "static inline int ext4_es_is_referenced(struct extent_status *es)\n{\n\treturn (ext4_es_status(es) & EXTENT_STATUS_REFERENCED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)\n\nstatic inline int ext4_es_is_referenced(struct extent_status *es)\n{\n\treturn (ext4_es_status(es) & EXTENT_STATUS_REFERENCED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_can_be_merged",
          "args": [
            "es",
            "es1"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_can_be_merged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "382-412",
          "snippet": "static int ext4_es_can_be_merged(struct extent_status *es1,\n\t\t\t\t struct extent_status *es2)\n{\n\tif (ext4_es_type(es1) != ext4_es_type(es2))\n\t\treturn 0;\n\n\tif (((__u64) es1->es_len) + es2->es_len > EXT_MAX_BLOCKS) {\n\t\tpr_warn(\"ES assertion failed when merging extents. \"\n\t\t\t\"The sum of lengths of es1 (%d) and es2 (%d) \"\n\t\t\t\"is bigger than allowed file size (%d)\\n\",\n\t\t\tes1->es_len, es2->es_len, EXT_MAX_BLOCKS);\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (((__u64) es1->es_lblk) + es1->es_len != es2->es_lblk)\n\t\treturn 0;\n\n\tif ((ext4_es_is_written(es1) || ext4_es_is_unwritten(es1)) &&\n\t    (ext4_es_pblock(es1) + es1->es_len == ext4_es_pblock(es2)))\n\t\treturn 1;\n\n\tif (ext4_es_is_hole(es1))\n\t\treturn 1;\n\n\t/* we need to check delayed extent is without unwritten status */\n\tif (ext4_es_is_delayed(es1) && !ext4_es_is_unwritten(es1))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int ext4_es_can_be_merged(struct extent_status *es1,\n\t\t\t\t struct extent_status *es2)\n{\n\tif (ext4_es_type(es1) != ext4_es_type(es2))\n\t\treturn 0;\n\n\tif (((__u64) es1->es_len) + es2->es_len > EXT_MAX_BLOCKS) {\n\t\tpr_warn(\"ES assertion failed when merging extents. \"\n\t\t\t\"The sum of lengths of es1 (%d) and es2 (%d) \"\n\t\t\t\"is bigger than allowed file size (%d)\\n\",\n\t\t\tes1->es_len, es2->es_len, EXT_MAX_BLOCKS);\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (((__u64) es1->es_lblk) + es1->es_len != es2->es_lblk)\n\t\treturn 0;\n\n\tif ((ext4_es_is_written(es1) || ext4_es_is_unwritten(es1)) &&\n\t    (ext4_es_pblock(es1) + es1->es_len == ext4_es_pblock(es2)))\n\t\treturn 1;\n\n\tif (ext4_es_is_hole(es1))\n\t\treturn 1;\n\n\t/* we need to check delayed extent is without unwritten status */\n\tif (ext4_es_is_delayed(es1) && !ext4_es_is_unwritten(es1))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_status",
            "rb_node"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&es->rb_node"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct extent_status *\next4_es_try_to_merge_right(struct inode *inode, struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es1;\n\tstruct rb_node *node;\n\n\tnode = rb_next(&es->rb_node);\n\tif (!node)\n\t\treturn es;\n\n\tes1 = rb_entry(node, struct extent_status, rb_node);\n\tif (ext4_es_can_be_merged(es, es1)) {\n\t\tes->es_len += es1->es_len;\n\t\tif (ext4_es_is_referenced(es1))\n\t\t\text4_es_set_referenced(es);\n\t\trb_erase(node, &tree->root);\n\t\text4_es_free_extent(inode, es1);\n\t}\n\n\treturn es;\n}"
  },
  {
    "function_name": "ext4_es_try_to_merge_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "414-436",
    "snippet": "static struct extent_status *\next4_es_try_to_merge_left(struct inode *inode, struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es1;\n\tstruct rb_node *node;\n\n\tnode = rb_prev(&es->rb_node);\n\tif (!node)\n\t\treturn es;\n\n\tes1 = rb_entry(node, struct extent_status, rb_node);\n\tif (ext4_es_can_be_merged(es1, es)) {\n\t\tes1->es_len += es->es_len;\n\t\tif (ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es1);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tes = es1;\n\t}\n\n\treturn es;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_es_free_extent",
          "args": [
            "inode",
            "es"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "358-373",
          "snippet": "static void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_es_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nstatic void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&es->rb_node",
            "&tree->root"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_set_referenced",
          "args": [
            "es1"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_set_referenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "128-131",
          "snippet": "static inline void ext4_es_set_referenced(struct extent_status *es)\n{\n\tes->es_pblk |= ((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)",
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)\n#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline void ext4_es_set_referenced(struct extent_status *es)\n{\n\tes->es_pblk |= ((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_referenced",
          "args": [
            "es"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_referenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "138-141",
          "snippet": "static inline int ext4_es_is_referenced(struct extent_status *es)\n{\n\treturn (ext4_es_status(es) & EXTENT_STATUS_REFERENCED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)\n\nstatic inline int ext4_es_is_referenced(struct extent_status *es)\n{\n\treturn (ext4_es_status(es) & EXTENT_STATUS_REFERENCED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_can_be_merged",
          "args": [
            "es1",
            "es"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_can_be_merged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "382-412",
          "snippet": "static int ext4_es_can_be_merged(struct extent_status *es1,\n\t\t\t\t struct extent_status *es2)\n{\n\tif (ext4_es_type(es1) != ext4_es_type(es2))\n\t\treturn 0;\n\n\tif (((__u64) es1->es_len) + es2->es_len > EXT_MAX_BLOCKS) {\n\t\tpr_warn(\"ES assertion failed when merging extents. \"\n\t\t\t\"The sum of lengths of es1 (%d) and es2 (%d) \"\n\t\t\t\"is bigger than allowed file size (%d)\\n\",\n\t\t\tes1->es_len, es2->es_len, EXT_MAX_BLOCKS);\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (((__u64) es1->es_lblk) + es1->es_len != es2->es_lblk)\n\t\treturn 0;\n\n\tif ((ext4_es_is_written(es1) || ext4_es_is_unwritten(es1)) &&\n\t    (ext4_es_pblock(es1) + es1->es_len == ext4_es_pblock(es2)))\n\t\treturn 1;\n\n\tif (ext4_es_is_hole(es1))\n\t\treturn 1;\n\n\t/* we need to check delayed extent is without unwritten status */\n\tif (ext4_es_is_delayed(es1) && !ext4_es_is_unwritten(es1))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int ext4_es_can_be_merged(struct extent_status *es1,\n\t\t\t\t struct extent_status *es2)\n{\n\tif (ext4_es_type(es1) != ext4_es_type(es2))\n\t\treturn 0;\n\n\tif (((__u64) es1->es_len) + es2->es_len > EXT_MAX_BLOCKS) {\n\t\tpr_warn(\"ES assertion failed when merging extents. \"\n\t\t\t\"The sum of lengths of es1 (%d) and es2 (%d) \"\n\t\t\t\"is bigger than allowed file size (%d)\\n\",\n\t\t\tes1->es_len, es2->es_len, EXT_MAX_BLOCKS);\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (((__u64) es1->es_lblk) + es1->es_len != es2->es_lblk)\n\t\treturn 0;\n\n\tif ((ext4_es_is_written(es1) || ext4_es_is_unwritten(es1)) &&\n\t    (ext4_es_pblock(es1) + es1->es_len == ext4_es_pblock(es2)))\n\t\treturn 1;\n\n\tif (ext4_es_is_hole(es1))\n\t\treturn 1;\n\n\t/* we need to check delayed extent is without unwritten status */\n\tif (ext4_es_is_delayed(es1) && !ext4_es_is_unwritten(es1))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_status",
            "rb_node"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&es->rb_node"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct extent_status *\next4_es_try_to_merge_left(struct inode *inode, struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es1;\n\tstruct rb_node *node;\n\n\tnode = rb_prev(&es->rb_node);\n\tif (!node)\n\t\treturn es;\n\n\tes1 = rb_entry(node, struct extent_status, rb_node);\n\tif (ext4_es_can_be_merged(es1, es)) {\n\t\tes1->es_len += es->es_len;\n\t\tif (ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es1);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tes = es1;\n\t}\n\n\treturn es;\n}"
  },
  {
    "function_name": "ext4_es_can_be_merged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "382-412",
    "snippet": "static int ext4_es_can_be_merged(struct extent_status *es1,\n\t\t\t\t struct extent_status *es2)\n{\n\tif (ext4_es_type(es1) != ext4_es_type(es2))\n\t\treturn 0;\n\n\tif (((__u64) es1->es_len) + es2->es_len > EXT_MAX_BLOCKS) {\n\t\tpr_warn(\"ES assertion failed when merging extents. \"\n\t\t\t\"The sum of lengths of es1 (%d) and es2 (%d) \"\n\t\t\t\"is bigger than allowed file size (%d)\\n\",\n\t\t\tes1->es_len, es2->es_len, EXT_MAX_BLOCKS);\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (((__u64) es1->es_lblk) + es1->es_len != es2->es_lblk)\n\t\treturn 0;\n\n\tif ((ext4_es_is_written(es1) || ext4_es_is_unwritten(es1)) &&\n\t    (ext4_es_pblock(es1) + es1->es_len == ext4_es_pblock(es2)))\n\t\treturn 1;\n\n\tif (ext4_es_is_hole(es1))\n\t\treturn 1;\n\n\t/* we need to check delayed extent is without unwritten status */\n\tif (ext4_es_is_delayed(es1) && !ext4_es_is_unwritten(es1))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_es_is_unwritten",
          "args": [
            "es1"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "113-116",
          "snippet": "static inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)\n\nstatic inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_delayed",
          "args": [
            "es1"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "118-121",
          "snippet": "static inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_hole",
          "args": [
            "es1"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "123-126",
          "snippet": "static inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)\n\nstatic inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_pblock",
          "args": [
            "es2"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "143-146",
          "snippet": "static inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\nstatic inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_written",
          "args": [
            "es1"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "108-111",
          "snippet": "static inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)\n\nstatic inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ES assertion failed when merging extents. \"\n\t\t\t\"The sum of lengths of es1 (%d) and es2 (%d) \"\n\t\t\t\"is bigger than allowed file size (%d)\\n\"",
            "es1->es_len",
            "es2->es_len",
            "EXT_MAX_BLOCKS"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_type",
          "args": [
            "es2"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "103-106",
          "snippet": "static inline unsigned int ext4_es_type(struct extent_status *es)\n{\n\treturn (es->es_pblk & ES_TYPE_MASK) >> ES_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_TYPE_MASK\t((ext4_fsblk_t)(EXTENT_STATUS_WRITTEN | \\\n\t\t\t  EXTENT_STATUS_UNWRITTEN | \\\n\t\t\t  EXTENT_STATUS_DELAYED | \\\n\t\t\t  EXTENT_STATUS_HOLE) << ES_SHIFT)",
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_TYPE_MASK\t((ext4_fsblk_t)(EXTENT_STATUS_WRITTEN | \\\n\t\t\t  EXTENT_STATUS_UNWRITTEN | \\\n\t\t\t  EXTENT_STATUS_DELAYED | \\\n\t\t\t  EXTENT_STATUS_HOLE) << ES_SHIFT)\n#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline unsigned int ext4_es_type(struct extent_status *es)\n{\n\treturn (es->es_pblk & ES_TYPE_MASK) >> ES_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int ext4_es_can_be_merged(struct extent_status *es1,\n\t\t\t\t struct extent_status *es2)\n{\n\tif (ext4_es_type(es1) != ext4_es_type(es2))\n\t\treturn 0;\n\n\tif (((__u64) es1->es_len) + es2->es_len > EXT_MAX_BLOCKS) {\n\t\tpr_warn(\"ES assertion failed when merging extents. \"\n\t\t\t\"The sum of lengths of es1 (%d) and es2 (%d) \"\n\t\t\t\"is bigger than allowed file size (%d)\\n\",\n\t\t\tes1->es_len, es2->es_len, EXT_MAX_BLOCKS);\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (((__u64) es1->es_lblk) + es1->es_len != es2->es_lblk)\n\t\treturn 0;\n\n\tif ((ext4_es_is_written(es1) || ext4_es_is_unwritten(es1)) &&\n\t    (ext4_es_pblock(es1) + es1->es_len == ext4_es_pblock(es2)))\n\t\treturn 1;\n\n\tif (ext4_es_is_hole(es1))\n\t\treturn 1;\n\n\t/* we need to check delayed extent is without unwritten status */\n\tif (ext4_es_is_delayed(es1) && !ext4_es_is_unwritten(es1))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_es_free_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "358-373",
    "snippet": "static void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_es_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_es_cachep",
            "es"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_dec",
          "args": [
            "&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_list_del",
          "args": [
            "inode"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "316-328",
          "snippet": "static void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "EXT4_I(inode)->i_es_shk_nr == 0"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_is_delayed",
          "args": [
            "es"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "118-121",
          "snippet": "static inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_dec",
          "args": [
            "&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nstatic void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}"
  },
  {
    "function_name": "ext4_es_alloc_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "330-356",
    "snippet": "static struct extent_status *\next4_es_alloc_extent(struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len,\n\t\t     ext4_fsblk_t pblk)\n{\n\tstruct extent_status *es;\n\tes = kmem_cache_alloc(ext4_es_cachep, GFP_ATOMIC);\n\tif (es == NULL)\n\t\treturn NULL;\n\tes->es_lblk = lblk;\n\tes->es_len = len;\n\tes->es_pblk = pblk;\n\n\t/*\n\t * We don't count delayed extent because we never try to reclaim them\n\t */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tif (!EXT4_I(inode)->i_es_shk_nr++)\n\t\t\text4_es_list_add(inode);\n\t\tpercpu_counter_inc(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tEXT4_I(inode)->i_es_all_nr++;\n\tpercpu_counter_inc(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\treturn es;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_es_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_inc",
          "args": [
            "&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_inc",
          "args": [
            "&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_list_add",
          "args": [
            "inode"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "300-314",
          "snippet": "static void ext4_es_list_add(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tif (!list_empty(&ei->i_es_list))\n\t\treturn;\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (list_empty(&ei->i_es_list)) {\n\t\tlist_add_tail(&ei->i_es_list, &sbi->s_es_list);\n\t\tsbi->s_es_nr_inode++;\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_add(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tif (!list_empty(&ei->i_es_list))\n\t\treturn;\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (list_empty(&ei->i_es_list)) {\n\t\tlist_add_tail(&ei->i_es_list, &sbi->s_es_list);\n\t\tsbi->s_es_nr_inode++;\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_delayed",
          "args": [
            "es"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "118-121",
          "snippet": "static inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ext4_es_cachep",
            "GFP_ATOMIC"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nstatic struct extent_status *\next4_es_alloc_extent(struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len,\n\t\t     ext4_fsblk_t pblk)\n{\n\tstruct extent_status *es;\n\tes = kmem_cache_alloc(ext4_es_cachep, GFP_ATOMIC);\n\tif (es == NULL)\n\t\treturn NULL;\n\tes->es_lblk = lblk;\n\tes->es_len = len;\n\tes->es_pblk = pblk;\n\n\t/*\n\t * We don't count delayed extent because we never try to reclaim them\n\t */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tif (!EXT4_I(inode)->i_es_shk_nr++)\n\t\t\text4_es_list_add(inode);\n\t\tpercpu_counter_inc(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tEXT4_I(inode)->i_es_all_nr++;\n\tpercpu_counter_inc(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\treturn es;\n}"
  },
  {
    "function_name": "ext4_es_list_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "316-328",
    "snippet": "static void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_es_lock"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "sbi->s_es_nr_inode < 0"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ei->i_es_list"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ei->i_es_list"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_es_lock"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
  },
  {
    "function_name": "ext4_es_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "300-314",
    "snippet": "static void ext4_es_list_add(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tif (!list_empty(&ei->i_es_list))\n\t\treturn;\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (list_empty(&ei->i_es_list)) {\n\t\tlist_add_tail(&ei->i_es_list, &sbi->s_es_list);\n\t\tsbi->s_es_nr_inode++;\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_es_lock"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ei->i_es_list",
            "&sbi->s_es_list"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ei->i_es_list"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_es_lock"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_add(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tif (!list_empty(&ei->i_es_list))\n\t\treturn;\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (list_empty(&ei->i_es_list)) {\n\t\tlist_add_tail(&ei->i_es_list, &sbi->s_es_list);\n\t\tsbi->s_es_nr_inode++;\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
  },
  {
    "function_name": "ext4_es_find_delayed_extent_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "246-298",
    "snippet": "void ext4_es_find_delayed_extent_range(struct inode *inode,\n\t\t\t\t ext4_lblk_t lblk, ext4_lblk_t end,\n\t\t\t\t struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = NULL;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\n\tBUG_ON(es == NULL);\n\tBUG_ON(end < lblk);\n\ttrace_ext4_es_find_delayed_extent_range_enter(inode, lblk);\n\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u) %llu %x\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len,\n\t\t\t\t ext4_es_pblock(es1), ext4_es_status(es1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tes1 = __es_tree_search(&tree->root, lblk);\n\nout:\n\tif (es1 && !ext4_es_is_delayed(es1)) {\n\t\twhile ((node = rb_next(&es1->rb_node)) != NULL) {\n\t\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\t\tif (es1->es_lblk > end) {\n\t\t\t\tes1 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ext4_es_is_delayed(es1))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (es1 && ext4_es_is_delayed(es1)) {\n\t\ttree->cache_es = es1;\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_find_delayed_extent_range_exit(inode, es);\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_es_find_delayed_extent_range_exit",
          "args": [
            "inode",
            "es"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&EXT4_I(inode)->i_es_lock"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_delayed",
          "args": [
            "es1"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "118-121",
          "snippet": "static inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_status",
            "rb_node"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&es1->rb_node"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__es_tree_search",
          "args": [
            "&tree->root",
            "lblk"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "__es_tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "209-235",
          "snippet": "static struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "es_debug",
          "args": [
            "\"%u cached by [%u/%u) %llu %x\\n\"",
            "lblk",
            "es1->es_lblk",
            "es1->es_len",
            "ext4_es_pblock(es1)",
            "ext4_es_status(es1)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_status",
          "args": [
            "es1"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "98-101",
          "snippet": "static inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_pblock",
          "args": [
            "es1"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "143-146",
          "snippet": "static inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\nstatic inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "lblk",
            "es1->es_lblk",
            "es1->es_len"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&EXT4_I(inode)->i_es_lock"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_es_find_delayed_extent_range_enter",
          "args": [
            "inode",
            "lblk"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end < lblk"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "es == NULL"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nvoid ext4_es_find_delayed_extent_range(struct inode *inode,\n\t\t\t\t ext4_lblk_t lblk, ext4_lblk_t end,\n\t\t\t\t struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = NULL;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\n\tBUG_ON(es == NULL);\n\tBUG_ON(end < lblk);\n\ttrace_ext4_es_find_delayed_extent_range_enter(inode, lblk);\n\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u) %llu %x\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len,\n\t\t\t\t ext4_es_pblock(es1), ext4_es_status(es1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tes1 = __es_tree_search(&tree->root, lblk);\n\nout:\n\tif (es1 && !ext4_es_is_delayed(es1)) {\n\t\twhile ((node = rb_next(&es1->rb_node)) != NULL) {\n\t\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\t\tif (es1->es_lblk > end) {\n\t\t\t\tes1 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ext4_es_is_delayed(es1))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (es1 && ext4_es_is_delayed(es1)) {\n\t\ttree->cache_es = es1;\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_find_delayed_extent_range_exit(inode, es);\n}"
  },
  {
    "function_name": "__es_tree_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "209-235",
    "snippet": "static struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_status",
            "rb_node"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&es->rb_node"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_end",
          "args": [
            "es"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "199-203",
          "snippet": "static inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_status",
            "rb_node"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext4_es_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "199-203",
    "snippet": "static inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "es->es_lblk + es->es_len < es->es_lblk"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}"
  },
  {
    "function_name": "ext4_es_print_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "177-194",
    "snippet": "static void ext4_es_print_tree(struct inode *inode)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct rb_node *node;\n\n\tprintk(KERN_DEBUG \"status extents for inode %lu:\", inode->i_ino);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tnode = rb_first(&tree->root);\n\twhile (node) {\n\t\tstruct extent_status *es;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tprintk(KERN_DEBUG \" [%u/%u) %llu %x\",\n\t\t       es->es_lblk, es->es_len,\n\t\t       ext4_es_pblock(es), ext4_es_status(es));\n\t\tnode = rb_next(node);\n\t}\n\tprintk(KERN_DEBUG \"\\n\");\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"\\n\""
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_status",
          "args": [
            "es"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "98-101",
          "snippet": "static inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n\nstatic inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_pblock",
          "args": [
            "es"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "143-146",
          "snippet": "static inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\nstatic inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_status",
            "rb_node"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&tree->root"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_print_tree(struct inode *inode)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct rb_node *node;\n\n\tprintk(KERN_DEBUG \"status extents for inode %lu:\", inode->i_ino);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tnode = rb_first(&tree->root);\n\twhile (node) {\n\t\tstruct extent_status *es;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tprintk(KERN_DEBUG \" [%u/%u) %llu %x\",\n\t\t       es->es_lblk, es->es_len,\n\t\t       ext4_es_pblock(es), ext4_es_status(es));\n\t\tnode = rb_next(node);\n\t}\n\tprintk(KERN_DEBUG \"\\n\");\n}"
  },
  {
    "function_name": "ext4_es_init_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "170-174",
    "snippet": "void ext4_es_init_tree(struct ext4_es_tree *tree)\n{\n\ttree->root = RB_ROOT;\n\ttree->cache_es = NULL;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_init_tree(struct ext4_es_tree *tree)\n{\n\ttree->root = RB_ROOT;\n\ttree->cache_es = NULL;\n}"
  },
  {
    "function_name": "ext4_exit_es",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "164-168",
    "snippet": "void ext4_exit_es(void)\n{\n\tif (ext4_es_cachep)\n\t\tkmem_cache_destroy(ext4_es_cachep);\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_es_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext4_es_cachep"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nvoid ext4_exit_es(void)\n{\n\tif (ext4_es_cachep)\n\t\tkmem_cache_destroy(ext4_es_cachep);\n}"
  },
  {
    "function_name": "ext4_init_es",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
    "lines": "154-162",
    "snippet": "int __init ext4_init_es(void)\n{\n\text4_es_cachep = kmem_cache_create(\"ext4_extent_status\",\n\t\t\t\t\t   sizeof(struct extent_status),\n\t\t\t\t\t   0, (SLAB_RECLAIM_ACCOUNT), NULL);\n\tif (ext4_es_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
      "#include <trace/events/ext4.h>",
      "#include \"extents_status.h\"",
      "#include \"ext4.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/rbtree.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_es_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ext4_extent_status\"",
            "sizeof(struct extent_status)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT)",
            "NULL"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nint __init ext4_init_es(void)\n{\n\text4_es_cachep = kmem_cache_create(\"ext4_extent_status\",\n\t\t\t\t\t   sizeof(struct extent_status),\n\t\t\t\t\t   0, (SLAB_RECLAIM_ACCOUNT), NULL);\n\tif (ext4_es_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  }
]