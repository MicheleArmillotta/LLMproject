[
  {
    "function_name": "afs_deliver_cb_tell_me_about_yourself",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "588-604",
    "snippet": "static int afs_deliver_cb_tell_me_about_yourself(struct afs_call *call,\n\t\t\t\t\t\t struct sk_buff *skb, bool last)\n{\n\t_enter(\",{%u},%d\", skb->len, last);\n\n\tif (skb->len > 0)\n\t\treturn -EBADMSG;\n\tif (!last)\n\t\treturn 0;\n\n\t/* no unmarshalling required */\n\tcall->state = AFS_CALL_REPLYING;\n\n\tINIT_WORK(&call->work, SRXAFSCB_TellMeAboutYourself);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);",
      "static int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);",
      "static int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);",
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "afs_wq",
            "&call->work"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&call->work",
            "SRXAFSCB_TellMeAboutYourself"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",{%u},%d\"",
            "skb->len",
            "last"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);\nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);\nstatic int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *call,\n\t\t\t\t\t\t struct sk_buff *skb, bool last)\n{\n\t_enter(\",{%u},%d\", skb->len, last);\n\n\tif (skb->len > 0)\n\t\treturn -EBADMSG;\n\tif (!last)\n\t\treturn 0;\n\n\t/* no unmarshalling required */\n\tcall->state = AFS_CALL_REPLYING;\n\n\tINIT_WORK(&call->work, SRXAFSCB_TellMeAboutYourself);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}"
  },
  {
    "function_name": "SRXAFSCB_TellMeAboutYourself",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "525-583",
    "snippet": "static void SRXAFSCB_TellMeAboutYourself(struct work_struct *work)\n{\n\tstruct afs_interface *ifs;\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\tint loop, nifs;\n\n\tstruct {\n\t\tstruct /* InterfaceAddr */ {\n\t\t\t__be32 nifs;\n\t\t\t__be32 uuid[11];\n\t\t\t__be32 ifaddr[32];\n\t\t\t__be32 netmask[32];\n\t\t\t__be32 mtu[32];\n\t\t} ia;\n\t\tstruct /* Capabilities */ {\n\t\t\t__be32 capcount;\n\t\t\t__be32 caps[1];\n\t\t} cap;\n\t} reply;\n\n\t_enter(\"\");\n\n\tnifs = 0;\n\tifs = kcalloc(32, sizeof(*ifs), GFP_KERNEL);\n\tif (ifs) {\n\t\tnifs = afs_get_ipv4_interfaces(ifs, 32, false);\n\t\tif (nifs < 0) {\n\t\t\tkfree(ifs);\n\t\t\tifs = NULL;\n\t\t\tnifs = 0;\n\t\t}\n\t}\n\n\tmemset(&reply, 0, sizeof(reply));\n\treply.ia.nifs = htonl(nifs);\n\n\treply.ia.uuid[0] = htonl(afs_uuid.time_low);\n\treply.ia.uuid[1] = htonl(afs_uuid.time_mid);\n\treply.ia.uuid[2] = htonl(afs_uuid.time_hi_and_version);\n\treply.ia.uuid[3] = htonl((s8) afs_uuid.clock_seq_hi_and_reserved);\n\treply.ia.uuid[4] = htonl((s8) afs_uuid.clock_seq_low);\n\tfor (loop = 0; loop < 6; loop++)\n\t\treply.ia.uuid[loop + 5] = htonl((s8) afs_uuid.node[loop]);\n\n\tif (ifs) {\n\t\tfor (loop = 0; loop < nifs; loop++) {\n\t\t\treply.ia.ifaddr[loop] = ifs[loop].address.s_addr;\n\t\t\treply.ia.netmask[loop] = ifs[loop].netmask.s_addr;\n\t\t\treply.ia.mtu[loop] = htonl(ifs[loop].mtu);\n\t\t}\n\t\tkfree(ifs);\n\t}\n\n\treply.cap.capcount = htonl(1);\n\treply.cap.caps[0] = htonl(AFS_CAP_ERROR_TRANSLATION);\n\tafs_send_simple_reply(call, &reply, sizeof(reply));\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_send_simple_reply",
          "args": [
            "call",
            "&reply",
            "sizeof(reply)"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "afs_send_simple_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "805-836",
          "snippet": "void afs_send_simple_reply(struct afs_call *call, const void *buf, size_t len)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint n;\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= (void *) buf;\n\tiov[0].iov_len\t\t= len;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1, len);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tn = rxrpc_kernel_send_data(call->rxcall, &msg, len);\n\tif (n >= 0) {\n\t\t/* Success */\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\t}\n\n\tif (n == -ENOMEM) {\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\t}\n\tafs_end_call(call);\n\t_leave(\" [error]\");\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nvoid afs_send_simple_reply(struct afs_call *call, const void *buf, size_t len)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint n;\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= (void *) buf;\n\tiov[0].iov_len\t\t= len;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1, len);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tn = rxrpc_kernel_send_data(call->rxcall, &msg, len);\n\tif (n >= 0) {\n\t\t/* Success */\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\t}\n\n\tif (n == -ENOMEM) {\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\t}\n\tafs_end_call(call);\n\t_leave(\" [error]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "AFS_CAP_ERROR_TRANSLATION"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "1"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ifs"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "ifs[loop].mtu"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(s8) afs_uuid.node[loop]"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(s8) afs_uuid.clock_seq_low"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(s8) afs_uuid.clock_seq_hi_and_reserved"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "afs_uuid.time_hi_and_version"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "afs_uuid.time_mid"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "afs_uuid.time_low"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "nifs"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&reply",
            "0",
            "sizeof(reply)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ifs"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_get_ipv4_interfaces",
          "args": [
            "ifs",
            "32",
            "false"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "afs_get_ipv4_interfaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/netdevices.c",
          "lines": "40-68",
          "snippet": "int afs_get_ipv4_interfaces(struct afs_interface *bufs, size_t maxbufs,\n\t\t\t    bool wantloopback)\n{\n\tstruct net_device *dev;\n\tstruct in_device *idev;\n\tint n = 0;\n\n\tASSERT(maxbufs > 0);\n\n\trtnl_lock();\n\tfor_each_netdev(&init_net, dev) {\n\t\tif (dev->type == ARPHRD_LOOPBACK && !wantloopback)\n\t\t\tcontinue;\n\t\tidev = __in_dev_get_rtnl(dev);\n\t\tif (!idev)\n\t\t\tcontinue;\n\t\tfor_primary_ifa(idev) {\n\t\t\tbufs[n].address.s_addr = ifa->ifa_address;\n\t\t\tbufs[n].netmask.s_addr = ifa->ifa_mask;\n\t\t\tbufs[n].mtu = dev->mtu;\n\t\t\tn++;\n\t\t\tif (n >= maxbufs)\n\t\t\t\tgoto out;\n\t\t} endfor_ifa(idev);\n\t}\nout:\n\trtnl_unlock();\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/if_arp.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/string.h>\n\nint afs_get_ipv4_interfaces(struct afs_interface *bufs, size_t maxbufs,\n\t\t\t    bool wantloopback)\n{\n\tstruct net_device *dev;\n\tstruct in_device *idev;\n\tint n = 0;\n\n\tASSERT(maxbufs > 0);\n\n\trtnl_lock();\n\tfor_each_netdev(&init_net, dev) {\n\t\tif (dev->type == ARPHRD_LOOPBACK && !wantloopback)\n\t\t\tcontinue;\n\t\tidev = __in_dev_get_rtnl(dev);\n\t\tif (!idev)\n\t\t\tcontinue;\n\t\tfor_primary_ifa(idev) {\n\t\t\tbufs[n].address.s_addr = ifa->ifa_address;\n\t\t\tbufs[n].netmask.s_addr = ifa->ifa_mask;\n\t\t\tbufs[n].mtu = dev->mtu;\n\t\t\tn++;\n\t\t\tif (n >= maxbufs)\n\t\t\t\tgoto out;\n\t\t} endfor_ifa(idev);\n\t}\nout:\n\trtnl_unlock();\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "32",
            "sizeof(*ifs)",
            "GFP_KERNEL"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structafs_call",
            "work"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic void SRXAFSCB_TellMeAboutYourself(struct work_struct *work)\n{\n\tstruct afs_interface *ifs;\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\tint loop, nifs;\n\n\tstruct {\n\t\tstruct /* InterfaceAddr */ {\n\t\t\t__be32 nifs;\n\t\t\t__be32 uuid[11];\n\t\t\t__be32 ifaddr[32];\n\t\t\t__be32 netmask[32];\n\t\t\t__be32 mtu[32];\n\t\t} ia;\n\t\tstruct /* Capabilities */ {\n\t\t\t__be32 capcount;\n\t\t\t__be32 caps[1];\n\t\t} cap;\n\t} reply;\n\n\t_enter(\"\");\n\n\tnifs = 0;\n\tifs = kcalloc(32, sizeof(*ifs), GFP_KERNEL);\n\tif (ifs) {\n\t\tnifs = afs_get_ipv4_interfaces(ifs, 32, false);\n\t\tif (nifs < 0) {\n\t\t\tkfree(ifs);\n\t\t\tifs = NULL;\n\t\t\tnifs = 0;\n\t\t}\n\t}\n\n\tmemset(&reply, 0, sizeof(reply));\n\treply.ia.nifs = htonl(nifs);\n\n\treply.ia.uuid[0] = htonl(afs_uuid.time_low);\n\treply.ia.uuid[1] = htonl(afs_uuid.time_mid);\n\treply.ia.uuid[2] = htonl(afs_uuid.time_hi_and_version);\n\treply.ia.uuid[3] = htonl((s8) afs_uuid.clock_seq_hi_and_reserved);\n\treply.ia.uuid[4] = htonl((s8) afs_uuid.clock_seq_low);\n\tfor (loop = 0; loop < 6; loop++)\n\t\treply.ia.uuid[loop + 5] = htonl((s8) afs_uuid.node[loop]);\n\n\tif (ifs) {\n\t\tfor (loop = 0; loop < nifs; loop++) {\n\t\t\treply.ia.ifaddr[loop] = ifs[loop].address.s_addr;\n\t\t\treply.ia.netmask[loop] = ifs[loop].netmask.s_addr;\n\t\t\treply.ia.mtu[loop] = htonl(ifs[loop].mtu);\n\t\t}\n\t\tkfree(ifs);\n\t}\n\n\treply.cap.capcount = htonl(1);\n\treply.cap.caps[0] = htonl(AFS_CAP_ERROR_TRANSLATION);\n\tafs_send_simple_reply(call, &reply, sizeof(reply));\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_deliver_cb_probe_uuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "453-520",
    "snippet": "static int afs_deliver_cb_probe_uuid(struct afs_call *call, struct sk_buff *skb,\n\t\t\t\t     bool last)\n{\n\tstruct afs_uuid *r;\n\tunsigned loop;\n\t__be32 *b;\n\tint ret;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tif (skb->len > 0)\n\t\treturn -EBADMSG;\n\tif (!last)\n\t\treturn 0;\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->offset = 0;\n\t\tcall->buffer = kmalloc(11 * sizeof(__be32), GFP_KERNEL);\n\t\tif (!call->buffer)\n\t\t\treturn -ENOMEM;\n\t\tcall->unmarshall++;\n\n\tcase 1:\n\t\t_debug(\"extract UUID\");\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       11 * sizeof(__be32));\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\t_debug(\"unmarshall UUID\");\n\t\tcall->request = kmalloc(sizeof(struct afs_uuid), GFP_KERNEL);\n\t\tif (!call->request)\n\t\t\treturn -ENOMEM;\n\n\t\tb = call->buffer;\n\t\tr = call->request;\n\t\tr->time_low\t\t\t= ntohl(b[0]);\n\t\tr->time_mid\t\t\t= ntohl(b[1]);\n\t\tr->time_hi_and_version\t\t= ntohl(b[2]);\n\t\tr->clock_seq_hi_and_reserved \t= ntohl(b[3]);\n\t\tr->clock_seq_low\t\t= ntohl(b[4]);\n\n\t\tfor (loop = 0; loop < 6; loop++)\n\t\t\tr->node[loop] = ntohl(b[loop + 5]);\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\tcase 2:\n\t\t_debug(\"trailer\");\n\t\tif (skb->len != 0)\n\t\t\treturn -EBADMSG;\n\t\tbreak;\n\t}\n\n\tif (!last)\n\t\treturn 0;\n\n\tcall->state = AFS_CALL_REPLYING;\n\n\tINIT_WORK(&call->work, SRXAFSCB_ProbeUuid);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);",
      "static int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);",
      "static int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);",
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "afs_wq",
            "&call->work"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&call->work",
            "SRXAFSCB_ProbeUuid"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"trailer\""
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "b[loop + 5]"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "b[4]"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "b[3]"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "b[2]"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "b[1]"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "b[0]"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct afs_uuid)",
            "GFP_KERNEL"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_extract_data",
          "args": [
            "call",
            "skb",
            "last",
            "call->buffer",
            "11 * sizeof(__be32)"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "afs_extract_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "841-865",
          "snippet": "int afs_extract_data(struct afs_call *call, struct sk_buff *skb,\n\t\t     bool last, void *buf, size_t count)\n{\n\tsize_t len = skb->len;\n\n\t_enter(\"{%u},{%zu},%d,,%zu\", call->offset, len, last, count);\n\n\tASSERTCMP(call->offset, <, count);\n\n\tlen = min_t(size_t, len, count - call->offset);\n\tif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\n\t    !pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < count) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [%d < %zu]\", call->offset, count);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = -EAGAIN\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_extract_data(struct afs_call *call, struct sk_buff *skb,\n\t\t     bool last, void *buf, size_t count)\n{\n\tsize_t len = skb->len;\n\n\t_enter(\"{%u},{%zu},%d,,%zu\", call->offset, len, last, count);\n\n\tASSERTCMP(call->offset, <, count);\n\n\tlen = min_t(size_t, len, count - call->offset);\n\tif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\n\t    !pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < count) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [%d < %zu]\", call->offset, count);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = -EAGAIN\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%u},%d\"",
            "call->unmarshall",
            "skb->len",
            "last"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);\nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);\nstatic int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic int afs_deliver_cb_probe_uuid(struct afs_call *call, struct sk_buff *skb,\n\t\t\t\t     bool last)\n{\n\tstruct afs_uuid *r;\n\tunsigned loop;\n\t__be32 *b;\n\tint ret;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tif (skb->len > 0)\n\t\treturn -EBADMSG;\n\tif (!last)\n\t\treturn 0;\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->offset = 0;\n\t\tcall->buffer = kmalloc(11 * sizeof(__be32), GFP_KERNEL);\n\t\tif (!call->buffer)\n\t\t\treturn -ENOMEM;\n\t\tcall->unmarshall++;\n\n\tcase 1:\n\t\t_debug(\"extract UUID\");\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       11 * sizeof(__be32));\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\t_debug(\"unmarshall UUID\");\n\t\tcall->request = kmalloc(sizeof(struct afs_uuid), GFP_KERNEL);\n\t\tif (!call->request)\n\t\t\treturn -ENOMEM;\n\n\t\tb = call->buffer;\n\t\tr = call->request;\n\t\tr->time_low\t\t\t= ntohl(b[0]);\n\t\tr->time_mid\t\t\t= ntohl(b[1]);\n\t\tr->time_hi_and_version\t\t= ntohl(b[2]);\n\t\tr->clock_seq_hi_and_reserved \t= ntohl(b[3]);\n\t\tr->clock_seq_low\t\t= ntohl(b[4]);\n\n\t\tfor (loop = 0; loop < 6; loop++)\n\t\t\tr->node[loop] = ntohl(b[loop + 5]);\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\tcase 2:\n\t\t_debug(\"trailer\");\n\t\tif (skb->len != 0)\n\t\t\treturn -EBADMSG;\n\t\tbreak;\n\t}\n\n\tif (!last)\n\t\treturn 0;\n\n\tcall->state = AFS_CALL_REPLYING;\n\n\tINIT_WORK(&call->work, SRXAFSCB_ProbeUuid);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}"
  },
  {
    "function_name": "SRXAFSCB_ProbeUuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "429-448",
    "snippet": "static void SRXAFSCB_ProbeUuid(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\tstruct afs_uuid *r = call->request;\n\n\tstruct {\n\t\t__be32\tmatch;\n\t} reply;\n\n\t_enter(\"\");\n\n\n\tif (memcmp(r, &afs_uuid, sizeof(afs_uuid)) == 0)\n\t\treply.match = htonl(0);\n\telse\n\t\treply.match = htonl(1);\n\n\tafs_send_simple_reply(call, &reply, sizeof(reply));\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_send_simple_reply",
          "args": [
            "call",
            "&reply",
            "sizeof(reply)"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "afs_send_simple_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "805-836",
          "snippet": "void afs_send_simple_reply(struct afs_call *call, const void *buf, size_t len)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint n;\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= (void *) buf;\n\tiov[0].iov_len\t\t= len;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1, len);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tn = rxrpc_kernel_send_data(call->rxcall, &msg, len);\n\tif (n >= 0) {\n\t\t/* Success */\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\t}\n\n\tif (n == -ENOMEM) {\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\t}\n\tafs_end_call(call);\n\t_leave(\" [error]\");\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nvoid afs_send_simple_reply(struct afs_call *call, const void *buf, size_t len)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint n;\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= (void *) buf;\n\tiov[0].iov_len\t\t= len;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1, len);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tn = rxrpc_kernel_send_data(call->rxcall, &msg, len);\n\tif (n >= 0) {\n\t\t/* Success */\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\t}\n\n\tif (n == -ENOMEM) {\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\t}\n\tafs_end_call(call);\n\t_leave(\" [error]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "1"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "r",
            "&afs_uuid",
            "sizeof(afs_uuid)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structafs_call",
            "work"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic void SRXAFSCB_ProbeUuid(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\tstruct afs_uuid *r = call->request;\n\n\tstruct {\n\t\t__be32\tmatch;\n\t} reply;\n\n\t_enter(\"\");\n\n\n\tif (memcmp(r, &afs_uuid, sizeof(afs_uuid)) == 0)\n\t\treply.match = htonl(0);\n\telse\n\t\treply.match = htonl(1);\n\n\tafs_send_simple_reply(call, &reply, sizeof(reply));\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_deliver_cb_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "408-424",
    "snippet": "static int afs_deliver_cb_probe(struct afs_call *call, struct sk_buff *skb,\n\t\t\t\tbool last)\n{\n\t_enter(\",{%u},%d\", skb->len, last);\n\n\tif (skb->len > 0)\n\t\treturn -EBADMSG;\n\tif (!last)\n\t\treturn 0;\n\n\t/* no unmarshalling required */\n\tcall->state = AFS_CALL_REPLYING;\n\n\tINIT_WORK(&call->work, SRXAFSCB_Probe);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);",
      "static int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);",
      "static int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);",
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "afs_wq",
            "&call->work"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&call->work",
            "SRXAFSCB_Probe"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",{%u},%d\"",
            "skb->len",
            "last"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);\nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);\nstatic int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic int afs_deliver_cb_probe(struct afs_call *call, struct sk_buff *skb,\n\t\t\t\tbool last)\n{\n\t_enter(\",{%u},%d\", skb->len, last);\n\n\tif (skb->len > 0)\n\t\treturn -EBADMSG;\n\tif (!last)\n\t\treturn 0;\n\n\t/* no unmarshalling required */\n\tcall->state = AFS_CALL_REPLYING;\n\n\tINIT_WORK(&call->work, SRXAFSCB_Probe);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}"
  },
  {
    "function_name": "SRXAFSCB_Probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "396-403",
    "snippet": "static void SRXAFSCB_Probe(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\n\t_enter(\"\");\n\tafs_send_empty_reply(call);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_send_empty_reply",
          "args": [
            "call"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "afs_send_empty_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "770-800",
          "snippet": "void afs_send_empty_reply(struct afs_call *call)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= NULL;\n\tiov[0].iov_len\t\t= 0;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 0, 0);\t/* WTF? */\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tswitch (rxrpc_kernel_send_data(call->rxcall, &msg, 0)) {\n\tcase 0:\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\n\tcase -ENOMEM:\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\tdefault:\n\t\tafs_end_call(call);\n\t\t_leave(\" [error]\");\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nvoid afs_send_empty_reply(struct afs_call *call)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= NULL;\n\tiov[0].iov_len\t\t= 0;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 0, 0);\t/* WTF? */\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tswitch (rxrpc_kernel_send_data(call->rxcall, &msg, 0)) {\n\tcase 0:\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\n\tcase -ENOMEM:\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\tdefault:\n\t\tafs_end_call(call);\n\t\t_leave(\" [error]\");\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structafs_call",
            "work"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic void SRXAFSCB_Probe(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\n\t_enter(\"\");\n\tafs_send_empty_reply(call);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_deliver_cb_init_call_back_state3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "365-391",
    "snippet": "static int afs_deliver_cb_init_call_back_state3(struct afs_call *call,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tbool last)\n{\n\tstruct afs_server *server;\n\tstruct in_addr addr;\n\n\t_enter(\",{%u},%d\", skb->len, last);\n\n\tif (!last)\n\t\treturn 0;\n\n\t/* no unmarshalling required */\n\tcall->state = AFS_CALL_REPLYING;\n\n\t/* we'll need the file server record as that tells us which set of\n\t * vnodes to operate upon */\n\tmemcpy(&addr, &ip_hdr(skb)->saddr, 4);\n\tserver = afs_find_server(&addr);\n\tif (!server)\n\t\treturn -ENOTCONN;\n\tcall->server = server;\n\n\tINIT_WORK(&call->work, SRXAFSCB_InitCallBackState);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);",
      "static int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);",
      "static int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);",
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "afs_wq",
            "&call->work"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&call->work",
            "SRXAFSCB_InitCallBackState"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_find_server",
          "args": [
            "&addr"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "afs_find_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "181-213",
          "snippet": "struct afs_server *afs_find_server(const struct in_addr *_addr)\n{\n\tstruct afs_server *server = NULL;\n\tstruct rb_node *p;\n\tstruct in_addr addr = *_addr;\n\n\t_enter(\"%pI4\", &addr.s_addr);\n\n\tread_lock(&afs_servers_lock);\n\n\tp = afs_servers.rb_node;\n\twhile (p) {\n\t\tserver = rb_entry(p, struct afs_server, master_rb);\n\n\t\t_debug(\"- consider %p\", p);\n\n\t\tif (addr.s_addr < server->addr.s_addr) {\n\t\t\tp = p->rb_left;\n\t\t} else if (addr.s_addr > server->addr.s_addr) {\n\t\t\tp = p->rb_right;\n\t\t} else {\n\t\t\tafs_get_server(server);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tserver = NULL;\nfound:\n\tread_unlock(&afs_servers_lock);\n\tASSERTIFCMP(server, server->addr.s_addr, ==, addr.s_addr);\n\t_leave(\" = %p\", server);\n\treturn server;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root afs_servers = RB_ROOT;",
            "static DEFINE_RWLOCK(afs_servers_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct rb_root afs_servers = RB_ROOT;\nstatic DEFINE_RWLOCK(afs_servers_lock);\n\nstruct afs_server *afs_find_server(const struct in_addr *_addr)\n{\n\tstruct afs_server *server = NULL;\n\tstruct rb_node *p;\n\tstruct in_addr addr = *_addr;\n\n\t_enter(\"%pI4\", &addr.s_addr);\n\n\tread_lock(&afs_servers_lock);\n\n\tp = afs_servers.rb_node;\n\twhile (p) {\n\t\tserver = rb_entry(p, struct afs_server, master_rb);\n\n\t\t_debug(\"- consider %p\", p);\n\n\t\tif (addr.s_addr < server->addr.s_addr) {\n\t\t\tp = p->rb_left;\n\t\t} else if (addr.s_addr > server->addr.s_addr) {\n\t\t\tp = p->rb_right;\n\t\t} else {\n\t\t\tafs_get_server(server);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tserver = NULL;\nfound:\n\tread_unlock(&afs_servers_lock);\n\tASSERTIFCMP(server, server->addr.s_addr, ==, addr.s_addr);\n\t_leave(\" = %p\", server);\n\treturn server;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr",
            "&ip_hdr(skb)->saddr",
            "4"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_hdr",
          "args": [
            "skb"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",{%u},%d\"",
            "skb->len",
            "last"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);\nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);\nstatic int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *call,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tbool last)\n{\n\tstruct afs_server *server;\n\tstruct in_addr addr;\n\n\t_enter(\",{%u},%d\", skb->len, last);\n\n\tif (!last)\n\t\treturn 0;\n\n\t/* no unmarshalling required */\n\tcall->state = AFS_CALL_REPLYING;\n\n\t/* we'll need the file server record as that tells us which set of\n\t * vnodes to operate upon */\n\tmemcpy(&addr, &ip_hdr(skb)->saddr, 4);\n\tserver = afs_find_server(&addr);\n\tif (!server)\n\t\treturn -ENOTCONN;\n\tcall->server = server;\n\n\tINIT_WORK(&call->work, SRXAFSCB_InitCallBackState);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_deliver_cb_init_call_back_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "332-360",
    "snippet": "static int afs_deliver_cb_init_call_back_state(struct afs_call *call,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       bool last)\n{\n\tstruct afs_server *server;\n\tstruct in_addr addr;\n\n\t_enter(\",{%u},%d\", skb->len, last);\n\n\tif (skb->len > 0)\n\t\treturn -EBADMSG;\n\tif (!last)\n\t\treturn 0;\n\n\t/* no unmarshalling required */\n\tcall->state = AFS_CALL_REPLYING;\n\n\t/* we'll need the file server record as that tells us which set of\n\t * vnodes to operate upon */\n\tmemcpy(&addr, &ip_hdr(skb)->saddr, 4);\n\tserver = afs_find_server(&addr);\n\tif (!server)\n\t\treturn -ENOTCONN;\n\tcall->server = server;\n\n\tINIT_WORK(&call->work, SRXAFSCB_InitCallBackState);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);",
      "static int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);",
      "static int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);",
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "afs_wq",
            "&call->work"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&call->work",
            "SRXAFSCB_InitCallBackState"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_find_server",
          "args": [
            "&addr"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "afs_find_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "181-213",
          "snippet": "struct afs_server *afs_find_server(const struct in_addr *_addr)\n{\n\tstruct afs_server *server = NULL;\n\tstruct rb_node *p;\n\tstruct in_addr addr = *_addr;\n\n\t_enter(\"%pI4\", &addr.s_addr);\n\n\tread_lock(&afs_servers_lock);\n\n\tp = afs_servers.rb_node;\n\twhile (p) {\n\t\tserver = rb_entry(p, struct afs_server, master_rb);\n\n\t\t_debug(\"- consider %p\", p);\n\n\t\tif (addr.s_addr < server->addr.s_addr) {\n\t\t\tp = p->rb_left;\n\t\t} else if (addr.s_addr > server->addr.s_addr) {\n\t\t\tp = p->rb_right;\n\t\t} else {\n\t\t\tafs_get_server(server);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tserver = NULL;\nfound:\n\tread_unlock(&afs_servers_lock);\n\tASSERTIFCMP(server, server->addr.s_addr, ==, addr.s_addr);\n\t_leave(\" = %p\", server);\n\treturn server;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root afs_servers = RB_ROOT;",
            "static DEFINE_RWLOCK(afs_servers_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct rb_root afs_servers = RB_ROOT;\nstatic DEFINE_RWLOCK(afs_servers_lock);\n\nstruct afs_server *afs_find_server(const struct in_addr *_addr)\n{\n\tstruct afs_server *server = NULL;\n\tstruct rb_node *p;\n\tstruct in_addr addr = *_addr;\n\n\t_enter(\"%pI4\", &addr.s_addr);\n\n\tread_lock(&afs_servers_lock);\n\n\tp = afs_servers.rb_node;\n\twhile (p) {\n\t\tserver = rb_entry(p, struct afs_server, master_rb);\n\n\t\t_debug(\"- consider %p\", p);\n\n\t\tif (addr.s_addr < server->addr.s_addr) {\n\t\t\tp = p->rb_left;\n\t\t} else if (addr.s_addr > server->addr.s_addr) {\n\t\t\tp = p->rb_right;\n\t\t} else {\n\t\t\tafs_get_server(server);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tserver = NULL;\nfound:\n\tread_unlock(&afs_servers_lock);\n\tASSERTIFCMP(server, server->addr.s_addr, ==, addr.s_addr);\n\t_leave(\" = %p\", server);\n\treturn server;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr",
            "&ip_hdr(skb)->saddr",
            "4"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_hdr",
          "args": [
            "skb"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",{%u},%d\"",
            "skb->len",
            "last"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);\nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);\nstatic int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *call,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       bool last)\n{\n\tstruct afs_server *server;\n\tstruct in_addr addr;\n\n\t_enter(\",{%u},%d\", skb->len, last);\n\n\tif (skb->len > 0)\n\t\treturn -EBADMSG;\n\tif (!last)\n\t\treturn 0;\n\n\t/* no unmarshalling required */\n\tcall->state = AFS_CALL_REPLYING;\n\n\t/* we'll need the file server record as that tells us which set of\n\t * vnodes to operate upon */\n\tmemcpy(&addr, &ip_hdr(skb)->saddr, 4);\n\tserver = afs_find_server(&addr);\n\tif (!server)\n\t\treturn -ENOTCONN;\n\tcall->server = server;\n\n\tINIT_WORK(&call->work, SRXAFSCB_InitCallBackState);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}"
  },
  {
    "function_name": "SRXAFSCB_InitCallBackState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "318-327",
    "snippet": "static void SRXAFSCB_InitCallBackState(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\n\t_enter(\"{%p}\", call->server);\n\n\tafs_init_callback_state(call->server);\n\tafs_send_empty_reply(call);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_send_empty_reply",
          "args": [
            "call"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "afs_send_empty_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "770-800",
          "snippet": "void afs_send_empty_reply(struct afs_call *call)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= NULL;\n\tiov[0].iov_len\t\t= 0;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 0, 0);\t/* WTF? */\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tswitch (rxrpc_kernel_send_data(call->rxcall, &msg, 0)) {\n\tcase 0:\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\n\tcase -ENOMEM:\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\tdefault:\n\t\tafs_end_call(call);\n\t\t_leave(\" [error]\");\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nvoid afs_send_empty_reply(struct afs_call *call)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= NULL;\n\tiov[0].iov_len\t\t= 0;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 0, 0);\t/* WTF? */\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tswitch (rxrpc_kernel_send_data(call->rxcall, &msg, 0)) {\n\tcase 0:\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\n\tcase -ENOMEM:\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\tdefault:\n\t\tafs_end_call(call);\n\t\t_leave(\" [error]\");\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_init_callback_state",
          "args": [
            "call->server"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "afs_init_callback_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/callback.c",
          "lines": "38-58",
          "snippet": "void afs_init_callback_state(struct afs_server *server)\n{\n\tstruct afs_vnode *vnode;\n\n\t_enter(\"{%p}\", server);\n\n\tspin_lock(&server->cb_lock);\n\n\t/* kill all the promises on record from this server */\n\twhile (!RB_EMPTY_ROOT(&server->cb_promises)) {\n\t\tvnode = rb_entry(server->cb_promises.rb_node,\n\t\t\t\t struct afs_vnode, cb_promise);\n\t\t_debug(\"UNPROMISE { vid=%x:%u uq=%u}\",\n\t\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\t\trb_erase(&vnode->cb_promise, &server->cb_promises);\n\t\tvnode->cb_promised = false;\n\t}\n\n\tspin_unlock(&server->cb_lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/circ_buf.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_init_callback_state(struct afs_server *server)\n{\n\tstruct afs_vnode *vnode;\n\n\t_enter(\"{%p}\", server);\n\n\tspin_lock(&server->cb_lock);\n\n\t/* kill all the promises on record from this server */\n\twhile (!RB_EMPTY_ROOT(&server->cb_promises)) {\n\t\tvnode = rb_entry(server->cb_promises.rb_node,\n\t\t\t\t struct afs_vnode, cb_promise);\n\t\t_debug(\"UNPROMISE { vid=%x:%u uq=%u}\",\n\t\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\t\trb_erase(&vnode->cb_promise, &server->cb_promises);\n\t\tvnode->cb_promised = false;\n\t}\n\n\tspin_unlock(&server->cb_lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%p}\"",
            "call->server"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structafs_call",
            "work"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic void SRXAFSCB_InitCallBackState(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\n\t_enter(\"{%p}\", call->server);\n\n\tafs_init_callback_state(call->server);\n\tafs_send_empty_reply(call);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_deliver_cb_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "171-313",
    "snippet": "static int afs_deliver_cb_callback(struct afs_call *call, struct sk_buff *skb,\n\t\t\t\t   bool last)\n{\n\tstruct afs_callback *cb;\n\tstruct afs_server *server;\n\tstruct in_addr addr;\n\t__be32 *bp;\n\tu32 tmp;\n\tint ret, loop;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the FID array and its count in two steps */\n\tcase 1:\n\t\t_debug(\"extract FID count\");\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"FID count: %u\", call->count);\n\t\tif (call->count > AFSCBMAX)\n\t\t\treturn -EBADMSG;\n\n\t\tcall->buffer = kmalloc(call->count * 3 * 4, GFP_KERNEL);\n\t\tif (!call->buffer)\n\t\t\treturn -ENOMEM;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\tcase 2:\n\t\t_debug(\"extract FID array\");\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       call->count * 3 * 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\t_debug(\"unmarshall FID array\");\n\t\tcall->request = kcalloc(call->count,\n\t\t\t\t\tsizeof(struct afs_callback),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!call->request)\n\t\t\treturn -ENOMEM;\n\n\t\tcb = call->request;\n\t\tbp = call->buffer;\n\t\tfor (loop = call->count; loop > 0; loop--, cb++) {\n\t\t\tcb->fid.vid\t= ntohl(*bp++);\n\t\t\tcb->fid.vnode\t= ntohl(*bp++);\n\t\t\tcb->fid.unique\t= ntohl(*bp++);\n\t\t\tcb->type\t= AFSCM_CB_UNTYPED;\n\t\t}\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the callback array and its count in two steps */\n\tcase 3:\n\t\t_debug(\"extract CB count\");\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\ttmp = ntohl(call->tmp);\n\t\t_debug(\"CB count: %u\", tmp);\n\t\tif (tmp != call->count && tmp != 0)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\t\tif (tmp == 0)\n\t\t\tgoto empty_cb_array;\n\n\tcase 4:\n\t\t_debug(\"extract CB array\");\n\t\tret = afs_extract_data(call, skb, last, call->request,\n\t\t\t\t       call->count * 3 * 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\t_debug(\"unmarshall CB array\");\n\t\tcb = call->request;\n\t\tbp = call->buffer;\n\t\tfor (loop = call->count; loop > 0; loop--, cb++) {\n\t\t\tcb->version\t= ntohl(*bp++);\n\t\t\tcb->expiry\t= ntohl(*bp++);\n\t\t\tcb->type\t= ntohl(*bp++);\n\t\t}\n\n\tempty_cb_array:\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\tcase 5:\n\t\t_debug(\"trailer\");\n\t\tif (skb->len != 0)\n\t\t\treturn -EBADMSG;\n\n\t\t/* Record that the message was unmarshalled successfully so\n\t\t * that the call destructor can know do the callback breaking\n\t\t * work, even if the final ACK isn't received.\n\t\t *\n\t\t * If the step number changes, then afs_cm_destructor() must be\n\t\t * updated also.\n\t\t */\n\t\tcall->unmarshall++;\n\tcase 6:\n\t\tbreak;\n\t}\n\n\tif (!last)\n\t\treturn 0;\n\n\tcall->state = AFS_CALL_REPLYING;\n\n\t/* we'll need the file server record as that tells us which set of\n\t * vnodes to operate upon */\n\tmemcpy(&addr, &ip_hdr(skb)->saddr, 4);\n\tserver = afs_find_server(&addr);\n\tif (!server)\n\t\treturn -ENOTCONN;\n\tcall->server = server;\n\n\tINIT_WORK(&call->work, SRXAFSCB_CallBack);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);",
      "static int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);",
      "static int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);",
      "static int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);",
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "afs_wq",
            "&call->work"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&call->work",
            "SRXAFSCB_CallBack"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_find_server",
          "args": [
            "&addr"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "afs_find_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "181-213",
          "snippet": "struct afs_server *afs_find_server(const struct in_addr *_addr)\n{\n\tstruct afs_server *server = NULL;\n\tstruct rb_node *p;\n\tstruct in_addr addr = *_addr;\n\n\t_enter(\"%pI4\", &addr.s_addr);\n\n\tread_lock(&afs_servers_lock);\n\n\tp = afs_servers.rb_node;\n\twhile (p) {\n\t\tserver = rb_entry(p, struct afs_server, master_rb);\n\n\t\t_debug(\"- consider %p\", p);\n\n\t\tif (addr.s_addr < server->addr.s_addr) {\n\t\t\tp = p->rb_left;\n\t\t} else if (addr.s_addr > server->addr.s_addr) {\n\t\t\tp = p->rb_right;\n\t\t} else {\n\t\t\tafs_get_server(server);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tserver = NULL;\nfound:\n\tread_unlock(&afs_servers_lock);\n\tASSERTIFCMP(server, server->addr.s_addr, ==, addr.s_addr);\n\t_leave(\" = %p\", server);\n\treturn server;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root afs_servers = RB_ROOT;",
            "static DEFINE_RWLOCK(afs_servers_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct rb_root afs_servers = RB_ROOT;\nstatic DEFINE_RWLOCK(afs_servers_lock);\n\nstruct afs_server *afs_find_server(const struct in_addr *_addr)\n{\n\tstruct afs_server *server = NULL;\n\tstruct rb_node *p;\n\tstruct in_addr addr = *_addr;\n\n\t_enter(\"%pI4\", &addr.s_addr);\n\n\tread_lock(&afs_servers_lock);\n\n\tp = afs_servers.rb_node;\n\twhile (p) {\n\t\tserver = rb_entry(p, struct afs_server, master_rb);\n\n\t\t_debug(\"- consider %p\", p);\n\n\t\tif (addr.s_addr < server->addr.s_addr) {\n\t\t\tp = p->rb_left;\n\t\t} else if (addr.s_addr > server->addr.s_addr) {\n\t\t\tp = p->rb_right;\n\t\t} else {\n\t\t\tafs_get_server(server);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tserver = NULL;\nfound:\n\tread_unlock(&afs_servers_lock);\n\tASSERTIFCMP(server, server->addr.s_addr, ==, addr.s_addr);\n\t_leave(\" = %p\", server);\n\treturn server;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr",
            "&ip_hdr(skb)->saddr",
            "4"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_hdr",
          "args": [
            "skb"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"trailer\""
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_extract_data",
          "args": [
            "call",
            "skb",
            "last",
            "call->request",
            "call->count * 3 * 4"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "afs_extract_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "841-865",
          "snippet": "int afs_extract_data(struct afs_call *call, struct sk_buff *skb,\n\t\t     bool last, void *buf, size_t count)\n{\n\tsize_t len = skb->len;\n\n\t_enter(\"{%u},{%zu},%d,,%zu\", call->offset, len, last, count);\n\n\tASSERTCMP(call->offset, <, count);\n\n\tlen = min_t(size_t, len, count - call->offset);\n\tif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\n\t    !pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < count) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [%d < %zu]\", call->offset, count);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = -EAGAIN\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_extract_data(struct afs_call *call, struct sk_buff *skb,\n\t\t     bool last, void *buf, size_t count)\n{\n\tsize_t len = skb->len;\n\n\t_enter(\"{%u},{%zu},%d,,%zu\", call->offset, len, last, count);\n\n\tASSERTCMP(call->offset, <, count);\n\n\tlen = min_t(size_t, len, count - call->offset);\n\tif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\n\t    !pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < count) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [%d < %zu]\", call->offset, count);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = -EAGAIN\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"CB count: %u\"",
            "tmp"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "call->tmp"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "call->count",
            "sizeof(struct afs_callback)",
            "GFP_KERNEL"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "call->count * 3 * 4",
            "GFP_KERNEL"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "call->tmp"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%u},%d\"",
            "call->unmarshall",
            "skb->len",
            "last"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *,\n\t\t\t\t\t       struct sk_buff *, bool);\nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *,\n\t\t\t\t\t\tstruct sk_buff *, bool);\nstatic int afs_deliver_cb_probe(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_callback(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_probe_uuid(struct afs_call *, struct sk_buff *, bool);\nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *,\n\t\t\t\t\t\t struct sk_buff *, bool);\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic int afs_deliver_cb_callback(struct afs_call *call, struct sk_buff *skb,\n\t\t\t\t   bool last)\n{\n\tstruct afs_callback *cb;\n\tstruct afs_server *server;\n\tstruct in_addr addr;\n\t__be32 *bp;\n\tu32 tmp;\n\tint ret, loop;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the FID array and its count in two steps */\n\tcase 1:\n\t\t_debug(\"extract FID count\");\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"FID count: %u\", call->count);\n\t\tif (call->count > AFSCBMAX)\n\t\t\treturn -EBADMSG;\n\n\t\tcall->buffer = kmalloc(call->count * 3 * 4, GFP_KERNEL);\n\t\tif (!call->buffer)\n\t\t\treturn -ENOMEM;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\tcase 2:\n\t\t_debug(\"extract FID array\");\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       call->count * 3 * 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\t_debug(\"unmarshall FID array\");\n\t\tcall->request = kcalloc(call->count,\n\t\t\t\t\tsizeof(struct afs_callback),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!call->request)\n\t\t\treturn -ENOMEM;\n\n\t\tcb = call->request;\n\t\tbp = call->buffer;\n\t\tfor (loop = call->count; loop > 0; loop--, cb++) {\n\t\t\tcb->fid.vid\t= ntohl(*bp++);\n\t\t\tcb->fid.vnode\t= ntohl(*bp++);\n\t\t\tcb->fid.unique\t= ntohl(*bp++);\n\t\t\tcb->type\t= AFSCM_CB_UNTYPED;\n\t\t}\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the callback array and its count in two steps */\n\tcase 3:\n\t\t_debug(\"extract CB count\");\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\ttmp = ntohl(call->tmp);\n\t\t_debug(\"CB count: %u\", tmp);\n\t\tif (tmp != call->count && tmp != 0)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\t\tif (tmp == 0)\n\t\t\tgoto empty_cb_array;\n\n\tcase 4:\n\t\t_debug(\"extract CB array\");\n\t\tret = afs_extract_data(call, skb, last, call->request,\n\t\t\t\t       call->count * 3 * 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\t_debug(\"unmarshall CB array\");\n\t\tcb = call->request;\n\t\tbp = call->buffer;\n\t\tfor (loop = call->count; loop > 0; loop--, cb++) {\n\t\t\tcb->version\t= ntohl(*bp++);\n\t\t\tcb->expiry\t= ntohl(*bp++);\n\t\t\tcb->type\t= ntohl(*bp++);\n\t\t}\n\n\tempty_cb_array:\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\tcase 5:\n\t\t_debug(\"trailer\");\n\t\tif (skb->len != 0)\n\t\t\treturn -EBADMSG;\n\n\t\t/* Record that the message was unmarshalled successfully so\n\t\t * that the call destructor can know do the callback breaking\n\t\t * work, even if the final ACK isn't received.\n\t\t *\n\t\t * If the step number changes, then afs_cm_destructor() must be\n\t\t * updated also.\n\t\t */\n\t\tcall->unmarshall++;\n\tcase 6:\n\t\tbreak;\n\t}\n\n\tif (!last)\n\t\treturn 0;\n\n\tcall->state = AFS_CALL_REPLYING;\n\n\t/* we'll need the file server record as that tells us which set of\n\t * vnodes to operate upon */\n\tmemcpy(&addr, &ip_hdr(skb)->saddr, 4);\n\tserver = afs_find_server(&addr);\n\tif (!server)\n\t\treturn -ENOTCONN;\n\tcall->server = server;\n\n\tINIT_WORK(&call->work, SRXAFSCB_CallBack);\n\tqueue_work(afs_wq, &call->work);\n\treturn 0;\n}"
  },
  {
    "function_name": "SRXAFSCB_CallBack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "151-166",
    "snippet": "static void SRXAFSCB_CallBack(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\n\t_enter(\"\");\n\n\t/* be sure to send the reply *before* attempting to spam the AFS server\n\t * with FSFetchStatus requests on the vnodes with broken callbacks lest\n\t * the AFS server get into a vicious cycle of trying to break further\n\t * callbacks because it hadn't received completion of the CBCallBack op\n\t * yet */\n\tafs_send_empty_reply(call);\n\n\tafs_break_callbacks(call->server, call->count, call->request);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_break_callbacks",
          "args": [
            "call->server",
            "call->count",
            "call->request"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "afs_break_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/callback.c",
          "lines": "194-216",
          "snippet": "void afs_break_callbacks(struct afs_server *server, size_t count,\n\t\t\t struct afs_callback callbacks[])\n{\n\t_enter(\"%p,%zu,\", server, count);\n\n\tASSERT(server != NULL);\n\tASSERTCMP(count, <=, AFSCBMAX);\n\n\tfor (; count > 0; callbacks++, count--) {\n\t\t_debug(\"- Fid { vl=%08x n=%u u=%u }  CB { v=%u x=%u t=%u }\",\n\t\t       callbacks->fid.vid,\n\t\t       callbacks->fid.vnode,\n\t\t       callbacks->fid.unique,\n\t\t       callbacks->version,\n\t\t       callbacks->expiry,\n\t\t       callbacks->type\n\t\t       );\n\t\tafs_break_one_callback(server, &callbacks->fid);\n\t}\n\n\t_leave(\"\");\n\treturn;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/circ_buf.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_break_callbacks(struct afs_server *server, size_t count,\n\t\t\t struct afs_callback callbacks[])\n{\n\t_enter(\"%p,%zu,\", server, count);\n\n\tASSERT(server != NULL);\n\tASSERTCMP(count, <=, AFSCBMAX);\n\n\tfor (; count > 0; callbacks++, count--) {\n\t\t_debug(\"- Fid { vl=%08x n=%u u=%u }  CB { v=%u x=%u t=%u }\",\n\t\t       callbacks->fid.vid,\n\t\t       callbacks->fid.vnode,\n\t\t       callbacks->fid.unique,\n\t\t       callbacks->version,\n\t\t       callbacks->expiry,\n\t\t       callbacks->type\n\t\t       );\n\t\tafs_break_one_callback(server, &callbacks->fid);\n\t}\n\n\t_leave(\"\");\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_send_empty_reply",
          "args": [
            "call"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "afs_send_empty_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "770-800",
          "snippet": "void afs_send_empty_reply(struct afs_call *call)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= NULL;\n\tiov[0].iov_len\t\t= 0;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 0, 0);\t/* WTF? */\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tswitch (rxrpc_kernel_send_data(call->rxcall, &msg, 0)) {\n\tcase 0:\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\n\tcase -ENOMEM:\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\tdefault:\n\t\tafs_end_call(call);\n\t\t_leave(\" [error]\");\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nvoid afs_send_empty_reply(struct afs_call *call)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= NULL;\n\tiov[0].iov_len\t\t= 0;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 0, 0);\t/* WTF? */\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tswitch (rxrpc_kernel_send_data(call->rxcall, &msg, 0)) {\n\tcase 0:\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\n\tcase -ENOMEM:\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\tdefault:\n\t\tafs_end_call(call);\n\t\t_leave(\" [error]\");\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structafs_call",
            "work"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic void SRXAFSCB_CallBack(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, work);\n\n\t_enter(\"\");\n\n\t/* be sure to send the reply *before* attempting to spam the AFS server\n\t * with FSFetchStatus requests on the vnodes with broken callbacks lest\n\t * the AFS server get into a vicious cycle of trying to break further\n\t * callbacks because it hadn't received completion of the CBCallBack op\n\t * yet */\n\tafs_send_empty_reply(call);\n\n\tafs_break_callbacks(call->server, call->count, call->request);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_cm_destructor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "129-146",
    "snippet": "static void afs_cm_destructor(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\t/* Break the callbacks here so that we do it after the final ACK is\n\t * received.  The step number here must match the final number in\n\t * afs_deliver_cb_callback().\n\t */\n\tif (call->unmarshall == 6) {\n\t\tASSERT(call->server && call->count && call->request);\n\t\tafs_break_callbacks(call->server, call->count, call->request);\n\t}\n\n\tafs_put_server(call->server);\n\tcall->server = NULL;\n\tkfree(call->buffer);\n\tcall->buffer = NULL;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_cm_destructor(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->buffer"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "call->server"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_break_callbacks",
          "args": [
            "call->server",
            "call->count",
            "call->request"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "afs_break_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/callback.c",
          "lines": "194-216",
          "snippet": "void afs_break_callbacks(struct afs_server *server, size_t count,\n\t\t\t struct afs_callback callbacks[])\n{\n\t_enter(\"%p,%zu,\", server, count);\n\n\tASSERT(server != NULL);\n\tASSERTCMP(count, <=, AFSCBMAX);\n\n\tfor (; count > 0; callbacks++, count--) {\n\t\t_debug(\"- Fid { vl=%08x n=%u u=%u }  CB { v=%u x=%u t=%u }\",\n\t\t       callbacks->fid.vid,\n\t\t       callbacks->fid.vnode,\n\t\t       callbacks->fid.unique,\n\t\t       callbacks->version,\n\t\t       callbacks->expiry,\n\t\t       callbacks->type\n\t\t       );\n\t\tafs_break_one_callback(server, &callbacks->fid);\n\t}\n\n\t_leave(\"\");\n\treturn;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/circ_buf.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_break_callbacks(struct afs_server *server, size_t count,\n\t\t\t struct afs_callback callbacks[])\n{\n\t_enter(\"%p,%zu,\", server, count);\n\n\tASSERT(server != NULL);\n\tASSERTCMP(count, <=, AFSCBMAX);\n\n\tfor (; count > 0; callbacks++, count--) {\n\t\t_debug(\"- Fid { vl=%08x n=%u u=%u }  CB { v=%u x=%u t=%u }\",\n\t\t       callbacks->fid.vid,\n\t\t       callbacks->fid.vnode,\n\t\t       callbacks->fid.unique,\n\t\t       callbacks->version,\n\t\t       callbacks->expiry,\n\t\t       callbacks->type\n\t\t       );\n\t\tafs_break_one_callback(server, &callbacks->fid);\n\t}\n\n\t_leave(\"\");\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "call->server && call->count && call->request"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void afs_cm_destructor(struct afs_call *);\n\nstatic void afs_cm_destructor(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\t/* Break the callbacks here so that we do it after the final ACK is\n\t * received.  The step number here must match the final number in\n\t * afs_deliver_cb_callback().\n\t */\n\tif (call->unmarshall == 6) {\n\t\tASSERT(call->server && call->count && call->request);\n\t\tafs_break_callbacks(call->server, call->count, call->request);\n\t}\n\n\tafs_put_server(call->server);\n\tcall->server = NULL;\n\tkfree(call->buffer);\n\tcall->buffer = NULL;\n}"
  },
  {
    "function_name": "afs_cm_incoming_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
    "lines": "99-124",
    "snippet": "bool afs_cm_incoming_call(struct afs_call *call)\n{\n\tu32 operation_id = ntohl(call->operation_ID);\n\n\t_enter(\"{CB.OP %u}\", operation_id);\n\n\tswitch (operation_id) {\n\tcase CBCallBack:\n\t\tcall->type = &afs_SRXCBCallBack;\n\t\treturn true;\n\tcase CBInitCallBackState:\n\t\tcall->type = &afs_SRXCBInitCallBackState;\n\t\treturn true;\n\tcase CBInitCallBackState3:\n\t\tcall->type = &afs_SRXCBInitCallBackState3;\n\t\treturn true;\n\tcase CBProbe:\n\t\tcall->type = &afs_SRXCBProbe;\n\t\treturn true;\n\tcase CBTellMeAboutYourself:\n\t\tcall->type = &afs_SRXCBTellMeAboutYourself;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <linux/ip.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_cm_destructor(struct afs_call *);",
      "static const struct afs_call_type afs_SRXCBCallBack = {\n\t.name\t\t= \"CB.CallBack\",\n\t.deliver\t= afs_deliver_cb_callback,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};",
      "static const struct afs_call_type afs_SRXCBInitCallBackState = {\n\t.name\t\t= \"CB.InitCallBackState\",\n\t.deliver\t= afs_deliver_cb_init_call_back_state,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};",
      "static const struct afs_call_type afs_SRXCBInitCallBackState3 = {\n\t.name\t\t= \"CB.InitCallBackState3\",\n\t.deliver\t= afs_deliver_cb_init_call_back_state3,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};",
      "static const struct afs_call_type afs_SRXCBProbe = {\n\t.name\t\t= \"CB.Probe\",\n\t.deliver\t= afs_deliver_cb_probe,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};",
      "static const struct afs_call_type afs_SRXCBTellMeAboutYourself = {\n\t.name\t\t= \"CB.TellMeAboutYourself\",\n\t.deliver\t= afs_deliver_cb_tell_me_about_yourself,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{CB.OP %u}\"",
            "operation_id"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "call->operation_ID"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void afs_cm_destructor(struct afs_call *);\nstatic const struct afs_call_type afs_SRXCBCallBack = {\n\t.name\t\t= \"CB.CallBack\",\n\t.deliver\t= afs_deliver_cb_callback,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};\nstatic const struct afs_call_type afs_SRXCBInitCallBackState = {\n\t.name\t\t= \"CB.InitCallBackState\",\n\t.deliver\t= afs_deliver_cb_init_call_back_state,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};\nstatic const struct afs_call_type afs_SRXCBInitCallBackState3 = {\n\t.name\t\t= \"CB.InitCallBackState3\",\n\t.deliver\t= afs_deliver_cb_init_call_back_state3,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};\nstatic const struct afs_call_type afs_SRXCBProbe = {\n\t.name\t\t= \"CB.Probe\",\n\t.deliver\t= afs_deliver_cb_probe,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};\nstatic const struct afs_call_type afs_SRXCBTellMeAboutYourself = {\n\t.name\t\t= \"CB.TellMeAboutYourself\",\n\t.deliver\t= afs_deliver_cb_tell_me_about_yourself,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};\n\nbool afs_cm_incoming_call(struct afs_call *call)\n{\n\tu32 operation_id = ntohl(call->operation_ID);\n\n\t_enter(\"{CB.OP %u}\", operation_id);\n\n\tswitch (operation_id) {\n\tcase CBCallBack:\n\t\tcall->type = &afs_SRXCBCallBack;\n\t\treturn true;\n\tcase CBInitCallBackState:\n\t\tcall->type = &afs_SRXCBInitCallBackState;\n\t\treturn true;\n\tcase CBInitCallBackState3:\n\t\tcall->type = &afs_SRXCBInitCallBackState3;\n\t\treturn true;\n\tcase CBProbe:\n\t\tcall->type = &afs_SRXCBProbe;\n\t\treturn true;\n\tcase CBTellMeAboutYourself:\n\t\tcall->type = &afs_SRXCBTellMeAboutYourself;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  }
]