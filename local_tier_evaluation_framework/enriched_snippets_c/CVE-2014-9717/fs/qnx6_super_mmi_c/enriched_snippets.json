[
  {
    "function_name": "qnx6_mmi_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/super_mmi.c",
    "lines": "35-148",
    "snippet": "struct qnx6_super_block *qnx6_mmi_fill_super(struct super_block *s, int silent)\n{\n\tstruct buffer_head *bh1, *bh2 = NULL;\n\tstruct qnx6_mmi_super_block *sb1, *sb2;\n\tstruct qnx6_super_block *qsb = NULL;\n\tstruct qnx6_sb_info *sbi;\n\t__u64 offset;\n\n\t/* Check the superblock signatures\n\t   start with the first superblock */\n\tbh1 = sb_bread(s, 0);\n\tif (!bh1) {\n\t\tpr_err(\"Unable to read first mmi superblock\\n\");\n\t\treturn NULL;\n\t}\n\tsb1 = (struct qnx6_mmi_super_block *)bh1->b_data;\n\tsbi = QNX6_SB(s);\n\tif (fs32_to_cpu(sbi, sb1->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent) {\n\t\t\tpr_err(\"wrong signature (magic) in superblock #1.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb1->sb_checksum) !=\n\t\t\t\tcrc32_be(0, (char *)(bh1->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* calculate second superblock blocknumber */\n\toffset = fs32_to_cpu(sbi, sb1->sb_num_blocks) + QNX6_SUPERBLOCK_AREA /\n\t\t\t\t\tfs32_to_cpu(sbi, sb1->sb_blocksize);\n\n\t/* set new blocksize */\n\tif (!sb_set_blocksize(s, fs32_to_cpu(sbi, sb1->sb_blocksize))) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\t/* blocksize invalidates bh - pull it back in */\n\tbrelse(bh1);\n\tbh1 = sb_bread(s, 0);\n\tif (!bh1)\n\t\tgoto out;\n\tsb1 = (struct qnx6_mmi_super_block *)bh1->b_data;\n\n\t/* read second superblock */\n\tbh2 = sb_bread(s, offset);\n\tif (!bh2) {\n\t\tpr_err(\"unable to read the second superblock\\n\");\n\t\tgoto out;\n\t}\n\tsb2 = (struct qnx6_mmi_super_block *)bh2->b_data;\n\tif (fs32_to_cpu(sbi, sb2->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"wrong signature (magic) in superblock #2.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb2->sb_checksum)\n\t\t\t!= crc32_be(0, (char *)(bh2->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\tqsb = kmalloc(sizeof(*qsb), GFP_KERNEL);\n\tif (!qsb) {\n\t\tpr_err(\"unable to allocate memory.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (fs64_to_cpu(sbi, sb1->sb_serial) >\n\t\t\t\t\tfs64_to_cpu(sbi, sb2->sb_serial)) {\n\t\t/* superblock #1 active */\n\t\tqnx6_mmi_copy_sb(qsb, sb1);\n#ifdef CONFIG_QNX6FS_DEBUG\n\t\tqnx6_superblock_debug(qsb, s);\n#endif\n\t\tmemcpy(bh1->b_data, qsb, sizeof(struct qnx6_super_block));\n\n\t\tsbi->sb_buf = bh1;\n\t\tsbi->sb = (struct qnx6_super_block *)bh1->b_data;\n\t\tbrelse(bh2);\n\t\tpr_info(\"superblock #1 active\\n\");\n\t} else {\n\t\t/* superblock #2 active */\n\t\tqnx6_mmi_copy_sb(qsb, sb2);\n#ifdef CONFIG_QNX6FS_DEBUG\n\t\tqnx6_superblock_debug(qsb, s);\n#endif\n\t\tmemcpy(bh2->b_data, qsb, sizeof(struct qnx6_super_block));\n\n\t\tsbi->sb_buf = bh2;\n\t\tsbi->sb = (struct qnx6_super_block *)bh2->b_data;\n\t\tbrelse(bh1);\n\t\tpr_info(\"superblock #2 active\\n\");\n\t}\n\tkfree(qsb);\n\n\t/* offset for mmi_fs is just SUPERBLOCK_AREA bytes */\n\tsbi->s_blks_off = QNX6_SUPERBLOCK_AREA / s->s_blocksize;\n\n\t/* success */\n\treturn sbi->sb;\n\nout:\n\tif (bh1 != NULL)\n\t\tbrelse(bh1);\n\tif (bh2 != NULL)\n\t\tbrelse(bh2);\n\treturn NULL;\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh2"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qsb"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"superblock #2 active\\n\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh2->b_data",
            "qsb",
            "sizeof(struct qnx6_super_block)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx6_superblock_debug",
          "args": [
            "qsb",
            "s"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_superblock_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/inode.c",
          "lines": "204-218",
          "snippet": "void qnx6_superblock_debug(struct qnx6_super_block *sb, struct super_block *s)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\n\tpr_debug(\"magic: %08x\\n\", fs32_to_cpu(sbi, sb->sb_magic));\n\tpr_debug(\"checksum: %08x\\n\", fs32_to_cpu(sbi, sb->sb_checksum));\n\tpr_debug(\"serial: %llx\\n\", fs64_to_cpu(sbi, sb->sb_serial));\n\tpr_debug(\"flags: %08x\\n\", fs32_to_cpu(sbi, sb->sb_flags));\n\tpr_debug(\"blocksize: %08x\\n\", fs32_to_cpu(sbi, sb->sb_blocksize));\n\tpr_debug(\"num_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_inodes));\n\tpr_debug(\"free_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_inodes));\n\tpr_debug(\"num_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_blocks));\n\tpr_debug(\"free_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_blocks));\n\tpr_debug(\"inode_levels: %02x\\n\", sb->Inode.levels);\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/crc32.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx6_put_super(struct super_block *sb);",
            "static struct inode *qnx6_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/mpage.h>\n#include <linux/crc32.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx6_put_super(struct super_block *sb);\nstatic struct inode *qnx6_alloc_inode(struct super_block *sb);\n\nvoid qnx6_superblock_debug(struct qnx6_super_block *sb, struct super_block *s)\n{\n\tstruct qnx6_sb_info *sbi = QNX6_SB(s);\n\n\tpr_debug(\"magic: %08x\\n\", fs32_to_cpu(sbi, sb->sb_magic));\n\tpr_debug(\"checksum: %08x\\n\", fs32_to_cpu(sbi, sb->sb_checksum));\n\tpr_debug(\"serial: %llx\\n\", fs64_to_cpu(sbi, sb->sb_serial));\n\tpr_debug(\"flags: %08x\\n\", fs32_to_cpu(sbi, sb->sb_flags));\n\tpr_debug(\"blocksize: %08x\\n\", fs32_to_cpu(sbi, sb->sb_blocksize));\n\tpr_debug(\"num_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_inodes));\n\tpr_debug(\"free_inodes: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_inodes));\n\tpr_debug(\"num_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_num_blocks));\n\tpr_debug(\"free_blocks: %08x\\n\", fs32_to_cpu(sbi, sb->sb_free_blocks));\n\tpr_debug(\"inode_levels: %02x\\n\", sb->Inode.levels);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx6_mmi_copy_sb",
          "args": [
            "qsb",
            "sb2"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "qnx6_mmi_copy_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/super_mmi.c",
          "lines": "17-33",
          "snippet": "static void qnx6_mmi_copy_sb(struct qnx6_super_block *qsb,\n\t\tstruct qnx6_mmi_super_block *sb)\n{\n\tqsb->sb_magic = sb->sb_magic;\n\tqsb->sb_checksum = sb->sb_checksum;\n\tqsb->sb_serial = sb->sb_serial;\n\tqsb->sb_blocksize = sb->sb_blocksize;\n\tqsb->sb_num_inodes = sb->sb_num_inodes;\n\tqsb->sb_free_inodes = sb->sb_free_inodes;\n\tqsb->sb_num_blocks = sb->sb_num_blocks;\n\tqsb->sb_free_blocks = sb->sb_free_blocks;\n\n\t/* the rest of the superblock is the same */\n\tmemcpy(&qsb->Inode, &sb->Inode, sizeof(sb->Inode));\n\tmemcpy(&qsb->Bitmap, &sb->Bitmap, sizeof(sb->Bitmap));\n\tmemcpy(&qsb->Longfile, &sb->Longfile, sizeof(sb->Longfile));\n}",
          "includes": [
            "#include \"qnx6.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void qnx6_mmi_copy_sb(struct qnx6_super_block *qsb,\n\t\tstruct qnx6_mmi_super_block *sb)\n{\n\tqsb->sb_magic = sb->sb_magic;\n\tqsb->sb_checksum = sb->sb_checksum;\n\tqsb->sb_serial = sb->sb_serial;\n\tqsb->sb_blocksize = sb->sb_blocksize;\n\tqsb->sb_num_inodes = sb->sb_num_inodes;\n\tqsb->sb_free_inodes = sb->sb_free_inodes;\n\tqsb->sb_num_blocks = sb->sb_num_blocks;\n\tqsb->sb_free_blocks = sb->sb_free_blocks;\n\n\t/* the rest of the superblock is the same */\n\tmemcpy(&qsb->Inode, &sb->Inode, sizeof(sb->Inode));\n\tmemcpy(&qsb->Bitmap, &sb->Bitmap, sizeof(sb->Bitmap));\n\tmemcpy(&qsb->Longfile, &sb->Longfile, sizeof(sb->Longfile));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"superblock #1 active\\n\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh1->b_data",
            "qsb",
            "sizeof(struct qnx6_super_block)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sbi",
            "sb2->sb_serial"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "77-83",
          "snippet": "static inline __u64 fs64_to_cpu(struct qnx6_sb_info *sbi, __fs64 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u64 fs64_to_cpu(struct qnx6_sb_info *sbi, __fs64 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to allocate memory.\\n\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*qsb)",
            "GFP_KERNEL"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"superblock #1 checksum error\\n\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_be",
          "args": [
            "0",
            "(char *)(bh2->b_data + 8)",
            "504"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sb2->sb_checksum"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "93-99",
          "snippet": "static inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline __u32 fs32_to_cpu(struct qnx6_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"wrong signature (magic) in superblock #2.\\n\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to read the second superblock\\n\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "offset"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "0"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to set blocksize\\n\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "fs32_to_cpu(sbi, sb1->sb_blocksize)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"superblock #1 checksum error\\n\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_be",
          "args": [
            "0",
            "(char *)(bh1->b_data + 8)",
            "504"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"wrong signature (magic) in superblock #1.\\n\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX6_SB",
          "args": [
            "s"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "QNX6_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/qnx6.h",
          "lines": "58-61",
          "snippet": "static inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx6_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx6_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx6_sb_info *QNX6_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to read first mmi superblock\\n\""
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "0"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstruct qnx6_super_block *qnx6_mmi_fill_super(struct super_block *s, int silent)\n{\n\tstruct buffer_head *bh1, *bh2 = NULL;\n\tstruct qnx6_mmi_super_block *sb1, *sb2;\n\tstruct qnx6_super_block *qsb = NULL;\n\tstruct qnx6_sb_info *sbi;\n\t__u64 offset;\n\n\t/* Check the superblock signatures\n\t   start with the first superblock */\n\tbh1 = sb_bread(s, 0);\n\tif (!bh1) {\n\t\tpr_err(\"Unable to read first mmi superblock\\n\");\n\t\treturn NULL;\n\t}\n\tsb1 = (struct qnx6_mmi_super_block *)bh1->b_data;\n\tsbi = QNX6_SB(s);\n\tif (fs32_to_cpu(sbi, sb1->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent) {\n\t\t\tpr_err(\"wrong signature (magic) in superblock #1.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb1->sb_checksum) !=\n\t\t\t\tcrc32_be(0, (char *)(bh1->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* calculate second superblock blocknumber */\n\toffset = fs32_to_cpu(sbi, sb1->sb_num_blocks) + QNX6_SUPERBLOCK_AREA /\n\t\t\t\t\tfs32_to_cpu(sbi, sb1->sb_blocksize);\n\n\t/* set new blocksize */\n\tif (!sb_set_blocksize(s, fs32_to_cpu(sbi, sb1->sb_blocksize))) {\n\t\tpr_err(\"unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\t/* blocksize invalidates bh - pull it back in */\n\tbrelse(bh1);\n\tbh1 = sb_bread(s, 0);\n\tif (!bh1)\n\t\tgoto out;\n\tsb1 = (struct qnx6_mmi_super_block *)bh1->b_data;\n\n\t/* read second superblock */\n\tbh2 = sb_bread(s, offset);\n\tif (!bh2) {\n\t\tpr_err(\"unable to read the second superblock\\n\");\n\t\tgoto out;\n\t}\n\tsb2 = (struct qnx6_mmi_super_block *)bh2->b_data;\n\tif (fs32_to_cpu(sbi, sb2->sb_magic) != QNX6_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"wrong signature (magic) in superblock #2.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* checksum check - start at byte 8 and end at byte 512 */\n\tif (fs32_to_cpu(sbi, sb2->sb_checksum)\n\t\t\t!= crc32_be(0, (char *)(bh2->b_data + 8), 504)) {\n\t\tpr_err(\"superblock #1 checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\tqsb = kmalloc(sizeof(*qsb), GFP_KERNEL);\n\tif (!qsb) {\n\t\tpr_err(\"unable to allocate memory.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (fs64_to_cpu(sbi, sb1->sb_serial) >\n\t\t\t\t\tfs64_to_cpu(sbi, sb2->sb_serial)) {\n\t\t/* superblock #1 active */\n\t\tqnx6_mmi_copy_sb(qsb, sb1);\n#ifdef CONFIG_QNX6FS_DEBUG\n\t\tqnx6_superblock_debug(qsb, s);\n#endif\n\t\tmemcpy(bh1->b_data, qsb, sizeof(struct qnx6_super_block));\n\n\t\tsbi->sb_buf = bh1;\n\t\tsbi->sb = (struct qnx6_super_block *)bh1->b_data;\n\t\tbrelse(bh2);\n\t\tpr_info(\"superblock #1 active\\n\");\n\t} else {\n\t\t/* superblock #2 active */\n\t\tqnx6_mmi_copy_sb(qsb, sb2);\n#ifdef CONFIG_QNX6FS_DEBUG\n\t\tqnx6_superblock_debug(qsb, s);\n#endif\n\t\tmemcpy(bh2->b_data, qsb, sizeof(struct qnx6_super_block));\n\n\t\tsbi->sb_buf = bh2;\n\t\tsbi->sb = (struct qnx6_super_block *)bh2->b_data;\n\t\tbrelse(bh1);\n\t\tpr_info(\"superblock #2 active\\n\");\n\t}\n\tkfree(qsb);\n\n\t/* offset for mmi_fs is just SUPERBLOCK_AREA bytes */\n\tsbi->s_blks_off = QNX6_SUPERBLOCK_AREA / s->s_blocksize;\n\n\t/* success */\n\treturn sbi->sb;\n\nout:\n\tif (bh1 != NULL)\n\t\tbrelse(bh1);\n\tif (bh2 != NULL)\n\t\tbrelse(bh2);\n\treturn NULL;\n}"
  },
  {
    "function_name": "qnx6_mmi_copy_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx6/super_mmi.c",
    "lines": "17-33",
    "snippet": "static void qnx6_mmi_copy_sb(struct qnx6_super_block *qsb,\n\t\tstruct qnx6_mmi_super_block *sb)\n{\n\tqsb->sb_magic = sb->sb_magic;\n\tqsb->sb_checksum = sb->sb_checksum;\n\tqsb->sb_serial = sb->sb_serial;\n\tqsb->sb_blocksize = sb->sb_blocksize;\n\tqsb->sb_num_inodes = sb->sb_num_inodes;\n\tqsb->sb_free_inodes = sb->sb_free_inodes;\n\tqsb->sb_num_blocks = sb->sb_num_blocks;\n\tqsb->sb_free_blocks = sb->sb_free_blocks;\n\n\t/* the rest of the superblock is the same */\n\tmemcpy(&qsb->Inode, &sb->Inode, sizeof(sb->Inode));\n\tmemcpy(&qsb->Bitmap, &sb->Bitmap, sizeof(sb->Bitmap));\n\tmemcpy(&qsb->Longfile, &sb->Longfile, sizeof(sb->Longfile));\n}",
    "includes": [
      "#include \"qnx6.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&qsb->Longfile",
            "&sb->Longfile",
            "sizeof(sb->Longfile)"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&qsb->Bitmap",
            "&sb->Bitmap",
            "sizeof(sb->Bitmap)"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&qsb->Inode",
            "&sb->Inode",
            "sizeof(sb->Inode)"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx6.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void qnx6_mmi_copy_sb(struct qnx6_super_block *qsb,\n\t\tstruct qnx6_mmi_super_block *sb)\n{\n\tqsb->sb_magic = sb->sb_magic;\n\tqsb->sb_checksum = sb->sb_checksum;\n\tqsb->sb_serial = sb->sb_serial;\n\tqsb->sb_blocksize = sb->sb_blocksize;\n\tqsb->sb_num_inodes = sb->sb_num_inodes;\n\tqsb->sb_free_inodes = sb->sb_free_inodes;\n\tqsb->sb_num_blocks = sb->sb_num_blocks;\n\tqsb->sb_free_blocks = sb->sb_free_blocks;\n\n\t/* the rest of the superblock is the same */\n\tmemcpy(&qsb->Inode, &sb->Inode, sizeof(sb->Inode));\n\tmemcpy(&qsb->Bitmap, &sb->Bitmap, sizeof(sb->Bitmap));\n\tmemcpy(&qsb->Longfile, &sb->Longfile, sizeof(sb->Longfile));\n}"
  }
]