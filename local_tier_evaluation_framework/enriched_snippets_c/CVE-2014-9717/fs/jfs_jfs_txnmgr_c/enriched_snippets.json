[
  {
    "function_name": "jfs_txstats_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "3081-3084",
    "snippet": "static int jfs_txstats_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, jfs_txstats_proc_show, NULL);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "jfs_txstats_proc_show",
            "NULL"
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int jfs_txstats_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, jfs_txstats_proc_show, NULL);\n}"
  },
  {
    "function_name": "jfs_txstats_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "3055-3079",
    "snippet": "static int jfs_txstats_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS TxStats\\n\"\n\t\t       \"===========\\n\"\n\t\t       \"calls to txBegin = %d\\n\"\n\t\t       \"txBegin blocked by sync barrier = %d\\n\"\n\t\t       \"txBegin blocked by tlocks low = %d\\n\"\n\t\t       \"txBegin blocked by no free tid = %d\\n\"\n\t\t       \"calls to txBeginAnon = %d\\n\"\n\t\t       \"txBeginAnon blocked by sync barrier = %d\\n\"\n\t\t       \"txBeginAnon blocked by tlocks low = %d\\n\"\n\t\t       \"calls to txLockAlloc = %d\\n\"\n\t\t       \"tLockAlloc blocked by no free lock = %d\\n\",\n\t\t       TxStat.txBegin,\n\t\t       TxStat.txBegin_barrier,\n\t\t       TxStat.txBegin_lockslow,\n\t\t       TxStat.txBegin_freetid,\n\t\t       TxStat.txBeginAnon,\n\t\t       TxStat.txBeginAnon_barrier,\n\t\t       TxStat.txBeginAnon_lockslow,\n\t\t       TxStat.txLockAlloc,\n\t\t       TxStat.txLockAlloc_freelock);\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"JFS TxStats\\n\"\n\t\t       \"===========\\n\"\n\t\t       \"calls to txBegin = %d\\n\"\n\t\t       \"txBegin blocked by sync barrier = %d\\n\"\n\t\t       \"txBegin blocked by tlocks low = %d\\n\"\n\t\t       \"txBegin blocked by no free tid = %d\\n\"\n\t\t       \"calls to txBeginAnon = %d\\n\"\n\t\t       \"txBeginAnon blocked by sync barrier = %d\\n\"\n\t\t       \"txBeginAnon blocked by tlocks low = %d\\n\"\n\t\t       \"calls to txLockAlloc = %d\\n\"\n\t\t       \"tLockAlloc blocked by no free lock = %d\\n\"",
            "TxStat.txBegin",
            "TxStat.txBegin_barrier",
            "TxStat.txBegin_lockslow",
            "TxStat.txBegin_freetid",
            "TxStat.txBeginAnon",
            "TxStat.txBeginAnon_barrier",
            "TxStat.txBeginAnon_lockslow",
            "TxStat.txLockAlloc",
            "TxStat.txLockAlloc_freelock"
          ],
          "line": 3057
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int jfs_txstats_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS TxStats\\n\"\n\t\t       \"===========\\n\"\n\t\t       \"calls to txBegin = %d\\n\"\n\t\t       \"txBegin blocked by sync barrier = %d\\n\"\n\t\t       \"txBegin blocked by tlocks low = %d\\n\"\n\t\t       \"txBegin blocked by no free tid = %d\\n\"\n\t\t       \"calls to txBeginAnon = %d\\n\"\n\t\t       \"txBeginAnon blocked by sync barrier = %d\\n\"\n\t\t       \"txBeginAnon blocked by tlocks low = %d\\n\"\n\t\t       \"calls to txLockAlloc = %d\\n\"\n\t\t       \"tLockAlloc blocked by no free lock = %d\\n\",\n\t\t       TxStat.txBegin,\n\t\t       TxStat.txBegin_barrier,\n\t\t       TxStat.txBegin_lockslow,\n\t\t       TxStat.txBegin_freetid,\n\t\t       TxStat.txBeginAnon,\n\t\t       TxStat.txBeginAnon_barrier,\n\t\t       TxStat.txBeginAnon_lockslow,\n\t\t       TxStat.txLockAlloc,\n\t\t       TxStat.txLockAlloc_freelock);\n\treturn 0;\n}"
  },
  {
    "function_name": "jfs_txanchor_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "3040-3043",
    "snippet": "static int jfs_txanchor_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, jfs_txanchor_proc_show, NULL);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "jfs_txanchor_proc_show",
            "NULL"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int jfs_txanchor_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, jfs_txanchor_proc_show, NULL);\n}"
  },
  {
    "function_name": "jfs_txanchor_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "3005-3038",
    "snippet": "static int jfs_txanchor_proc_show(struct seq_file *m, void *v)\n{\n\tchar *freewait;\n\tchar *freelockwait;\n\tchar *lowlockwait;\n\n\tfreewait =\n\t    waitqueue_active(&TxAnchor.freewait) ? \"active\" : \"empty\";\n\tfreelockwait =\n\t    waitqueue_active(&TxAnchor.freelockwait) ? \"active\" : \"empty\";\n\tlowlockwait =\n\t    waitqueue_active(&TxAnchor.lowlockwait) ? \"active\" : \"empty\";\n\n\tseq_printf(m,\n\t\t       \"JFS TxAnchor\\n\"\n\t\t       \"============\\n\"\n\t\t       \"freetid = %d\\n\"\n\t\t       \"freewait = %s\\n\"\n\t\t       \"freelock = %d\\n\"\n\t\t       \"freelockwait = %s\\n\"\n\t\t       \"lowlockwait = %s\\n\"\n\t\t       \"tlocksInUse = %d\\n\"\n\t\t       \"jfs_tlocks_low = %d\\n\"\n\t\t       \"unlock_queue is %sempty\\n\",\n\t\t       TxAnchor.freetid,\n\t\t       freewait,\n\t\t       TxAnchor.freelock,\n\t\t       freelockwait,\n\t\t       lowlockwait,\n\t\t       TxAnchor.tlocksInUse,\n\t\t       jfs_tlocks_low,\n\t\t       list_empty(&TxAnchor.unlock_queue) ? \"\" : \"not \");\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "int jfs_tlocks_low;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"JFS TxAnchor\\n\"\n\t\t       \"============\\n\"\n\t\t       \"freetid = %d\\n\"\n\t\t       \"freewait = %s\\n\"\n\t\t       \"freelock = %d\\n\"\n\t\t       \"freelockwait = %s\\n\"\n\t\t       \"lowlockwait = %s\\n\"\n\t\t       \"tlocksInUse = %d\\n\"\n\t\t       \"jfs_tlocks_low = %d\\n\"\n\t\t       \"unlock_queue is %sempty\\n\"",
            "TxAnchor.freetid",
            "freewait",
            "TxAnchor.freelock",
            "freelockwait",
            "lowlockwait",
            "TxAnchor.tlocksInUse",
            "jfs_tlocks_low",
            "list_empty(&TxAnchor.unlock_queue) ? \"\" : \"not \""
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&TxAnchor.unlock_queue"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&TxAnchor.lowlockwait"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&TxAnchor.freelockwait"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&TxAnchor.freewait"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nint jfs_tlocks_low;\n\nstatic int jfs_txanchor_proc_show(struct seq_file *m, void *v)\n{\n\tchar *freewait;\n\tchar *freelockwait;\n\tchar *lowlockwait;\n\n\tfreewait =\n\t    waitqueue_active(&TxAnchor.freewait) ? \"active\" : \"empty\";\n\tfreelockwait =\n\t    waitqueue_active(&TxAnchor.freelockwait) ? \"active\" : \"empty\";\n\tlowlockwait =\n\t    waitqueue_active(&TxAnchor.lowlockwait) ? \"active\" : \"empty\";\n\n\tseq_printf(m,\n\t\t       \"JFS TxAnchor\\n\"\n\t\t       \"============\\n\"\n\t\t       \"freetid = %d\\n\"\n\t\t       \"freewait = %s\\n\"\n\t\t       \"freelock = %d\\n\"\n\t\t       \"freelockwait = %s\\n\"\n\t\t       \"lowlockwait = %s\\n\"\n\t\t       \"tlocksInUse = %d\\n\"\n\t\t       \"jfs_tlocks_low = %d\\n\"\n\t\t       \"unlock_queue is %sempty\\n\",\n\t\t       TxAnchor.freetid,\n\t\t       freewait,\n\t\t       TxAnchor.freelock,\n\t\t       freelockwait,\n\t\t       lowlockwait,\n\t\t       TxAnchor.tlocksInUse,\n\t\t       jfs_tlocks_low,\n\t\t       list_empty(&TxAnchor.unlock_queue) ? \"\" : \"not \");\n\treturn 0;\n}"
  },
  {
    "function_name": "jfs_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2931-3002",
    "snippet": "int jfs_sync(void *arg)\n{\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\ttid_t tid;\n\n\tdo {\n\t\t/*\n\t\t * write each inode on the anonymous inode list\n\t\t */\n\t\tTXN_LOCK();\n\t\twhile (jfs_tlocks_low && !list_empty(&TxAnchor.anon_list)) {\n\t\t\tjfs_ip = list_entry(TxAnchor.anon_list.next,\n\t\t\t\t\t    struct jfs_inode_info,\n\t\t\t\t\t    anon_inode_list);\n\t\t\tip = &jfs_ip->vfs_inode;\n\n\t\t\tif (! igrab(ip)) {\n\t\t\t\t/*\n\t\t\t\t * Inode is being freed\n\t\t\t\t */\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t} else if (mutex_trylock(&jfs_ip->commit_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * inode will be removed from anonymous list\n\t\t\t\t * when it is committed\n\t\t\t\t */\n\t\t\t\tTXN_UNLOCK();\n\t\t\t\ttid = txBegin(ip->i_sb, COMMIT_INODE);\n\t\t\t\ttxCommit(tid, 1, &ip, 0);\n\t\t\t\ttxEnd(tid);\n\t\t\t\tmutex_unlock(&jfs_ip->commit_mutex);\n\n\t\t\t\tiput(ip);\n\t\t\t\t/*\n\t\t\t\t * Just to be safe.  I don't know how\n\t\t\t\t * long we can run without blocking\n\t\t\t\t */\n\t\t\t\tcond_resched();\n\t\t\t\tTXN_LOCK();\n\t\t\t} else {\n\t\t\t\t/* We can't get the commit mutex.  It may\n\t\t\t\t * be held by a thread waiting for tlock's\n\t\t\t\t * so let's not block here.  Save it to\n\t\t\t\t * put back on the anon_list.\n\t\t\t\t */\n\n\t\t\t\t/* Move from anon_list to anon_list2 */\n\t\t\t\tlist_move(&jfs_ip->anon_inode_list,\n\t\t\t\t\t  &TxAnchor.anon_list2);\n\n\t\t\t\tTXN_UNLOCK();\n\t\t\t\tiput(ip);\n\t\t\t\tTXN_LOCK();\n\t\t\t}\n\t\t}\n\t\t/* Add anon_list2 back to anon_list */\n\t\tlist_splice_init(&TxAnchor.anon_list2, &TxAnchor.anon_list);\n\n\t\tif (freezing(current)) {\n\t\t\tTXN_UNLOCK();\n\t\t\ttry_to_freeze();\n\t\t} else {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tTXN_UNLOCK();\n\t\t\tschedule();\n\t\t}\n\t} while (!kthread_should_stop());\n\n\tjfs_info(\"jfs_sync being killed\");\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "int jfs_tlocks_low;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_sync being killed\""
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&TxAnchor.anon_list2",
            "&TxAnchor.anon_list"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip"
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&jfs_ip->anon_inode_list",
            "&TxAnchor.anon_list2"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_ip->commit_mutex"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&ip",
            "0"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "ip->i_sb",
            "COMMIT_INODE"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&jfs_ip->commit_mutex"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&jfs_ip->anon_inode_list"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "ip"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "TxAnchor.anon_list.next",
            "structjfs_inode_info",
            "anon_inode_list"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&TxAnchor.anon_list"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nint jfs_tlocks_low;\n\nint jfs_sync(void *arg)\n{\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\ttid_t tid;\n\n\tdo {\n\t\t/*\n\t\t * write each inode on the anonymous inode list\n\t\t */\n\t\tTXN_LOCK();\n\t\twhile (jfs_tlocks_low && !list_empty(&TxAnchor.anon_list)) {\n\t\t\tjfs_ip = list_entry(TxAnchor.anon_list.next,\n\t\t\t\t\t    struct jfs_inode_info,\n\t\t\t\t\t    anon_inode_list);\n\t\t\tip = &jfs_ip->vfs_inode;\n\n\t\t\tif (! igrab(ip)) {\n\t\t\t\t/*\n\t\t\t\t * Inode is being freed\n\t\t\t\t */\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t} else if (mutex_trylock(&jfs_ip->commit_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * inode will be removed from anonymous list\n\t\t\t\t * when it is committed\n\t\t\t\t */\n\t\t\t\tTXN_UNLOCK();\n\t\t\t\ttid = txBegin(ip->i_sb, COMMIT_INODE);\n\t\t\t\ttxCommit(tid, 1, &ip, 0);\n\t\t\t\ttxEnd(tid);\n\t\t\t\tmutex_unlock(&jfs_ip->commit_mutex);\n\n\t\t\t\tiput(ip);\n\t\t\t\t/*\n\t\t\t\t * Just to be safe.  I don't know how\n\t\t\t\t * long we can run without blocking\n\t\t\t\t */\n\t\t\t\tcond_resched();\n\t\t\t\tTXN_LOCK();\n\t\t\t} else {\n\t\t\t\t/* We can't get the commit mutex.  It may\n\t\t\t\t * be held by a thread waiting for tlock's\n\t\t\t\t * so let's not block here.  Save it to\n\t\t\t\t * put back on the anon_list.\n\t\t\t\t */\n\n\t\t\t\t/* Move from anon_list to anon_list2 */\n\t\t\t\tlist_move(&jfs_ip->anon_inode_list,\n\t\t\t\t\t  &TxAnchor.anon_list2);\n\n\t\t\t\tTXN_UNLOCK();\n\t\t\t\tiput(ip);\n\t\t\t\tTXN_LOCK();\n\t\t\t}\n\t\t}\n\t\t/* Add anon_list2 back to anon_list */\n\t\tlist_splice_init(&TxAnchor.anon_list2, &TxAnchor.anon_list);\n\n\t\tif (freezing(current)) {\n\t\t\tTXN_UNLOCK();\n\t\t\ttry_to_freeze();\n\t\t} else {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tTXN_UNLOCK();\n\t\t\tschedule();\n\t\t}\n\t} while (!kthread_should_stop());\n\n\tjfs_info(\"jfs_sync being killed\");\n\treturn 0;\n}"
  },
  {
    "function_name": "txResume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2916-2922",
    "snippet": "void txResume(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\tclear_bit(log_QUIESCE, &log->flag);\n\tTXN_WAKEUP(&log->syncwait);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TXN_WAKEUP",
          "args": [
            "&log->syncwait"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "log_QUIESCE",
            "&log->flag"
          ],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nvoid txResume(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\tclear_bit(log_QUIESCE, &log->flag);\n\tTXN_WAKEUP(&log->syncwait);\n}"
  },
  {
    "function_name": "txQuiesce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2859-2909",
    "snippet": "void txQuiesce(struct super_block *sb)\n{\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\ttid_t tid;\n\n\tset_bit(log_QUIESCE, &log->flag);\n\n\tTXN_LOCK();\nrestart:\n\twhile (!list_empty(&TxAnchor.anon_list)) {\n\t\tjfs_ip = list_entry(TxAnchor.anon_list.next,\n\t\t\t\t    struct jfs_inode_info,\n\t\t\t\t    anon_inode_list);\n\t\tip = &jfs_ip->vfs_inode;\n\n\t\t/*\n\t\t * inode will be removed from anonymous list\n\t\t * when it is committed\n\t\t */\n\t\tTXN_UNLOCK();\n\t\ttid = txBegin(ip->i_sb, COMMIT_INODE | COMMIT_FORCE);\n\t\tmutex_lock(&jfs_ip->commit_mutex);\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&jfs_ip->commit_mutex);\n\t\t/*\n\t\t * Just to be safe.  I don't know how\n\t\t * long we can run without blocking\n\t\t */\n\t\tcond_resched();\n\t\tTXN_LOCK();\n\t}\n\n\t/*\n\t * If jfs_sync is running in parallel, there could be some inodes\n\t * on anon_list2.  Let's check.\n\t */\n\tif (!list_empty(&TxAnchor.anon_list2)) {\n\t\tlist_splice(&TxAnchor.anon_list2, &TxAnchor.anon_list);\n\t\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\t\tgoto restart;\n\t}\n\tTXN_UNLOCK();\n\n\t/*\n\t * We may need to kick off the group commit\n\t */\n\tjfs_flush_journal(log, 0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_flush_journal",
          "args": [
            "log",
            "0"
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_flush_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1532-1638",
          "snippet": "void jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nvoid jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&TxAnchor.anon_list2"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&TxAnchor.anon_list2",
            "&TxAnchor.anon_list"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&TxAnchor.anon_list2"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_ip->commit_mutex"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 2884
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&ip",
            "0"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&jfs_ip->commit_mutex"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "ip->i_sb",
            "COMMIT_INODE | COMMIT_FORCE"
          ],
          "line": 2881
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "TxAnchor.anon_list.next",
            "structjfs_inode_info",
            "anon_inode_list"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "log_QUIESCE",
            "&log->flag"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\n\nvoid txQuiesce(struct super_block *sb)\n{\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\ttid_t tid;\n\n\tset_bit(log_QUIESCE, &log->flag);\n\n\tTXN_LOCK();\nrestart:\n\twhile (!list_empty(&TxAnchor.anon_list)) {\n\t\tjfs_ip = list_entry(TxAnchor.anon_list.next,\n\t\t\t\t    struct jfs_inode_info,\n\t\t\t\t    anon_inode_list);\n\t\tip = &jfs_ip->vfs_inode;\n\n\t\t/*\n\t\t * inode will be removed from anonymous list\n\t\t * when it is committed\n\t\t */\n\t\tTXN_UNLOCK();\n\t\ttid = txBegin(ip->i_sb, COMMIT_INODE | COMMIT_FORCE);\n\t\tmutex_lock(&jfs_ip->commit_mutex);\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&jfs_ip->commit_mutex);\n\t\t/*\n\t\t * Just to be safe.  I don't know how\n\t\t * long we can run without blocking\n\t\t */\n\t\tcond_resched();\n\t\tTXN_LOCK();\n\t}\n\n\t/*\n\t * If jfs_sync is running in parallel, there could be some inodes\n\t * on anon_list2.  Let's check.\n\t */\n\tif (!list_empty(&TxAnchor.anon_list2)) {\n\t\tlist_splice(&TxAnchor.anon_list2, &TxAnchor.anon_list);\n\t\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\t\tgoto restart;\n\t}\n\tTXN_UNLOCK();\n\n\t/*\n\t * We may need to kick off the group commit\n\t */\n\tjfs_flush_journal(log, 0);\n}"
  },
  {
    "function_name": "LogSyncRelease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2840-2847",
    "snippet": "static void LogSyncRelease(struct metapage * mp)\n{\n\tstruct jfs_log *log = mp->log;\n\n\tassert(mp->nohomeok);\n\tassert(log);\n\tmetapage_homeok(mp);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "metapage_homeok",
          "args": [
            "mp"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_homeok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "135-140",
          "snippet": "static inline void metapage_homeok(struct metapage *mp)\n{\n\thold_metapage(mp);\n\t_metapage_homeok(mp);\n\tput_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\nstatic inline void metapage_homeok(struct metapage *mp)\n{\n\thold_metapage(mp);\n\t_metapage_homeok(mp);\n\tput_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "log"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void LogSyncRelease(struct metapage * mp)\n{\n\tstruct jfs_log *log = mp->log;\n\n\tassert(mp->nohomeok);\n\tassert(log);\n\tmetapage_homeok(mp);\n}"
  },
  {
    "function_name": "txLazyUnlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2821-2838",
    "snippet": "void txLazyUnlock(struct tblock * tblk)\n{\n\tunsigned long flags;\n\n\tLAZY_LOCK(flags);\n\n\tlist_add_tail(&tblk->cqueue, &TxAnchor.unlock_queue);\n\t/*\n\t * Don't wake up a commit thread if there is already one servicing\n\t * this superblock, or if the last one we woke up hasn't started yet.\n\t */\n\tif (!(JFS_SBI(tblk->sb)->commit_state & IN_LAZYCOMMIT) &&\n\t    !jfs_commit_thread_waking) {\n\t\tjfs_commit_thread_waking = 1;\n\t\twake_up(&jfs_commit_thread_wait);\n\t}\n\tLAZY_UNLOCK(flags);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "static DECLARE_WAIT_QUEUE_HEAD(jfs_commit_thread_wait);",
      "static int jfs_commit_thread_waking;",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LAZY_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&jfs_commit_thread_wait"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "tblk->sb"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tblk->cqueue",
            "&TxAnchor.unlock_queue"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LAZY_LOCK",
          "args": [
            "flags"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic DECLARE_WAIT_QUEUE_HEAD(jfs_commit_thread_wait);\nstatic int jfs_commit_thread_waking;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txLazyUnlock(struct tblock * tblk)\n{\n\tunsigned long flags;\n\n\tLAZY_LOCK(flags);\n\n\tlist_add_tail(&tblk->cqueue, &TxAnchor.unlock_queue);\n\t/*\n\t * Don't wake up a commit thread if there is already one servicing\n\t * this superblock, or if the last one we woke up hasn't started yet.\n\t */\n\tif (!(JFS_SBI(tblk->sb)->commit_state & IN_LAZYCOMMIT) &&\n\t    !jfs_commit_thread_waking) {\n\t\tjfs_commit_thread_waking = 1;\n\t\twake_up(&jfs_commit_thread_wait);\n\t}\n\tLAZY_UNLOCK(flags);\n}"
  },
  {
    "function_name": "jfs_lazycommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2747-2819",
    "snippet": "int jfs_lazycommit(void *arg)\n{\n\tint WorkDone;\n\tstruct tblock *tblk;\n\tunsigned long flags;\n\tstruct jfs_sb_info *sbi;\n\n\tdo {\n\t\tLAZY_LOCK(flags);\n\t\tjfs_commit_thread_waking = 0;\t/* OK to wake another thread */\n\t\twhile (!list_empty(&TxAnchor.unlock_queue)) {\n\t\t\tWorkDone = 0;\n\t\t\tlist_for_each_entry(tblk, &TxAnchor.unlock_queue,\n\t\t\t\t\t    cqueue) {\n\n\t\t\t\tsbi = JFS_SBI(tblk->sb);\n\t\t\t\t/*\n\t\t\t\t * For each volume, the transactions must be\n\t\t\t\t * handled in order.  If another commit thread\n\t\t\t\t * is handling a tblk for this superblock,\n\t\t\t\t * skip it\n\t\t\t\t */\n\t\t\t\tif (sbi->commit_state & IN_LAZYCOMMIT)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsbi->commit_state |= IN_LAZYCOMMIT;\n\t\t\t\tWorkDone = 1;\n\n\t\t\t\t/*\n\t\t\t\t * Remove transaction from queue\n\t\t\t\t */\n\t\t\t\tlist_del(&tblk->cqueue);\n\n\t\t\t\tLAZY_UNLOCK(flags);\n\t\t\t\ttxLazyCommit(tblk);\n\t\t\t\tLAZY_LOCK(flags);\n\n\t\t\t\tsbi->commit_state &= ~IN_LAZYCOMMIT;\n\t\t\t\t/*\n\t\t\t\t * Don't continue in the for loop.  (We can't\n\t\t\t\t * anyway, it's unsafe!)  We want to go back to\n\t\t\t\t * the beginning of the list.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* If there was nothing to do, don't continue */\n\t\t\tif (!WorkDone)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* In case a wakeup came while all threads were active */\n\t\tjfs_commit_thread_waking = 0;\n\n\t\tif (freezing(current)) {\n\t\t\tLAZY_UNLOCK(flags);\n\t\t\ttry_to_freeze();\n\t\t} else {\n\t\t\tDECLARE_WAITQUEUE(wq, current);\n\n\t\t\tadd_wait_queue(&jfs_commit_thread_wait, &wq);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tLAZY_UNLOCK(flags);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&jfs_commit_thread_wait, &wq);\n\t\t}\n\t} while (!kthread_should_stop());\n\n\tif (!list_empty(&TxAnchor.unlock_queue))\n\t\tjfs_err(\"jfs_lazycommit being killed w/pending transactions!\");\n\telse\n\t\tjfs_info(\"jfs_lazycommit being killed\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "static DECLARE_WAIT_QUEUE_HEAD(jfs_commit_thread_wait);",
      "static int jfs_commit_thread_waking;",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_lazycommit being killed\\n\""
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_lazycommit being killed w/pending transactions!\""
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&TxAnchor.unlock_queue"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&jfs_commit_thread_wait",
            "&wq"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LAZY_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&jfs_commit_thread_wait",
            "&wq"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wq",
            "current"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LAZY_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LAZY_LOCK",
          "args": [
            "flags"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLazyCommit",
          "args": [
            "tblk"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "txLazyCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2699-2738",
          "snippet": "static void txLazyCommit(struct tblock * tblk)\n{\n\tstruct jfs_log *log;\n\n\twhile (((tblk->flag & tblkGC_READY) == 0) &&\n\t       ((tblk->flag & tblkGC_UNLOCKED) == 0)) {\n\t\t/* We must have gotten ahead of the user thread\n\t\t */\n\t\tjfs_info(\"jfs_lazycommit: tblk 0x%p not unlocked\", tblk);\n\t\tyield();\n\t}\n\n\tjfs_info(\"txLazyCommit: processing tblk 0x%p\", tblk);\n\n\ttxUpdateMap(tblk);\n\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\n\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\n\ttblk->flag |= tblkGC_COMMITTED;\n\n\tif (tblk->flag & tblkGC_READY)\n\t\tlog->gcrtc--;\n\n\twake_up_all(&tblk->gcwait);\t// LOGGC_WAKEUP\n\n\t/*\n\t * Can't release log->gclock until we've tested tblk->flag\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\ttxUnlock(tblk);\n\t\ttblk->flag &= ~tblkGC_LAZY;\n\t\ttxEnd(tblk - TxBlock);\t/* Convert back to tid */\n\t} else\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\n\tjfs_info(\"txLazyCommit: done: tblk = 0x%p\", tblk);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tblock *TxBlock;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tblock *TxBlock;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nstatic void txLazyCommit(struct tblock * tblk)\n{\n\tstruct jfs_log *log;\n\n\twhile (((tblk->flag & tblkGC_READY) == 0) &&\n\t       ((tblk->flag & tblkGC_UNLOCKED) == 0)) {\n\t\t/* We must have gotten ahead of the user thread\n\t\t */\n\t\tjfs_info(\"jfs_lazycommit: tblk 0x%p not unlocked\", tblk);\n\t\tyield();\n\t}\n\n\tjfs_info(\"txLazyCommit: processing tblk 0x%p\", tblk);\n\n\ttxUpdateMap(tblk);\n\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\n\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\n\ttblk->flag |= tblkGC_COMMITTED;\n\n\tif (tblk->flag & tblkGC_READY)\n\t\tlog->gcrtc--;\n\n\twake_up_all(&tblk->gcwait);\t// LOGGC_WAKEUP\n\n\t/*\n\t * Can't release log->gclock until we've tested tblk->flag\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\ttxUnlock(tblk);\n\t\ttblk->flag &= ~tblkGC_LAZY;\n\t\ttxEnd(tblk - TxBlock);\t/* Convert back to tid */\n\t} else\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\n\tjfs_info(\"txLazyCommit: done: tblk = 0x%p\", tblk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LAZY_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tblk->cqueue"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "tblk->sb"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tblk",
            "&TxAnchor.unlock_queue",
            "cqueue"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LAZY_LOCK",
          "args": [
            "flags"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic DECLARE_WAIT_QUEUE_HEAD(jfs_commit_thread_wait);\nstatic int jfs_commit_thread_waking;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint jfs_lazycommit(void *arg)\n{\n\tint WorkDone;\n\tstruct tblock *tblk;\n\tunsigned long flags;\n\tstruct jfs_sb_info *sbi;\n\n\tdo {\n\t\tLAZY_LOCK(flags);\n\t\tjfs_commit_thread_waking = 0;\t/* OK to wake another thread */\n\t\twhile (!list_empty(&TxAnchor.unlock_queue)) {\n\t\t\tWorkDone = 0;\n\t\t\tlist_for_each_entry(tblk, &TxAnchor.unlock_queue,\n\t\t\t\t\t    cqueue) {\n\n\t\t\t\tsbi = JFS_SBI(tblk->sb);\n\t\t\t\t/*\n\t\t\t\t * For each volume, the transactions must be\n\t\t\t\t * handled in order.  If another commit thread\n\t\t\t\t * is handling a tblk for this superblock,\n\t\t\t\t * skip it\n\t\t\t\t */\n\t\t\t\tif (sbi->commit_state & IN_LAZYCOMMIT)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsbi->commit_state |= IN_LAZYCOMMIT;\n\t\t\t\tWorkDone = 1;\n\n\t\t\t\t/*\n\t\t\t\t * Remove transaction from queue\n\t\t\t\t */\n\t\t\t\tlist_del(&tblk->cqueue);\n\n\t\t\t\tLAZY_UNLOCK(flags);\n\t\t\t\ttxLazyCommit(tblk);\n\t\t\t\tLAZY_LOCK(flags);\n\n\t\t\t\tsbi->commit_state &= ~IN_LAZYCOMMIT;\n\t\t\t\t/*\n\t\t\t\t * Don't continue in the for loop.  (We can't\n\t\t\t\t * anyway, it's unsafe!)  We want to go back to\n\t\t\t\t * the beginning of the list.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* If there was nothing to do, don't continue */\n\t\t\tif (!WorkDone)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* In case a wakeup came while all threads were active */\n\t\tjfs_commit_thread_waking = 0;\n\n\t\tif (freezing(current)) {\n\t\t\tLAZY_UNLOCK(flags);\n\t\t\ttry_to_freeze();\n\t\t} else {\n\t\t\tDECLARE_WAITQUEUE(wq, current);\n\n\t\t\tadd_wait_queue(&jfs_commit_thread_wait, &wq);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tLAZY_UNLOCK(flags);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&jfs_commit_thread_wait, &wq);\n\t\t}\n\t} while (!kthread_should_stop());\n\n\tif (!list_empty(&TxAnchor.unlock_queue))\n\t\tjfs_err(\"jfs_lazycommit being killed w/pending transactions!\");\n\telse\n\t\tjfs_info(\"jfs_lazycommit being killed\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "txLazyCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2699-2738",
    "snippet": "static void txLazyCommit(struct tblock * tblk)\n{\n\tstruct jfs_log *log;\n\n\twhile (((tblk->flag & tblkGC_READY) == 0) &&\n\t       ((tblk->flag & tblkGC_UNLOCKED) == 0)) {\n\t\t/* We must have gotten ahead of the user thread\n\t\t */\n\t\tjfs_info(\"jfs_lazycommit: tblk 0x%p not unlocked\", tblk);\n\t\tyield();\n\t}\n\n\tjfs_info(\"txLazyCommit: processing tblk 0x%p\", tblk);\n\n\ttxUpdateMap(tblk);\n\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\n\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\n\ttblk->flag |= tblkGC_COMMITTED;\n\n\tif (tblk->flag & tblkGC_READY)\n\t\tlog->gcrtc--;\n\n\twake_up_all(&tblk->gcwait);\t// LOGGC_WAKEUP\n\n\t/*\n\t * Can't release log->gclock until we've tested tblk->flag\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\ttxUnlock(tblk);\n\t\ttblk->flag &= ~tblkGC_LAZY;\n\t\ttxEnd(tblk - TxBlock);\t/* Convert back to tid */\n\t} else\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\n\tjfs_info(\"txLazyCommit: done: tblk = 0x%p\", tblk);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct tblock *TxBlock;",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txLazyCommit: done: tblk = 0x%p\"",
            "tblk"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log->gclock"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tblk - TxBlock"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txUnlock",
          "args": [
            "tblk"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "txUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "908-987",
          "snippet": "static void txUnlock(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\tlid_t lid, next, llid, k;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint difft, diffp;\n\tunsigned long flags;\n\n\tjfs_info(\"txUnlock: tblk = 0x%p\", tblk);\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * mark page under tlock homeok (its log has been written):\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tjfs_info(\"unlocking lid = %d, tlck = 0x%p\", lid, tlck);\n\n\t\t/* unbind page from tlock */\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\t/* hold buffer\n\t\t\t */\n\t\t\thold_metapage(mp);\n\n\t\t\tassert(mp->nohomeok > 0);\n\t\t\t_metapage_homeok(mp);\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tLOGSYNC_LOCK(log, flags);\n\t\t\tif (mp->clsn) {\n\t\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\t\tif (difft > diffp)\n\t\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\t} else\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t\t\tassert(!(tlck->flag & tlckFREEPAGE));\n\n\t\t\tput_metapage(mp);\n\t\t}\n\n\t\t/* insert tlock, and linelock(s) of the tlock if any,\n\t\t * at head of freelist\n\t\t */\n\t\tTXN_LOCK();\n\n\t\tllid = ((struct linelock *) & tlck->lock)->next;\n\t\twhile (llid) {\n\t\t\tlinelock = (struct linelock *) lid_to_tlock(llid);\n\t\t\tk = linelock->next;\n\t\t\ttxLockFree(llid);\n\t\t\tllid = k;\n\t\t}\n\t\ttxLockFree(lid);\n\n\t\tTXN_UNLOCK();\n\t}\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * remove tblock from logsynclist\n\t * (allocation map pages inherited lsn of tblk and\n\t * has been inserted in logsync list at txUpdateMap())\n\t */\n\tif (tblk->lsn) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tlog->count--;\n\t\tlist_del(&tblk->synclist);\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void txUnlock(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\tlid_t lid, next, llid, k;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint difft, diffp;\n\tunsigned long flags;\n\n\tjfs_info(\"txUnlock: tblk = 0x%p\", tblk);\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * mark page under tlock homeok (its log has been written):\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tjfs_info(\"unlocking lid = %d, tlck = 0x%p\", lid, tlck);\n\n\t\t/* unbind page from tlock */\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\t/* hold buffer\n\t\t\t */\n\t\t\thold_metapage(mp);\n\n\t\t\tassert(mp->nohomeok > 0);\n\t\t\t_metapage_homeok(mp);\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tLOGSYNC_LOCK(log, flags);\n\t\t\tif (mp->clsn) {\n\t\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\t\tif (difft > diffp)\n\t\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\t} else\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t\t\tassert(!(tlck->flag & tlckFREEPAGE));\n\n\t\t\tput_metapage(mp);\n\t\t}\n\n\t\t/* insert tlock, and linelock(s) of the tlock if any,\n\t\t * at head of freelist\n\t\t */\n\t\tTXN_LOCK();\n\n\t\tllid = ((struct linelock *) & tlck->lock)->next;\n\t\twhile (llid) {\n\t\t\tlinelock = (struct linelock *) lid_to_tlock(llid);\n\t\t\tk = linelock->next;\n\t\t\ttxLockFree(llid);\n\t\t\tllid = k;\n\t\t}\n\t\ttxLockFree(lid);\n\n\t\tTXN_UNLOCK();\n\t}\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * remove tblock from logsynclist\n\t * (allocation map pages inherited lsn of tblk and\n\t * has been inserted in logsync list at txUpdateMap())\n\t */\n\tif (tblk->lsn) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tlog->count--;\n\t\tlist_del(&tblk->synclist);\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log->gclock"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&tblk->gcwait"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&log->gclock"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "tblk->sb"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txUpdateMap",
          "args": [
            "tblk"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "txUpdateMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2293-2417",
          "snippet": "static void txUpdateMap(struct tblock * tblk)\n{\n\tstruct inode *ip;\n\tstruct inode *ipimap;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\tstruct pxd_lock pxdlock;\n\tint maptype;\n\tint k, nlock;\n\tstruct metapage *mp = NULL;\n\n\tipimap = JFS_SBI(tblk->sb)->ipimap;\n\n\tmaptype = (tblk->xflag & COMMIT_PMAP) ? COMMIT_PMAP : COMMIT_PWMAP;\n\n\n\t/*\n\t *\tupdate block allocation map\n\t *\n\t * update allocation state in pmap (and wmap) and\n\t * update lsn of the pmap page;\n\t */\n\t/*\n\t * scan each tlock/page of transaction for block allocation/free:\n\t *\n\t * for each tlock/page of transaction, update map.\n\t *  ? are there tlock for pmap and pwmap at the same time ?\n\t */\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif ((tlck->flag & tlckUPDATEMAP) == 0)\n\t\t\tcontinue;\n\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\t/*\n\t\t\t * Another thread may attempt to reuse freed space\n\t\t\t * immediately, so we want to get rid of the metapage\n\t\t\t * before anyone else has a chance to get it.\n\t\t\t * Lock metapage, update maps, then invalidate\n\t\t\t * the metapage.\n\t\t\t */\n\t\t\tmp = tlck->mp;\n\t\t\tASSERT(mp->xflag & COMMIT_PAGE);\n\t\t\tgrab_metapage(mp);\n\t\t}\n\n\t\t/*\n\t\t * extent list:\n\t\t * . in-line PXD list:\n\t\t * . out-of-line XAD list:\n\t\t */\n\t\tmaplock = (struct maplock *) & tlck->lock;\n\t\tnlock = maplock->index;\n\n\t\tfor (k = 0; k < nlock; k++, maplock++) {\n\t\t\t/*\n\t\t\t * allocate blocks in persistent map:\n\t\t\t *\n\t\t\t * blocks have been allocated from wmap at alloc time;\n\t\t\t */\n\t\t\tif (maplock->flag & mlckALLOC) {\n\t\t\t\ttxAllocPMap(ipimap, maplock, tblk);\n\t\t\t}\n\t\t\t/*\n\t\t\t * free blocks in persistent and working map:\n\t\t\t * blocks will be freed in pmap and then in wmap;\n\t\t\t *\n\t\t\t * ? tblock specifies the PMAP/PWMAP based upon\n\t\t\t * transaction\n\t\t\t *\n\t\t\t * free blocks in persistent map:\n\t\t\t * blocks will be freed from wmap at last reference\n\t\t\t * release of the object for regular files;\n\t\t\t *\n\t\t\t * Alway free blocks from both persistent & working\n\t\t\t * maps for directories\n\t\t\t */\n\t\t\telse {\t/* (maplock->flag & mlckFREE) */\n\n\t\t\t\tif (tlck->flag & tlckDIRECTORY)\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, COMMIT_PWMAP);\n\t\t\t\telse\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, maptype);\n\t\t\t}\n\t\t}\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\tif (!(tblk->flag & tblkGC_LAZY)) {\n\t\t\t\t/* This is equivalent to txRelease */\n\t\t\t\tASSERT(mp->lid == lid);\n\t\t\t\ttlck->mp->lid = 0;\n\t\t\t}\n\t\t\tassert(mp->nohomeok == 1);\n\t\t\tmetapage_homeok(mp);\n\t\t\tdiscard_metapage(mp);\n\t\t\ttlck->mp = NULL;\n\t\t}\n\t}\n\t/*\n\t *\tupdate inode allocation map\n\t *\n\t * update allocation state in pmap and\n\t * update lsn of the pmap page;\n\t * update in-memory inode flag/state\n\t *\n\t * unlock mapper/write lock\n\t */\n\tif (tblk->xflag & COMMIT_CREATE) {\n\t\tdiUpdatePMap(ipimap, tblk->ino, false, tblk);\n\t\t/* update persistent block allocation map\n\t\t * for the allocation of inode extent;\n\t\t */\n\t\tpxdlock.flag = mlckALLOCPXD;\n\t\tpxdlock.pxd = tblk->u.ixpxd;\n\t\tpxdlock.index = 1;\n\t\ttxAllocPMap(ipimap, (struct maplock *) & pxdlock, tblk);\n\t} else if (tblk->xflag & COMMIT_DELETE) {\n\t\tip = tblk->u.ip;\n\t\tdiUpdatePMap(ipimap, ip->i_ino, true, tblk);\n\t\tiput(ip);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void txUpdateMap(struct tblock * tblk)\n{\n\tstruct inode *ip;\n\tstruct inode *ipimap;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\tstruct pxd_lock pxdlock;\n\tint maptype;\n\tint k, nlock;\n\tstruct metapage *mp = NULL;\n\n\tipimap = JFS_SBI(tblk->sb)->ipimap;\n\n\tmaptype = (tblk->xflag & COMMIT_PMAP) ? COMMIT_PMAP : COMMIT_PWMAP;\n\n\n\t/*\n\t *\tupdate block allocation map\n\t *\n\t * update allocation state in pmap (and wmap) and\n\t * update lsn of the pmap page;\n\t */\n\t/*\n\t * scan each tlock/page of transaction for block allocation/free:\n\t *\n\t * for each tlock/page of transaction, update map.\n\t *  ? are there tlock for pmap and pwmap at the same time ?\n\t */\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif ((tlck->flag & tlckUPDATEMAP) == 0)\n\t\t\tcontinue;\n\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\t/*\n\t\t\t * Another thread may attempt to reuse freed space\n\t\t\t * immediately, so we want to get rid of the metapage\n\t\t\t * before anyone else has a chance to get it.\n\t\t\t * Lock metapage, update maps, then invalidate\n\t\t\t * the metapage.\n\t\t\t */\n\t\t\tmp = tlck->mp;\n\t\t\tASSERT(mp->xflag & COMMIT_PAGE);\n\t\t\tgrab_metapage(mp);\n\t\t}\n\n\t\t/*\n\t\t * extent list:\n\t\t * . in-line PXD list:\n\t\t * . out-of-line XAD list:\n\t\t */\n\t\tmaplock = (struct maplock *) & tlck->lock;\n\t\tnlock = maplock->index;\n\n\t\tfor (k = 0; k < nlock; k++, maplock++) {\n\t\t\t/*\n\t\t\t * allocate blocks in persistent map:\n\t\t\t *\n\t\t\t * blocks have been allocated from wmap at alloc time;\n\t\t\t */\n\t\t\tif (maplock->flag & mlckALLOC) {\n\t\t\t\ttxAllocPMap(ipimap, maplock, tblk);\n\t\t\t}\n\t\t\t/*\n\t\t\t * free blocks in persistent and working map:\n\t\t\t * blocks will be freed in pmap and then in wmap;\n\t\t\t *\n\t\t\t * ? tblock specifies the PMAP/PWMAP based upon\n\t\t\t * transaction\n\t\t\t *\n\t\t\t * free blocks in persistent map:\n\t\t\t * blocks will be freed from wmap at last reference\n\t\t\t * release of the object for regular files;\n\t\t\t *\n\t\t\t * Alway free blocks from both persistent & working\n\t\t\t * maps for directories\n\t\t\t */\n\t\t\telse {\t/* (maplock->flag & mlckFREE) */\n\n\t\t\t\tif (tlck->flag & tlckDIRECTORY)\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, COMMIT_PWMAP);\n\t\t\t\telse\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, maptype);\n\t\t\t}\n\t\t}\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\tif (!(tblk->flag & tblkGC_LAZY)) {\n\t\t\t\t/* This is equivalent to txRelease */\n\t\t\t\tASSERT(mp->lid == lid);\n\t\t\t\ttlck->mp->lid = 0;\n\t\t\t}\n\t\t\tassert(mp->nohomeok == 1);\n\t\t\tmetapage_homeok(mp);\n\t\t\tdiscard_metapage(mp);\n\t\t\ttlck->mp = NULL;\n\t\t}\n\t}\n\t/*\n\t *\tupdate inode allocation map\n\t *\n\t * update allocation state in pmap and\n\t * update lsn of the pmap page;\n\t * update in-memory inode flag/state\n\t *\n\t * unlock mapper/write lock\n\t */\n\tif (tblk->xflag & COMMIT_CREATE) {\n\t\tdiUpdatePMap(ipimap, tblk->ino, false, tblk);\n\t\t/* update persistent block allocation map\n\t\t * for the allocation of inode extent;\n\t\t */\n\t\tpxdlock.flag = mlckALLOCPXD;\n\t\tpxdlock.pxd = tblk->u.ixpxd;\n\t\tpxdlock.index = 1;\n\t\ttxAllocPMap(ipimap, (struct maplock *) & pxdlock, tblk);\n\t} else if (tblk->xflag & COMMIT_DELETE) {\n\t\tip = tblk->u.ip;\n\t\tdiUpdatePMap(ipimap, ip->i_ino, true, tblk);\n\t\tiput(ip);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txLazyCommit: processing tblk 0x%p\"",
            "tblk"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yield",
          "args": [],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_lazycommit: tblk 0x%p not unlocked\"",
            "tblk"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tblock *TxBlock;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nstatic void txLazyCommit(struct tblock * tblk)\n{\n\tstruct jfs_log *log;\n\n\twhile (((tblk->flag & tblkGC_READY) == 0) &&\n\t       ((tblk->flag & tblkGC_UNLOCKED) == 0)) {\n\t\t/* We must have gotten ahead of the user thread\n\t\t */\n\t\tjfs_info(\"jfs_lazycommit: tblk 0x%p not unlocked\", tblk);\n\t\tyield();\n\t}\n\n\tjfs_info(\"txLazyCommit: processing tblk 0x%p\", tblk);\n\n\ttxUpdateMap(tblk);\n\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\n\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\n\ttblk->flag |= tblkGC_COMMITTED;\n\n\tif (tblk->flag & tblkGC_READY)\n\t\tlog->gcrtc--;\n\n\twake_up_all(&tblk->gcwait);\t// LOGGC_WAKEUP\n\n\t/*\n\t * Can't release log->gclock until we've tested tblk->flag\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\ttxUnlock(tblk);\n\t\ttblk->flag &= ~tblkGC_LAZY;\n\t\ttxEnd(tblk - TxBlock);\t/* Convert back to tid */\n\t} else\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\n\tjfs_info(\"txLazyCommit: done: tblk = 0x%p\", tblk);\n}"
  },
  {
    "function_name": "txAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2642-2689",
    "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "tblk->sb",
            "\"\\n\""
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLockFree",
          "args": [
            "lid"
          ],
          "line": 2674
        },
        "resolved": true,
        "details": {
          "function_name": "txLockFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "215-227",
          "snippet": "static void txLockFree(lid_t lid)\n{\n\tTxLock[lid].tid = 0;\n\tTxLock[lid].next = TxAnchor.freelock;\n\tTxAnchor.freelock = lid;\n\tTxAnchor.tlocksInUse--;\n\tif (jfs_tlocks_low && (TxAnchor.tlocksInUse < TxLockLWM)) {\n\t\tjfs_info(\"txLockFree jfs_tlocks_low no more\");\n\t\tjfs_tlocks_low = 0;\n\t\tTXN_WAKEUP(&TxAnchor.lowlockwait);\n\t}\n\tTXN_WAKEUP(&TxAnchor.freelockwait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "int jfs_tlocks_low;",
            "static int TxLockLWM;",
            "struct tlock *TxLock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nint jfs_tlocks_low;\nstatic int TxLockLWM;\nstruct tlock *TxLock;\n\nstatic void txLockFree(lid_t lid)\n{\n\tTxLock[lid].tid = 0;\n\tTxLock[lid].next = TxAnchor.freelock;\n\tTxAnchor.freelock = lid;\n\tTxAnchor.tlocksInUse--;\n\tif (jfs_tlocks_low && (TxAnchor.tlocksInUse < TxLockLWM)) {\n\t\tjfs_info(\"txLockFree jfs_tlocks_low no more\");\n\t\tjfs_tlocks_low = 0;\n\t\tTXN_WAKEUP(&TxAnchor.lowlockwait);\n\t}\n\tTXN_WAKEUP(&TxAnchor.freelockwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogSyncRelease",
          "args": [
            "mp"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "LogSyncRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2840-2847",
          "snippet": "static void LogSyncRelease(struct metapage * mp)\n{\n\tstruct jfs_log *log = mp->log;\n\n\tassert(mp->nohomeok);\n\tassert(log);\n\tmetapage_homeok(mp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void LogSyncRelease(struct metapage * mp)\n{\n\tstruct jfs_log *log = mp->log;\n\n\tassert(mp->nohomeok);\n\tassert(log);\n\tmetapage_homeok(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "tlck->ip"
          ],
          "line": 2656
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
  },
  {
    "function_name": "txFreelock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2596-2629",
    "snippet": "void txFreelock(struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct tlock *xtlck, *tlck;\n\tlid_t xlid = 0, lid;\n\n\tif (!jfs_ip->atlhead)\n\t\treturn;\n\n\tTXN_LOCK();\n\txtlck = (struct tlock *) &jfs_ip->atlhead;\n\n\twhile ((lid = xtlck->next) != 0) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tif (tlck->flag & tlckFREELOCK) {\n\t\t\txtlck->next = tlck->next;\n\t\t\ttxLockFree(lid);\n\t\t} else {\n\t\t\txtlck = tlck;\n\t\t\txlid = lid;\n\t\t}\n\t}\n\n\tif (jfs_ip->atlhead)\n\t\tjfs_ip->atltail = xlid;\n\telse {\n\t\tjfs_ip->atltail = 0;\n\t\t/*\n\t\t * If inode was on anon_list, remove it\n\t\t */\n\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t}\n\tTXN_UNLOCK();\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&jfs_ip->anon_inode_list"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLockFree",
          "args": [
            "lid"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "txLockFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "215-227",
          "snippet": "static void txLockFree(lid_t lid)\n{\n\tTxLock[lid].tid = 0;\n\tTxLock[lid].next = TxAnchor.freelock;\n\tTxAnchor.freelock = lid;\n\tTxAnchor.tlocksInUse--;\n\tif (jfs_tlocks_low && (TxAnchor.tlocksInUse < TxLockLWM)) {\n\t\tjfs_info(\"txLockFree jfs_tlocks_low no more\");\n\t\tjfs_tlocks_low = 0;\n\t\tTXN_WAKEUP(&TxAnchor.lowlockwait);\n\t}\n\tTXN_WAKEUP(&TxAnchor.freelockwait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "int jfs_tlocks_low;",
            "static int TxLockLWM;",
            "struct tlock *TxLock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nint jfs_tlocks_low;\nstatic int TxLockLWM;\nstruct tlock *TxLock;\n\nstatic void txLockFree(lid_t lid)\n{\n\tTxLock[lid].tid = 0;\n\tTxLock[lid].next = TxAnchor.freelock;\n\tTxAnchor.freelock = lid;\n\tTxAnchor.tlocksInUse--;\n\tif (jfs_tlocks_low && (TxAnchor.tlocksInUse < TxLockLWM)) {\n\t\tjfs_info(\"txLockFree jfs_tlocks_low no more\");\n\t\tjfs_tlocks_low = 0;\n\t\tTXN_WAKEUP(&TxAnchor.lowlockwait);\n\t}\n\tTXN_WAKEUP(&TxAnchor.freelockwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nvoid txFreelock(struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct tlock *xtlck, *tlck;\n\tlid_t xlid = 0, lid;\n\n\tif (!jfs_ip->atlhead)\n\t\treturn;\n\n\tTXN_LOCK();\n\txtlck = (struct tlock *) &jfs_ip->atlhead;\n\n\twhile ((lid = xtlck->next) != 0) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tif (tlck->flag & tlckFREELOCK) {\n\t\t\txtlck->next = tlck->next;\n\t\t\ttxLockFree(lid);\n\t\t} else {\n\t\t\txtlck = tlck;\n\t\t\txlid = lid;\n\t\t}\n\t}\n\n\tif (jfs_ip->atlhead)\n\t\tjfs_ip->atltail = xlid;\n\telse {\n\t\tjfs_ip->atltail = 0;\n\t\t/*\n\t\t * If inode was on anon_list, remove it\n\t\t */\n\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t}\n\tTXN_UNLOCK();\n}"
  },
  {
    "function_name": "txFreeMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2497-2589",
    "snippet": "void txFreeMap(struct inode *ip,\n\t       struct maplock * maplock, struct tblock * tblk, int maptype)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\tjfs_info(\"txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x\",\n\t\t tblk, maplock, maptype);\n\n\t/*\n\t * free from persistent map;\n\t */\n\tif (maptype == COMMIT_PMAP || maptype == COMMIT_PWMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\tif (!(xad->flag & XAD_NEW)) {\n\t\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx \"\n\t\t\t\t\t\t \"xlen:%d\",\n\t\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbUpdatePMap(ipbmap, true, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * free from working map;\n\t */\n\tif (maptype == COMMIT_PWMAP || maptype == COMMIT_WMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\txad->flag = 0;\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckFREEPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"freeWMap: xaddr:0x%lx xlen:%d\"",
            "(ulong) xaddr",
            "xlen"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "xaddr",
            "(s64) xlen"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "pxd"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "pxd"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"freeWMap: xaddr:0x%lx xlen:%d\"",
            "(ulong) xaddr",
            "xlen"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"freeWMap: xaddr:0x%lx xlen:%d\"",
            "(ulong) xaddr",
            "xlen"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"freePMap: xaddr:0x%lx xlen:%d\"",
            "(ulong) xaddr",
            "xlen"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbUpdatePMap",
          "args": [
            "ipbmap",
            "true",
            "xaddr",
            "(s64) xlen",
            "tblk"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "dbUpdatePMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "423-576",
          "snippet": "int\ndbUpdatePMap(struct inode *ipbmap,\n\t     int free, s64 blkno, s64 nblocks, struct tblock * tblk)\n{\n\tint nblks, dbitno, wbitno, rbits;\n\tint word, nbits, nwords;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\ts64 lblkno, rem, lastlblkno;\n\tu32 mask;\n\tstruct dmap *dp;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\t/* the blocks better be within the mapsize. */\n\tif (blkno + nblocks > bmp->db_mapsize) {\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ipbmap->i_sb, \"blocks are outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute delta of transaction lsn from log syncpt */\n\tlsn = tblk->lsn;\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\tlogdiff(difft, lsn, log);\n\n\t/*\n\t * update the block state a dmap at a time.\n\t */\n\tmp = NULL;\n\tlastlblkno = 0;\n\tfor (rem = nblocks; rem > 0; rem -= nblks, blkno += nblks) {\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tif (lblkno != lastlblkno) {\n\t\t\tif (mp) {\n\t\t\t\twrite_metapage(mp);\n\t\t\t}\n\n\t\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE,\n\t\t\t\t\t   0);\n\t\t\tif (mp == NULL)\n\t\t\t\treturn -EIO;\n\t\t\tmetapage_wait_for_io(mp);\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the bit number and word within the dmap of\n\t\t * the starting block.  also determine how many blocks\n\t\t * are to be updated within this dmap.\n\t\t */\n\t\tdbitno = blkno & (BPERDMAP - 1);\n\t\tword = dbitno >> L2DBWORD;\n\t\tnblks = min(rem, (s64)BPERDMAP - dbitno);\n\n\t\t/* update the bits of the dmap words. the first and last\n\t\t * words may only have a subset of their bits updated. if\n\t\t * this is the case, we'll work against that word (i.e.\n\t\t * partial first and/or last) only in a single pass.  a\n\t\t * single pass will also be used to update all words that\n\t\t * are to have all their bits updated.\n\t\t */\n\t\tfor (rbits = nblks; rbits > 0;\n\t\t     rbits -= nbits, dbitno += nbits) {\n\t\t\t/* determine the bit number within the word and\n\t\t\t * the number of bits within the word.\n\t\t\t */\n\t\t\twbitno = dbitno & (DBWORD - 1);\n\t\t\tnbits = min(rbits, DBWORD - wbitno);\n\n\t\t\t/* check if only part of the word is to be updated. */\n\t\t\tif (nbits < DBWORD) {\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in this word.\n\t\t\t\t */\n\t\t\t\tmask =\n\t\t\t\t    (ONES << (DBWORD - nbits) >> wbitno);\n\t\t\t\tif (free)\n\t\t\t\t\tdp->pmap[word] &=\n\t\t\t\t\t    cpu_to_le32(~mask);\n\t\t\t\telse\n\t\t\t\t\tdp->pmap[word] |=\n\t\t\t\t\t    cpu_to_le32(mask);\n\n\t\t\t\tword += 1;\n\t\t\t} else {\n\t\t\t\t/* one or more words are to have all\n\t\t\t\t * their bits updated.  determine how\n\t\t\t\t * many words and how many bits.\n\t\t\t\t */\n\t\t\t\tnwords = rbits >> L2DBWORD;\n\t\t\t\tnbits = nwords << L2DBWORD;\n\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in these words.\n\t\t\t\t */\n\t\t\t\tif (free)\n\t\t\t\t\tmemset(&dp->pmap[word], 0,\n\t\t\t\t\t       nwords * 4);\n\t\t\t\telse\n\t\t\t\t\tmemset(&dp->pmap[word], (int) ONES,\n\t\t\t\t\t       nwords * 4);\n\n\t\t\t\tword += nwords;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * update dmap lsn\n\t\t */\n\t\tif (lblkno == lastlblkno)\n\t\t\tcontinue;\n\n\t\tlastlblkno = lblkno;\n\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (mp->lsn != 0) {\n\t\t\t/* inherit older/smaller lsn */\n\t\t\tlogdiff(diffp, mp->lsn, log);\n\t\t\tif (difft < diffp) {\n\t\t\t\tmp->lsn = lsn;\n\n\t\t\t\t/* move bp after tblock in logsync list */\n\t\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t\t}\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\tif (difft > diffp)\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t} else {\n\t\t\tmp->log = log;\n\t\t\tmp->lsn = lsn;\n\n\t\t\t/* insert bp after tblock in logsync list */\n\t\t\tlog->count++;\n\t\t\tlist_add(&mp->synclist, &tblk->synclist);\n\n\t\t\tmp->clsn = tblk->clsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n\n\t/* write the last buffer. */\n\tif (mp) {\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint\ndbUpdatePMap(struct inode *ipbmap,\n\t     int free, s64 blkno, s64 nblocks, struct tblock * tblk)\n{\n\tint nblks, dbitno, wbitno, rbits;\n\tint word, nbits, nwords;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\ts64 lblkno, rem, lastlblkno;\n\tu32 mask;\n\tstruct dmap *dp;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\t/* the blocks better be within the mapsize. */\n\tif (blkno + nblocks > bmp->db_mapsize) {\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ipbmap->i_sb, \"blocks are outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute delta of transaction lsn from log syncpt */\n\tlsn = tblk->lsn;\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\tlogdiff(difft, lsn, log);\n\n\t/*\n\t * update the block state a dmap at a time.\n\t */\n\tmp = NULL;\n\tlastlblkno = 0;\n\tfor (rem = nblocks; rem > 0; rem -= nblks, blkno += nblks) {\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tif (lblkno != lastlblkno) {\n\t\t\tif (mp) {\n\t\t\t\twrite_metapage(mp);\n\t\t\t}\n\n\t\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE,\n\t\t\t\t\t   0);\n\t\t\tif (mp == NULL)\n\t\t\t\treturn -EIO;\n\t\t\tmetapage_wait_for_io(mp);\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the bit number and word within the dmap of\n\t\t * the starting block.  also determine how many blocks\n\t\t * are to be updated within this dmap.\n\t\t */\n\t\tdbitno = blkno & (BPERDMAP - 1);\n\t\tword = dbitno >> L2DBWORD;\n\t\tnblks = min(rem, (s64)BPERDMAP - dbitno);\n\n\t\t/* update the bits of the dmap words. the first and last\n\t\t * words may only have a subset of their bits updated. if\n\t\t * this is the case, we'll work against that word (i.e.\n\t\t * partial first and/or last) only in a single pass.  a\n\t\t * single pass will also be used to update all words that\n\t\t * are to have all their bits updated.\n\t\t */\n\t\tfor (rbits = nblks; rbits > 0;\n\t\t     rbits -= nbits, dbitno += nbits) {\n\t\t\t/* determine the bit number within the word and\n\t\t\t * the number of bits within the word.\n\t\t\t */\n\t\t\twbitno = dbitno & (DBWORD - 1);\n\t\t\tnbits = min(rbits, DBWORD - wbitno);\n\n\t\t\t/* check if only part of the word is to be updated. */\n\t\t\tif (nbits < DBWORD) {\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in this word.\n\t\t\t\t */\n\t\t\t\tmask =\n\t\t\t\t    (ONES << (DBWORD - nbits) >> wbitno);\n\t\t\t\tif (free)\n\t\t\t\t\tdp->pmap[word] &=\n\t\t\t\t\t    cpu_to_le32(~mask);\n\t\t\t\telse\n\t\t\t\t\tdp->pmap[word] |=\n\t\t\t\t\t    cpu_to_le32(mask);\n\n\t\t\t\tword += 1;\n\t\t\t} else {\n\t\t\t\t/* one or more words are to have all\n\t\t\t\t * their bits updated.  determine how\n\t\t\t\t * many words and how many bits.\n\t\t\t\t */\n\t\t\t\tnwords = rbits >> L2DBWORD;\n\t\t\t\tnbits = nwords << L2DBWORD;\n\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in these words.\n\t\t\t\t */\n\t\t\t\tif (free)\n\t\t\t\t\tmemset(&dp->pmap[word], 0,\n\t\t\t\t\t       nwords * 4);\n\t\t\t\telse\n\t\t\t\t\tmemset(&dp->pmap[word], (int) ONES,\n\t\t\t\t\t       nwords * 4);\n\n\t\t\t\tword += nwords;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * update dmap lsn\n\t\t */\n\t\tif (lblkno == lastlblkno)\n\t\t\tcontinue;\n\n\t\tlastlblkno = lblkno;\n\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (mp->lsn != 0) {\n\t\t\t/* inherit older/smaller lsn */\n\t\t\tlogdiff(diffp, mp->lsn, log);\n\t\t\tif (difft < diffp) {\n\t\t\t\tmp->lsn = lsn;\n\n\t\t\t\t/* move bp after tblock in logsync list */\n\t\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t\t}\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\tif (difft > diffp)\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t} else {\n\t\t\tmp->log = log;\n\t\t\tmp->lsn = lsn;\n\n\t\t\t/* insert bp after tblock in logsync list */\n\t\t\tlog->count++;\n\t\t\tlist_add(&mp->synclist, &tblk->synclist);\n\n\t\t\tmp->clsn = tblk->clsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n\n\t/* write the last buffer. */\n\tif (mp) {\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"freePMap: xaddr:0x%lx xlen:%d\"",
            "(ulong) xaddr",
            "xlen"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"freePMap: xaddr:0x%lx \"\n\t\t\t\t\t\t \"xlen:%d\"",
            "(ulong) xaddr",
            "xlen"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x\"",
            "tblk",
            "maplock",
            "maptype"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txFreeMap(struct inode *ip,\n\t       struct maplock * maplock, struct tblock * tblk, int maptype)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\tjfs_info(\"txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x\",\n\t\t tblk, maplock, maptype);\n\n\t/*\n\t * free from persistent map;\n\t */\n\tif (maptype == COMMIT_PMAP || maptype == COMMIT_PWMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\tif (!(xad->flag & XAD_NEW)) {\n\t\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx \"\n\t\t\t\t\t\t \"xlen:%d\",\n\t\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbUpdatePMap(ipbmap, true, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * free from working map;\n\t */\n\tif (maptype == COMMIT_PWMAP || maptype == COMMIT_WMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\txad->flag = 0;\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckFREEPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "txAllocPMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2439-2488",
    "snippet": "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\t\tstruct tblock * tblk)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\t/*\n\t * allocate from persistent map;\n\t */\n\tif (maplock->flag & mlckALLOCXADLIST) {\n\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\txad = xadlistlock->xdlist;\n\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED)) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbUpdatePMap(ipbmap, false, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t\t\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t} else if (maplock->flag & mlckALLOCPXD) {\n\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\tdbUpdatePMap(ipbmap, false, xaddr, (s64) xlen, tblk);\n\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\", (ulong) xaddr, xlen);\n\t} else {\t\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\tpxd = pxdlistlock->xdlist;\n\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\txaddr = addressPXD(pxd);\n\t\t\txlen = lengthPXD(pxd);\n\t\t\tdbUpdatePMap(ipbmap, false, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"allocPMap: xaddr:0x%lx xlen:%d\"",
            "(ulong) xaddr",
            "xlen"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbUpdatePMap",
          "args": [
            "ipbmap",
            "false",
            "xaddr",
            "(s64) xlen",
            "tblk"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "dbUpdatePMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "423-576",
          "snippet": "int\ndbUpdatePMap(struct inode *ipbmap,\n\t     int free, s64 blkno, s64 nblocks, struct tblock * tblk)\n{\n\tint nblks, dbitno, wbitno, rbits;\n\tint word, nbits, nwords;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\ts64 lblkno, rem, lastlblkno;\n\tu32 mask;\n\tstruct dmap *dp;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\t/* the blocks better be within the mapsize. */\n\tif (blkno + nblocks > bmp->db_mapsize) {\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ipbmap->i_sb, \"blocks are outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute delta of transaction lsn from log syncpt */\n\tlsn = tblk->lsn;\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\tlogdiff(difft, lsn, log);\n\n\t/*\n\t * update the block state a dmap at a time.\n\t */\n\tmp = NULL;\n\tlastlblkno = 0;\n\tfor (rem = nblocks; rem > 0; rem -= nblks, blkno += nblks) {\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tif (lblkno != lastlblkno) {\n\t\t\tif (mp) {\n\t\t\t\twrite_metapage(mp);\n\t\t\t}\n\n\t\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE,\n\t\t\t\t\t   0);\n\t\t\tif (mp == NULL)\n\t\t\t\treturn -EIO;\n\t\t\tmetapage_wait_for_io(mp);\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the bit number and word within the dmap of\n\t\t * the starting block.  also determine how many blocks\n\t\t * are to be updated within this dmap.\n\t\t */\n\t\tdbitno = blkno & (BPERDMAP - 1);\n\t\tword = dbitno >> L2DBWORD;\n\t\tnblks = min(rem, (s64)BPERDMAP - dbitno);\n\n\t\t/* update the bits of the dmap words. the first and last\n\t\t * words may only have a subset of their bits updated. if\n\t\t * this is the case, we'll work against that word (i.e.\n\t\t * partial first and/or last) only in a single pass.  a\n\t\t * single pass will also be used to update all words that\n\t\t * are to have all their bits updated.\n\t\t */\n\t\tfor (rbits = nblks; rbits > 0;\n\t\t     rbits -= nbits, dbitno += nbits) {\n\t\t\t/* determine the bit number within the word and\n\t\t\t * the number of bits within the word.\n\t\t\t */\n\t\t\twbitno = dbitno & (DBWORD - 1);\n\t\t\tnbits = min(rbits, DBWORD - wbitno);\n\n\t\t\t/* check if only part of the word is to be updated. */\n\t\t\tif (nbits < DBWORD) {\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in this word.\n\t\t\t\t */\n\t\t\t\tmask =\n\t\t\t\t    (ONES << (DBWORD - nbits) >> wbitno);\n\t\t\t\tif (free)\n\t\t\t\t\tdp->pmap[word] &=\n\t\t\t\t\t    cpu_to_le32(~mask);\n\t\t\t\telse\n\t\t\t\t\tdp->pmap[word] |=\n\t\t\t\t\t    cpu_to_le32(mask);\n\n\t\t\t\tword += 1;\n\t\t\t} else {\n\t\t\t\t/* one or more words are to have all\n\t\t\t\t * their bits updated.  determine how\n\t\t\t\t * many words and how many bits.\n\t\t\t\t */\n\t\t\t\tnwords = rbits >> L2DBWORD;\n\t\t\t\tnbits = nwords << L2DBWORD;\n\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in these words.\n\t\t\t\t */\n\t\t\t\tif (free)\n\t\t\t\t\tmemset(&dp->pmap[word], 0,\n\t\t\t\t\t       nwords * 4);\n\t\t\t\telse\n\t\t\t\t\tmemset(&dp->pmap[word], (int) ONES,\n\t\t\t\t\t       nwords * 4);\n\n\t\t\t\tword += nwords;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * update dmap lsn\n\t\t */\n\t\tif (lblkno == lastlblkno)\n\t\t\tcontinue;\n\n\t\tlastlblkno = lblkno;\n\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (mp->lsn != 0) {\n\t\t\t/* inherit older/smaller lsn */\n\t\t\tlogdiff(diffp, mp->lsn, log);\n\t\t\tif (difft < diffp) {\n\t\t\t\tmp->lsn = lsn;\n\n\t\t\t\t/* move bp after tblock in logsync list */\n\t\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t\t}\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\tif (difft > diffp)\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t} else {\n\t\t\tmp->log = log;\n\t\t\tmp->lsn = lsn;\n\n\t\t\t/* insert bp after tblock in logsync list */\n\t\t\tlog->count++;\n\t\t\tlist_add(&mp->synclist, &tblk->synclist);\n\n\t\t\tmp->clsn = tblk->clsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n\n\t/* write the last buffer. */\n\tif (mp) {\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint\ndbUpdatePMap(struct inode *ipbmap,\n\t     int free, s64 blkno, s64 nblocks, struct tblock * tblk)\n{\n\tint nblks, dbitno, wbitno, rbits;\n\tint word, nbits, nwords;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\ts64 lblkno, rem, lastlblkno;\n\tu32 mask;\n\tstruct dmap *dp;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\t/* the blocks better be within the mapsize. */\n\tif (blkno + nblocks > bmp->db_mapsize) {\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ipbmap->i_sb, \"blocks are outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute delta of transaction lsn from log syncpt */\n\tlsn = tblk->lsn;\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\tlogdiff(difft, lsn, log);\n\n\t/*\n\t * update the block state a dmap at a time.\n\t */\n\tmp = NULL;\n\tlastlblkno = 0;\n\tfor (rem = nblocks; rem > 0; rem -= nblks, blkno += nblks) {\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tif (lblkno != lastlblkno) {\n\t\t\tif (mp) {\n\t\t\t\twrite_metapage(mp);\n\t\t\t}\n\n\t\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE,\n\t\t\t\t\t   0);\n\t\t\tif (mp == NULL)\n\t\t\t\treturn -EIO;\n\t\t\tmetapage_wait_for_io(mp);\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the bit number and word within the dmap of\n\t\t * the starting block.  also determine how many blocks\n\t\t * are to be updated within this dmap.\n\t\t */\n\t\tdbitno = blkno & (BPERDMAP - 1);\n\t\tword = dbitno >> L2DBWORD;\n\t\tnblks = min(rem, (s64)BPERDMAP - dbitno);\n\n\t\t/* update the bits of the dmap words. the first and last\n\t\t * words may only have a subset of their bits updated. if\n\t\t * this is the case, we'll work against that word (i.e.\n\t\t * partial first and/or last) only in a single pass.  a\n\t\t * single pass will also be used to update all words that\n\t\t * are to have all their bits updated.\n\t\t */\n\t\tfor (rbits = nblks; rbits > 0;\n\t\t     rbits -= nbits, dbitno += nbits) {\n\t\t\t/* determine the bit number within the word and\n\t\t\t * the number of bits within the word.\n\t\t\t */\n\t\t\twbitno = dbitno & (DBWORD - 1);\n\t\t\tnbits = min(rbits, DBWORD - wbitno);\n\n\t\t\t/* check if only part of the word is to be updated. */\n\t\t\tif (nbits < DBWORD) {\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in this word.\n\t\t\t\t */\n\t\t\t\tmask =\n\t\t\t\t    (ONES << (DBWORD - nbits) >> wbitno);\n\t\t\t\tif (free)\n\t\t\t\t\tdp->pmap[word] &=\n\t\t\t\t\t    cpu_to_le32(~mask);\n\t\t\t\telse\n\t\t\t\t\tdp->pmap[word] |=\n\t\t\t\t\t    cpu_to_le32(mask);\n\n\t\t\t\tword += 1;\n\t\t\t} else {\n\t\t\t\t/* one or more words are to have all\n\t\t\t\t * their bits updated.  determine how\n\t\t\t\t * many words and how many bits.\n\t\t\t\t */\n\t\t\t\tnwords = rbits >> L2DBWORD;\n\t\t\t\tnbits = nwords << L2DBWORD;\n\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in these words.\n\t\t\t\t */\n\t\t\t\tif (free)\n\t\t\t\t\tmemset(&dp->pmap[word], 0,\n\t\t\t\t\t       nwords * 4);\n\t\t\t\telse\n\t\t\t\t\tmemset(&dp->pmap[word], (int) ONES,\n\t\t\t\t\t       nwords * 4);\n\n\t\t\t\tword += nwords;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * update dmap lsn\n\t\t */\n\t\tif (lblkno == lastlblkno)\n\t\t\tcontinue;\n\n\t\tlastlblkno = lblkno;\n\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (mp->lsn != 0) {\n\t\t\t/* inherit older/smaller lsn */\n\t\t\tlogdiff(diffp, mp->lsn, log);\n\t\t\tif (difft < diffp) {\n\t\t\t\tmp->lsn = lsn;\n\n\t\t\t\t/* move bp after tblock in logsync list */\n\t\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t\t}\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\tif (difft > diffp)\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t} else {\n\t\t\tmp->log = log;\n\t\t\tmp->lsn = lsn;\n\n\t\t\t/* insert bp after tblock in logsync list */\n\t\t\tlog->count++;\n\t\t\tlist_add(&mp->synclist, &tblk->synclist);\n\n\t\t\tmp->clsn = tblk->clsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n\n\t/* write the last buffer. */\n\tif (mp) {\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "pxd"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "pxd"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"allocPMap: xaddr:0x%lx xlen:%d\"",
            "(ulong) xaddr",
            "xlen"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"allocPMap: xaddr:0x%lx xlen:%d\"",
            "(ulong) xaddr",
            "xlen"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\t\tstruct tblock * tblk)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\t/*\n\t * allocate from persistent map;\n\t */\n\tif (maplock->flag & mlckALLOCXADLIST) {\n\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\txad = xadlistlock->xdlist;\n\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED)) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbUpdatePMap(ipbmap, false, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t\t\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t} else if (maplock->flag & mlckALLOCPXD) {\n\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\tdbUpdatePMap(ipbmap, false, xaddr, (s64) xlen, tblk);\n\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\", (ulong) xaddr, xlen);\n\t} else {\t\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\tpxd = pxdlistlock->xdlist;\n\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\txaddr = addressPXD(pxd);\n\t\t\txlen = lengthPXD(pxd);\n\t\t\tdbUpdatePMap(ipbmap, false, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "txUpdateMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2293-2417",
    "snippet": "static void txUpdateMap(struct tblock * tblk)\n{\n\tstruct inode *ip;\n\tstruct inode *ipimap;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\tstruct pxd_lock pxdlock;\n\tint maptype;\n\tint k, nlock;\n\tstruct metapage *mp = NULL;\n\n\tipimap = JFS_SBI(tblk->sb)->ipimap;\n\n\tmaptype = (tblk->xflag & COMMIT_PMAP) ? COMMIT_PMAP : COMMIT_PWMAP;\n\n\n\t/*\n\t *\tupdate block allocation map\n\t *\n\t * update allocation state in pmap (and wmap) and\n\t * update lsn of the pmap page;\n\t */\n\t/*\n\t * scan each tlock/page of transaction for block allocation/free:\n\t *\n\t * for each tlock/page of transaction, update map.\n\t *  ? are there tlock for pmap and pwmap at the same time ?\n\t */\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif ((tlck->flag & tlckUPDATEMAP) == 0)\n\t\t\tcontinue;\n\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\t/*\n\t\t\t * Another thread may attempt to reuse freed space\n\t\t\t * immediately, so we want to get rid of the metapage\n\t\t\t * before anyone else has a chance to get it.\n\t\t\t * Lock metapage, update maps, then invalidate\n\t\t\t * the metapage.\n\t\t\t */\n\t\t\tmp = tlck->mp;\n\t\t\tASSERT(mp->xflag & COMMIT_PAGE);\n\t\t\tgrab_metapage(mp);\n\t\t}\n\n\t\t/*\n\t\t * extent list:\n\t\t * . in-line PXD list:\n\t\t * . out-of-line XAD list:\n\t\t */\n\t\tmaplock = (struct maplock *) & tlck->lock;\n\t\tnlock = maplock->index;\n\n\t\tfor (k = 0; k < nlock; k++, maplock++) {\n\t\t\t/*\n\t\t\t * allocate blocks in persistent map:\n\t\t\t *\n\t\t\t * blocks have been allocated from wmap at alloc time;\n\t\t\t */\n\t\t\tif (maplock->flag & mlckALLOC) {\n\t\t\t\ttxAllocPMap(ipimap, maplock, tblk);\n\t\t\t}\n\t\t\t/*\n\t\t\t * free blocks in persistent and working map:\n\t\t\t * blocks will be freed in pmap and then in wmap;\n\t\t\t *\n\t\t\t * ? tblock specifies the PMAP/PWMAP based upon\n\t\t\t * transaction\n\t\t\t *\n\t\t\t * free blocks in persistent map:\n\t\t\t * blocks will be freed from wmap at last reference\n\t\t\t * release of the object for regular files;\n\t\t\t *\n\t\t\t * Alway free blocks from both persistent & working\n\t\t\t * maps for directories\n\t\t\t */\n\t\t\telse {\t/* (maplock->flag & mlckFREE) */\n\n\t\t\t\tif (tlck->flag & tlckDIRECTORY)\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, COMMIT_PWMAP);\n\t\t\t\telse\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, maptype);\n\t\t\t}\n\t\t}\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\tif (!(tblk->flag & tblkGC_LAZY)) {\n\t\t\t\t/* This is equivalent to txRelease */\n\t\t\t\tASSERT(mp->lid == lid);\n\t\t\t\ttlck->mp->lid = 0;\n\t\t\t}\n\t\t\tassert(mp->nohomeok == 1);\n\t\t\tmetapage_homeok(mp);\n\t\t\tdiscard_metapage(mp);\n\t\t\ttlck->mp = NULL;\n\t\t}\n\t}\n\t/*\n\t *\tupdate inode allocation map\n\t *\n\t * update allocation state in pmap and\n\t * update lsn of the pmap page;\n\t * update in-memory inode flag/state\n\t *\n\t * unlock mapper/write lock\n\t */\n\tif (tblk->xflag & COMMIT_CREATE) {\n\t\tdiUpdatePMap(ipimap, tblk->ino, false, tblk);\n\t\t/* update persistent block allocation map\n\t\t * for the allocation of inode extent;\n\t\t */\n\t\tpxdlock.flag = mlckALLOCPXD;\n\t\tpxdlock.pxd = tblk->u.ixpxd;\n\t\tpxdlock.index = 1;\n\t\ttxAllocPMap(ipimap, (struct maplock *) & pxdlock, tblk);\n\t} else if (tblk->xflag & COMMIT_DELETE) {\n\t\tip = tblk->u.ip;\n\t\tdiUpdatePMap(ipimap, ip->i_ino, true, tblk);\n\t\tiput(ip);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "diUpdatePMap",
          "args": [
            "ipimap",
            "ip->i_ino",
            "true",
            "tblk"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "diUpdatePMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2736-2849",
          "snippet": "int\ndiUpdatePMap(struct inode *ipimap,\n\t     unsigned long inum, bool is_free, struct tblock * tblk)\n{\n\tint rc;\n\tstruct iag *iagp;\n\tstruct metapage *mp;\n\tint iagno, ino, extno, bitno;\n\tstruct inomap *imap;\n\tu32 mask;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\timap = JFS_IP(ipimap)->i_imap;\n\t/* get the iag number containing the inode */\n\tiagno = INOTOIAG(inum);\n\t/* make sure that the iag is contained within the map */\n\tif (iagno >= imap->im_nextiag) {\n\t\tjfs_error(ipimap->i_sb, \"the iag is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\t/* read the iag */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\trc = diIAGRead(imap, iagno, &mp);\n\tIREAD_UNLOCK(ipimap);\n\tif (rc)\n\t\treturn (rc);\n\tmetapage_wait_for_io(mp);\n\tiagp = (struct iag *) mp->data;\n\t/* get the inode number and extent number of the inode within\n\t * the iag and the inode number within the extent.\n\t */\n\tino = inum & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\tmask = HIGHORDER >> bitno;\n\t/*\n\t * mark the inode free in persistent map:\n\t */\n\tif (is_free) {\n\t\t/* The inode should have been allocated both in working\n\t\t * map and in persistent map;\n\t\t * the inode will be freed from working map at the release\n\t\t * of last reference release;\n\t\t */\n\t\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"inode %ld not marked as allocated in wmap!\\n\",\n\t\t\t\t  inum);\n\t\t}\n\t\tif (!(le32_to_cpu(iagp->pmap[extno]) & mask)) {\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"inode %ld not marked as allocated in pmap!\\n\",\n\t\t\t\t  inum);\n\t\t}\n\t\t/* update the bitmap for the extent of the freed inode */\n\t\tiagp->pmap[extno] &= cpu_to_le32(~mask);\n\t}\n\t/*\n\t * mark the inode allocated in persistent map:\n\t */\n\telse {\n\t\t/* The inode should be already allocated in the working map\n\t\t * and should be free in persistent map;\n\t\t */\n\t\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"the inode is not allocated in the working map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"the inode is not free in the persistent map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* update the bitmap for the extent of the allocated inode */\n\t\tiagp->pmap[extno] |= cpu_to_le32(mask);\n\t}\n\t/*\n\t * update iag lsn\n\t */\n\tlsn = tblk->lsn;\n\tlog = JFS_SBI(tblk->sb)->log;\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn != 0) {\n\t\t/* inherit older/smaller lsn */\n\t\tlogdiff(difft, lsn, log);\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tif (difft < diffp) {\n\t\t\tmp->lsn = lsn;\n\t\t\t/* move mp after tblock in logsync list */\n\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t}\n\t\t/* inherit younger/larger clsn */\n\t\tassert(mp->clsn);\n\t\tlogdiff(difft, tblk->clsn, log);\n\t\tlogdiff(diffp, mp->clsn, log);\n\t\tif (difft > diffp)\n\t\t\tmp->clsn = tblk->clsn;\n\t} else {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\t/* insert mp after tblock in logsync list */\n\t\tlog->count++;\n\t\tlist_add(&mp->synclist, &tblk->synclist);\n\t\tmp->clsn = tblk->clsn;\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n\twrite_metapage(mp);\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diFindFree(u32, int);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint\ndiUpdatePMap(struct inode *ipimap,\n\t     unsigned long inum, bool is_free, struct tblock * tblk)\n{\n\tint rc;\n\tstruct iag *iagp;\n\tstruct metapage *mp;\n\tint iagno, ino, extno, bitno;\n\tstruct inomap *imap;\n\tu32 mask;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\timap = JFS_IP(ipimap)->i_imap;\n\t/* get the iag number containing the inode */\n\tiagno = INOTOIAG(inum);\n\t/* make sure that the iag is contained within the map */\n\tif (iagno >= imap->im_nextiag) {\n\t\tjfs_error(ipimap->i_sb, \"the iag is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\t/* read the iag */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\trc = diIAGRead(imap, iagno, &mp);\n\tIREAD_UNLOCK(ipimap);\n\tif (rc)\n\t\treturn (rc);\n\tmetapage_wait_for_io(mp);\n\tiagp = (struct iag *) mp->data;\n\t/* get the inode number and extent number of the inode within\n\t * the iag and the inode number within the extent.\n\t */\n\tino = inum & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\tmask = HIGHORDER >> bitno;\n\t/*\n\t * mark the inode free in persistent map:\n\t */\n\tif (is_free) {\n\t\t/* The inode should have been allocated both in working\n\t\t * map and in persistent map;\n\t\t * the inode will be freed from working map at the release\n\t\t * of last reference release;\n\t\t */\n\t\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"inode %ld not marked as allocated in wmap!\\n\",\n\t\t\t\t  inum);\n\t\t}\n\t\tif (!(le32_to_cpu(iagp->pmap[extno]) & mask)) {\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"inode %ld not marked as allocated in pmap!\\n\",\n\t\t\t\t  inum);\n\t\t}\n\t\t/* update the bitmap for the extent of the freed inode */\n\t\tiagp->pmap[extno] &= cpu_to_le32(~mask);\n\t}\n\t/*\n\t * mark the inode allocated in persistent map:\n\t */\n\telse {\n\t\t/* The inode should be already allocated in the working map\n\t\t * and should be free in persistent map;\n\t\t */\n\t\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"the inode is not allocated in the working map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"the inode is not free in the persistent map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* update the bitmap for the extent of the allocated inode */\n\t\tiagp->pmap[extno] |= cpu_to_le32(mask);\n\t}\n\t/*\n\t * update iag lsn\n\t */\n\tlsn = tblk->lsn;\n\tlog = JFS_SBI(tblk->sb)->log;\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn != 0) {\n\t\t/* inherit older/smaller lsn */\n\t\tlogdiff(difft, lsn, log);\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tif (difft < diffp) {\n\t\t\tmp->lsn = lsn;\n\t\t\t/* move mp after tblock in logsync list */\n\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t}\n\t\t/* inherit younger/larger clsn */\n\t\tassert(mp->clsn);\n\t\tlogdiff(difft, tblk->clsn, log);\n\t\tlogdiff(diffp, mp->clsn, log);\n\t\tif (difft > diffp)\n\t\t\tmp->clsn = tblk->clsn;\n\t} else {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\t/* insert mp after tblock in logsync list */\n\t\tlog->count++;\n\t\tlist_add(&mp->synclist, &tblk->synclist);\n\t\tmp->clsn = tblk->clsn;\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n\twrite_metapage(mp);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txAllocPMap",
          "args": [
            "ipimap",
            "(struct maplock *) & pxdlock",
            "tblk"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "txAllocPMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2439-2488",
          "snippet": "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\t\tstruct tblock * tblk)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\t/*\n\t * allocate from persistent map;\n\t */\n\tif (maplock->flag & mlckALLOCXADLIST) {\n\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\txad = xadlistlock->xdlist;\n\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED)) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbUpdatePMap(ipbmap, false, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t\t\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t} else if (maplock->flag & mlckALLOCPXD) {\n\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\tdbUpdatePMap(ipbmap, false, xaddr, (s64) xlen, tblk);\n\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\", (ulong) xaddr, xlen);\n\t} else {\t\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\tpxd = pxdlistlock->xdlist;\n\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\txaddr = addressPXD(pxd);\n\t\t\txlen = lengthPXD(pxd);\n\t\t\tdbUpdatePMap(ipbmap, false, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\t\tstruct tblock * tblk)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\t/*\n\t * allocate from persistent map;\n\t */\n\tif (maplock->flag & mlckALLOCXADLIST) {\n\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\txad = xadlistlock->xdlist;\n\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED)) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbUpdatePMap(ipbmap, false, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t\t\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t} else if (maplock->flag & mlckALLOCPXD) {\n\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\tdbUpdatePMap(ipbmap, false, xaddr, (s64) xlen, tblk);\n\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\", (ulong) xaddr, xlen);\n\t} else {\t\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\tpxd = pxdlistlock->xdlist;\n\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\txaddr = addressPXD(pxd);\n\t\t\txlen = lengthPXD(pxd);\n\t\t\tdbUpdatePMap(ipbmap, false, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_metapage",
          "args": [
            "mp"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "discard_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "97-102",
          "snippet": "static inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_discard\t4",
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_discard\t4\n#define META_dirty\t2\n\nstatic inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "metapage_homeok",
          "args": [
            "mp"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_homeok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "135-140",
          "snippet": "static inline void metapage_homeok(struct metapage *mp)\n{\n\thold_metapage(mp);\n\t_metapage_homeok(mp);\n\tput_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\nstatic inline void metapage_homeok(struct metapage *mp)\n{\n\thold_metapage(mp);\n\t_metapage_homeok(mp);\n\tput_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mp->nohomeok == 1"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->lid == lid"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txFreeMap",
          "args": [
            "ipimap",
            "maplock",
            "tblk",
            "maptype"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "txFreeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2497-2589",
          "snippet": "void txFreeMap(struct inode *ip,\n\t       struct maplock * maplock, struct tblock * tblk, int maptype)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\tjfs_info(\"txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x\",\n\t\t tblk, maplock, maptype);\n\n\t/*\n\t * free from persistent map;\n\t */\n\tif (maptype == COMMIT_PMAP || maptype == COMMIT_PWMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\tif (!(xad->flag & XAD_NEW)) {\n\t\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx \"\n\t\t\t\t\t\t \"xlen:%d\",\n\t\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbUpdatePMap(ipbmap, true, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * free from working map;\n\t */\n\tif (maptype == COMMIT_PWMAP || maptype == COMMIT_WMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\txad->flag = 0;\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckFREEPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txFreeMap(struct inode *ip,\n\t       struct maplock * maplock, struct tblock * tblk, int maptype)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\tjfs_info(\"txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x\",\n\t\t tblk, maplock, maptype);\n\n\t/*\n\t * free from persistent map;\n\t */\n\tif (maptype == COMMIT_PMAP || maptype == COMMIT_PWMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\tif (!(xad->flag & XAD_NEW)) {\n\t\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx \"\n\t\t\t\t\t\t \"xlen:%d\",\n\t\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbUpdatePMap(ipbmap, true, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * free from working map;\n\t */\n\tif (maptype == COMMIT_PWMAP || maptype == COMMIT_WMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\txad->flag = 0;\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckFREEPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_metapage",
          "args": [
            "mp"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "grab_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "700-708",
          "snippet": "void grab_metapage(struct metapage * mp)\n{\n\tjfs_info(\"grab_metapage: mp = 0x%p\", mp);\n\tpage_cache_get(mp->page);\n\tlock_page(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid grab_metapage(struct metapage * mp)\n{\n\tjfs_info(\"grab_metapage: mp = 0x%p\", mp);\n\tpage_cache_get(mp->page);\n\tlock_page(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->xflag & COMMIT_PAGE"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "tblk->sb"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void txUpdateMap(struct tblock * tblk)\n{\n\tstruct inode *ip;\n\tstruct inode *ipimap;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\tstruct pxd_lock pxdlock;\n\tint maptype;\n\tint k, nlock;\n\tstruct metapage *mp = NULL;\n\n\tipimap = JFS_SBI(tblk->sb)->ipimap;\n\n\tmaptype = (tblk->xflag & COMMIT_PMAP) ? COMMIT_PMAP : COMMIT_PWMAP;\n\n\n\t/*\n\t *\tupdate block allocation map\n\t *\n\t * update allocation state in pmap (and wmap) and\n\t * update lsn of the pmap page;\n\t */\n\t/*\n\t * scan each tlock/page of transaction for block allocation/free:\n\t *\n\t * for each tlock/page of transaction, update map.\n\t *  ? are there tlock for pmap and pwmap at the same time ?\n\t */\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif ((tlck->flag & tlckUPDATEMAP) == 0)\n\t\t\tcontinue;\n\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\t/*\n\t\t\t * Another thread may attempt to reuse freed space\n\t\t\t * immediately, so we want to get rid of the metapage\n\t\t\t * before anyone else has a chance to get it.\n\t\t\t * Lock metapage, update maps, then invalidate\n\t\t\t * the metapage.\n\t\t\t */\n\t\t\tmp = tlck->mp;\n\t\t\tASSERT(mp->xflag & COMMIT_PAGE);\n\t\t\tgrab_metapage(mp);\n\t\t}\n\n\t\t/*\n\t\t * extent list:\n\t\t * . in-line PXD list:\n\t\t * . out-of-line XAD list:\n\t\t */\n\t\tmaplock = (struct maplock *) & tlck->lock;\n\t\tnlock = maplock->index;\n\n\t\tfor (k = 0; k < nlock; k++, maplock++) {\n\t\t\t/*\n\t\t\t * allocate blocks in persistent map:\n\t\t\t *\n\t\t\t * blocks have been allocated from wmap at alloc time;\n\t\t\t */\n\t\t\tif (maplock->flag & mlckALLOC) {\n\t\t\t\ttxAllocPMap(ipimap, maplock, tblk);\n\t\t\t}\n\t\t\t/*\n\t\t\t * free blocks in persistent and working map:\n\t\t\t * blocks will be freed in pmap and then in wmap;\n\t\t\t *\n\t\t\t * ? tblock specifies the PMAP/PWMAP based upon\n\t\t\t * transaction\n\t\t\t *\n\t\t\t * free blocks in persistent map:\n\t\t\t * blocks will be freed from wmap at last reference\n\t\t\t * release of the object for regular files;\n\t\t\t *\n\t\t\t * Alway free blocks from both persistent & working\n\t\t\t * maps for directories\n\t\t\t */\n\t\t\telse {\t/* (maplock->flag & mlckFREE) */\n\n\t\t\t\tif (tlck->flag & tlckDIRECTORY)\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, COMMIT_PWMAP);\n\t\t\t\telse\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, maptype);\n\t\t\t}\n\t\t}\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\tif (!(tblk->flag & tblkGC_LAZY)) {\n\t\t\t\t/* This is equivalent to txRelease */\n\t\t\t\tASSERT(mp->lid == lid);\n\t\t\t\ttlck->mp->lid = 0;\n\t\t\t}\n\t\t\tassert(mp->nohomeok == 1);\n\t\t\tmetapage_homeok(mp);\n\t\t\tdiscard_metapage(mp);\n\t\t\ttlck->mp = NULL;\n\t\t}\n\t}\n\t/*\n\t *\tupdate inode allocation map\n\t *\n\t * update allocation state in pmap and\n\t * update lsn of the pmap page;\n\t * update in-memory inode flag/state\n\t *\n\t * unlock mapper/write lock\n\t */\n\tif (tblk->xflag & COMMIT_CREATE) {\n\t\tdiUpdatePMap(ipimap, tblk->ino, false, tblk);\n\t\t/* update persistent block allocation map\n\t\t * for the allocation of inode extent;\n\t\t */\n\t\tpxdlock.flag = mlckALLOCPXD;\n\t\tpxdlock.pxd = tblk->u.ixpxd;\n\t\tpxdlock.index = 1;\n\t\ttxAllocPMap(ipimap, (struct maplock *) & pxdlock, tblk);\n\t} else if (tblk->xflag & COMMIT_DELETE) {\n\t\tip = tblk->u.ip;\n\t\tdiUpdatePMap(ipimap, ip->i_ino, true, tblk);\n\t\tiput(ip);\n\t}\n}"
  },
  {
    "function_name": "txForce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2225-2283",
    "snippet": "static void txForce(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\n\t/*\n\t * reverse the order of transaction tlocks in\n\t * careful update order of address index pages\n\t * (right to left, bottom up)\n\t */\n\ttlck = lid_to_tlock(tblk->next);\n\tlid = tlck->next;\n\ttlck->next = 0;\n\twhile (lid) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\ttlck->next = tblk->next;\n\t\ttblk->next = lid;\n\t\tlid = next;\n\t}\n\n\t/*\n\t * synchronously write the page, and\n\t * hold the page for txUpdateMap();\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\tif (tlck->flag & tlckWRITEPAGE) {\n\t\t\t\ttlck->flag &= ~tlckWRITEPAGE;\n\n\t\t\t\t/* do not release page to freelist */\n\t\t\t\tforce_metapage(mp);\n#if 0\n\t\t\t\t/*\n\t\t\t\t * The \"right\" thing to do here is to\n\t\t\t\t * synchronously write the metadata.\n\t\t\t\t * With the current implementation this\n\t\t\t\t * is hard since write_metapage requires\n\t\t\t\t * us to kunmap & remap the page.  If we\n\t\t\t\t * have tlocks pointing into the metadata\n\t\t\t\t * pages, we don't want to do this.  I think\n\t\t\t\t * we can get by with synchronously writing\n\t\t\t\t * the pages when they are released.\n\t\t\t\t */\n\t\t\t\tassert(mp->nohomeok);\n\t\t\t\tset_bit(META_dirty, &mp->flag);\n\t\t\t\tset_bit(META_sync, &mp->flag);\n#endif\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "META_sync",
            "&mp->flag"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mp->nohomeok"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_metapage",
          "args": [
            "mp"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "force_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "710-722",
          "snippet": "void force_metapage(struct metapage *mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"force_metapage: mp = 0x%p\", mp);\n\tset_bit(META_forcewrite, &mp->flag);\n\tclear_bit(META_sync, &mp->flag);\n\tpage_cache_get(page);\n\tlock_page(page);\n\tset_page_dirty(page);\n\twrite_one_page(page, 1);\n\tclear_bit(META_forcewrite, &mp->flag);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid force_metapage(struct metapage *mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"force_metapage: mp = 0x%p\", mp);\n\tset_bit(META_forcewrite, &mp->flag);\n\tclear_bit(META_sync, &mp->flag);\n\tpage_cache_get(page);\n\tlock_page(page);\n\tset_page_dirty(page);\n\twrite_one_page(page, 1);\n\tclear_bit(META_forcewrite, &mp->flag);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "tblk->next"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void txForce(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\n\t/*\n\t * reverse the order of transaction tlocks in\n\t * careful update order of address index pages\n\t * (right to left, bottom up)\n\t */\n\ttlck = lid_to_tlock(tblk->next);\n\tlid = tlck->next;\n\ttlck->next = 0;\n\twhile (lid) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\ttlck->next = tblk->next;\n\t\ttblk->next = lid;\n\t\tlid = next;\n\t}\n\n\t/*\n\t * synchronously write the page, and\n\t * hold the page for txUpdateMap();\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\tif (tlck->flag & tlckWRITEPAGE) {\n\t\t\t\ttlck->flag &= ~tlckWRITEPAGE;\n\n\t\t\t\t/* do not release page to freelist */\n\t\t\t\tforce_metapage(mp);\n#if 0\n\t\t\t\t/*\n\t\t\t\t * The \"right\" thing to do here is to\n\t\t\t\t * synchronously write the metadata.\n\t\t\t\t * With the current implementation this\n\t\t\t\t * is hard since write_metapage requires\n\t\t\t\t * us to kunmap & remap the page.  If we\n\t\t\t\t * have tlocks pointing into the metadata\n\t\t\t\t * pages, we don't want to do this.  I think\n\t\t\t\t * we can get by with synchronously writing\n\t\t\t\t * the pages when they are released.\n\t\t\t\t */\n\t\t\t\tassert(mp->nohomeok);\n\t\t\t\tset_bit(META_dirty, &mp->flag);\n\t\t\t\tset_bit(META_sync, &mp->flag);\n#endif\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "txEA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2173-2217",
    "snippet": "void txEA(tid_t tid, struct inode *ip, dxd_t * oldea, dxd_t * newea)\n{\n\tstruct tlock *tlck = NULL;\n\tstruct pxd_lock *maplock = NULL, *pxdlock = NULL;\n\n\t/*\n\t * format maplock for alloc of new EA extent\n\t */\n\tif (newea) {\n\t\t/* Since the newea could be a completely zeroed entry we need to\n\t\t * check for the two flags which indicate we should actually\n\t\t * commit new EA data\n\t\t */\n\t\tif (newea->flag & DXD_EXTENT) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tpxdlock->flag = mlckALLOCPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressDXD(newea));\n\t\t\tPXDlength(&pxdlock->pxd, lengthDXD(newea));\n\t\t\tpxdlock++;\n\t\t\tmaplock->index = 1;\n\t\t} else if (newea->flag & DXD_INLINE) {\n\t\t\ttlck = NULL;\n\n\t\t\tset_cflag(COMMIT_Inlineea, ip);\n\t\t}\n\t}\n\n\t/*\n\t * format maplock for free of old EA extent\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip) && oldea->flag & DXD_EXTENT) {\n\t\tif (tlck == NULL) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tmaplock->index = 0;\n\t\t}\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, addressDXD(oldea));\n\t\tPXDlength(&pxdlock->pxd, lengthDXD(oldea));\n\t\tmaplock->index++;\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "&pxdlock->pxd",
            "lengthDXD(oldea)"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthDXD",
          "args": [
            "oldea"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "&pxdlock->pxd",
            "addressDXD(oldea)"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressDXD",
          "args": [
            "oldea"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txMaplock",
          "args": [
            "tid",
            "ip",
            "tlckMAP"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "txMaplock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "995-1061",
          "snippet": "struct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cflag",
          "args": [
            "COMMIT_Inlineea",
            "ip"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthDXD",
          "args": [
            "newea"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressDXD",
          "args": [
            "newea"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nvoid txEA(tid_t tid, struct inode *ip, dxd_t * oldea, dxd_t * newea)\n{\n\tstruct tlock *tlck = NULL;\n\tstruct pxd_lock *maplock = NULL, *pxdlock = NULL;\n\n\t/*\n\t * format maplock for alloc of new EA extent\n\t */\n\tif (newea) {\n\t\t/* Since the newea could be a completely zeroed entry we need to\n\t\t * check for the two flags which indicate we should actually\n\t\t * commit new EA data\n\t\t */\n\t\tif (newea->flag & DXD_EXTENT) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tpxdlock->flag = mlckALLOCPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressDXD(newea));\n\t\t\tPXDlength(&pxdlock->pxd, lengthDXD(newea));\n\t\t\tpxdlock++;\n\t\t\tmaplock->index = 1;\n\t\t} else if (newea->flag & DXD_INLINE) {\n\t\t\ttlck = NULL;\n\n\t\t\tset_cflag(COMMIT_Inlineea, ip);\n\t\t}\n\t}\n\n\t/*\n\t * format maplock for free of old EA extent\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip) && oldea->flag & DXD_EXTENT) {\n\t\tif (tlck == NULL) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tmaplock->index = 0;\n\t\t}\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, addressDXD(oldea));\n\t\tPXDlength(&pxdlock->pxd, lengthDXD(oldea));\n\t\tmaplock->index++;\n\t}\n}"
  },
  {
    "function_name": "mapLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "2086-2165",
    "snippet": "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\t   struct tlock * tlck)\n{\n\tstruct pxd_lock *pxdlock;\n\tint i, nlock;\n\tpxd_t *pxd;\n\n\t/*\n\t *\tpage relocation: free the source page extent\n\t *\n\t * a maplock for txUpdateMap() for free of the page\n\t * has been formatted at txLock() time saving the src\n\t * relocated page address;\n\t */\n\tif (tlck->type & tlckRELOCATE) {\n\t\t/* log LOG_NOREDOPAGE of the old relocated page\n\t\t * for logredo() to start NoRedoPage filter;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxd = &lrd->log.redopage.pxd;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* (N.B. currently, logredo() does NOT update bmap\n\t\t * for free of the page itself for (LOG_XTREE|LOG_NOREDOPAGE);\n\t\t * if page free from relocation, LOG_UPDATEMAP log is\n\t\t * specifically generated now for logredo()\n\t\t * to update bmap for free of src relocated page;\n\t\t * (new flag LOG_RELOCATE may be introduced which will\n\t\t * inform logredo() to start NORedoPage filter and also\n\t\t * update block allocation map at the same time, thus\n\t\t * avoiding an extra log write);\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\n\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* a maplock for txUpdateMap() for free of the page\n\t\t * has been formatted at txLock() time;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\treturn;\n\t}\n\t/*\n\n\t * Otherwise it's not a relocate request\n\t *\n\t */\n\telse {\n\t\t/* log LOG_UPDATEMAP for logredo() to update bmap for\n\t\t * free of truncated/relocated delta extent of the data;\n\t\t * e.g.: external EA extent, relocated/truncated extent\n\t\t * from xtTailgate();\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tnlock = pxdlock->index;\n\t\tfor (i = 0; i < nlock; i++, pxdlock++) {\n\t\t\tif (pxdlock->flag & mlckALLOCPXD)\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_ALLOCPXD);\n\t\t\telse\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t\tjfs_info(\"mapLog: xaddr:0x%lx xlen:0x%x\",\n\t\t\t\t (ulong) addressPXD(&pxdlock->pxd),\n\t\t\t\t lengthPXD(&pxdlock->pxd));\n\t\t}\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"mapLog: xaddr:0x%lx xlen:0x%x\"",
            "(ulong) addressPXD(&pxdlock->pxd)",
            "lengthPXD(&pxdlock->pxd)"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "&pxdlock->pxd"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&pxdlock->pxd"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, NULL)"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "NULL"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "lmLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "238-343",
          "snippet": "int lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nint lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_FREEPXD"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_ALLOCPXD"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_UPDATEMAP"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, NULL)"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_FREEPXD"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_UPDATEMAP"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, NULL)"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_NOREDOPAGE"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\t   struct tlock * tlck)\n{\n\tstruct pxd_lock *pxdlock;\n\tint i, nlock;\n\tpxd_t *pxd;\n\n\t/*\n\t *\tpage relocation: free the source page extent\n\t *\n\t * a maplock for txUpdateMap() for free of the page\n\t * has been formatted at txLock() time saving the src\n\t * relocated page address;\n\t */\n\tif (tlck->type & tlckRELOCATE) {\n\t\t/* log LOG_NOREDOPAGE of the old relocated page\n\t\t * for logredo() to start NoRedoPage filter;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxd = &lrd->log.redopage.pxd;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* (N.B. currently, logredo() does NOT update bmap\n\t\t * for free of the page itself for (LOG_XTREE|LOG_NOREDOPAGE);\n\t\t * if page free from relocation, LOG_UPDATEMAP log is\n\t\t * specifically generated now for logredo()\n\t\t * to update bmap for free of src relocated page;\n\t\t * (new flag LOG_RELOCATE may be introduced which will\n\t\t * inform logredo() to start NORedoPage filter and also\n\t\t * update block allocation map at the same time, thus\n\t\t * avoiding an extra log write);\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\n\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* a maplock for txUpdateMap() for free of the page\n\t\t * has been formatted at txLock() time;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\treturn;\n\t}\n\t/*\n\n\t * Otherwise it's not a relocate request\n\t *\n\t */\n\telse {\n\t\t/* log LOG_UPDATEMAP for logredo() to update bmap for\n\t\t * free of truncated/relocated delta extent of the data;\n\t\t * e.g.: external EA extent, relocated/truncated extent\n\t\t * from xtTailgate();\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tnlock = pxdlock->index;\n\t\tfor (i = 0; i < nlock; i++, pxdlock++) {\n\t\t\tif (pxdlock->flag & mlckALLOCPXD)\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_ALLOCPXD);\n\t\t\telse\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t\tjfs_info(\"mapLog: xaddr:0x%lx xlen:0x%x\",\n\t\t\t\t (ulong) addressPXD(&pxdlock->pxd),\n\t\t\t\t lengthPXD(&pxdlock->pxd));\n\t\t}\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n}"
  },
  {
    "function_name": "xtLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "1700-2079",
    "snippet": "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck)\n{\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct xtlock *xtlck;\n\tstruct maplock *maplock;\n\tstruct xdlistlock *xadlock;\n\tstruct pxd_lock *pxdlock;\n\tpxd_t *page_pxd;\n\tint next, lwm, hwm;\n\n\tip = tlck->ip;\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE/NOREDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_XTREE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2XTSLOTSIZE);\n\n\tpage_pxd = &lrd->log.redopage.pxd;\n\n\tif (tlck->type & tlckBTROOT) {\n\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\n\t\tp = &JFS_IP(ip)->i_xtroot;\n\t\tif (S_ISDIR(ip->i_mode))\n\t\t\tlrd->log.redopage.type |=\n\t\t\t    cpu_to_le16(LOG_DIR_XTREE);\n\t} else\n\t\tp = (xtpage_t *) mp->data;\n\tnext = le16_to_cpu(p->header.nextindex);\n\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\tmaplock = (struct maplock *) & tlck->lock;\n\txadlock = (struct xdlistlock *) maplock;\n\n\t/*\n\t *\tentry insertion/extension;\n\t *\tsibling page link update (old right page before split);\n\t */\n\tif (tlck->type & (tlckNEW | tlckGROW | tlckRELINK)) {\n\t\t/* log after-image for logredo():\n\t\t * logredo() will update bmap for alloc of new/extended\n\t\t * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from\n\t\t * after-image of XADlist;\n\t\t * logredo() resets (XAD_NEW|XAD_EXTEND) flag when\n\t\t * applying the after-image to the meta-data page.\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(page_pxd, mp->index);\n\t\tPXDlength(page_pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bPMAP\n\t\t * for alloc of new/extended extents of XAD[lwm:next)\n\t\t * from the page itself;\n\t\t * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.\n\t\t */\n\t\tlwm = xtlck->lwm.offset;\n\t\tif (lwm == 0)\n\t\t\tlwm = XTPAGEMAXSLOT;\n\n\t\tif (lwm == next)\n\t\t\tgoto out;\n\t\tif (lwm > next) {\n\t\t\tjfs_err(\"xtLog: lwm > next\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\txadlock->flag = mlckALLOCXADLIST;\n\t\txadlock->count = next - lwm;\n\t\tif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\n\t\t\tint i;\n\t\t\tpxd_t *pxd;\n\t\t\t/*\n\t\t\t * Lazy commit may allow xtree to be modified before\n\t\t\t * txUpdateMap runs.  Copy xad into linelock to\n\t\t\t * preserve correct data.\n\t\t\t *\n\t\t\t * We can fit twice as may pxd's as xads in the lock\n\t\t\t */\n\t\t\txadlock->flag = mlckALLOCPXDLIST;\n\t\t\tpxd = xadlock->xdlist = &xtlck->pxdlock;\n\t\t\tfor (i = 0; i < xadlock->count; i++) {\n\t\t\t\tPXDaddress(pxd, addressXAD(&p->xad[lwm + i]));\n\t\t\t\tPXDlength(pxd, lengthXAD(&p->xad[lwm + i]));\n\t\t\t\tp->xad[lwm + i].flag &=\n\t\t\t\t    ~(XAD_NEW | XAD_EXTENDED);\n\t\t\t\tpxd++;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * xdlist will point to into inode's xtree, ensure\n\t\t\t * that transaction is not committed lazily.\n\t\t\t */\n\t\t\txadlock->flag = mlckALLOCXADLIST;\n\t\t\txadlock->xdlist = &p->xad[lwm];\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\t}\n\t\tjfs_info(\"xtLog: alloc ip:0x%p mp:0x%p tlck:0x%p lwm:%d \"\n\t\t\t \"count:%d\", tlck->ip, mp, tlck, lwm, xadlock->count);\n\n\t\tmaplock->index = 1;\n\n\t      out:\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage deletion: file deletion/truncation (ref. xtTruncate())\n\t *\n\t * (page will be invalidated after log is written and bmap\n\t * is updated from the page);\n\t */\n\tif (tlck->type & tlckFREE) {\n\t\t/* LOG_NOREDOPAGE log for NoRedoPage filter:\n\t\t * if page free from file delete, NoRedoFile filter from\n\t\t * inode image of zero link count will subsume NoRedoPage\n\t\t * filters for each page;\n\t\t * if page free from file truncattion, write NoRedoPage\n\t\t * filter;\n\t\t *\n\t\t * upadte of block allocation map for the page itself:\n\t\t * if page free from deletion and truncation, LOG_UPDATEMAP\n\t\t * log for the page itself is generated from processing\n\t\t * its parent page xad entries;\n\t\t */\n\t\t/* if page free from file truncation, log LOG_NOREDOPAGE\n\t\t * of the deleted page for logredo() to start NoRedoPage\n\t\t * filter for the page;\n\t\t */\n\t\tif (tblk->xflag & COMMIT_TRUNCATE) {\n\t\t\t/* write NOREDOPAGE for the page */\n\t\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\t\tPXDaddress(page_pxd, mp->index);\n\t\t\tPXDlength(page_pxd,\n\t\t\t\t  mp->logical_size >> tblk->sb->\n\t\t\t\t  s_blocksize_bits);\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t\tif (tlck->type & tlckBTROOT) {\n\t\t\t\t/* Empty xtree must be logged */\n\t\t\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\t\t\tlrd->backchain =\n\t\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\t\t\t}\n\t\t}\n\n\t\t/* init LOG_UPDATEMAP of the freed extents\n\t\t * XAD[XTENTRYSTART:hwm) from the deleted page itself\n\t\t * for logredo() to update bmap;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEXADLIST);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\thwm = xtlck->hwm.offset;\n\t\tlrd->log.updatemap.nxd =\n\t\t    cpu_to_le16(hwm - XTENTRYSTART + 1);\n\t\t/* reformat linelock for lmLog() */\n\t\txtlck->header.offset = XTENTRYSTART;\n\t\txtlck->header.length = hwm - XTENTRYSTART + 1;\n\t\txtlck->index = 1;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t * to free extents of XAD[XTENTRYSTART:hwm) from the\n\t\t * deleted page itself;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\txadlock->count = hwm - XTENTRYSTART + 1;\n\t\tif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\n\t\t\tint i;\n\t\t\tpxd_t *pxd;\n\t\t\t/*\n\t\t\t * Lazy commit may allow xtree to be modified before\n\t\t\t * txUpdateMap runs.  Copy xad into linelock to\n\t\t\t * preserve correct data.\n\t\t\t *\n\t\t\t * We can fit twice as may pxd's as xads in the lock\n\t\t\t */\n\t\t\txadlock->flag = mlckFREEPXDLIST;\n\t\t\tpxd = xadlock->xdlist = &xtlck->pxdlock;\n\t\t\tfor (i = 0; i < xadlock->count; i++) {\n\t\t\t\tPXDaddress(pxd,\n\t\t\t\t\taddressXAD(&p->xad[XTENTRYSTART + i]));\n\t\t\t\tPXDlength(pxd,\n\t\t\t\t\tlengthXAD(&p->xad[XTENTRYSTART + i]));\n\t\t\t\tpxd++;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * xdlist will point to into inode's xtree, ensure\n\t\t\t * that transaction is not committed lazily.\n\t\t\t */\n\t\t\txadlock->flag = mlckFREEXADLIST;\n\t\t\txadlock->xdlist = &p->xad[XTENTRYSTART];\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\t}\n\t\tjfs_info(\"xtLog: free ip:0x%p mp:0x%p count:%d lwm:2\",\n\t\t\t tlck->ip, mp, xadlock->count);\n\n\t\tmaplock->index = 1;\n\n\t\t/* mark page as invalid */\n\t\tif (((tblk->xflag & COMMIT_PWMAP) || S_ISDIR(ip->i_mode))\n\t\t    && !(tlck->type & tlckBTROOT))\n\t\t\ttlck->flag |= tlckFREEPAGE;\n\t\t/*\n\t\t   else (tblk->xflag & COMMIT_PMAP)\n\t\t   ? release the page;\n\t\t */\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage/entry truncation: file truncation (ref. xtTruncate())\n\t *\n\t *\t|----------+------+------+---------------|\n\t *\t\t   |      |      |\n\t *\t\t   |      |     hwm - hwm before truncation\n\t *\t\t   |     next - truncation point\n\t *\t\t  lwm - lwm before truncation\n\t * header ?\n\t */\n\tif (tlck->type & tlckTRUNCATE) {\n\t\t/* This odd declaration suppresses a bogus gcc warning */\n\t\tpxd_t pxd = pxd;\t/* truncated extent of xad */\n\t\tint twm;\n\n\t\t/*\n\t\t * For truncation the entire linelock may be used, so it would\n\t\t * be difficult to store xad list in linelock itself.\n\t\t * Therefore, we'll just force transaction to be committed\n\t\t * synchronously, so that xtree pages won't be changed before\n\t\t * txUpdateMap runs.\n\t\t */\n\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\tlwm = xtlck->lwm.offset;\n\t\tif (lwm == 0)\n\t\t\tlwm = XTPAGEMAXSLOT;\n\t\thwm = xtlck->hwm.offset;\n\t\ttwm = xtlck->twm.offset;\n\n\t\t/*\n\t\t *\twrite log records\n\t\t */\n\t\t/* log after-image for logredo():\n\t\t *\n\t\t * logredo() will update bmap for alloc of new/extended\n\t\t * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from\n\t\t * after-image of XADlist;\n\t\t * logredo() resets (XAD_NEW|XAD_EXTEND) flag when\n\t\t * applying the after-image to the meta-data page.\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(page_pxd, mp->index);\n\t\tPXDlength(page_pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/*\n\t\t * truncate entry XAD[twm == next - 1]:\n\t\t */\n\t\tif (twm == next - 1) {\n\t\t\t/* init LOG_UPDATEMAP for logredo() to update bmap for\n\t\t\t * free of truncated delta extent of the truncated\n\t\t\t * entry XAD[next - 1]:\n\t\t\t * (xtlck->pxdlock = truncated delta extent);\n\t\t\t */\n\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t/* assert(pxdlock->type & tlckTRUNCATE); */\n\t\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tpxd = pxdlock->pxd;\t/* save to format maplock */\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t}\n\n\t\t/*\n\t\t * free entries XAD[next:hwm]:\n\t\t */\n\t\tif (hwm >= next) {\n\t\t\t/* init LOG_UPDATEMAP of the freed extents\n\t\t\t * XAD[next:hwm] from the deleted page itself\n\t\t\t * for logredo() to update bmap;\n\t\t\t */\n\t\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\t\tlrd->log.updatemap.type =\n\t\t\t    cpu_to_le16(LOG_FREEXADLIST);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\thwm = xtlck->hwm.offset;\n\t\t\tlrd->log.updatemap.nxd =\n\t\t\t    cpu_to_le16(hwm - next + 1);\n\t\t\t/* reformat linelock for lmLog() */\n\t\t\txtlck->header.offset = next;\n\t\t\txtlck->header.length = hwm - next + 1;\n\t\t\txtlck->index = 1;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\t\t}\n\n\t\t/*\n\t\t *\tformat maplock(s) for txUpdateMap() to update bmap\n\t\t */\n\t\tmaplock->index = 0;\n\n\t\t/*\n\t\t * allocate entries XAD[lwm:next):\n\t\t */\n\t\tif (lwm < next) {\n\t\t\t/* format a maplock for txUpdateMap() to update bPMAP\n\t\t\t * for alloc of new/extended extents of XAD[lwm:next)\n\t\t\t * from the page itself;\n\t\t\t * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\txadlock->flag = mlckALLOCXADLIST;\n\t\t\txadlock->count = next - lwm;\n\t\t\txadlock->xdlist = &p->xad[lwm];\n\n\t\t\tjfs_info(\"xtLog: alloc ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"lwm:%d next:%d\",\n\t\t\t\t tlck->ip, mp, xadlock->count, lwm, next);\n\t\t\tmaplock->index++;\n\t\t\txadlock++;\n\t\t}\n\n\t\t/*\n\t\t * truncate entry XAD[twm == next - 1]:\n\t\t */\n\t\tif (twm == next - 1) {\n\t\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t\t * to free truncated delta extent of the truncated\n\t\t\t * entry XAD[next - 1];\n\t\t\t * (xtlck->pxdlock = truncated delta extent);\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\tpxdlock = (struct pxd_lock *) xadlock;\n\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\tpxdlock->count = 1;\n\t\t\tpxdlock->pxd = pxd;\n\n\t\t\tjfs_info(\"xtLog: truncate ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"hwm:%d\", ip, mp, pxdlock->count, hwm);\n\t\t\tmaplock->index++;\n\t\t\txadlock++;\n\t\t}\n\n\t\t/*\n\t\t * free entries XAD[next:hwm]:\n\t\t */\n\t\tif (hwm >= next) {\n\t\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t\t * to free extents of XAD[next:hwm] from thedeleted\n\t\t\t * page itself;\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\txadlock->flag = mlckFREEXADLIST;\n\t\t\txadlock->count = hwm - next + 1;\n\t\t\txadlock->xdlist = &p->xad[next];\n\n\t\t\tjfs_info(\"xtLog: free ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"next:%d hwm:%d\",\n\t\t\t\t tlck->ip, mp, xadlock->count, next, hwm);\n\t\t\tmaplock->index++;\n\t\t}\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtLog: free ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"next:%d hwm:%d\"",
            "tlck->ip",
            "mp",
            "xadlock->count",
            "next",
            "hwm"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtLog: truncate ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"hwm:%d\"",
            "ip",
            "mp",
            "pxdlock->count",
            "hwm"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtLog: alloc ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"lwm:%d next:%d\"",
            "tlck->ip",
            "mp",
            "xadlock->count",
            "lwm",
            "next"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, tlck)"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "tlck"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "lmLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "238-343",
          "snippet": "int lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nint lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "hwm - next + 1"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_FREEXADLIST"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_UPDATEMAP"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, NULL)"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_FREEPXD"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_UPDATEMAP"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, tlck)"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "page_pxd",
            "mp->logical_size >> tblk->sb->s_blocksize_bits"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "page_pxd",
            "mp->index"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_REDOPAGE"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtLog: free ip:0x%p mp:0x%p count:%d lwm:2\"",
            "tlck->ip",
            "mp",
            "xadlock->count"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "&p->xad[XTENTRYSTART + i]"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "&p->xad[XTENTRYSTART + i]"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, tlck)"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "hwm - XTENTRYSTART + 1"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_FREEXADLIST"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_UPDATEMAP"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, tlck)"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_REDOPAGE"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, NULL)"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_NOREDOPAGE"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtLog: alloc ip:0x%p mp:0x%p tlck:0x%p lwm:%d \"\n\t\t\t \"count:%d\"",
            "tlck->ip",
            "mp",
            "tlck",
            "lwm",
            "xadlock->count"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "&p->xad[lwm + i]"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "&p->xad[lwm + i]"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"xtLog: lwm > next\\n\""
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, tlck)"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_REDOPAGE"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_DIR_XTREE"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_BTROOT"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "L2XTSLOTSIZE"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_XTREE"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck)\n{\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct xtlock *xtlck;\n\tstruct maplock *maplock;\n\tstruct xdlistlock *xadlock;\n\tstruct pxd_lock *pxdlock;\n\tpxd_t *page_pxd;\n\tint next, lwm, hwm;\n\n\tip = tlck->ip;\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE/NOREDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_XTREE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2XTSLOTSIZE);\n\n\tpage_pxd = &lrd->log.redopage.pxd;\n\n\tif (tlck->type & tlckBTROOT) {\n\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\n\t\tp = &JFS_IP(ip)->i_xtroot;\n\t\tif (S_ISDIR(ip->i_mode))\n\t\t\tlrd->log.redopage.type |=\n\t\t\t    cpu_to_le16(LOG_DIR_XTREE);\n\t} else\n\t\tp = (xtpage_t *) mp->data;\n\tnext = le16_to_cpu(p->header.nextindex);\n\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\tmaplock = (struct maplock *) & tlck->lock;\n\txadlock = (struct xdlistlock *) maplock;\n\n\t/*\n\t *\tentry insertion/extension;\n\t *\tsibling page link update (old right page before split);\n\t */\n\tif (tlck->type & (tlckNEW | tlckGROW | tlckRELINK)) {\n\t\t/* log after-image for logredo():\n\t\t * logredo() will update bmap for alloc of new/extended\n\t\t * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from\n\t\t * after-image of XADlist;\n\t\t * logredo() resets (XAD_NEW|XAD_EXTEND) flag when\n\t\t * applying the after-image to the meta-data page.\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(page_pxd, mp->index);\n\t\tPXDlength(page_pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bPMAP\n\t\t * for alloc of new/extended extents of XAD[lwm:next)\n\t\t * from the page itself;\n\t\t * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.\n\t\t */\n\t\tlwm = xtlck->lwm.offset;\n\t\tif (lwm == 0)\n\t\t\tlwm = XTPAGEMAXSLOT;\n\n\t\tif (lwm == next)\n\t\t\tgoto out;\n\t\tif (lwm > next) {\n\t\t\tjfs_err(\"xtLog: lwm > next\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\txadlock->flag = mlckALLOCXADLIST;\n\t\txadlock->count = next - lwm;\n\t\tif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\n\t\t\tint i;\n\t\t\tpxd_t *pxd;\n\t\t\t/*\n\t\t\t * Lazy commit may allow xtree to be modified before\n\t\t\t * txUpdateMap runs.  Copy xad into linelock to\n\t\t\t * preserve correct data.\n\t\t\t *\n\t\t\t * We can fit twice as may pxd's as xads in the lock\n\t\t\t */\n\t\t\txadlock->flag = mlckALLOCPXDLIST;\n\t\t\tpxd = xadlock->xdlist = &xtlck->pxdlock;\n\t\t\tfor (i = 0; i < xadlock->count; i++) {\n\t\t\t\tPXDaddress(pxd, addressXAD(&p->xad[lwm + i]));\n\t\t\t\tPXDlength(pxd, lengthXAD(&p->xad[lwm + i]));\n\t\t\t\tp->xad[lwm + i].flag &=\n\t\t\t\t    ~(XAD_NEW | XAD_EXTENDED);\n\t\t\t\tpxd++;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * xdlist will point to into inode's xtree, ensure\n\t\t\t * that transaction is not committed lazily.\n\t\t\t */\n\t\t\txadlock->flag = mlckALLOCXADLIST;\n\t\t\txadlock->xdlist = &p->xad[lwm];\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\t}\n\t\tjfs_info(\"xtLog: alloc ip:0x%p mp:0x%p tlck:0x%p lwm:%d \"\n\t\t\t \"count:%d\", tlck->ip, mp, tlck, lwm, xadlock->count);\n\n\t\tmaplock->index = 1;\n\n\t      out:\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage deletion: file deletion/truncation (ref. xtTruncate())\n\t *\n\t * (page will be invalidated after log is written and bmap\n\t * is updated from the page);\n\t */\n\tif (tlck->type & tlckFREE) {\n\t\t/* LOG_NOREDOPAGE log for NoRedoPage filter:\n\t\t * if page free from file delete, NoRedoFile filter from\n\t\t * inode image of zero link count will subsume NoRedoPage\n\t\t * filters for each page;\n\t\t * if page free from file truncattion, write NoRedoPage\n\t\t * filter;\n\t\t *\n\t\t * upadte of block allocation map for the page itself:\n\t\t * if page free from deletion and truncation, LOG_UPDATEMAP\n\t\t * log for the page itself is generated from processing\n\t\t * its parent page xad entries;\n\t\t */\n\t\t/* if page free from file truncation, log LOG_NOREDOPAGE\n\t\t * of the deleted page for logredo() to start NoRedoPage\n\t\t * filter for the page;\n\t\t */\n\t\tif (tblk->xflag & COMMIT_TRUNCATE) {\n\t\t\t/* write NOREDOPAGE for the page */\n\t\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\t\tPXDaddress(page_pxd, mp->index);\n\t\t\tPXDlength(page_pxd,\n\t\t\t\t  mp->logical_size >> tblk->sb->\n\t\t\t\t  s_blocksize_bits);\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t\tif (tlck->type & tlckBTROOT) {\n\t\t\t\t/* Empty xtree must be logged */\n\t\t\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\t\t\tlrd->backchain =\n\t\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\t\t\t}\n\t\t}\n\n\t\t/* init LOG_UPDATEMAP of the freed extents\n\t\t * XAD[XTENTRYSTART:hwm) from the deleted page itself\n\t\t * for logredo() to update bmap;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEXADLIST);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\thwm = xtlck->hwm.offset;\n\t\tlrd->log.updatemap.nxd =\n\t\t    cpu_to_le16(hwm - XTENTRYSTART + 1);\n\t\t/* reformat linelock for lmLog() */\n\t\txtlck->header.offset = XTENTRYSTART;\n\t\txtlck->header.length = hwm - XTENTRYSTART + 1;\n\t\txtlck->index = 1;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t * to free extents of XAD[XTENTRYSTART:hwm) from the\n\t\t * deleted page itself;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\txadlock->count = hwm - XTENTRYSTART + 1;\n\t\tif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\n\t\t\tint i;\n\t\t\tpxd_t *pxd;\n\t\t\t/*\n\t\t\t * Lazy commit may allow xtree to be modified before\n\t\t\t * txUpdateMap runs.  Copy xad into linelock to\n\t\t\t * preserve correct data.\n\t\t\t *\n\t\t\t * We can fit twice as may pxd's as xads in the lock\n\t\t\t */\n\t\t\txadlock->flag = mlckFREEPXDLIST;\n\t\t\tpxd = xadlock->xdlist = &xtlck->pxdlock;\n\t\t\tfor (i = 0; i < xadlock->count; i++) {\n\t\t\t\tPXDaddress(pxd,\n\t\t\t\t\taddressXAD(&p->xad[XTENTRYSTART + i]));\n\t\t\t\tPXDlength(pxd,\n\t\t\t\t\tlengthXAD(&p->xad[XTENTRYSTART + i]));\n\t\t\t\tpxd++;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * xdlist will point to into inode's xtree, ensure\n\t\t\t * that transaction is not committed lazily.\n\t\t\t */\n\t\t\txadlock->flag = mlckFREEXADLIST;\n\t\t\txadlock->xdlist = &p->xad[XTENTRYSTART];\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\t}\n\t\tjfs_info(\"xtLog: free ip:0x%p mp:0x%p count:%d lwm:2\",\n\t\t\t tlck->ip, mp, xadlock->count);\n\n\t\tmaplock->index = 1;\n\n\t\t/* mark page as invalid */\n\t\tif (((tblk->xflag & COMMIT_PWMAP) || S_ISDIR(ip->i_mode))\n\t\t    && !(tlck->type & tlckBTROOT))\n\t\t\ttlck->flag |= tlckFREEPAGE;\n\t\t/*\n\t\t   else (tblk->xflag & COMMIT_PMAP)\n\t\t   ? release the page;\n\t\t */\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage/entry truncation: file truncation (ref. xtTruncate())\n\t *\n\t *\t|----------+------+------+---------------|\n\t *\t\t   |      |      |\n\t *\t\t   |      |     hwm - hwm before truncation\n\t *\t\t   |     next - truncation point\n\t *\t\t  lwm - lwm before truncation\n\t * header ?\n\t */\n\tif (tlck->type & tlckTRUNCATE) {\n\t\t/* This odd declaration suppresses a bogus gcc warning */\n\t\tpxd_t pxd = pxd;\t/* truncated extent of xad */\n\t\tint twm;\n\n\t\t/*\n\t\t * For truncation the entire linelock may be used, so it would\n\t\t * be difficult to store xad list in linelock itself.\n\t\t * Therefore, we'll just force transaction to be committed\n\t\t * synchronously, so that xtree pages won't be changed before\n\t\t * txUpdateMap runs.\n\t\t */\n\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\tlwm = xtlck->lwm.offset;\n\t\tif (lwm == 0)\n\t\t\tlwm = XTPAGEMAXSLOT;\n\t\thwm = xtlck->hwm.offset;\n\t\ttwm = xtlck->twm.offset;\n\n\t\t/*\n\t\t *\twrite log records\n\t\t */\n\t\t/* log after-image for logredo():\n\t\t *\n\t\t * logredo() will update bmap for alloc of new/extended\n\t\t * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from\n\t\t * after-image of XADlist;\n\t\t * logredo() resets (XAD_NEW|XAD_EXTEND) flag when\n\t\t * applying the after-image to the meta-data page.\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(page_pxd, mp->index);\n\t\tPXDlength(page_pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/*\n\t\t * truncate entry XAD[twm == next - 1]:\n\t\t */\n\t\tif (twm == next - 1) {\n\t\t\t/* init LOG_UPDATEMAP for logredo() to update bmap for\n\t\t\t * free of truncated delta extent of the truncated\n\t\t\t * entry XAD[next - 1]:\n\t\t\t * (xtlck->pxdlock = truncated delta extent);\n\t\t\t */\n\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t/* assert(pxdlock->type & tlckTRUNCATE); */\n\t\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tpxd = pxdlock->pxd;\t/* save to format maplock */\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t}\n\n\t\t/*\n\t\t * free entries XAD[next:hwm]:\n\t\t */\n\t\tif (hwm >= next) {\n\t\t\t/* init LOG_UPDATEMAP of the freed extents\n\t\t\t * XAD[next:hwm] from the deleted page itself\n\t\t\t * for logredo() to update bmap;\n\t\t\t */\n\t\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\t\tlrd->log.updatemap.type =\n\t\t\t    cpu_to_le16(LOG_FREEXADLIST);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\thwm = xtlck->hwm.offset;\n\t\t\tlrd->log.updatemap.nxd =\n\t\t\t    cpu_to_le16(hwm - next + 1);\n\t\t\t/* reformat linelock for lmLog() */\n\t\t\txtlck->header.offset = next;\n\t\t\txtlck->header.length = hwm - next + 1;\n\t\t\txtlck->index = 1;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\t\t}\n\n\t\t/*\n\t\t *\tformat maplock(s) for txUpdateMap() to update bmap\n\t\t */\n\t\tmaplock->index = 0;\n\n\t\t/*\n\t\t * allocate entries XAD[lwm:next):\n\t\t */\n\t\tif (lwm < next) {\n\t\t\t/* format a maplock for txUpdateMap() to update bPMAP\n\t\t\t * for alloc of new/extended extents of XAD[lwm:next)\n\t\t\t * from the page itself;\n\t\t\t * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\txadlock->flag = mlckALLOCXADLIST;\n\t\t\txadlock->count = next - lwm;\n\t\t\txadlock->xdlist = &p->xad[lwm];\n\n\t\t\tjfs_info(\"xtLog: alloc ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"lwm:%d next:%d\",\n\t\t\t\t tlck->ip, mp, xadlock->count, lwm, next);\n\t\t\tmaplock->index++;\n\t\t\txadlock++;\n\t\t}\n\n\t\t/*\n\t\t * truncate entry XAD[twm == next - 1]:\n\t\t */\n\t\tif (twm == next - 1) {\n\t\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t\t * to free truncated delta extent of the truncated\n\t\t\t * entry XAD[next - 1];\n\t\t\t * (xtlck->pxdlock = truncated delta extent);\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\tpxdlock = (struct pxd_lock *) xadlock;\n\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\tpxdlock->count = 1;\n\t\t\tpxdlock->pxd = pxd;\n\n\t\t\tjfs_info(\"xtLog: truncate ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"hwm:%d\", ip, mp, pxdlock->count, hwm);\n\t\t\tmaplock->index++;\n\t\t\txadlock++;\n\t\t}\n\n\t\t/*\n\t\t * free entries XAD[next:hwm]:\n\t\t */\n\t\tif (hwm >= next) {\n\t\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t\t * to free extents of XAD[next:hwm] from thedeleted\n\t\t\t * page itself;\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\txadlock->flag = mlckFREEXADLIST;\n\t\t\txadlock->count = hwm - next + 1;\n\t\t\txadlock->xdlist = &p->xad[next];\n\n\t\t\tjfs_info(\"xtLog: free ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"next:%d hwm:%d\",\n\t\t\t\t tlck->ip, mp, xadlock->count, next, hwm);\n\t\t\tmaplock->index++;\n\t\t}\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "dtLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "1597-1693",
    "snippet": "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck)\n{\n\tstruct metapage *mp;\n\tstruct pxd_lock *pxdlock;\n\tpxd_t *pxd;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE/NOREDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_DTREE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2DTSLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\tif (tlck->type & tlckBTROOT)\n\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\n\n\t/*\n\t *\tpage extension via relocation: entry insertion;\n\t *\tpage extension in-place: entry insertion;\n\t *\tnew right page from page split, reinitialized in-line\n\t *\troot from root page split: entry insertion;\n\t */\n\tif (tlck->type & (tlckNEW | tlckEXTEND)) {\n\t\t/* log after-image of the new page for logredo():\n\t\t * mark log (LOG_NEW) for logredo() to initialize\n\t\t * freelist and update bmap for alloc of the new page;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tif (tlck->type & tlckEXTEND)\n\t\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_EXTEND);\n\t\telse\n\t\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_NEW);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bPMAP for\n\t\t * alloc of the new page;\n\t\t */\n\t\tif (tlck->type & tlckBTROOT)\n\t\t\treturn;\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxdlock->flag = mlckALLOCPXD;\n\t\tpxdlock->pxd = *pxd;\n\n\t\tpxdlock->index = 1;\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t\treturn;\n\t}\n\n\t/*\n\t *\tentry insertion/deletion,\n\t *\tsibling page link update (old right page before split);\n\t */\n\tif (tlck->type & (tlckENTRY | tlckRELINK)) {\n\t\t/* log after-image for logredo(): */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage deletion: page has been invalidated\n\t *\tpage relocation: source extent\n\t *\n\t *\ta maplock for free of the page has been formatted\n\t *\tat txLock() time);\n\t */\n\tif (tlck->type & (tlckFREE | tlckRELOCATE)) {\n\t\t/* log LOG_NOREDOPAGE of the deleted page for logredo()\n\t\t * to start NoRedoPage filter and to update bmap for free\n\t\t * of the deletd page\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* a maplock for txUpdateMap() for free of the page\n\t\t * has been formatted at txLock() time;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, NULL)"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "NULL"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "lmLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "238-343",
          "snippet": "int lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nint lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_NOREDOPAGE"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, tlck)"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "pxd",
            "mp->logical_size >> tblk->sb->s_blocksize_bits"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "pxd",
            "mp->index"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_REDOPAGE"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, tlck)"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_NEW"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_EXTEND"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_REDOPAGE"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_BTROOT"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "L2DTSLOTSIZE"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_DTREE"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck)\n{\n\tstruct metapage *mp;\n\tstruct pxd_lock *pxdlock;\n\tpxd_t *pxd;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE/NOREDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_DTREE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2DTSLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\tif (tlck->type & tlckBTROOT)\n\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\n\n\t/*\n\t *\tpage extension via relocation: entry insertion;\n\t *\tpage extension in-place: entry insertion;\n\t *\tnew right page from page split, reinitialized in-line\n\t *\troot from root page split: entry insertion;\n\t */\n\tif (tlck->type & (tlckNEW | tlckEXTEND)) {\n\t\t/* log after-image of the new page for logredo():\n\t\t * mark log (LOG_NEW) for logredo() to initialize\n\t\t * freelist and update bmap for alloc of the new page;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tif (tlck->type & tlckEXTEND)\n\t\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_EXTEND);\n\t\telse\n\t\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_NEW);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bPMAP for\n\t\t * alloc of the new page;\n\t\t */\n\t\tif (tlck->type & tlckBTROOT)\n\t\t\treturn;\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxdlock->flag = mlckALLOCPXD;\n\t\tpxdlock->pxd = *pxd;\n\n\t\tpxdlock->index = 1;\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t\treturn;\n\t}\n\n\t/*\n\t *\tentry insertion/deletion,\n\t *\tsibling page link update (old right page before split);\n\t */\n\tif (tlck->type & (tlckENTRY | tlckRELINK)) {\n\t\t/* log after-image for logredo(): */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage deletion: page has been invalidated\n\t *\tpage relocation: source extent\n\t *\n\t *\ta maplock for free of the page has been formatted\n\t *\tat txLock() time);\n\t */\n\tif (tlck->type & (tlckFREE | tlckRELOCATE)) {\n\t\t/* log LOG_NOREDOPAGE of the deleted page for logredo()\n\t\t * to start NoRedoPage filter and to update bmap for free\n\t\t * of the deletd page\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* a maplock for txUpdateMap() for free of the page\n\t\t * has been formatted at txLock() time;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "dataLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "1551-1590",
    "snippet": "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t    struct tlock * tlck)\n{\n\tstruct metapage *mp;\n\tpxd_t *pxd;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_DATA);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2DATASLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\t/* log after-image for logredo(): */\n\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\n\tif (jfs_dirtable_inline(tlck->ip)) {\n\t\t/*\n\t\t * The table has been truncated, we've must have deleted\n\t\t * the last entry, so don't bother logging this\n\t\t */\n\t\tmp->lid = 0;\n\t\tgrab_metapage(mp);\n\t\tmetapage_homeok(mp);\n\t\tdiscard_metapage(mp);\n\t\ttlck->mp = NULL;\n\t\treturn 0;\n\t}\n\n\tPXDaddress(pxd, mp->index);\n\tPXDlength(pxd, mp->logical_size >> tblk->sb->s_blocksize_bits);\n\n\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t/* mark page as homeward bound */\n\ttlck->flag |= tlckWRITEPAGE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, tlck)"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "tlck"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "lmLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "238-343",
          "snippet": "int lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nint lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "pxd",
            "mp->logical_size >> tblk->sb->s_blocksize_bits"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "pxd",
            "mp->index"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_metapage",
          "args": [
            "mp"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "discard_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "97-102",
          "snippet": "static inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_discard\t4",
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_discard\t4\n#define META_dirty\t2\n\nstatic inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "metapage_homeok",
          "args": [
            "mp"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_homeok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "135-140",
          "snippet": "static inline void metapage_homeok(struct metapage *mp)\n{\n\thold_metapage(mp);\n\t_metapage_homeok(mp);\n\tput_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\nstatic inline void metapage_homeok(struct metapage *mp)\n{\n\thold_metapage(mp);\n\t_metapage_homeok(mp);\n\tput_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_metapage",
          "args": [
            "mp"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "grab_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "700-708",
          "snippet": "void grab_metapage(struct metapage * mp)\n{\n\tjfs_info(\"grab_metapage: mp = 0x%p\", mp);\n\tpage_cache_get(mp->page);\n\tlock_page(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid grab_metapage(struct metapage * mp)\n{\n\tjfs_info(\"grab_metapage: mp = 0x%p\", mp);\n\tpage_cache_get(mp->page);\n\tlock_page(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_dirtable_inline",
          "args": [
            "tlck->ip"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_dirtable_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "212-215",
          "snippet": "static inline int jfs_dirtable_inline(struct inode *inode)\n{\n\treturn (JFS_IP(inode)->next_index <= (MAX_INLINE_DIRTABLE_ENTRY + 1));\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline int jfs_dirtable_inline(struct inode *inode)\n{\n\treturn (JFS_IP(inode)->next_index <= (MAX_INLINE_DIRTABLE_ENTRY + 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_REDOPAGE"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "L2DATASLOTSIZE"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_DATA"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t    struct tlock * tlck)\n{\n\tstruct metapage *mp;\n\tpxd_t *pxd;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_DATA);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2DATASLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\t/* log after-image for logredo(): */\n\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\n\tif (jfs_dirtable_inline(tlck->ip)) {\n\t\t/*\n\t\t * The table has been truncated, we've must have deleted\n\t\t * the last entry, so don't bother logging this\n\t\t */\n\t\tmp->lid = 0;\n\t\tgrab_metapage(mp);\n\t\tmetapage_homeok(mp);\n\t\tdiscard_metapage(mp);\n\t\ttlck->mp = NULL;\n\t\treturn 0;\n\t}\n\n\tPXDaddress(pxd, mp->index);\n\tPXDlength(pxd, mp->logical_size >> tblk->sb->s_blocksize_bits);\n\n\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t/* mark page as homeward bound */\n\ttlck->flag |= tlckWRITEPAGE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "diLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "1438-1544",
    "snippet": "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\t struct tlock * tlck, struct commit * cd)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tpxd_t *pxd;\n\tstruct pxd_lock *pxdlock;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_INODE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2INODESLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\t/*\n\t *\tinode after image\n\t */\n\tif (tlck->type & tlckENTRY) {\n\t\t/* log after-image for logredo(): */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t} else if (tlck->type & tlckFREE) {\n\t\t/*\n\t\t *\tfree inode extent\n\t\t *\n\t\t * (pages of the freed inode extent have been invalidated and\n\t\t * a maplock for free of the extent has been formatted at\n\t\t * txLock() time);\n\t\t *\n\t\t * the tlock had been acquired on the inode allocation map page\n\t\t * (iag) that specifies the freed extent, even though the map\n\t\t * page is not itself logged, to prevent pageout of the map\n\t\t * page before the log;\n\t\t */\n\n\t\t/* log LOG_NOREDOINOEXT of the freed inode extent for\n\t\t * logredo() to start NoRedoPage filters, and to update\n\t\t * imap and bmap for free of the extent;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOINOEXT);\n\t\t/*\n\t\t * For the LOG_NOREDOINOEXT record, we need\n\t\t * to pass the IAG number and inode extent\n\t\t * index (within that IAG) from which the\n\t\t * the extent being released.  These have been\n\t\t * passed to us in the iplist[1] and iplist[2].\n\t\t */\n\t\tlrd->log.noredoinoext.iagnum =\n\t\t    cpu_to_le32((u32) (size_t) cd->iplist[1]);\n\t\tlrd->log.noredoinoext.inoext_idx =\n\t\t    cpu_to_le32((u32) (size_t) cd->iplist[2]);\n\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t} else\n\t\tjfs_err(\"diLog: UFO type tlck:0x%p\", tlck);\n#ifdef  _JFS_WIP\n\t/*\n\t *\talloc/free external EA extent\n\t *\n\t * a maplock for txUpdateMap() to update bPWMAP for alloc/free\n\t * of the extent has been formatted at txLock() time;\n\t */\n\telse {\n\t\tassert(tlck->type & tlckEA);\n\n\t\t/* log LOG_UPDATEMAP for logredo() to update bmap for\n\t\t * alloc of new (and free of old) external EA extent;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tnlock = pxdlock->index;\n\t\tfor (i = 0; i < nlock; i++, pxdlock++) {\n\t\t\tif (pxdlock->flag & mlckALLOCPXD)\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_ALLOCPXD);\n\t\t\telse\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t}\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, NULL)"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "NULL"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "lmLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "238-343",
          "snippet": "int lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nint lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_FREEPXD"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_ALLOCPXD"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_UPDATEMAP"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tlck->type & tlckEA"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"diLog: UFO type tlck:0x%p\"",
            "tlck"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, NULL)"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32) (size_t) cd->iplist[2]"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32) (size_t) cd->iplist[1]"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_NOREDOINOEXT"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lmLog(log, tblk, lrd, tlck)"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "pxd",
            "mp->logical_size >> tblk->sb->s_blocksize_bits"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "pxd",
            "mp->index"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_REDOPAGE"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "L2INODESLOTSIZE"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_INODE"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\t struct tlock * tlck, struct commit * cd)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tpxd_t *pxd;\n\tstruct pxd_lock *pxdlock;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_INODE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2INODESLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\t/*\n\t *\tinode after image\n\t */\n\tif (tlck->type & tlckENTRY) {\n\t\t/* log after-image for logredo(): */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t} else if (tlck->type & tlckFREE) {\n\t\t/*\n\t\t *\tfree inode extent\n\t\t *\n\t\t * (pages of the freed inode extent have been invalidated and\n\t\t * a maplock for free of the extent has been formatted at\n\t\t * txLock() time);\n\t\t *\n\t\t * the tlock had been acquired on the inode allocation map page\n\t\t * (iag) that specifies the freed extent, even though the map\n\t\t * page is not itself logged, to prevent pageout of the map\n\t\t * page before the log;\n\t\t */\n\n\t\t/* log LOG_NOREDOINOEXT of the freed inode extent for\n\t\t * logredo() to start NoRedoPage filters, and to update\n\t\t * imap and bmap for free of the extent;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOINOEXT);\n\t\t/*\n\t\t * For the LOG_NOREDOINOEXT record, we need\n\t\t * to pass the IAG number and inode extent\n\t\t * index (within that IAG) from which the\n\t\t * the extent being released.  These have been\n\t\t * passed to us in the iplist[1] and iplist[2].\n\t\t */\n\t\tlrd->log.noredoinoext.iagnum =\n\t\t    cpu_to_le32((u32) (size_t) cd->iplist[1]);\n\t\tlrd->log.noredoinoext.inoext_idx =\n\t\t    cpu_to_le32((u32) (size_t) cd->iplist[2]);\n\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t} else\n\t\tjfs_err(\"diLog: UFO type tlck:0x%p\", tlck);\n#ifdef  _JFS_WIP\n\t/*\n\t *\talloc/free external EA extent\n\t *\n\t * a maplock for txUpdateMap() to update bPWMAP for alloc/free\n\t * of the extent has been formatted at txLock() time;\n\t */\n\telse {\n\t\tassert(tlck->type & tlckEA);\n\n\t\t/* log LOG_UPDATEMAP for logredo() to update bmap for\n\t\t * alloc of new (and free of old) external EA extent;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tnlock = pxdlock->index;\n\t\tfor (i = 0; i < nlock; i++, pxdlock++) {\n\t\t\tif (pxdlock->flag & mlckALLOCPXD)\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_ALLOCPXD);\n\t\t\telse\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t}\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "txLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "1381-1431",
    "snippet": "static int txLog(struct jfs_log * log, struct tblock * tblk, struct commit * cd)\n{\n\tint rc = 0;\n\tstruct inode *ip;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct lrd *lrd = &cd->lrd;\n\n\t/*\n\t * write log record(s) for each tlock of transaction,\n\t */\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\ttlck->flag |= tlckLOG;\n\n\t\t/* initialize lrd common */\n\t\tip = tlck->ip;\n\t\tlrd->aggregate = cpu_to_le32(JFS_SBI(ip->i_sb)->aggregate);\n\t\tlrd->log.redopage.fileset = cpu_to_le32(JFS_IP(ip)->fileset);\n\t\tlrd->log.redopage.inode = cpu_to_le32(ip->i_ino);\n\n\t\t/* write log record of page from the tlock */\n\t\tswitch (tlck->type & tlckTYPE) {\n\t\tcase tlckXTREE:\n\t\t\txtLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckDTREE:\n\t\t\tdtLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckINODE:\n\t\t\tdiLog(log, tblk, lrd, tlck, cd);\n\t\t\tbreak;\n\n\t\tcase tlckMAP:\n\t\t\tmapLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckDATA:\n\t\t\tdataLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t\t}\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"UFO tlock:0x%p\"",
            "tlck"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dataLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "tlck"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "dataLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1551-1590",
          "snippet": "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t    struct tlock * tlck)\n{\n\tstruct metapage *mp;\n\tpxd_t *pxd;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_DATA);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2DATASLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\t/* log after-image for logredo(): */\n\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\n\tif (jfs_dirtable_inline(tlck->ip)) {\n\t\t/*\n\t\t * The table has been truncated, we've must have deleted\n\t\t * the last entry, so don't bother logging this\n\t\t */\n\t\tmp->lid = 0;\n\t\tgrab_metapage(mp);\n\t\tmetapage_homeok(mp);\n\t\tdiscard_metapage(mp);\n\t\ttlck->mp = NULL;\n\t\treturn 0;\n\t}\n\n\tPXDaddress(pxd, mp->index);\n\tPXDlength(pxd, mp->logical_size >> tblk->sb->s_blocksize_bits);\n\n\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t/* mark page as homeward bound */\n\ttlck->flag |= tlckWRITEPAGE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t    struct tlock * tlck)\n{\n\tstruct metapage *mp;\n\tpxd_t *pxd;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_DATA);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2DATASLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\t/* log after-image for logredo(): */\n\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\n\tif (jfs_dirtable_inline(tlck->ip)) {\n\t\t/*\n\t\t * The table has been truncated, we've must have deleted\n\t\t * the last entry, so don't bother logging this\n\t\t */\n\t\tmp->lid = 0;\n\t\tgrab_metapage(mp);\n\t\tmetapage_homeok(mp);\n\t\tdiscard_metapage(mp);\n\t\ttlck->mp = NULL;\n\t\treturn 0;\n\t}\n\n\tPXDaddress(pxd, mp->index);\n\tPXDlength(pxd, mp->logical_size >> tblk->sb->s_blocksize_bits);\n\n\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t/* mark page as homeward bound */\n\ttlck->flag |= tlckWRITEPAGE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "tlck"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "mapLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2086-2165",
          "snippet": "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\t   struct tlock * tlck)\n{\n\tstruct pxd_lock *pxdlock;\n\tint i, nlock;\n\tpxd_t *pxd;\n\n\t/*\n\t *\tpage relocation: free the source page extent\n\t *\n\t * a maplock for txUpdateMap() for free of the page\n\t * has been formatted at txLock() time saving the src\n\t * relocated page address;\n\t */\n\tif (tlck->type & tlckRELOCATE) {\n\t\t/* log LOG_NOREDOPAGE of the old relocated page\n\t\t * for logredo() to start NoRedoPage filter;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxd = &lrd->log.redopage.pxd;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* (N.B. currently, logredo() does NOT update bmap\n\t\t * for free of the page itself for (LOG_XTREE|LOG_NOREDOPAGE);\n\t\t * if page free from relocation, LOG_UPDATEMAP log is\n\t\t * specifically generated now for logredo()\n\t\t * to update bmap for free of src relocated page;\n\t\t * (new flag LOG_RELOCATE may be introduced which will\n\t\t * inform logredo() to start NORedoPage filter and also\n\t\t * update block allocation map at the same time, thus\n\t\t * avoiding an extra log write);\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\n\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* a maplock for txUpdateMap() for free of the page\n\t\t * has been formatted at txLock() time;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\treturn;\n\t}\n\t/*\n\n\t * Otherwise it's not a relocate request\n\t *\n\t */\n\telse {\n\t\t/* log LOG_UPDATEMAP for logredo() to update bmap for\n\t\t * free of truncated/relocated delta extent of the data;\n\t\t * e.g.: external EA extent, relocated/truncated extent\n\t\t * from xtTailgate();\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tnlock = pxdlock->index;\n\t\tfor (i = 0; i < nlock; i++, pxdlock++) {\n\t\t\tif (pxdlock->flag & mlckALLOCPXD)\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_ALLOCPXD);\n\t\t\telse\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t\tjfs_info(\"mapLog: xaddr:0x%lx xlen:0x%x\",\n\t\t\t\t (ulong) addressPXD(&pxdlock->pxd),\n\t\t\t\t lengthPXD(&pxdlock->pxd));\n\t\t}\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\t   struct tlock * tlck)\n{\n\tstruct pxd_lock *pxdlock;\n\tint i, nlock;\n\tpxd_t *pxd;\n\n\t/*\n\t *\tpage relocation: free the source page extent\n\t *\n\t * a maplock for txUpdateMap() for free of the page\n\t * has been formatted at txLock() time saving the src\n\t * relocated page address;\n\t */\n\tif (tlck->type & tlckRELOCATE) {\n\t\t/* log LOG_NOREDOPAGE of the old relocated page\n\t\t * for logredo() to start NoRedoPage filter;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxd = &lrd->log.redopage.pxd;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* (N.B. currently, logredo() does NOT update bmap\n\t\t * for free of the page itself for (LOG_XTREE|LOG_NOREDOPAGE);\n\t\t * if page free from relocation, LOG_UPDATEMAP log is\n\t\t * specifically generated now for logredo()\n\t\t * to update bmap for free of src relocated page;\n\t\t * (new flag LOG_RELOCATE may be introduced which will\n\t\t * inform logredo() to start NORedoPage filter and also\n\t\t * update block allocation map at the same time, thus\n\t\t * avoiding an extra log write);\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\n\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* a maplock for txUpdateMap() for free of the page\n\t\t * has been formatted at txLock() time;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\treturn;\n\t}\n\t/*\n\n\t * Otherwise it's not a relocate request\n\t *\n\t */\n\telse {\n\t\t/* log LOG_UPDATEMAP for logredo() to update bmap for\n\t\t * free of truncated/relocated delta extent of the data;\n\t\t * e.g.: external EA extent, relocated/truncated extent\n\t\t * from xtTailgate();\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tnlock = pxdlock->index;\n\t\tfor (i = 0; i < nlock; i++, pxdlock++) {\n\t\t\tif (pxdlock->flag & mlckALLOCPXD)\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_ALLOCPXD);\n\t\t\telse\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t\tjfs_info(\"mapLog: xaddr:0x%lx xlen:0x%x\",\n\t\t\t\t (ulong) addressPXD(&pxdlock->pxd),\n\t\t\t\t lengthPXD(&pxdlock->pxd));\n\t\t}\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "diLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "tlck",
            "cd"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "diLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1438-1544",
          "snippet": "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\t struct tlock * tlck, struct commit * cd)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tpxd_t *pxd;\n\tstruct pxd_lock *pxdlock;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_INODE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2INODESLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\t/*\n\t *\tinode after image\n\t */\n\tif (tlck->type & tlckENTRY) {\n\t\t/* log after-image for logredo(): */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t} else if (tlck->type & tlckFREE) {\n\t\t/*\n\t\t *\tfree inode extent\n\t\t *\n\t\t * (pages of the freed inode extent have been invalidated and\n\t\t * a maplock for free of the extent has been formatted at\n\t\t * txLock() time);\n\t\t *\n\t\t * the tlock had been acquired on the inode allocation map page\n\t\t * (iag) that specifies the freed extent, even though the map\n\t\t * page is not itself logged, to prevent pageout of the map\n\t\t * page before the log;\n\t\t */\n\n\t\t/* log LOG_NOREDOINOEXT of the freed inode extent for\n\t\t * logredo() to start NoRedoPage filters, and to update\n\t\t * imap and bmap for free of the extent;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOINOEXT);\n\t\t/*\n\t\t * For the LOG_NOREDOINOEXT record, we need\n\t\t * to pass the IAG number and inode extent\n\t\t * index (within that IAG) from which the\n\t\t * the extent being released.  These have been\n\t\t * passed to us in the iplist[1] and iplist[2].\n\t\t */\n\t\tlrd->log.noredoinoext.iagnum =\n\t\t    cpu_to_le32((u32) (size_t) cd->iplist[1]);\n\t\tlrd->log.noredoinoext.inoext_idx =\n\t\t    cpu_to_le32((u32) (size_t) cd->iplist[2]);\n\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t} else\n\t\tjfs_err(\"diLog: UFO type tlck:0x%p\", tlck);\n#ifdef  _JFS_WIP\n\t/*\n\t *\talloc/free external EA extent\n\t *\n\t * a maplock for txUpdateMap() to update bPWMAP for alloc/free\n\t * of the extent has been formatted at txLock() time;\n\t */\n\telse {\n\t\tassert(tlck->type & tlckEA);\n\n\t\t/* log LOG_UPDATEMAP for logredo() to update bmap for\n\t\t * alloc of new (and free of old) external EA extent;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tnlock = pxdlock->index;\n\t\tfor (i = 0; i < nlock; i++, pxdlock++) {\n\t\t\tif (pxdlock->flag & mlckALLOCPXD)\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_ALLOCPXD);\n\t\t\telse\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t}\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\t struct tlock * tlck, struct commit * cd)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tpxd_t *pxd;\n\tstruct pxd_lock *pxdlock;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_INODE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2INODESLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\t/*\n\t *\tinode after image\n\t */\n\tif (tlck->type & tlckENTRY) {\n\t\t/* log after-image for logredo(): */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t} else if (tlck->type & tlckFREE) {\n\t\t/*\n\t\t *\tfree inode extent\n\t\t *\n\t\t * (pages of the freed inode extent have been invalidated and\n\t\t * a maplock for free of the extent has been formatted at\n\t\t * txLock() time);\n\t\t *\n\t\t * the tlock had been acquired on the inode allocation map page\n\t\t * (iag) that specifies the freed extent, even though the map\n\t\t * page is not itself logged, to prevent pageout of the map\n\t\t * page before the log;\n\t\t */\n\n\t\t/* log LOG_NOREDOINOEXT of the freed inode extent for\n\t\t * logredo() to start NoRedoPage filters, and to update\n\t\t * imap and bmap for free of the extent;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOINOEXT);\n\t\t/*\n\t\t * For the LOG_NOREDOINOEXT record, we need\n\t\t * to pass the IAG number and inode extent\n\t\t * index (within that IAG) from which the\n\t\t * the extent being released.  These have been\n\t\t * passed to us in the iplist[1] and iplist[2].\n\t\t */\n\t\tlrd->log.noredoinoext.iagnum =\n\t\t    cpu_to_le32((u32) (size_t) cd->iplist[1]);\n\t\tlrd->log.noredoinoext.inoext_idx =\n\t\t    cpu_to_le32((u32) (size_t) cd->iplist[2]);\n\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t} else\n\t\tjfs_err(\"diLog: UFO type tlck:0x%p\", tlck);\n#ifdef  _JFS_WIP\n\t/*\n\t *\talloc/free external EA extent\n\t *\n\t * a maplock for txUpdateMap() to update bPWMAP for alloc/free\n\t * of the extent has been formatted at txLock() time;\n\t */\n\telse {\n\t\tassert(tlck->type & tlckEA);\n\n\t\t/* log LOG_UPDATEMAP for logredo() to update bmap for\n\t\t * alloc of new (and free of old) external EA extent;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tnlock = pxdlock->index;\n\t\tfor (i = 0; i < nlock; i++, pxdlock++) {\n\t\t\tif (pxdlock->flag & mlckALLOCPXD)\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_ALLOCPXD);\n\t\t\telse\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t}\n\n\t\t/* update bmap */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "tlck"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "dtLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1597-1693",
          "snippet": "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck)\n{\n\tstruct metapage *mp;\n\tstruct pxd_lock *pxdlock;\n\tpxd_t *pxd;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE/NOREDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_DTREE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2DTSLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\tif (tlck->type & tlckBTROOT)\n\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\n\n\t/*\n\t *\tpage extension via relocation: entry insertion;\n\t *\tpage extension in-place: entry insertion;\n\t *\tnew right page from page split, reinitialized in-line\n\t *\troot from root page split: entry insertion;\n\t */\n\tif (tlck->type & (tlckNEW | tlckEXTEND)) {\n\t\t/* log after-image of the new page for logredo():\n\t\t * mark log (LOG_NEW) for logredo() to initialize\n\t\t * freelist and update bmap for alloc of the new page;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tif (tlck->type & tlckEXTEND)\n\t\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_EXTEND);\n\t\telse\n\t\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_NEW);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bPMAP for\n\t\t * alloc of the new page;\n\t\t */\n\t\tif (tlck->type & tlckBTROOT)\n\t\t\treturn;\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxdlock->flag = mlckALLOCPXD;\n\t\tpxdlock->pxd = *pxd;\n\n\t\tpxdlock->index = 1;\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t\treturn;\n\t}\n\n\t/*\n\t *\tentry insertion/deletion,\n\t *\tsibling page link update (old right page before split);\n\t */\n\tif (tlck->type & (tlckENTRY | tlckRELINK)) {\n\t\t/* log after-image for logredo(): */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage deletion: page has been invalidated\n\t *\tpage relocation: source extent\n\t *\n\t *\ta maplock for free of the page has been formatted\n\t *\tat txLock() time);\n\t */\n\tif (tlck->type & (tlckFREE | tlckRELOCATE)) {\n\t\t/* log LOG_NOREDOPAGE of the deleted page for logredo()\n\t\t * to start NoRedoPage filter and to update bmap for free\n\t\t * of the deletd page\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* a maplock for txUpdateMap() for free of the page\n\t\t * has been formatted at txLock() time;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck)\n{\n\tstruct metapage *mp;\n\tstruct pxd_lock *pxdlock;\n\tpxd_t *pxd;\n\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE/NOREDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_DTREE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2DTSLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\tif (tlck->type & tlckBTROOT)\n\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\n\n\t/*\n\t *\tpage extension via relocation: entry insertion;\n\t *\tpage extension in-place: entry insertion;\n\t *\tnew right page from page split, reinitialized in-line\n\t *\troot from root page split: entry insertion;\n\t */\n\tif (tlck->type & (tlckNEW | tlckEXTEND)) {\n\t\t/* log after-image of the new page for logredo():\n\t\t * mark log (LOG_NEW) for logredo() to initialize\n\t\t * freelist and update bmap for alloc of the new page;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tif (tlck->type & tlckEXTEND)\n\t\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_EXTEND);\n\t\telse\n\t\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_NEW);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bPMAP for\n\t\t * alloc of the new page;\n\t\t */\n\t\tif (tlck->type & tlckBTROOT)\n\t\t\treturn;\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxdlock->flag = mlckALLOCPXD;\n\t\tpxdlock->pxd = *pxd;\n\n\t\tpxdlock->index = 1;\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t\treturn;\n\t}\n\n\t/*\n\t *\tentry insertion/deletion,\n\t *\tsibling page link update (old right page before split);\n\t */\n\tif (tlck->type & (tlckENTRY | tlckRELINK)) {\n\t\t/* log after-image for logredo(): */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage deletion: page has been invalidated\n\t *\tpage relocation: source extent\n\t *\n\t *\ta maplock for free of the page has been formatted\n\t *\tat txLock() time);\n\t */\n\tif (tlck->type & (tlckFREE | tlckRELOCATE)) {\n\t\t/* log LOG_NOREDOPAGE of the deleted page for logredo()\n\t\t * to start NoRedoPage filter and to update bmap for free\n\t\t * of the deletd page\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t/* a maplock for txUpdateMap() for free of the page\n\t\t * has been formatted at txLock() time;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "tlck"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "xtLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1700-2079",
          "snippet": "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck)\n{\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct xtlock *xtlck;\n\tstruct maplock *maplock;\n\tstruct xdlistlock *xadlock;\n\tstruct pxd_lock *pxdlock;\n\tpxd_t *page_pxd;\n\tint next, lwm, hwm;\n\n\tip = tlck->ip;\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE/NOREDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_XTREE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2XTSLOTSIZE);\n\n\tpage_pxd = &lrd->log.redopage.pxd;\n\n\tif (tlck->type & tlckBTROOT) {\n\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\n\t\tp = &JFS_IP(ip)->i_xtroot;\n\t\tif (S_ISDIR(ip->i_mode))\n\t\t\tlrd->log.redopage.type |=\n\t\t\t    cpu_to_le16(LOG_DIR_XTREE);\n\t} else\n\t\tp = (xtpage_t *) mp->data;\n\tnext = le16_to_cpu(p->header.nextindex);\n\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\tmaplock = (struct maplock *) & tlck->lock;\n\txadlock = (struct xdlistlock *) maplock;\n\n\t/*\n\t *\tentry insertion/extension;\n\t *\tsibling page link update (old right page before split);\n\t */\n\tif (tlck->type & (tlckNEW | tlckGROW | tlckRELINK)) {\n\t\t/* log after-image for logredo():\n\t\t * logredo() will update bmap for alloc of new/extended\n\t\t * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from\n\t\t * after-image of XADlist;\n\t\t * logredo() resets (XAD_NEW|XAD_EXTEND) flag when\n\t\t * applying the after-image to the meta-data page.\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(page_pxd, mp->index);\n\t\tPXDlength(page_pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bPMAP\n\t\t * for alloc of new/extended extents of XAD[lwm:next)\n\t\t * from the page itself;\n\t\t * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.\n\t\t */\n\t\tlwm = xtlck->lwm.offset;\n\t\tif (lwm == 0)\n\t\t\tlwm = XTPAGEMAXSLOT;\n\n\t\tif (lwm == next)\n\t\t\tgoto out;\n\t\tif (lwm > next) {\n\t\t\tjfs_err(\"xtLog: lwm > next\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\txadlock->flag = mlckALLOCXADLIST;\n\t\txadlock->count = next - lwm;\n\t\tif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\n\t\t\tint i;\n\t\t\tpxd_t *pxd;\n\t\t\t/*\n\t\t\t * Lazy commit may allow xtree to be modified before\n\t\t\t * txUpdateMap runs.  Copy xad into linelock to\n\t\t\t * preserve correct data.\n\t\t\t *\n\t\t\t * We can fit twice as may pxd's as xads in the lock\n\t\t\t */\n\t\t\txadlock->flag = mlckALLOCPXDLIST;\n\t\t\tpxd = xadlock->xdlist = &xtlck->pxdlock;\n\t\t\tfor (i = 0; i < xadlock->count; i++) {\n\t\t\t\tPXDaddress(pxd, addressXAD(&p->xad[lwm + i]));\n\t\t\t\tPXDlength(pxd, lengthXAD(&p->xad[lwm + i]));\n\t\t\t\tp->xad[lwm + i].flag &=\n\t\t\t\t    ~(XAD_NEW | XAD_EXTENDED);\n\t\t\t\tpxd++;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * xdlist will point to into inode's xtree, ensure\n\t\t\t * that transaction is not committed lazily.\n\t\t\t */\n\t\t\txadlock->flag = mlckALLOCXADLIST;\n\t\t\txadlock->xdlist = &p->xad[lwm];\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\t}\n\t\tjfs_info(\"xtLog: alloc ip:0x%p mp:0x%p tlck:0x%p lwm:%d \"\n\t\t\t \"count:%d\", tlck->ip, mp, tlck, lwm, xadlock->count);\n\n\t\tmaplock->index = 1;\n\n\t      out:\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage deletion: file deletion/truncation (ref. xtTruncate())\n\t *\n\t * (page will be invalidated after log is written and bmap\n\t * is updated from the page);\n\t */\n\tif (tlck->type & tlckFREE) {\n\t\t/* LOG_NOREDOPAGE log for NoRedoPage filter:\n\t\t * if page free from file delete, NoRedoFile filter from\n\t\t * inode image of zero link count will subsume NoRedoPage\n\t\t * filters for each page;\n\t\t * if page free from file truncattion, write NoRedoPage\n\t\t * filter;\n\t\t *\n\t\t * upadte of block allocation map for the page itself:\n\t\t * if page free from deletion and truncation, LOG_UPDATEMAP\n\t\t * log for the page itself is generated from processing\n\t\t * its parent page xad entries;\n\t\t */\n\t\t/* if page free from file truncation, log LOG_NOREDOPAGE\n\t\t * of the deleted page for logredo() to start NoRedoPage\n\t\t * filter for the page;\n\t\t */\n\t\tif (tblk->xflag & COMMIT_TRUNCATE) {\n\t\t\t/* write NOREDOPAGE for the page */\n\t\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\t\tPXDaddress(page_pxd, mp->index);\n\t\t\tPXDlength(page_pxd,\n\t\t\t\t  mp->logical_size >> tblk->sb->\n\t\t\t\t  s_blocksize_bits);\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t\tif (tlck->type & tlckBTROOT) {\n\t\t\t\t/* Empty xtree must be logged */\n\t\t\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\t\t\tlrd->backchain =\n\t\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\t\t\t}\n\t\t}\n\n\t\t/* init LOG_UPDATEMAP of the freed extents\n\t\t * XAD[XTENTRYSTART:hwm) from the deleted page itself\n\t\t * for logredo() to update bmap;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEXADLIST);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\thwm = xtlck->hwm.offset;\n\t\tlrd->log.updatemap.nxd =\n\t\t    cpu_to_le16(hwm - XTENTRYSTART + 1);\n\t\t/* reformat linelock for lmLog() */\n\t\txtlck->header.offset = XTENTRYSTART;\n\t\txtlck->header.length = hwm - XTENTRYSTART + 1;\n\t\txtlck->index = 1;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t * to free extents of XAD[XTENTRYSTART:hwm) from the\n\t\t * deleted page itself;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\txadlock->count = hwm - XTENTRYSTART + 1;\n\t\tif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\n\t\t\tint i;\n\t\t\tpxd_t *pxd;\n\t\t\t/*\n\t\t\t * Lazy commit may allow xtree to be modified before\n\t\t\t * txUpdateMap runs.  Copy xad into linelock to\n\t\t\t * preserve correct data.\n\t\t\t *\n\t\t\t * We can fit twice as may pxd's as xads in the lock\n\t\t\t */\n\t\t\txadlock->flag = mlckFREEPXDLIST;\n\t\t\tpxd = xadlock->xdlist = &xtlck->pxdlock;\n\t\t\tfor (i = 0; i < xadlock->count; i++) {\n\t\t\t\tPXDaddress(pxd,\n\t\t\t\t\taddressXAD(&p->xad[XTENTRYSTART + i]));\n\t\t\t\tPXDlength(pxd,\n\t\t\t\t\tlengthXAD(&p->xad[XTENTRYSTART + i]));\n\t\t\t\tpxd++;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * xdlist will point to into inode's xtree, ensure\n\t\t\t * that transaction is not committed lazily.\n\t\t\t */\n\t\t\txadlock->flag = mlckFREEXADLIST;\n\t\t\txadlock->xdlist = &p->xad[XTENTRYSTART];\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\t}\n\t\tjfs_info(\"xtLog: free ip:0x%p mp:0x%p count:%d lwm:2\",\n\t\t\t tlck->ip, mp, xadlock->count);\n\n\t\tmaplock->index = 1;\n\n\t\t/* mark page as invalid */\n\t\tif (((tblk->xflag & COMMIT_PWMAP) || S_ISDIR(ip->i_mode))\n\t\t    && !(tlck->type & tlckBTROOT))\n\t\t\ttlck->flag |= tlckFREEPAGE;\n\t\t/*\n\t\t   else (tblk->xflag & COMMIT_PMAP)\n\t\t   ? release the page;\n\t\t */\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage/entry truncation: file truncation (ref. xtTruncate())\n\t *\n\t *\t|----------+------+------+---------------|\n\t *\t\t   |      |      |\n\t *\t\t   |      |     hwm - hwm before truncation\n\t *\t\t   |     next - truncation point\n\t *\t\t  lwm - lwm before truncation\n\t * header ?\n\t */\n\tif (tlck->type & tlckTRUNCATE) {\n\t\t/* This odd declaration suppresses a bogus gcc warning */\n\t\tpxd_t pxd = pxd;\t/* truncated extent of xad */\n\t\tint twm;\n\n\t\t/*\n\t\t * For truncation the entire linelock may be used, so it would\n\t\t * be difficult to store xad list in linelock itself.\n\t\t * Therefore, we'll just force transaction to be committed\n\t\t * synchronously, so that xtree pages won't be changed before\n\t\t * txUpdateMap runs.\n\t\t */\n\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\tlwm = xtlck->lwm.offset;\n\t\tif (lwm == 0)\n\t\t\tlwm = XTPAGEMAXSLOT;\n\t\thwm = xtlck->hwm.offset;\n\t\ttwm = xtlck->twm.offset;\n\n\t\t/*\n\t\t *\twrite log records\n\t\t */\n\t\t/* log after-image for logredo():\n\t\t *\n\t\t * logredo() will update bmap for alloc of new/extended\n\t\t * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from\n\t\t * after-image of XADlist;\n\t\t * logredo() resets (XAD_NEW|XAD_EXTEND) flag when\n\t\t * applying the after-image to the meta-data page.\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(page_pxd, mp->index);\n\t\tPXDlength(page_pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/*\n\t\t * truncate entry XAD[twm == next - 1]:\n\t\t */\n\t\tif (twm == next - 1) {\n\t\t\t/* init LOG_UPDATEMAP for logredo() to update bmap for\n\t\t\t * free of truncated delta extent of the truncated\n\t\t\t * entry XAD[next - 1]:\n\t\t\t * (xtlck->pxdlock = truncated delta extent);\n\t\t\t */\n\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t/* assert(pxdlock->type & tlckTRUNCATE); */\n\t\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tpxd = pxdlock->pxd;\t/* save to format maplock */\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t}\n\n\t\t/*\n\t\t * free entries XAD[next:hwm]:\n\t\t */\n\t\tif (hwm >= next) {\n\t\t\t/* init LOG_UPDATEMAP of the freed extents\n\t\t\t * XAD[next:hwm] from the deleted page itself\n\t\t\t * for logredo() to update bmap;\n\t\t\t */\n\t\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\t\tlrd->log.updatemap.type =\n\t\t\t    cpu_to_le16(LOG_FREEXADLIST);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\thwm = xtlck->hwm.offset;\n\t\t\tlrd->log.updatemap.nxd =\n\t\t\t    cpu_to_le16(hwm - next + 1);\n\t\t\t/* reformat linelock for lmLog() */\n\t\t\txtlck->header.offset = next;\n\t\t\txtlck->header.length = hwm - next + 1;\n\t\t\txtlck->index = 1;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\t\t}\n\n\t\t/*\n\t\t *\tformat maplock(s) for txUpdateMap() to update bmap\n\t\t */\n\t\tmaplock->index = 0;\n\n\t\t/*\n\t\t * allocate entries XAD[lwm:next):\n\t\t */\n\t\tif (lwm < next) {\n\t\t\t/* format a maplock for txUpdateMap() to update bPMAP\n\t\t\t * for alloc of new/extended extents of XAD[lwm:next)\n\t\t\t * from the page itself;\n\t\t\t * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\txadlock->flag = mlckALLOCXADLIST;\n\t\t\txadlock->count = next - lwm;\n\t\t\txadlock->xdlist = &p->xad[lwm];\n\n\t\t\tjfs_info(\"xtLog: alloc ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"lwm:%d next:%d\",\n\t\t\t\t tlck->ip, mp, xadlock->count, lwm, next);\n\t\t\tmaplock->index++;\n\t\t\txadlock++;\n\t\t}\n\n\t\t/*\n\t\t * truncate entry XAD[twm == next - 1]:\n\t\t */\n\t\tif (twm == next - 1) {\n\t\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t\t * to free truncated delta extent of the truncated\n\t\t\t * entry XAD[next - 1];\n\t\t\t * (xtlck->pxdlock = truncated delta extent);\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\tpxdlock = (struct pxd_lock *) xadlock;\n\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\tpxdlock->count = 1;\n\t\t\tpxdlock->pxd = pxd;\n\n\t\t\tjfs_info(\"xtLog: truncate ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"hwm:%d\", ip, mp, pxdlock->count, hwm);\n\t\t\tmaplock->index++;\n\t\t\txadlock++;\n\t\t}\n\n\t\t/*\n\t\t * free entries XAD[next:hwm]:\n\t\t */\n\t\tif (hwm >= next) {\n\t\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t\t * to free extents of XAD[next:hwm] from thedeleted\n\t\t\t * page itself;\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\txadlock->flag = mlckFREEXADLIST;\n\t\t\txadlock->count = hwm - next + 1;\n\t\t\txadlock->xdlist = &p->xad[next];\n\n\t\t\tjfs_info(\"xtLog: free ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"next:%d hwm:%d\",\n\t\t\t\t tlck->ip, mp, xadlock->count, next, hwm);\n\t\t\tmaplock->index++;\n\t\t}\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck)\n{\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct xtlock *xtlck;\n\tstruct maplock *maplock;\n\tstruct xdlistlock *xadlock;\n\tstruct pxd_lock *pxdlock;\n\tpxd_t *page_pxd;\n\tint next, lwm, hwm;\n\n\tip = tlck->ip;\n\tmp = tlck->mp;\n\n\t/* initialize as REDOPAGE/NOREDOPAGE record format */\n\tlrd->log.redopage.type = cpu_to_le16(LOG_XTREE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2XTSLOTSIZE);\n\n\tpage_pxd = &lrd->log.redopage.pxd;\n\n\tif (tlck->type & tlckBTROOT) {\n\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\n\t\tp = &JFS_IP(ip)->i_xtroot;\n\t\tif (S_ISDIR(ip->i_mode))\n\t\t\tlrd->log.redopage.type |=\n\t\t\t    cpu_to_le16(LOG_DIR_XTREE);\n\t} else\n\t\tp = (xtpage_t *) mp->data;\n\tnext = le16_to_cpu(p->header.nextindex);\n\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\tmaplock = (struct maplock *) & tlck->lock;\n\txadlock = (struct xdlistlock *) maplock;\n\n\t/*\n\t *\tentry insertion/extension;\n\t *\tsibling page link update (old right page before split);\n\t */\n\tif (tlck->type & (tlckNEW | tlckGROW | tlckRELINK)) {\n\t\t/* log after-image for logredo():\n\t\t * logredo() will update bmap for alloc of new/extended\n\t\t * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from\n\t\t * after-image of XADlist;\n\t\t * logredo() resets (XAD_NEW|XAD_EXTEND) flag when\n\t\t * applying the after-image to the meta-data page.\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(page_pxd, mp->index);\n\t\tPXDlength(page_pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bPMAP\n\t\t * for alloc of new/extended extents of XAD[lwm:next)\n\t\t * from the page itself;\n\t\t * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.\n\t\t */\n\t\tlwm = xtlck->lwm.offset;\n\t\tif (lwm == 0)\n\t\t\tlwm = XTPAGEMAXSLOT;\n\n\t\tif (lwm == next)\n\t\t\tgoto out;\n\t\tif (lwm > next) {\n\t\t\tjfs_err(\"xtLog: lwm > next\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\txadlock->flag = mlckALLOCXADLIST;\n\t\txadlock->count = next - lwm;\n\t\tif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\n\t\t\tint i;\n\t\t\tpxd_t *pxd;\n\t\t\t/*\n\t\t\t * Lazy commit may allow xtree to be modified before\n\t\t\t * txUpdateMap runs.  Copy xad into linelock to\n\t\t\t * preserve correct data.\n\t\t\t *\n\t\t\t * We can fit twice as may pxd's as xads in the lock\n\t\t\t */\n\t\t\txadlock->flag = mlckALLOCPXDLIST;\n\t\t\tpxd = xadlock->xdlist = &xtlck->pxdlock;\n\t\t\tfor (i = 0; i < xadlock->count; i++) {\n\t\t\t\tPXDaddress(pxd, addressXAD(&p->xad[lwm + i]));\n\t\t\t\tPXDlength(pxd, lengthXAD(&p->xad[lwm + i]));\n\t\t\t\tp->xad[lwm + i].flag &=\n\t\t\t\t    ~(XAD_NEW | XAD_EXTENDED);\n\t\t\t\tpxd++;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * xdlist will point to into inode's xtree, ensure\n\t\t\t * that transaction is not committed lazily.\n\t\t\t */\n\t\t\txadlock->flag = mlckALLOCXADLIST;\n\t\t\txadlock->xdlist = &p->xad[lwm];\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\t}\n\t\tjfs_info(\"xtLog: alloc ip:0x%p mp:0x%p tlck:0x%p lwm:%d \"\n\t\t\t \"count:%d\", tlck->ip, mp, tlck, lwm, xadlock->count);\n\n\t\tmaplock->index = 1;\n\n\t      out:\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage deletion: file deletion/truncation (ref. xtTruncate())\n\t *\n\t * (page will be invalidated after log is written and bmap\n\t * is updated from the page);\n\t */\n\tif (tlck->type & tlckFREE) {\n\t\t/* LOG_NOREDOPAGE log for NoRedoPage filter:\n\t\t * if page free from file delete, NoRedoFile filter from\n\t\t * inode image of zero link count will subsume NoRedoPage\n\t\t * filters for each page;\n\t\t * if page free from file truncattion, write NoRedoPage\n\t\t * filter;\n\t\t *\n\t\t * upadte of block allocation map for the page itself:\n\t\t * if page free from deletion and truncation, LOG_UPDATEMAP\n\t\t * log for the page itself is generated from processing\n\t\t * its parent page xad entries;\n\t\t */\n\t\t/* if page free from file truncation, log LOG_NOREDOPAGE\n\t\t * of the deleted page for logredo() to start NoRedoPage\n\t\t * filter for the page;\n\t\t */\n\t\tif (tblk->xflag & COMMIT_TRUNCATE) {\n\t\t\t/* write NOREDOPAGE for the page */\n\t\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\t\tPXDaddress(page_pxd, mp->index);\n\t\t\tPXDlength(page_pxd,\n\t\t\t\t  mp->logical_size >> tblk->sb->\n\t\t\t\t  s_blocksize_bits);\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t\tif (tlck->type & tlckBTROOT) {\n\t\t\t\t/* Empty xtree must be logged */\n\t\t\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\t\t\tlrd->backchain =\n\t\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\t\t\t}\n\t\t}\n\n\t\t/* init LOG_UPDATEMAP of the freed extents\n\t\t * XAD[XTENTRYSTART:hwm) from the deleted page itself\n\t\t * for logredo() to update bmap;\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEXADLIST);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\thwm = xtlck->hwm.offset;\n\t\tlrd->log.updatemap.nxd =\n\t\t    cpu_to_le16(hwm - XTENTRYSTART + 1);\n\t\t/* reformat linelock for lmLog() */\n\t\txtlck->header.offset = XTENTRYSTART;\n\t\txtlck->header.length = hwm - XTENTRYSTART + 1;\n\t\txtlck->index = 1;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t * to free extents of XAD[XTENTRYSTART:hwm) from the\n\t\t * deleted page itself;\n\t\t */\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\txadlock->count = hwm - XTENTRYSTART + 1;\n\t\tif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\n\t\t\tint i;\n\t\t\tpxd_t *pxd;\n\t\t\t/*\n\t\t\t * Lazy commit may allow xtree to be modified before\n\t\t\t * txUpdateMap runs.  Copy xad into linelock to\n\t\t\t * preserve correct data.\n\t\t\t *\n\t\t\t * We can fit twice as may pxd's as xads in the lock\n\t\t\t */\n\t\t\txadlock->flag = mlckFREEPXDLIST;\n\t\t\tpxd = xadlock->xdlist = &xtlck->pxdlock;\n\t\t\tfor (i = 0; i < xadlock->count; i++) {\n\t\t\t\tPXDaddress(pxd,\n\t\t\t\t\taddressXAD(&p->xad[XTENTRYSTART + i]));\n\t\t\t\tPXDlength(pxd,\n\t\t\t\t\tlengthXAD(&p->xad[XTENTRYSTART + i]));\n\t\t\t\tpxd++;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * xdlist will point to into inode's xtree, ensure\n\t\t\t * that transaction is not committed lazily.\n\t\t\t */\n\t\t\txadlock->flag = mlckFREEXADLIST;\n\t\t\txadlock->xdlist = &p->xad[XTENTRYSTART];\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\t}\n\t\tjfs_info(\"xtLog: free ip:0x%p mp:0x%p count:%d lwm:2\",\n\t\t\t tlck->ip, mp, xadlock->count);\n\n\t\tmaplock->index = 1;\n\n\t\t/* mark page as invalid */\n\t\tif (((tblk->xflag & COMMIT_PWMAP) || S_ISDIR(ip->i_mode))\n\t\t    && !(tlck->type & tlckBTROOT))\n\t\t\ttlck->flag |= tlckFREEPAGE;\n\t\t/*\n\t\t   else (tblk->xflag & COMMIT_PMAP)\n\t\t   ? release the page;\n\t\t */\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpage/entry truncation: file truncation (ref. xtTruncate())\n\t *\n\t *\t|----------+------+------+---------------|\n\t *\t\t   |      |      |\n\t *\t\t   |      |     hwm - hwm before truncation\n\t *\t\t   |     next - truncation point\n\t *\t\t  lwm - lwm before truncation\n\t * header ?\n\t */\n\tif (tlck->type & tlckTRUNCATE) {\n\t\t/* This odd declaration suppresses a bogus gcc warning */\n\t\tpxd_t pxd = pxd;\t/* truncated extent of xad */\n\t\tint twm;\n\n\t\t/*\n\t\t * For truncation the entire linelock may be used, so it would\n\t\t * be difficult to store xad list in linelock itself.\n\t\t * Therefore, we'll just force transaction to be committed\n\t\t * synchronously, so that xtree pages won't be changed before\n\t\t * txUpdateMap runs.\n\t\t */\n\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\tlwm = xtlck->lwm.offset;\n\t\tif (lwm == 0)\n\t\t\tlwm = XTPAGEMAXSLOT;\n\t\thwm = xtlck->hwm.offset;\n\t\ttwm = xtlck->twm.offset;\n\n\t\t/*\n\t\t *\twrite log records\n\t\t */\n\t\t/* log after-image for logredo():\n\t\t *\n\t\t * logredo() will update bmap for alloc of new/extended\n\t\t * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from\n\t\t * after-image of XADlist;\n\t\t * logredo() resets (XAD_NEW|XAD_EXTEND) flag when\n\t\t * applying the after-image to the meta-data page.\n\t\t */\n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(page_pxd, mp->index);\n\t\tPXDlength(page_pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t/*\n\t\t * truncate entry XAD[twm == next - 1]:\n\t\t */\n\t\tif (twm == next - 1) {\n\t\t\t/* init LOG_UPDATEMAP for logredo() to update bmap for\n\t\t\t * free of truncated delta extent of the truncated\n\t\t\t * entry XAD[next - 1]:\n\t\t\t * (xtlck->pxdlock = truncated delta extent);\n\t\t\t */\n\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t/* assert(pxdlock->type & tlckTRUNCATE); */\n\t\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tpxd = pxdlock->pxd;\t/* save to format maplock */\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t}\n\n\t\t/*\n\t\t * free entries XAD[next:hwm]:\n\t\t */\n\t\tif (hwm >= next) {\n\t\t\t/* init LOG_UPDATEMAP of the freed extents\n\t\t\t * XAD[next:hwm] from the deleted page itself\n\t\t\t * for logredo() to update bmap;\n\t\t\t */\n\t\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\t\tlrd->log.updatemap.type =\n\t\t\t    cpu_to_le16(LOG_FREEXADLIST);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\thwm = xtlck->hwm.offset;\n\t\t\tlrd->log.updatemap.nxd =\n\t\t\t    cpu_to_le16(hwm - next + 1);\n\t\t\t/* reformat linelock for lmLog() */\n\t\t\txtlck->header.offset = next;\n\t\t\txtlck->header.length = hwm - next + 1;\n\t\t\txtlck->index = 1;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\t\t}\n\n\t\t/*\n\t\t *\tformat maplock(s) for txUpdateMap() to update bmap\n\t\t */\n\t\tmaplock->index = 0;\n\n\t\t/*\n\t\t * allocate entries XAD[lwm:next):\n\t\t */\n\t\tif (lwm < next) {\n\t\t\t/* format a maplock for txUpdateMap() to update bPMAP\n\t\t\t * for alloc of new/extended extents of XAD[lwm:next)\n\t\t\t * from the page itself;\n\t\t\t * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\txadlock->flag = mlckALLOCXADLIST;\n\t\t\txadlock->count = next - lwm;\n\t\t\txadlock->xdlist = &p->xad[lwm];\n\n\t\t\tjfs_info(\"xtLog: alloc ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"lwm:%d next:%d\",\n\t\t\t\t tlck->ip, mp, xadlock->count, lwm, next);\n\t\t\tmaplock->index++;\n\t\t\txadlock++;\n\t\t}\n\n\t\t/*\n\t\t * truncate entry XAD[twm == next - 1]:\n\t\t */\n\t\tif (twm == next - 1) {\n\t\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t\t * to free truncated delta extent of the truncated\n\t\t\t * entry XAD[next - 1];\n\t\t\t * (xtlck->pxdlock = truncated delta extent);\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\tpxdlock = (struct pxd_lock *) xadlock;\n\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\tpxdlock->count = 1;\n\t\t\tpxdlock->pxd = pxd;\n\n\t\t\tjfs_info(\"xtLog: truncate ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"hwm:%d\", ip, mp, pxdlock->count, hwm);\n\t\t\tmaplock->index++;\n\t\t\txadlock++;\n\t\t}\n\n\t\t/*\n\t\t * free entries XAD[next:hwm]:\n\t\t */\n\t\tif (hwm >= next) {\n\t\t\t/* format a maplock for txUpdateMap() to update bmap\n\t\t\t * to free extents of XAD[next:hwm] from thedeleted\n\t\t\t * page itself;\n\t\t\t */\n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\txadlock->flag = mlckFREEXADLIST;\n\t\t\txadlock->count = hwm - next + 1;\n\t\t\txadlock->xdlist = &p->xad[next];\n\n\t\t\tjfs_info(\"xtLog: free ip:0x%p mp:0x%p count:%d \"\n\t\t\t\t \"next:%d hwm:%d\",\n\t\t\t\t tlck->ip, mp, xadlock->count, next, hwm);\n\t\t\tmaplock->index++;\n\t\t}\n\n\t\t/* mark page as homeward bound */\n\t\ttlck->flag |= tlckWRITEPAGE;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ip->i_ino"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_IP(ip)->fileset"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_SBI(ip->i_sb)->aggregate"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstatic int txLog(struct jfs_log * log, struct tblock * tblk, struct commit * cd)\n{\n\tint rc = 0;\n\tstruct inode *ip;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct lrd *lrd = &cd->lrd;\n\n\t/*\n\t * write log record(s) for each tlock of transaction,\n\t */\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\ttlck->flag |= tlckLOG;\n\n\t\t/* initialize lrd common */\n\t\tip = tlck->ip;\n\t\tlrd->aggregate = cpu_to_le32(JFS_SBI(ip->i_sb)->aggregate);\n\t\tlrd->log.redopage.fileset = cpu_to_le32(JFS_IP(ip)->fileset);\n\t\tlrd->log.redopage.inode = cpu_to_le32(ip->i_ino);\n\n\t\t/* write log record of page from the tlock */\n\t\tswitch (tlck->type & tlckTYPE) {\n\t\tcase tlckXTREE:\n\t\t\txtLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckDTREE:\n\t\t\tdtLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckINODE:\n\t\t\tdiLog(log, tblk, lrd, tlck, cd);\n\t\t\tbreak;\n\n\t\tcase tlckMAP:\n\t\t\tmapLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckDATA:\n\t\t\tdataLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t\t}\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "txCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "1135-1368",
    "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txCommit: tid = %d, returning %d\"",
            "tid",
            "rc"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txAbort",
          "args": [
            "tid",
            "1"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "txAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2642-2689",
          "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txUnlock",
          "args": [
            "tblk"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "txUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "908-987",
          "snippet": "static void txUnlock(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\tlid_t lid, next, llid, k;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint difft, diffp;\n\tunsigned long flags;\n\n\tjfs_info(\"txUnlock: tblk = 0x%p\", tblk);\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * mark page under tlock homeok (its log has been written):\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tjfs_info(\"unlocking lid = %d, tlck = 0x%p\", lid, tlck);\n\n\t\t/* unbind page from tlock */\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\t/* hold buffer\n\t\t\t */\n\t\t\thold_metapage(mp);\n\n\t\t\tassert(mp->nohomeok > 0);\n\t\t\t_metapage_homeok(mp);\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tLOGSYNC_LOCK(log, flags);\n\t\t\tif (mp->clsn) {\n\t\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\t\tif (difft > diffp)\n\t\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\t} else\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t\t\tassert(!(tlck->flag & tlckFREEPAGE));\n\n\t\t\tput_metapage(mp);\n\t\t}\n\n\t\t/* insert tlock, and linelock(s) of the tlock if any,\n\t\t * at head of freelist\n\t\t */\n\t\tTXN_LOCK();\n\n\t\tllid = ((struct linelock *) & tlck->lock)->next;\n\t\twhile (llid) {\n\t\t\tlinelock = (struct linelock *) lid_to_tlock(llid);\n\t\t\tk = linelock->next;\n\t\t\ttxLockFree(llid);\n\t\t\tllid = k;\n\t\t}\n\t\ttxLockFree(lid);\n\n\t\tTXN_UNLOCK();\n\t}\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * remove tblock from logsynclist\n\t * (allocation map pages inherited lsn of tblk and\n\t * has been inserted in logsync list at txUpdateMap())\n\t */\n\tif (tblk->lsn) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tlog->count--;\n\t\tlist_del(&tblk->synclist);\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void txUnlock(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\tlid_t lid, next, llid, k;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint difft, diffp;\n\tunsigned long flags;\n\n\tjfs_info(\"txUnlock: tblk = 0x%p\", tblk);\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * mark page under tlock homeok (its log has been written):\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tjfs_info(\"unlocking lid = %d, tlck = 0x%p\", lid, tlck);\n\n\t\t/* unbind page from tlock */\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\t/* hold buffer\n\t\t\t */\n\t\t\thold_metapage(mp);\n\n\t\t\tassert(mp->nohomeok > 0);\n\t\t\t_metapage_homeok(mp);\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tLOGSYNC_LOCK(log, flags);\n\t\t\tif (mp->clsn) {\n\t\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\t\tif (difft > diffp)\n\t\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\t} else\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t\t\tassert(!(tlck->flag & tlckFREEPAGE));\n\n\t\t\tput_metapage(mp);\n\t\t}\n\n\t\t/* insert tlock, and linelock(s) of the tlock if any,\n\t\t * at head of freelist\n\t\t */\n\t\tTXN_LOCK();\n\n\t\tllid = ((struct linelock *) & tlck->lock)->next;\n\t\twhile (llid) {\n\t\t\tlinelock = (struct linelock *) lid_to_tlock(llid);\n\t\t\tk = linelock->next;\n\t\t\ttxLockFree(llid);\n\t\t\tllid = k;\n\t\t}\n\t\ttxLockFree(lid);\n\n\t\tTXN_UNLOCK();\n\t}\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * remove tblock from logsynclist\n\t * (allocation map pages inherited lsn of tblk and\n\t * has been inserted in logsync list at txUpdateMap())\n\t */\n\tif (tblk->lsn) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tlog->count--;\n\t\tlist_del(&tblk->synclist);\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txRelease",
          "args": [
            "tblk"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "txRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "876-900",
          "snippet": "static void txRelease(struct tblock * tblk)\n{\n\tstruct metapage *mp;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\n\tTXN_LOCK();\n\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\t\t\tmp->lid = 0;\n\t\t}\n\t}\n\n\t/*\n\t * wakeup transactions waiting on a page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tTXN_UNLOCK();\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void txRelease(struct tblock * tblk)\n{\n\tstruct metapage *mp;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\n\tTXN_LOCK();\n\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\t\t\tmp->lid = 0;\n\t\t}\n\t}\n\n\t/*\n\t * wakeup transactions waiting on a page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tTXN_UNLOCK();\n}"
        }
      },
      {
        "call_info": {
          "callee": "txUpdateMap",
          "args": [
            "tblk"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "txUpdateMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2293-2417",
          "snippet": "static void txUpdateMap(struct tblock * tblk)\n{\n\tstruct inode *ip;\n\tstruct inode *ipimap;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\tstruct pxd_lock pxdlock;\n\tint maptype;\n\tint k, nlock;\n\tstruct metapage *mp = NULL;\n\n\tipimap = JFS_SBI(tblk->sb)->ipimap;\n\n\tmaptype = (tblk->xflag & COMMIT_PMAP) ? COMMIT_PMAP : COMMIT_PWMAP;\n\n\n\t/*\n\t *\tupdate block allocation map\n\t *\n\t * update allocation state in pmap (and wmap) and\n\t * update lsn of the pmap page;\n\t */\n\t/*\n\t * scan each tlock/page of transaction for block allocation/free:\n\t *\n\t * for each tlock/page of transaction, update map.\n\t *  ? are there tlock for pmap and pwmap at the same time ?\n\t */\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif ((tlck->flag & tlckUPDATEMAP) == 0)\n\t\t\tcontinue;\n\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\t/*\n\t\t\t * Another thread may attempt to reuse freed space\n\t\t\t * immediately, so we want to get rid of the metapage\n\t\t\t * before anyone else has a chance to get it.\n\t\t\t * Lock metapage, update maps, then invalidate\n\t\t\t * the metapage.\n\t\t\t */\n\t\t\tmp = tlck->mp;\n\t\t\tASSERT(mp->xflag & COMMIT_PAGE);\n\t\t\tgrab_metapage(mp);\n\t\t}\n\n\t\t/*\n\t\t * extent list:\n\t\t * . in-line PXD list:\n\t\t * . out-of-line XAD list:\n\t\t */\n\t\tmaplock = (struct maplock *) & tlck->lock;\n\t\tnlock = maplock->index;\n\n\t\tfor (k = 0; k < nlock; k++, maplock++) {\n\t\t\t/*\n\t\t\t * allocate blocks in persistent map:\n\t\t\t *\n\t\t\t * blocks have been allocated from wmap at alloc time;\n\t\t\t */\n\t\t\tif (maplock->flag & mlckALLOC) {\n\t\t\t\ttxAllocPMap(ipimap, maplock, tblk);\n\t\t\t}\n\t\t\t/*\n\t\t\t * free blocks in persistent and working map:\n\t\t\t * blocks will be freed in pmap and then in wmap;\n\t\t\t *\n\t\t\t * ? tblock specifies the PMAP/PWMAP based upon\n\t\t\t * transaction\n\t\t\t *\n\t\t\t * free blocks in persistent map:\n\t\t\t * blocks will be freed from wmap at last reference\n\t\t\t * release of the object for regular files;\n\t\t\t *\n\t\t\t * Alway free blocks from both persistent & working\n\t\t\t * maps for directories\n\t\t\t */\n\t\t\telse {\t/* (maplock->flag & mlckFREE) */\n\n\t\t\t\tif (tlck->flag & tlckDIRECTORY)\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, COMMIT_PWMAP);\n\t\t\t\telse\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, maptype);\n\t\t\t}\n\t\t}\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\tif (!(tblk->flag & tblkGC_LAZY)) {\n\t\t\t\t/* This is equivalent to txRelease */\n\t\t\t\tASSERT(mp->lid == lid);\n\t\t\t\ttlck->mp->lid = 0;\n\t\t\t}\n\t\t\tassert(mp->nohomeok == 1);\n\t\t\tmetapage_homeok(mp);\n\t\t\tdiscard_metapage(mp);\n\t\t\ttlck->mp = NULL;\n\t\t}\n\t}\n\t/*\n\t *\tupdate inode allocation map\n\t *\n\t * update allocation state in pmap and\n\t * update lsn of the pmap page;\n\t * update in-memory inode flag/state\n\t *\n\t * unlock mapper/write lock\n\t */\n\tif (tblk->xflag & COMMIT_CREATE) {\n\t\tdiUpdatePMap(ipimap, tblk->ino, false, tblk);\n\t\t/* update persistent block allocation map\n\t\t * for the allocation of inode extent;\n\t\t */\n\t\tpxdlock.flag = mlckALLOCPXD;\n\t\tpxdlock.pxd = tblk->u.ixpxd;\n\t\tpxdlock.index = 1;\n\t\ttxAllocPMap(ipimap, (struct maplock *) & pxdlock, tblk);\n\t} else if (tblk->xflag & COMMIT_DELETE) {\n\t\tip = tblk->u.ip;\n\t\tdiUpdatePMap(ipimap, ip->i_ino, true, tblk);\n\t\tiput(ip);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void txUpdateMap(struct tblock * tblk)\n{\n\tstruct inode *ip;\n\tstruct inode *ipimap;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\tstruct pxd_lock pxdlock;\n\tint maptype;\n\tint k, nlock;\n\tstruct metapage *mp = NULL;\n\n\tipimap = JFS_SBI(tblk->sb)->ipimap;\n\n\tmaptype = (tblk->xflag & COMMIT_PMAP) ? COMMIT_PMAP : COMMIT_PWMAP;\n\n\n\t/*\n\t *\tupdate block allocation map\n\t *\n\t * update allocation state in pmap (and wmap) and\n\t * update lsn of the pmap page;\n\t */\n\t/*\n\t * scan each tlock/page of transaction for block allocation/free:\n\t *\n\t * for each tlock/page of transaction, update map.\n\t *  ? are there tlock for pmap and pwmap at the same time ?\n\t */\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif ((tlck->flag & tlckUPDATEMAP) == 0)\n\t\t\tcontinue;\n\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\t/*\n\t\t\t * Another thread may attempt to reuse freed space\n\t\t\t * immediately, so we want to get rid of the metapage\n\t\t\t * before anyone else has a chance to get it.\n\t\t\t * Lock metapage, update maps, then invalidate\n\t\t\t * the metapage.\n\t\t\t */\n\t\t\tmp = tlck->mp;\n\t\t\tASSERT(mp->xflag & COMMIT_PAGE);\n\t\t\tgrab_metapage(mp);\n\t\t}\n\n\t\t/*\n\t\t * extent list:\n\t\t * . in-line PXD list:\n\t\t * . out-of-line XAD list:\n\t\t */\n\t\tmaplock = (struct maplock *) & tlck->lock;\n\t\tnlock = maplock->index;\n\n\t\tfor (k = 0; k < nlock; k++, maplock++) {\n\t\t\t/*\n\t\t\t * allocate blocks in persistent map:\n\t\t\t *\n\t\t\t * blocks have been allocated from wmap at alloc time;\n\t\t\t */\n\t\t\tif (maplock->flag & mlckALLOC) {\n\t\t\t\ttxAllocPMap(ipimap, maplock, tblk);\n\t\t\t}\n\t\t\t/*\n\t\t\t * free blocks in persistent and working map:\n\t\t\t * blocks will be freed in pmap and then in wmap;\n\t\t\t *\n\t\t\t * ? tblock specifies the PMAP/PWMAP based upon\n\t\t\t * transaction\n\t\t\t *\n\t\t\t * free blocks in persistent map:\n\t\t\t * blocks will be freed from wmap at last reference\n\t\t\t * release of the object for regular files;\n\t\t\t *\n\t\t\t * Alway free blocks from both persistent & working\n\t\t\t * maps for directories\n\t\t\t */\n\t\t\telse {\t/* (maplock->flag & mlckFREE) */\n\n\t\t\t\tif (tlck->flag & tlckDIRECTORY)\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, COMMIT_PWMAP);\n\t\t\t\telse\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, maptype);\n\t\t\t}\n\t\t}\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\tif (!(tblk->flag & tblkGC_LAZY)) {\n\t\t\t\t/* This is equivalent to txRelease */\n\t\t\t\tASSERT(mp->lid == lid);\n\t\t\t\ttlck->mp->lid = 0;\n\t\t\t}\n\t\t\tassert(mp->nohomeok == 1);\n\t\t\tmetapage_homeok(mp);\n\t\t\tdiscard_metapage(mp);\n\t\t\ttlck->mp = NULL;\n\t\t}\n\t}\n\t/*\n\t *\tupdate inode allocation map\n\t *\n\t * update allocation state in pmap and\n\t * update lsn of the pmap page;\n\t * update in-memory inode flag/state\n\t *\n\t * unlock mapper/write lock\n\t */\n\tif (tblk->xflag & COMMIT_CREATE) {\n\t\tdiUpdatePMap(ipimap, tblk->ino, false, tblk);\n\t\t/* update persistent block allocation map\n\t\t * for the allocation of inode extent;\n\t\t */\n\t\tpxdlock.flag = mlckALLOCPXD;\n\t\tpxdlock.pxd = tblk->u.ixpxd;\n\t\tpxdlock.index = 1;\n\t\ttxAllocPMap(ipimap, (struct maplock *) & pxdlock, tblk);\n\t} else if (tblk->xflag & COMMIT_DELETE) {\n\t\tip = tblk->u.ip;\n\t\tdiUpdatePMap(ipimap, ip->i_ino, true, tblk);\n\t\tiput(ip);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txForce",
          "args": [
            "tblk"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "txForce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2225-2283",
          "snippet": "static void txForce(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\n\t/*\n\t * reverse the order of transaction tlocks in\n\t * careful update order of address index pages\n\t * (right to left, bottom up)\n\t */\n\ttlck = lid_to_tlock(tblk->next);\n\tlid = tlck->next;\n\ttlck->next = 0;\n\twhile (lid) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\ttlck->next = tblk->next;\n\t\ttblk->next = lid;\n\t\tlid = next;\n\t}\n\n\t/*\n\t * synchronously write the page, and\n\t * hold the page for txUpdateMap();\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\tif (tlck->flag & tlckWRITEPAGE) {\n\t\t\t\ttlck->flag &= ~tlckWRITEPAGE;\n\n\t\t\t\t/* do not release page to freelist */\n\t\t\t\tforce_metapage(mp);\n#if 0\n\t\t\t\t/*\n\t\t\t\t * The \"right\" thing to do here is to\n\t\t\t\t * synchronously write the metadata.\n\t\t\t\t * With the current implementation this\n\t\t\t\t * is hard since write_metapage requires\n\t\t\t\t * us to kunmap & remap the page.  If we\n\t\t\t\t * have tlocks pointing into the metadata\n\t\t\t\t * pages, we don't want to do this.  I think\n\t\t\t\t * we can get by with synchronously writing\n\t\t\t\t * the pages when they are released.\n\t\t\t\t */\n\t\t\t\tassert(mp->nohomeok);\n\t\t\t\tset_bit(META_dirty, &mp->flag);\n\t\t\t\tset_bit(META_sync, &mp->flag);\n#endif\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void txForce(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\n\t/*\n\t * reverse the order of transaction tlocks in\n\t * careful update order of address index pages\n\t * (right to left, bottom up)\n\t */\n\ttlck = lid_to_tlock(tblk->next);\n\tlid = tlck->next;\n\ttlck->next = 0;\n\twhile (lid) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\ttlck->next = tblk->next;\n\t\ttblk->next = lid;\n\t\tlid = next;\n\t}\n\n\t/*\n\t * synchronously write the page, and\n\t * hold the page for txUpdateMap();\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\tif (tlck->flag & tlckWRITEPAGE) {\n\t\t\t\ttlck->flag &= ~tlckWRITEPAGE;\n\n\t\t\t\t/* do not release page to freelist */\n\t\t\t\tforce_metapage(mp);\n#if 0\n\t\t\t\t/*\n\t\t\t\t * The \"right\" thing to do here is to\n\t\t\t\t * synchronously write the metadata.\n\t\t\t\t * With the current implementation this\n\t\t\t\t * is hard since write_metapage requires\n\t\t\t\t * us to kunmap & remap the page.  If we\n\t\t\t\t * have tlocks pointing into the metadata\n\t\t\t\t * pages, we don't want to do this.  I think\n\t\t\t\t * we can get by with synchronously writing\n\t\t\t\t * the pages when they are released.\n\t\t\t\t */\n\t\t\t\tassert(mp->nohomeok);\n\t\t\t\tset_bit(META_dirty, &mp->flag);\n\t\t\t\tset_bit(META_sync, &mp->flag);\n#endif\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmGroupCommit",
          "args": [
            "log",
            "tblk"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "lmGroupCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "679-743",
          "snippet": "int lmGroupCommit(struct jfs_log * log, struct tblock * tblk)\n{\n\tint rc = 0;\n\n\tLOGGC_LOCK(log);\n\n\t/* group committed already ? */\n\tif (tblk->flag & tblkGC_COMMITTED) {\n\t\tif (tblk->flag & tblkGC_ERROR)\n\t\t\trc = -EIO;\n\n\t\tLOGGC_UNLOCK(log);\n\t\treturn rc;\n\t}\n\tjfs_info(\"lmGroup Commit: tblk = 0x%p, gcrtc = %d\", tblk, log->gcrtc);\n\n\tif (tblk->xflag & COMMIT_LAZY)\n\t\ttblk->flag |= tblkGC_LAZY;\n\n\tif ((!(log->cflag & logGC_PAGEOUT)) && (!list_empty(&log->cqueue)) &&\n\t    (!(tblk->xflag & COMMIT_LAZY) || test_bit(log_FLUSH, &log->flag)\n\t     || jfs_tlocks_low)) {\n\t\t/*\n\t\t * No pageout in progress\n\t\t *\n\t\t * start group commit as its group leader.\n\t\t */\n\t\tlog->cflag |= logGC_PAGEOUT;\n\n\t\tlmGCwrite(log, 0);\n\t}\n\n\tif (tblk->xflag & COMMIT_LAZY) {\n\t\t/*\n\t\t * Lazy transactions can leave now\n\t\t */\n\t\tLOGGC_UNLOCK(log);\n\t\treturn 0;\n\t}\n\n\t/* lmGCwrite gives up LOGGC_LOCK, check again */\n\n\tif (tblk->flag & tblkGC_COMMITTED) {\n\t\tif (tblk->flag & tblkGC_ERROR)\n\t\t\trc = -EIO;\n\n\t\tLOGGC_UNLOCK(log);\n\t\treturn rc;\n\t}\n\n\t/* upcount transaction waiting for completion\n\t */\n\tlog->gcrtc++;\n\ttblk->flag |= tblkGC_READY;\n\n\t__SLEEP_COND(tblk->gcwait, (tblk->flag & tblkGC_COMMITTED),\n\t\t     LOGGC_LOCK(log), LOGGC_UNLOCK(log));\n\n\t/* removed from commit queue */\n\tif (tblk->flag & tblkGC_ERROR)\n\t\trc = -EIO;\n\n\tLOGGC_UNLOCK(log);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nint lmGroupCommit(struct jfs_log * log, struct tblock * tblk)\n{\n\tint rc = 0;\n\n\tLOGGC_LOCK(log);\n\n\t/* group committed already ? */\n\tif (tblk->flag & tblkGC_COMMITTED) {\n\t\tif (tblk->flag & tblkGC_ERROR)\n\t\t\trc = -EIO;\n\n\t\tLOGGC_UNLOCK(log);\n\t\treturn rc;\n\t}\n\tjfs_info(\"lmGroup Commit: tblk = 0x%p, gcrtc = %d\", tblk, log->gcrtc);\n\n\tif (tblk->xflag & COMMIT_LAZY)\n\t\ttblk->flag |= tblkGC_LAZY;\n\n\tif ((!(log->cflag & logGC_PAGEOUT)) && (!list_empty(&log->cqueue)) &&\n\t    (!(tblk->xflag & COMMIT_LAZY) || test_bit(log_FLUSH, &log->flag)\n\t     || jfs_tlocks_low)) {\n\t\t/*\n\t\t * No pageout in progress\n\t\t *\n\t\t * start group commit as its group leader.\n\t\t */\n\t\tlog->cflag |= logGC_PAGEOUT;\n\n\t\tlmGCwrite(log, 0);\n\t}\n\n\tif (tblk->xflag & COMMIT_LAZY) {\n\t\t/*\n\t\t * Lazy transactions can leave now\n\t\t */\n\t\tLOGGC_UNLOCK(log);\n\t\treturn 0;\n\t}\n\n\t/* lmGCwrite gives up LOGGC_LOCK, check again */\n\n\tif (tblk->flag & tblkGC_COMMITTED) {\n\t\tif (tblk->flag & tblkGC_ERROR)\n\t\t\trc = -EIO;\n\n\t\tLOGGC_UNLOCK(log);\n\t\treturn rc;\n\t}\n\n\t/* upcount transaction waiting for completion\n\t */\n\tlog->gcrtc++;\n\ttblk->flag |= tblkGC_READY;\n\n\t__SLEEP_COND(tblk->gcwait, (tblk->flag & tblkGC_COMMITTED),\n\t\t     LOGGC_LOCK(log), LOGGC_UNLOCK(log));\n\n\t/* removed from commit queue */\n\tif (tblk->flag & tblkGC_ERROR)\n\t\trc = -EIO;\n\n\tLOGGC_UNLOCK(log);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmLog",
          "args": [
            "log",
            "tblk",
            "lrd",
            "NULL"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "lmLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "238-343",
          "snippet": "int lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nint lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_COMMIT"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip))"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "tblk->u.ip"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "tblk->u.ip"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLog",
          "args": [
            "log",
            "tblk",
            "&cd"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "txLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1381-1431",
          "snippet": "static int txLog(struct jfs_log * log, struct tblock * tblk, struct commit * cd)\n{\n\tint rc = 0;\n\tstruct inode *ip;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct lrd *lrd = &cd->lrd;\n\n\t/*\n\t * write log record(s) for each tlock of transaction,\n\t */\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\ttlck->flag |= tlckLOG;\n\n\t\t/* initialize lrd common */\n\t\tip = tlck->ip;\n\t\tlrd->aggregate = cpu_to_le32(JFS_SBI(ip->i_sb)->aggregate);\n\t\tlrd->log.redopage.fileset = cpu_to_le32(JFS_IP(ip)->fileset);\n\t\tlrd->log.redopage.inode = cpu_to_le32(ip->i_ino);\n\n\t\t/* write log record of page from the tlock */\n\t\tswitch (tlck->type & tlckTYPE) {\n\t\tcase tlckXTREE:\n\t\t\txtLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckDTREE:\n\t\t\tdtLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckINODE:\n\t\t\tdiLog(log, tblk, lrd, tlck, cd);\n\t\t\tbreak;\n\n\t\tcase tlckMAP:\n\t\t\tmapLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckDATA:\n\t\t\tdataLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstatic int txLog(struct jfs_log * log, struct tblock * tblk, struct commit * cd)\n{\n\tint rc = 0;\n\tstruct inode *ip;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct lrd *lrd = &cd->lrd;\n\n\t/*\n\t * write log record(s) for each tlock of transaction,\n\t */\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\ttlck->flag |= tlckLOG;\n\n\t\t/* initialize lrd common */\n\t\tip = tlck->ip;\n\t\tlrd->aggregate = cpu_to_le32(JFS_SBI(ip->i_sb)->aggregate);\n\t\tlrd->log.redopage.fileset = cpu_to_le32(JFS_IP(ip)->fileset);\n\t\tlrd->log.redopage.inode = cpu_to_le32(ip->i_ino);\n\n\t\t/* write log record of page from the tlock */\n\t\tswitch (tlck->type & tlckTYPE) {\n\t\tcase tlckXTREE:\n\t\t\txtLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckDTREE:\n\t\t\tdtLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckINODE:\n\t\t\tdiLog(log, tblk, lrd, tlck, cd);\n\t\t\tbreak;\n\n\t\tcase tlckMAP:\n\t\t\tmapLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckDATA:\n\t\t\tdataLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diWrite",
          "args": [
            "tid",
            "ip"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "diWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "599-822",
          "snippet": "int diWrite(tid_t tid, struct inode *ip)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\ts32 ino;\n\tstruct dinode *dp;\n\ts64 blkno;\n\tint block_offset;\n\tint inodes_left;\n\tstruct metapage *mp;\n\tunsigned long pageno;\n\tint rel_inode;\n\tint dioffset;\n\tstruct inode *ipimap;\n\tuint type;\n\tlid_t lid;\n\tstruct tlock *ditlck, *tlck;\n\tstruct linelock *dilinelock, *ilinelock;\n\tstruct lv *lv;\n\tint n;\n\n\tipimap = jfs_ip->ipimap;\n\n\tino = ip->i_ino & (INOSPERIAG - 1);\n\n\tif (!addressPXD(&(jfs_ip->ixpxd)) ||\n\t    (lengthPXD(&(jfs_ip->ixpxd)) !=\n\t     JFS_IP(ipimap)->i_imap->im_nbperiext)) {\n\t\tjfs_error(ip->i_sb, \"ixpxd invalid\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * read the page of disk inode containing the specified inode:\n\t */\n\t/* compute the block address of the page */\n\tblkno = INOPBLK(&(jfs_ip->ixpxd), ino, sbi->l2nbperpage);\n\n\trel_inode = (ino & (INOSPERPAGE - 1));\n\tpageno = blkno >> sbi->l2nbperpage;\n\n\tif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\n\t\t/*\n\t\t * OS/2 didn't always align inode extents on page boundaries\n\t\t */\n\t\tinodes_left =\n\t\t    (sbi->nbperpage - block_offset) << sbi->l2niperblk;\n\n\t\tif (rel_inode < inodes_left)\n\t\t\trel_inode += block_offset << sbi->l2niperblk;\n\t\telse {\n\t\t\tpageno += 1;\n\t\t\trel_inode -= inodes_left;\n\t\t}\n\t}\n\t/* read the page of disk inode */\n      retry:\n\tmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\n\tif (!mp)\n\t\treturn -EIO;\n\n\t/* get the pointer to the disk inode */\n\tdp = (struct dinode *) mp->data;\n\tdp += rel_inode;\n\n\tdioffset = (ino & (INOSPERPAGE - 1)) << L2DISIZE;\n\n\t/*\n\t * acquire transaction lock on the on-disk inode;\n\t * N.B. tlock is acquired on ipimap not ip;\n\t */\n\tif ((ditlck =\n\t     txLock(tid, ipimap, mp, tlckINODE | tlckENTRY)) == NULL)\n\t\tgoto retry;\n\tdilinelock = (struct linelock *) & ditlck->lock;\n\n\t/*\n\t * copy btree root from in-memory inode to on-disk inode\n\t *\n\t * (tlock is taken from inline B+-tree root in in-memory\n\t * inode when the B+-tree root is updated, which is pointed\n\t * by jfs_ip->blid as well as being on tx tlock list)\n\t *\n\t * further processing of btree root is based on the copy\n\t * in in-memory inode, where txLog() will log from, and,\n\t * for xtree root, txUpdateMap() will update map and reset\n\t * XAD_NEW bit;\n\t */\n\n\tif (S_ISDIR(ip->i_mode) && (lid = jfs_ip->xtlid)) {\n\t\t/*\n\t\t * This is the special xtree inside the directory for storing\n\t\t * the directory table\n\t\t */\n\t\txtpage_t *p, *xp;\n\t\txad_t *xad;\n\n\t\tjfs_ip->xtlid = 0;\n\t\ttlck = lid_to_tlock(lid);\n\t\tassert(tlck->type & tlckXTREE);\n\t\ttlck->type |= tlckBTROOT;\n\t\ttlck->mp = mp;\n\t\tilinelock = (struct linelock *) & tlck->lock;\n\n\t\t/*\n\t\t * copy xtree root from inode to dinode:\n\t\t */\n\t\tp = &jfs_ip->i_xtroot;\n\t\txp = (xtpage_t *) &dp->di_dirtable;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\n\t\t\t       lv->length << L2XTSLOTSIZE);\n\t\t}\n\n\t\t/* reset on-disk (metadata page) xtree XAD_NEW bit */\n\t\txad = &xp->xad[XTENTRYSTART];\n\t\tfor (n = XTENTRYSTART;\n\t\t     n < le16_to_cpu(xp->header.nextindex); n++, xad++)\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED))\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t}\n\n\tif ((lid = jfs_ip->blid) == 0)\n\t\tgoto inlineData;\n\tjfs_ip->blid = 0;\n\n\ttlck = lid_to_tlock(lid);\n\ttype = tlck->type;\n\ttlck->type |= tlckBTROOT;\n\ttlck->mp = mp;\n\tilinelock = (struct linelock *) & tlck->lock;\n\n\t/*\n\t *\tregular file: 16 byte (XAD slot) granularity\n\t */\n\tif (type & tlckXTREE) {\n\t\txtpage_t *p, *xp;\n\t\txad_t *xad;\n\n\t\t/*\n\t\t * copy xtree root from inode to dinode:\n\t\t */\n\t\tp = &jfs_ip->i_xtroot;\n\t\txp = &dp->di_xtroot;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\n\t\t\t       lv->length << L2XTSLOTSIZE);\n\t\t}\n\n\t\t/* reset on-disk (metadata page) xtree XAD_NEW bit */\n\t\txad = &xp->xad[XTENTRYSTART];\n\t\tfor (n = XTENTRYSTART;\n\t\t     n < le16_to_cpu(xp->header.nextindex); n++, xad++)\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED))\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t}\n\t/*\n\t *\tdirectory: 32 byte (directory entry slot) granularity\n\t */\n\telse if (type & tlckDTREE) {\n\t\tdtpage_t *p, *xp;\n\n\t\t/*\n\t\t * copy dtree root from inode to dinode:\n\t\t */\n\t\tp = (dtpage_t *) &jfs_ip->i_dtroot;\n\t\txp = (dtpage_t *) & dp->di_dtroot;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->slot[lv->offset], &p->slot[lv->offset],\n\t\t\t       lv->length << L2DTSLOTSIZE);\n\t\t}\n\t} else {\n\t\tjfs_err(\"diWrite: UFO tlock\");\n\t}\n\n      inlineData:\n\t/*\n\t * copy inline symlink from in-memory inode to on-disk inode\n\t */\n\tif (S_ISLNK(ip->i_mode) && ip->i_size < IDATASIZE) {\n\t\tlv = & dilinelock->lv[dilinelock->index];\n\t\tlv->offset = (dioffset + 2 * 128) >> L2INODESLOTSIZE;\n\t\tlv->length = 2;\n\t\tmemcpy(&dp->di_fastsymlink, jfs_ip->i_inline, IDATASIZE);\n\t\tdilinelock->index++;\n\t}\n\t/*\n\t * copy inline data from in-memory inode to on-disk inode:\n\t * 128 byte slot granularity\n\t */\n\tif (test_cflag(COMMIT_Inlineea, ip)) {\n\t\tlv = & dilinelock->lv[dilinelock->index];\n\t\tlv->offset = (dioffset + 3 * 128) >> L2INODESLOTSIZE;\n\t\tlv->length = 1;\n\t\tmemcpy(&dp->di_inlineea, jfs_ip->i_inline_ea, INODESLOTSIZE);\n\t\tdilinelock->index++;\n\n\t\tclear_cflag(COMMIT_Inlineea, ip);\n\t}\n\n\t/*\n\t *\tlock/copy inode base: 128 byte slot granularity\n\t */\n\tlv = & dilinelock->lv[dilinelock->index];\n\tlv->offset = dioffset >> L2INODESLOTSIZE;\n\tcopy_to_dinode(dp, ip);\n\tif (test_and_clear_cflag(COMMIT_Dirtable, ip)) {\n\t\tlv->length = 2;\n\t\tmemcpy(&dp->di_dirtable, &jfs_ip->i_dirtable, 96);\n\t} else\n\t\tlv->length = 1;\n\tdilinelock->index++;\n\n\t/* release the buffer holding the updated on-disk inode.\n\t * the buffer will be later written by commit processing.\n\t */\n\twrite_metapage(mp);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diFindFree(u32, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diWrite(tid_t tid, struct inode *ip)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\ts32 ino;\n\tstruct dinode *dp;\n\ts64 blkno;\n\tint block_offset;\n\tint inodes_left;\n\tstruct metapage *mp;\n\tunsigned long pageno;\n\tint rel_inode;\n\tint dioffset;\n\tstruct inode *ipimap;\n\tuint type;\n\tlid_t lid;\n\tstruct tlock *ditlck, *tlck;\n\tstruct linelock *dilinelock, *ilinelock;\n\tstruct lv *lv;\n\tint n;\n\n\tipimap = jfs_ip->ipimap;\n\n\tino = ip->i_ino & (INOSPERIAG - 1);\n\n\tif (!addressPXD(&(jfs_ip->ixpxd)) ||\n\t    (lengthPXD(&(jfs_ip->ixpxd)) !=\n\t     JFS_IP(ipimap)->i_imap->im_nbperiext)) {\n\t\tjfs_error(ip->i_sb, \"ixpxd invalid\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * read the page of disk inode containing the specified inode:\n\t */\n\t/* compute the block address of the page */\n\tblkno = INOPBLK(&(jfs_ip->ixpxd), ino, sbi->l2nbperpage);\n\n\trel_inode = (ino & (INOSPERPAGE - 1));\n\tpageno = blkno >> sbi->l2nbperpage;\n\n\tif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\n\t\t/*\n\t\t * OS/2 didn't always align inode extents on page boundaries\n\t\t */\n\t\tinodes_left =\n\t\t    (sbi->nbperpage - block_offset) << sbi->l2niperblk;\n\n\t\tif (rel_inode < inodes_left)\n\t\t\trel_inode += block_offset << sbi->l2niperblk;\n\t\telse {\n\t\t\tpageno += 1;\n\t\t\trel_inode -= inodes_left;\n\t\t}\n\t}\n\t/* read the page of disk inode */\n      retry:\n\tmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\n\tif (!mp)\n\t\treturn -EIO;\n\n\t/* get the pointer to the disk inode */\n\tdp = (struct dinode *) mp->data;\n\tdp += rel_inode;\n\n\tdioffset = (ino & (INOSPERPAGE - 1)) << L2DISIZE;\n\n\t/*\n\t * acquire transaction lock on the on-disk inode;\n\t * N.B. tlock is acquired on ipimap not ip;\n\t */\n\tif ((ditlck =\n\t     txLock(tid, ipimap, mp, tlckINODE | tlckENTRY)) == NULL)\n\t\tgoto retry;\n\tdilinelock = (struct linelock *) & ditlck->lock;\n\n\t/*\n\t * copy btree root from in-memory inode to on-disk inode\n\t *\n\t * (tlock is taken from inline B+-tree root in in-memory\n\t * inode when the B+-tree root is updated, which is pointed\n\t * by jfs_ip->blid as well as being on tx tlock list)\n\t *\n\t * further processing of btree root is based on the copy\n\t * in in-memory inode, where txLog() will log from, and,\n\t * for xtree root, txUpdateMap() will update map and reset\n\t * XAD_NEW bit;\n\t */\n\n\tif (S_ISDIR(ip->i_mode) && (lid = jfs_ip->xtlid)) {\n\t\t/*\n\t\t * This is the special xtree inside the directory for storing\n\t\t * the directory table\n\t\t */\n\t\txtpage_t *p, *xp;\n\t\txad_t *xad;\n\n\t\tjfs_ip->xtlid = 0;\n\t\ttlck = lid_to_tlock(lid);\n\t\tassert(tlck->type & tlckXTREE);\n\t\ttlck->type |= tlckBTROOT;\n\t\ttlck->mp = mp;\n\t\tilinelock = (struct linelock *) & tlck->lock;\n\n\t\t/*\n\t\t * copy xtree root from inode to dinode:\n\t\t */\n\t\tp = &jfs_ip->i_xtroot;\n\t\txp = (xtpage_t *) &dp->di_dirtable;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\n\t\t\t       lv->length << L2XTSLOTSIZE);\n\t\t}\n\n\t\t/* reset on-disk (metadata page) xtree XAD_NEW bit */\n\t\txad = &xp->xad[XTENTRYSTART];\n\t\tfor (n = XTENTRYSTART;\n\t\t     n < le16_to_cpu(xp->header.nextindex); n++, xad++)\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED))\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t}\n\n\tif ((lid = jfs_ip->blid) == 0)\n\t\tgoto inlineData;\n\tjfs_ip->blid = 0;\n\n\ttlck = lid_to_tlock(lid);\n\ttype = tlck->type;\n\ttlck->type |= tlckBTROOT;\n\ttlck->mp = mp;\n\tilinelock = (struct linelock *) & tlck->lock;\n\n\t/*\n\t *\tregular file: 16 byte (XAD slot) granularity\n\t */\n\tif (type & tlckXTREE) {\n\t\txtpage_t *p, *xp;\n\t\txad_t *xad;\n\n\t\t/*\n\t\t * copy xtree root from inode to dinode:\n\t\t */\n\t\tp = &jfs_ip->i_xtroot;\n\t\txp = &dp->di_xtroot;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\n\t\t\t       lv->length << L2XTSLOTSIZE);\n\t\t}\n\n\t\t/* reset on-disk (metadata page) xtree XAD_NEW bit */\n\t\txad = &xp->xad[XTENTRYSTART];\n\t\tfor (n = XTENTRYSTART;\n\t\t     n < le16_to_cpu(xp->header.nextindex); n++, xad++)\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED))\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t}\n\t/*\n\t *\tdirectory: 32 byte (directory entry slot) granularity\n\t */\n\telse if (type & tlckDTREE) {\n\t\tdtpage_t *p, *xp;\n\n\t\t/*\n\t\t * copy dtree root from inode to dinode:\n\t\t */\n\t\tp = (dtpage_t *) &jfs_ip->i_dtroot;\n\t\txp = (dtpage_t *) & dp->di_dtroot;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->slot[lv->offset], &p->slot[lv->offset],\n\t\t\t       lv->length << L2DTSLOTSIZE);\n\t\t}\n\t} else {\n\t\tjfs_err(\"diWrite: UFO tlock\");\n\t}\n\n      inlineData:\n\t/*\n\t * copy inline symlink from in-memory inode to on-disk inode\n\t */\n\tif (S_ISLNK(ip->i_mode) && ip->i_size < IDATASIZE) {\n\t\tlv = & dilinelock->lv[dilinelock->index];\n\t\tlv->offset = (dioffset + 2 * 128) >> L2INODESLOTSIZE;\n\t\tlv->length = 2;\n\t\tmemcpy(&dp->di_fastsymlink, jfs_ip->i_inline, IDATASIZE);\n\t\tdilinelock->index++;\n\t}\n\t/*\n\t * copy inline data from in-memory inode to on-disk inode:\n\t * 128 byte slot granularity\n\t */\n\tif (test_cflag(COMMIT_Inlineea, ip)) {\n\t\tlv = & dilinelock->lv[dilinelock->index];\n\t\tlv->offset = (dioffset + 3 * 128) >> L2INODESLOTSIZE;\n\t\tlv->length = 1;\n\t\tmemcpy(&dp->di_inlineea, jfs_ip->i_inline_ea, INODESLOTSIZE);\n\t\tdilinelock->index++;\n\n\t\tclear_cflag(COMMIT_Inlineea, ip);\n\t}\n\n\t/*\n\t *\tlock/copy inode base: 128 byte slot granularity\n\t */\n\tlv = & dilinelock->lv[dilinelock->index];\n\tlv->offset = dioffset >> L2INODESLOTSIZE;\n\tcopy_to_dinode(dp, ip);\n\tif (test_and_clear_cflag(COMMIT_Dirtable, ip)) {\n\t\tlv->length = 2;\n\t\tmemcpy(&dp->di_dirtable, &jfs_ip->i_dirtable, 96);\n\t} else\n\t\tlv->length = 1;\n\tdilinelock->index++;\n\n\t/* release the buffer holding the updated on-disk inode.\n\t * the buffer will be later written by commit processing.\n\t */\n\twrite_metapage(mp);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&jfs_ip->anon_inode_list"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "jfs_ip->atltail"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_cflag",
          "args": [
            "COMMIT_Dirty",
            "ip"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tblk->logtid"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "sb",
            "0"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isReadOnly",
          "args": [
            "iplist[0]"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "isReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "222-227",
          "snippet": "static inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txCommit, tid = %d, flag = %d\"",
            "tid",
            "flag"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "txLinelock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "1068-1096",
    "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct tlock *TxLock;",
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLockAlloc",
          "args": [],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "txLockAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "193-213",
          "snippet": "static lid_t txLockAlloc(void)\n{\n\tlid_t lid;\n\n\tINCREMENT(TxStat.txLockAlloc);\n\tif (!TxAnchor.freelock) {\n\t\tINCREMENT(TxStat.txLockAlloc_freelock);\n\t}\n\n\twhile (!(lid = TxAnchor.freelock))\n\t\tTXN_SLEEP(&TxAnchor.freelockwait);\n\tTxAnchor.freelock = TxLock[lid].next;\n\tHIGHWATERMARK(stattx.maxlid, lid);\n\tif ((++TxAnchor.tlocksInUse > TxLockHWM) && (jfs_tlocks_low == 0)) {\n\t\tjfs_info(\"txLockAlloc tlocks low\");\n\t\tjfs_tlocks_low = 1;\n\t\twake_up_process(jfsSyncThread);\n\t}\n\n\treturn lid;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "int jfs_tlocks_low;",
            "static int TxLockHWM;",
            "struct tlock *TxLock;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nint jfs_tlocks_low;\nstatic int TxLockHWM;\nstruct tlock *TxLock;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\n\nstatic lid_t txLockAlloc(void)\n{\n\tlid_t lid;\n\n\tINCREMENT(TxStat.txLockAlloc);\n\tif (!TxAnchor.freelock) {\n\t\tINCREMENT(TxStat.txLockAlloc_freelock);\n\t}\n\n\twhile (!(lid = TxAnchor.freelock))\n\t\tTXN_SLEEP(&TxAnchor.freelockwait);\n\tTxAnchor.freelock = TxLock[lid].next;\n\tHIGHWATERMARK(stattx.maxlid, lid);\n\tif ((++TxAnchor.tlocksInUse > TxLockHWM) && (jfs_tlocks_low == 0)) {\n\t\tjfs_info(\"txLockAlloc tlocks low\");\n\t\tjfs_tlocks_low = 1;\n\t\twake_up_process(jfsSyncThread);\n\t}\n\n\treturn lid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
  },
  {
    "function_name": "txMaplock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "995-1061",
    "snippet": "struct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&jfs_ip->anon_inode_list",
            "&TxAnchor.anon_list"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "tblk->last"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLockAlloc",
          "args": [],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "txLockAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "193-213",
          "snippet": "static lid_t txLockAlloc(void)\n{\n\tlid_t lid;\n\n\tINCREMENT(TxStat.txLockAlloc);\n\tif (!TxAnchor.freelock) {\n\t\tINCREMENT(TxStat.txLockAlloc_freelock);\n\t}\n\n\twhile (!(lid = TxAnchor.freelock))\n\t\tTXN_SLEEP(&TxAnchor.freelockwait);\n\tTxAnchor.freelock = TxLock[lid].next;\n\tHIGHWATERMARK(stattx.maxlid, lid);\n\tif ((++TxAnchor.tlocksInUse > TxLockHWM) && (jfs_tlocks_low == 0)) {\n\t\tjfs_info(\"txLockAlloc tlocks low\");\n\t\tjfs_tlocks_low = 1;\n\t\twake_up_process(jfsSyncThread);\n\t}\n\n\treturn lid;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "int jfs_tlocks_low;",
            "static int TxLockHWM;",
            "struct tlock *TxLock;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nint jfs_tlocks_low;\nstatic int TxLockHWM;\nstruct tlock *TxLock;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\n\nstatic lid_t txLockAlloc(void)\n{\n\tlid_t lid;\n\n\tINCREMENT(TxStat.txLockAlloc);\n\tif (!TxAnchor.freelock) {\n\t\tINCREMENT(TxStat.txLockAlloc_freelock);\n\t}\n\n\twhile (!(lid = TxAnchor.freelock))\n\t\tTXN_SLEEP(&TxAnchor.freelockwait);\n\tTxAnchor.freelock = TxLock[lid].next;\n\tHIGHWATERMARK(stattx.maxlid, lid);\n\tif ((++TxAnchor.tlocksInUse > TxLockHWM) && (jfs_tlocks_low == 0)) {\n\t\tjfs_info(\"txLockAlloc tlocks low\");\n\t\tjfs_tlocks_low = 1;\n\t\twake_up_process(jfsSyncThread);\n\t}\n\n\treturn lid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}"
  },
  {
    "function_name": "txUnlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "908-987",
    "snippet": "static void txUnlock(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\tlid_t lid, next, llid, k;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint difft, diffp;\n\tunsigned long flags;\n\n\tjfs_info(\"txUnlock: tblk = 0x%p\", tblk);\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * mark page under tlock homeok (its log has been written):\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tjfs_info(\"unlocking lid = %d, tlck = 0x%p\", lid, tlck);\n\n\t\t/* unbind page from tlock */\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\t/* hold buffer\n\t\t\t */\n\t\t\thold_metapage(mp);\n\n\t\t\tassert(mp->nohomeok > 0);\n\t\t\t_metapage_homeok(mp);\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tLOGSYNC_LOCK(log, flags);\n\t\t\tif (mp->clsn) {\n\t\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\t\tif (difft > diffp)\n\t\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\t} else\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t\t\tassert(!(tlck->flag & tlckFREEPAGE));\n\n\t\t\tput_metapage(mp);\n\t\t}\n\n\t\t/* insert tlock, and linelock(s) of the tlock if any,\n\t\t * at head of freelist\n\t\t */\n\t\tTXN_LOCK();\n\n\t\tllid = ((struct linelock *) & tlck->lock)->next;\n\t\twhile (llid) {\n\t\t\tlinelock = (struct linelock *) lid_to_tlock(llid);\n\t\t\tk = linelock->next;\n\t\t\ttxLockFree(llid);\n\t\t\tllid = k;\n\t\t}\n\t\ttxLockFree(lid);\n\n\t\tTXN_UNLOCK();\n\t}\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * remove tblock from logsynclist\n\t * (allocation map pages inherited lsn of tblk and\n\t * has been inserted in logsync list at txUpdateMap())\n\t */\n\tif (tblk->lsn) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tlog->count--;\n\t\tlist_del(&tblk->synclist);\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOGSYNC_UNLOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tblk->synclist"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGSYNC_LOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLockFree",
          "args": [
            "lid"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "txLockFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "215-227",
          "snippet": "static void txLockFree(lid_t lid)\n{\n\tTxLock[lid].tid = 0;\n\tTxLock[lid].next = TxAnchor.freelock;\n\tTxAnchor.freelock = lid;\n\tTxAnchor.tlocksInUse--;\n\tif (jfs_tlocks_low && (TxAnchor.tlocksInUse < TxLockLWM)) {\n\t\tjfs_info(\"txLockFree jfs_tlocks_low no more\");\n\t\tjfs_tlocks_low = 0;\n\t\tTXN_WAKEUP(&TxAnchor.lowlockwait);\n\t}\n\tTXN_WAKEUP(&TxAnchor.freelockwait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "int jfs_tlocks_low;",
            "static int TxLockLWM;",
            "struct tlock *TxLock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nint jfs_tlocks_low;\nstatic int TxLockLWM;\nstruct tlock *TxLock;\n\nstatic void txLockFree(lid_t lid)\n{\n\tTxLock[lid].tid = 0;\n\tTxLock[lid].next = TxAnchor.freelock;\n\tTxAnchor.freelock = lid;\n\tTxAnchor.tlocksInUse--;\n\tif (jfs_tlocks_low && (TxAnchor.tlocksInUse < TxLockLWM)) {\n\t\tjfs_info(\"txLockFree jfs_tlocks_low no more\");\n\t\tjfs_tlocks_low = 0;\n\t\tTXN_WAKEUP(&TxAnchor.lowlockwait);\n\t}\n\tTXN_WAKEUP(&TxAnchor.freelockwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "llid"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_metapage",
          "args": [
            "mp"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "put_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "729-741",
          "snippet": "void put_metapage(struct metapage *mp)\n{\n\tif (mp->count || mp->nohomeok) {\n\t\t/* Someone else will release this */\n\t\tunlock_page(mp->page);\n\t\treturn;\n\t}\n\tpage_cache_get(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid put_metapage(struct metapage *mp)\n{\n\tif (mp->count || mp->nohomeok) {\n\t\t/* Someone else will release this */\n\t\tunlock_page(mp->page);\n\t\treturn;\n\t}\n\tpage_cache_get(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!(tlck->flag & tlckFREEPAGE)"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGSYNC_UNLOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "diffp",
            "mp->clsn",
            "log"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "difft",
            "tblk->clsn",
            "log"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGSYNC_LOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_metapage_homeok",
          "args": [
            "mp"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "_metapage_homeok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "129-133",
          "snippet": "static inline void _metapage_homeok(struct metapage *mp)\n{\n\tif (!--mp->nohomeok)\n\t\tpage_cache_release(mp->page);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\nstatic inline void _metapage_homeok(struct metapage *mp)\n{\n\tif (!--mp->nohomeok)\n\t\tpage_cache_release(mp->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hold_metapage",
          "args": [
            "mp"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "hold_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "724-727",
          "snippet": "void hold_metapage(struct metapage *mp)\n{\n\tlock_page(mp->page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid hold_metapage(struct metapage *mp)\n{\n\tlock_page(mp->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"unlocking lid = %d, tlck = 0x%p\"",
            "lid",
            "tlck"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "tblk->sb"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txUnlock: tblk = 0x%p\"",
            "tblk"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void txUnlock(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\tlid_t lid, next, llid, k;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint difft, diffp;\n\tunsigned long flags;\n\n\tjfs_info(\"txUnlock: tblk = 0x%p\", tblk);\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * mark page under tlock homeok (its log has been written):\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tjfs_info(\"unlocking lid = %d, tlck = 0x%p\", lid, tlck);\n\n\t\t/* unbind page from tlock */\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\t/* hold buffer\n\t\t\t */\n\t\t\thold_metapage(mp);\n\n\t\t\tassert(mp->nohomeok > 0);\n\t\t\t_metapage_homeok(mp);\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tLOGSYNC_LOCK(log, flags);\n\t\t\tif (mp->clsn) {\n\t\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\t\tif (difft > diffp)\n\t\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\t} else\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t\t\tassert(!(tlck->flag & tlckFREEPAGE));\n\n\t\t\tput_metapage(mp);\n\t\t}\n\n\t\t/* insert tlock, and linelock(s) of the tlock if any,\n\t\t * at head of freelist\n\t\t */\n\t\tTXN_LOCK();\n\n\t\tllid = ((struct linelock *) & tlck->lock)->next;\n\t\twhile (llid) {\n\t\t\tlinelock = (struct linelock *) lid_to_tlock(llid);\n\t\t\tk = linelock->next;\n\t\t\ttxLockFree(llid);\n\t\t\tllid = k;\n\t\t}\n\t\ttxLockFree(lid);\n\n\t\tTXN_UNLOCK();\n\t}\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * remove tblock from logsynclist\n\t * (allocation map pages inherited lsn of tblk and\n\t * has been inserted in logsync list at txUpdateMap())\n\t */\n\tif (tblk->lsn) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tlog->count--;\n\t\tlist_del(&tblk->synclist);\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n}"
  },
  {
    "function_name": "txRelease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "876-900",
    "snippet": "static void txRelease(struct tblock * tblk)\n{\n\tstruct metapage *mp;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\n\tTXN_LOCK();\n\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\t\t\tmp->lid = 0;\n\t\t}\n\t}\n\n\t/*\n\t * wakeup transactions waiting on a page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tTXN_UNLOCK();\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_WAKEUP",
          "args": [
            "&tblk->waitor"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mp->xflag & COMMIT_PAGE"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstatic void txRelease(struct tblock * tblk)\n{\n\tstruct metapage *mp;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\n\tTXN_LOCK();\n\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\t\t\tmp->lid = 0;\n\t\t}\n\t}\n\n\t/*\n\t * wakeup transactions waiting on a page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tTXN_UNLOCK();\n}"
  },
  {
    "function_name": "txLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "590-861",
    "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
      "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);",
      "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
      "static void LogSyncRelease(struct metapage * mp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txLock: awakened     tid = %d, lid = %d\"",
            "tid",
            "lid"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_SLEEP_DROP_LOCK",
          "args": [
            "&tid_to_tblock(xtid)->waitor"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "TXN_SLEEP_DROP_LOCK",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "131-140",
          "snippet": "static inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "xtid"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\"",
            "tid",
            "xtid",
            "lid"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "stattx.waitlock"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"Tlock: \"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "4",
            "tlck",
            "sizeof(*tlck)",
            "0"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"Locker's tblock: \"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "4",
            "tid_to_tblock(tid)",
            "sizeof(struct tblock)",
            "0"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"mp: \"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "4",
            "mp",
            "sizeof(*mp)",
            "0"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"ip: \"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "4",
            "ip",
            "sizeof(*ip)",
            "0"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"txLock: trying to lock locked page!\""
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"UFO tlock:0x%p\"",
            "tlck"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&jfs_ip->anon_inode_list",
            "&TxAnchor.anon_list"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "tblk->last"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cflag",
          "args": [
            "COMMIT_Synclist",
            "ip"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\"",
            "mp",
            "mp->nohomeok",
            "tid",
            "tlck"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metapage_nohomeok",
          "args": [
            "mp"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_nohomeok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "104-114",
          "snippet": "static inline void metapage_nohomeok(struct metapage *mp)\n{\n\tstruct page *page = mp->page;\n\tlock_page(page);\n\tif (!mp->nohomeok++) {\n\t\tmark_metapage_dirty(mp);\n\t\tpage_cache_get(page);\n\t\twait_on_page_writeback(page);\n\t}\n\tunlock_page(page);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\nstatic inline void metapage_nohomeok(struct metapage *mp)\n{\n\tstruct page *page = mp->page;\n\tlock_page(page);\n\tif (!mp->nohomeok++) {\n\t\tmark_metapage_dirty(mp);\n\t\tpage_cache_get(page);\n\t\twait_on_page_writeback(page);\n\t}\n\tunlock_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLockAlloc",
          "args": [],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "txLockAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "193-213",
          "snippet": "static lid_t txLockAlloc(void)\n{\n\tlid_t lid;\n\n\tINCREMENT(TxStat.txLockAlloc);\n\tif (!TxAnchor.freelock) {\n\t\tINCREMENT(TxStat.txLockAlloc_freelock);\n\t}\n\n\twhile (!(lid = TxAnchor.freelock))\n\t\tTXN_SLEEP(&TxAnchor.freelockwait);\n\tTxAnchor.freelock = TxLock[lid].next;\n\tHIGHWATERMARK(stattx.maxlid, lid);\n\tif ((++TxAnchor.tlocksInUse > TxLockHWM) && (jfs_tlocks_low == 0)) {\n\t\tjfs_info(\"txLockAlloc tlocks low\");\n\t\tjfs_tlocks_low = 1;\n\t\twake_up_process(jfsSyncThread);\n\t}\n\n\treturn lid;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "int jfs_tlocks_low;",
            "static int TxLockHWM;",
            "struct tlock *TxLock;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nint jfs_tlocks_low;\nstatic int TxLockHWM;\nstruct tlock *TxLock;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\n\nstatic lid_t txLockAlloc(void)\n{\n\tlid_t lid;\n\n\tINCREMENT(TxStat.txLockAlloc);\n\tif (!TxAnchor.freelock) {\n\t\tINCREMENT(TxStat.txLockAlloc_freelock);\n\t}\n\n\twhile (!(lid = TxAnchor.freelock))\n\t\tTXN_SLEEP(&TxAnchor.freelockwait);\n\tTxAnchor.freelock = TxLock[lid].next;\n\tHIGHWATERMARK(stattx.maxlid, lid);\n\tif ((++TxAnchor.tlocksInUse > TxLockHWM) && (jfs_tlocks_low == 0)) {\n\t\tjfs_info(\"txLockAlloc tlocks low\");\n\t\tjfs_tlocks_low = 1;\n\t\twake_up_process(jfsSyncThread);\n\t}\n\n\treturn lid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "tblk->last"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "last"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "last"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "last"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "last"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&jfs_ip->anon_inode_list"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\"",
            "tid",
            "ip",
            "mp",
            "lid"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "txEnd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "500-577",
    "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TXN_WAKEUP",
          "args": [
            "&TxAnchor.freewait"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_WAKEUP",
          "args": [
            "&log->syncwait"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "log_SYNCBARRIER",
            "&log->flag"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"log barrier off: 0x%x\"",
            "log->lsn"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_syncpt",
          "args": [
            "log",
            "1"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_syncpt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1059-1064",
          "snippet": "void jfs_syncpt(struct jfs_log *log, int hard_sync)\n{\tLOG_LOCK(log);\n\tif (!test_bit(log_QUIESCE, &log->flag))\n\t\tlmLogSync(log, hard_sync);\n\tLOG_UNLOCK(log);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static int lmLogSync(struct jfs_log * log, int hard_sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic int lmLogSync(struct jfs_log * log, int hard_sync);\n\nvoid jfs_syncpt(struct jfs_log *log, int hard_sync)\n{\tLOG_LOCK(log);\n\tif (!test_bit(log_QUIESCE, &log->flag))\n\t\tlmLogSync(log, hard_sync);\n\tLOG_UNLOCK(log);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "log_SYNCBARRIER",
            "&log->flag"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tblk->next == 0"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txEnd: tid: %d, tblk = 0x%p\"",
            "tid",
            "tblk"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log->gclock"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&log->gclock"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txEnd called w/lazy tid: %d, tblk = 0x%p\"",
            "tid",
            "tblk"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "tblk->sb"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXN_WAKEUP",
          "args": [
            "&tblk->waitor"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txEnd: tid = %d\"",
            "tid"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
  },
  {
    "function_name": "txBeginAnon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "460-489",
    "snippet": "void txBeginAnon(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\tINCREMENT(TxStat.txBeginAnon);\n\n      retry:\n\t/*\n\t * synchronize with logsync barrier\n\t */\n\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\tINCREMENT(TxStat.txBeginAnon_barrier);\n\t\tTXN_SLEEP(&log->syncwait);\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Don't begin transaction if we're getting starved for tlocks\n\t */\n\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\tINCREMENT(TxStat.txBeginAnon_lockslow);\n\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\tgoto retry;\n\t}\n\tTXN_UNLOCK();\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "static int TxLockVHWM;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_SLEEP",
          "args": [
            "&TxAnchor.lowlockwait"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "TXN_SLEEP_DROP_LOCK",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "131-140",
          "snippet": "static inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "TxStat.txBeginAnon_lockslow"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "TxStat.txBeginAnon_barrier"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "log_QUIESCE",
            "&log->flag"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "TxStat.txBeginAnon"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\n\nvoid txBeginAnon(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\tINCREMENT(TxStat.txBeginAnon);\n\n      retry:\n\t/*\n\t * synchronize with logsync barrier\n\t */\n\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\tINCREMENT(TxStat.txBeginAnon_barrier);\n\t\tTXN_SLEEP(&log->syncwait);\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Don't begin transaction if we're getting starved for tlocks\n\t */\n\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\tINCREMENT(TxStat.txBeginAnon_lockslow);\n\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\tgoto retry;\n\t}\n\tTXN_UNLOCK();\n}"
  },
  {
    "function_name": "txBegin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "361-447",
    "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "static int TxLockVHWM;",
      "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
      "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
      "static void txForce(struct tblock * tblk);",
      "static void txUpdateMap(struct tblock * tblk);",
      "static void txRelease(struct tblock * tblk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txBegin: returning tid = %d\"",
            "t"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "stattx.ntid"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HIGHWATERMARK",
          "args": [
            "stattx.maxtid",
            "t"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_SLEEP",
          "args": [
            "&TxAnchor.freewait"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "TXN_SLEEP_DROP_LOCK",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "131-140",
          "snippet": "static inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "TxStat.txBegin_freetid"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txBegin: waiting for free tid\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "t"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "TxStat.txBegin_freetid"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txBegin: waiting for free tid\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "TxStat.txBegin_lockslow"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "TxStat.txBegin_barrier"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "log_QUIESCE",
            "&log->flag"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "TxStat.txBegin"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_LOCK",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txBegin: flag = 0x%x\"",
            "flag"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
  },
  {
    "function_name": "txExit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "340-346",
    "snippet": "void txExit(void)\n{\n\tvfree(TxLock);\n\tTxLock = NULL;\n\tvfree(TxBlock);\n\tTxBlock = NULL;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct tblock *TxBlock;",
      "struct tlock *TxLock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "TxBlock"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "TxLock"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tblock *TxBlock;\nstruct tlock *TxLock;\n\nvoid txExit(void)\n{\n\tvfree(TxLock);\n\tTxLock = NULL;\n\tvfree(TxBlock);\n\tTxBlock = NULL;\n}"
  },
  {
    "function_name": "txInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "238-333",
    "snippet": "int txInit(void)\n{\n\tint k, size;\n\tstruct sysinfo si;\n\n\t/* Set defaults for nTxLock and nTxBlock if unset */\n\n\tif (nTxLock == -1) {\n\t\tif (nTxBlock == -1) {\n\t\t\t/* Base default on memory size */\n\t\t\tsi_meminfo(&si);\n\t\t\tif (si.totalram > (256 * 1024)) /* 1 GB */\n\t\t\t\tnTxLock = 64 * 1024;\n\t\t\telse\n\t\t\t\tnTxLock = si.totalram >> 2;\n\t\t} else if (nTxBlock > (8 * 1024))\n\t\t\tnTxLock = 64 * 1024;\n\t\telse\n\t\t\tnTxLock = nTxBlock << 3;\n\t}\n\tif (nTxBlock == -1)\n\t\tnTxBlock = nTxLock >> 3;\n\n\t/* Verify tunable parameters */\n\tif (nTxBlock < 16)\n\t\tnTxBlock = 16;\t/* No one should set it this low */\n\tif (nTxBlock > 65536)\n\t\tnTxBlock = 65536;\n\tif (nTxLock < 256)\n\t\tnTxLock = 256;\t/* No one should set it this low */\n\tif (nTxLock > 65536)\n\t\tnTxLock = 65536;\n\n\tprintk(KERN_INFO \"JFS: nTxBlock = %d, nTxLock = %d\\n\",\n\t       nTxBlock, nTxLock);\n\t/*\n\t * initialize transaction block (tblock) table\n\t *\n\t * transaction id (tid) = tblock index\n\t * tid = 0 is reserved.\n\t */\n\tTxLockLWM = (nTxLock * 4) / 10;\n\tTxLockHWM = (nTxLock * 7) / 10;\n\tTxLockVHWM = (nTxLock * 8) / 10;\n\n\tsize = sizeof(struct tblock) * nTxBlock;\n\tTxBlock = vmalloc(size);\n\tif (TxBlock == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (k = 1; k < nTxBlock - 1; k++) {\n\t\tTxBlock[k].next = k + 1;\n\t\tinit_waitqueue_head(&TxBlock[k].gcwait);\n\t\tinit_waitqueue_head(&TxBlock[k].waitor);\n\t}\n\tTxBlock[k].next = 0;\n\tinit_waitqueue_head(&TxBlock[k].gcwait);\n\tinit_waitqueue_head(&TxBlock[k].waitor);\n\n\tTxAnchor.freetid = 1;\n\tinit_waitqueue_head(&TxAnchor.freewait);\n\n\tstattx.maxtid = 1;\t/* statistics */\n\n\t/*\n\t * initialize transaction lock (tlock) table\n\t *\n\t * transaction lock id = tlock index\n\t * tlock id = 0 is reserved.\n\t */\n\tsize = sizeof(struct tlock) * nTxLock;\n\tTxLock = vmalloc(size);\n\tif (TxLock == NULL) {\n\t\tvfree(TxBlock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialize tlock table */\n\tfor (k = 1; k < nTxLock - 1; k++)\n\t\tTxLock[k].next = k + 1;\n\tTxLock[k].next = 0;\n\tinit_waitqueue_head(&TxAnchor.freelockwait);\n\tinit_waitqueue_head(&TxAnchor.lowlockwait);\n\n\tTxAnchor.freelock = 1;\n\tTxAnchor.tlocksInUse = 0;\n\tINIT_LIST_HEAD(&TxAnchor.anon_list);\n\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\n\tLAZY_LOCK_INIT();\n\tINIT_LIST_HEAD(&TxAnchor.unlock_queue);\n\n\tstattx.maxlid = 1;\t/* statistics */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "static int nTxBlock = -1;",
      "static int nTxLock = -1;",
      "struct tblock *TxBlock;",
      "static int TxLockLWM;",
      "static int TxLockHWM;",
      "static int TxLockVHWM;",
      "struct tlock *TxLock;",
      "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&TxAnchor.unlock_queue"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LAZY_LOCK_INIT",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&TxAnchor.anon_list2"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&TxAnchor.anon_list"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&TxAnchor.lowlockwait"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&TxAnchor.freelockwait"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "TxBlock"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "size"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&TxAnchor.freewait"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&TxBlock[k].waitor"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&TxBlock[k].gcwait"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&TxBlock[k].waitor"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&TxBlock[k].gcwait"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"JFS: nTxBlock = %d, nTxLock = %d\\n\"",
            "nTxBlock",
            "nTxLock"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "si_meminfo",
          "args": [
            "&si"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int nTxBlock = -1;\nstatic int nTxLock = -1;\nstruct tblock *TxBlock;\nstatic int TxLockLWM;\nstatic int TxLockHWM;\nstatic int TxLockVHWM;\nstruct tlock *TxLock;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\n\nint txInit(void)\n{\n\tint k, size;\n\tstruct sysinfo si;\n\n\t/* Set defaults for nTxLock and nTxBlock if unset */\n\n\tif (nTxLock == -1) {\n\t\tif (nTxBlock == -1) {\n\t\t\t/* Base default on memory size */\n\t\t\tsi_meminfo(&si);\n\t\t\tif (si.totalram > (256 * 1024)) /* 1 GB */\n\t\t\t\tnTxLock = 64 * 1024;\n\t\t\telse\n\t\t\t\tnTxLock = si.totalram >> 2;\n\t\t} else if (nTxBlock > (8 * 1024))\n\t\t\tnTxLock = 64 * 1024;\n\t\telse\n\t\t\tnTxLock = nTxBlock << 3;\n\t}\n\tif (nTxBlock == -1)\n\t\tnTxBlock = nTxLock >> 3;\n\n\t/* Verify tunable parameters */\n\tif (nTxBlock < 16)\n\t\tnTxBlock = 16;\t/* No one should set it this low */\n\tif (nTxBlock > 65536)\n\t\tnTxBlock = 65536;\n\tif (nTxLock < 256)\n\t\tnTxLock = 256;\t/* No one should set it this low */\n\tif (nTxLock > 65536)\n\t\tnTxLock = 65536;\n\n\tprintk(KERN_INFO \"JFS: nTxBlock = %d, nTxLock = %d\\n\",\n\t       nTxBlock, nTxLock);\n\t/*\n\t * initialize transaction block (tblock) table\n\t *\n\t * transaction id (tid) = tblock index\n\t * tid = 0 is reserved.\n\t */\n\tTxLockLWM = (nTxLock * 4) / 10;\n\tTxLockHWM = (nTxLock * 7) / 10;\n\tTxLockVHWM = (nTxLock * 8) / 10;\n\n\tsize = sizeof(struct tblock) * nTxBlock;\n\tTxBlock = vmalloc(size);\n\tif (TxBlock == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (k = 1; k < nTxBlock - 1; k++) {\n\t\tTxBlock[k].next = k + 1;\n\t\tinit_waitqueue_head(&TxBlock[k].gcwait);\n\t\tinit_waitqueue_head(&TxBlock[k].waitor);\n\t}\n\tTxBlock[k].next = 0;\n\tinit_waitqueue_head(&TxBlock[k].gcwait);\n\tinit_waitqueue_head(&TxBlock[k].waitor);\n\n\tTxAnchor.freetid = 1;\n\tinit_waitqueue_head(&TxAnchor.freewait);\n\n\tstattx.maxtid = 1;\t/* statistics */\n\n\t/*\n\t * initialize transaction lock (tlock) table\n\t *\n\t * transaction lock id = tlock index\n\t * tlock id = 0 is reserved.\n\t */\n\tsize = sizeof(struct tlock) * nTxLock;\n\tTxLock = vmalloc(size);\n\tif (TxLock == NULL) {\n\t\tvfree(TxBlock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialize tlock table */\n\tfor (k = 1; k < nTxLock - 1; k++)\n\t\tTxLock[k].next = k + 1;\n\tTxLock[k].next = 0;\n\tinit_waitqueue_head(&TxAnchor.freelockwait);\n\tinit_waitqueue_head(&TxAnchor.lowlockwait);\n\n\tTxAnchor.freelock = 1;\n\tTxAnchor.tlocksInUse = 0;\n\tINIT_LIST_HEAD(&TxAnchor.anon_list);\n\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\n\tLAZY_LOCK_INIT();\n\tINIT_LIST_HEAD(&TxAnchor.unlock_queue);\n\n\tstattx.maxlid = 1;\t/* statistics */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "txLockFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "215-227",
    "snippet": "static void txLockFree(lid_t lid)\n{\n\tTxLock[lid].tid = 0;\n\tTxLock[lid].next = TxAnchor.freelock;\n\tTxAnchor.freelock = lid;\n\tTxAnchor.tlocksInUse--;\n\tif (jfs_tlocks_low && (TxAnchor.tlocksInUse < TxLockLWM)) {\n\t\tjfs_info(\"txLockFree jfs_tlocks_low no more\");\n\t\tjfs_tlocks_low = 0;\n\t\tTXN_WAKEUP(&TxAnchor.lowlockwait);\n\t}\n\tTXN_WAKEUP(&TxAnchor.freelockwait);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "int jfs_tlocks_low;",
      "static int TxLockLWM;",
      "struct tlock *TxLock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TXN_WAKEUP",
          "args": [
            "&TxAnchor.freelockwait"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_WAKEUP",
          "args": [
            "&TxAnchor.lowlockwait"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txLockFree jfs_tlocks_low no more\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nint jfs_tlocks_low;\nstatic int TxLockLWM;\nstruct tlock *TxLock;\n\nstatic void txLockFree(lid_t lid)\n{\n\tTxLock[lid].tid = 0;\n\tTxLock[lid].next = TxAnchor.freelock;\n\tTxAnchor.freelock = lid;\n\tTxAnchor.tlocksInUse--;\n\tif (jfs_tlocks_low && (TxAnchor.tlocksInUse < TxLockLWM)) {\n\t\tjfs_info(\"txLockFree jfs_tlocks_low no more\");\n\t\tjfs_tlocks_low = 0;\n\t\tTXN_WAKEUP(&TxAnchor.lowlockwait);\n\t}\n\tTXN_WAKEUP(&TxAnchor.freelockwait);\n}"
  },
  {
    "function_name": "txLockAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "193-213",
    "snippet": "static lid_t txLockAlloc(void)\n{\n\tlid_t lid;\n\n\tINCREMENT(TxStat.txLockAlloc);\n\tif (!TxAnchor.freelock) {\n\t\tINCREMENT(TxStat.txLockAlloc_freelock);\n\t}\n\n\twhile (!(lid = TxAnchor.freelock))\n\t\tTXN_SLEEP(&TxAnchor.freelockwait);\n\tTxAnchor.freelock = TxLock[lid].next;\n\tHIGHWATERMARK(stattx.maxlid, lid);\n\tif ((++TxAnchor.tlocksInUse > TxLockHWM) && (jfs_tlocks_low == 0)) {\n\t\tjfs_info(\"txLockAlloc tlocks low\");\n\t\tjfs_tlocks_low = 1;\n\t\twake_up_process(jfsSyncThread);\n\t}\n\n\treturn lid;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
      "int jfs_tlocks_low;",
      "static int TxLockHWM;",
      "struct tlock *TxLock;",
      "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "jfsSyncThread"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"txLockAlloc tlocks low\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HIGHWATERMARK",
          "args": [
            "stattx.maxlid",
            "lid"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_SLEEP",
          "args": [
            "&TxAnchor.freelockwait"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "TXN_SLEEP_DROP_LOCK",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "131-140",
          "snippet": "static inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "TxStat.txLockAlloc_freelock"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "TxStat.txLockAlloc"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nint jfs_tlocks_low;\nstatic int TxLockHWM;\nstruct tlock *TxLock;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\n\nstatic lid_t txLockAlloc(void)\n{\n\tlid_t lid;\n\n\tINCREMENT(TxStat.txLockAlloc);\n\tif (!TxAnchor.freelock) {\n\t\tINCREMENT(TxStat.txLockAlloc_freelock);\n\t}\n\n\twhile (!(lid = TxAnchor.freelock))\n\t\tTXN_SLEEP(&TxAnchor.freelockwait);\n\tTxAnchor.freelock = TxLock[lid].next;\n\tHIGHWATERMARK(stattx.maxlid, lid);\n\tif ((++TxAnchor.tlocksInUse > TxLockHWM) && (jfs_tlocks_low == 0)) {\n\t\tjfs_info(\"txLockAlloc tlocks low\");\n\t\tjfs_tlocks_low = 1;\n\t\twake_up_process(jfsSyncThread);\n\t}\n\n\treturn lid;\n}"
  },
  {
    "function_name": "TXN_SLEEP_DROP_LOCK",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
    "lines": "131-140",
    "snippet": "static inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/completion.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "event",
            "&wait"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXN_UNLOCK",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "event",
            "&wait"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}"
  }
]